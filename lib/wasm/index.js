async function instantiate(module, imports = {}) {
  const adaptedImports = {
    env: Object.setPrototypeOf({
      abort(message, fileName, lineNumber, columnNumber) {
        // ~lib/builtins/abort(~lib/string/String | null?, ~lib/string/String | null?, u32?, u32?) => void
        message = __liftString(message >>> 0);
        fileName = __liftString(fileName >>> 0);
        lineNumber = lineNumber >>> 0;
        columnNumber = columnNumber >>> 0;
        (() => {
          // @external.js
          throw Error(`${message} in ${fileName}:${lineNumber}:${columnNumber}`);
        })();
      },
    }, Object.assign(Object.create(globalThis), imports.env || {})),
  };
  const { exports } = await WebAssembly.instantiate(module, adaptedImports);
  const memory = exports.memory || imports.env.memory;
  const adaptedExports = Object.setPrototypeOf({
    countDigits(value) {
      // src/wasm/string/operations/countDigits(i64) => i32
      value = value || 0n;
      return exports.countDigits(value);
    },
    formatIntToCodes(value, resultPtr) {
      // src/wasm/string/operations/formatIntToCodes(i64, usize) => i32
      value = value || 0n;
      return exports.formatIntToCodes(value, resultPtr);
    },
    hashCodes(codesPtr, n) {
      // src/wasm/string/operations/hashCodes(usize, i32) => u32
      return exports.hashCodes(codesPtr, n) >>> 0;
    },
    simdSupported() {
      // src/wasm/simd/operations/simdSupported() => bool
      return exports.simdSupported() != 0;
    },
    plainNot(x) {
      // src/wasm/plain/operations/not(f64) => bool
      return exports.plainNot(x) != 0;
    },
    plainOr(x, y) {
      // src/wasm/plain/operations/or(f64, f64) => bool
      return exports.plainOr(x, y) != 0;
    },
    plainXor(x, y) {
      // src/wasm/plain/operations/xor(f64, f64) => bool
      return exports.plainXor(x, y) != 0;
    },
    plainAnd(x, y) {
      // src/wasm/plain/operations/and(f64, f64) => bool
      return exports.plainAnd(x, y) != 0;
    },
    plainEqual(x, y) {
      // src/wasm/plain/operations/equal(f64, f64) => bool
      return exports.plainEqual(x, y) != 0;
    },
    plainUnequal(x, y) {
      // src/wasm/plain/operations/unequal(f64, f64) => bool
      return exports.plainUnequal(x, y) != 0;
    },
    plainSmaller(x, y) {
      // src/wasm/plain/operations/smaller(f64, f64) => bool
      return exports.plainSmaller(x, y) != 0;
    },
    plainSmallerEq(x, y) {
      // src/wasm/plain/operations/smallerEq(f64, f64) => bool
      return exports.plainSmallerEq(x, y) != 0;
    },
    plainLarger(x, y) {
      // src/wasm/plain/operations/larger(f64, f64) => bool
      return exports.plainLarger(x, y) != 0;
    },
    plainLargerEq(x, y) {
      // src/wasm/plain/operations/largerEq(f64, f64) => bool
      return exports.plainLargerEq(x, y) != 0;
    },
    plainIsIntegerValue(x) {
      // src/wasm/plain/operations/isIntegerValue(f64) => bool
      return exports.plainIsIntegerValue(x) != 0;
    },
    plainIsNegative(x) {
      // src/wasm/plain/operations/isNegative(f64) => bool
      return exports.plainIsNegative(x) != 0;
    },
    plainIsPositive(x) {
      // src/wasm/plain/operations/isPositive(f64) => bool
      return exports.plainIsPositive(x) != 0;
    },
    plainIsZero(x) {
      // src/wasm/plain/operations/isZero(f64) => bool
      return exports.plainIsZero(x) != 0;
    },
    plainIsNaN(x) {
      // src/wasm/plain/operations/isNaN(f64) => bool
      return exports.plainIsNaN(x) != 0;
    },
  }, exports);
  function __liftString(pointer) {
    if (!pointer) return null;
    const
      end = pointer + new Uint32Array(memory.buffer)[pointer - 4 >>> 2] >>> 1,
      memoryU16 = new Uint16Array(memory.buffer);
    let
      start = pointer >>> 1,
      string = "";
    while (end - start > 1024) string += String.fromCharCode(...memoryU16.subarray(start, start += 1024));
    return string + String.fromCharCode(...memoryU16.subarray(start, end));
  }
  exports._start();
  return adaptedExports;
}
export const {
  memory,
  __new,
  __pin,
  __unpin,
  __collect,
  __rtti_base,
  multiplyDense,
  multiplyDenseSIMD,
  multiplyVector,
  transpose,
  add,
  subtract,
  scalarMultiply,
  dotProduct,
  multiplyBlockedSIMD,
  addSIMD,
  subtractSIMD,
  scalarMultiplySIMD,
  dotProductSIMD,
  multiplyVectorSIMD,
  transposeSIMD,
  luDecomposition,
  qrDecomposition,
  choleskyDecomposition,
  luSolve,
  luDeterminant,
  luDecompositionSIMD,
  qrDecompositionSIMD,
  choleskyDecompositionSIMD,
  fft,
  fft2d,
  convolve,
  rfft,
  irfft,
  isPowerOf2,
  fftSIMD,
  convolveSIMD,
  powerSpectrumSIMD,
  crossCorrelationSIMD,
  freqz,
  freqzUniform,
  polyMultiply,
  zpk2tf,
  magnitude,
  magnitudeDb,
  phase,
  unwrapPhase,
  groupDelay,
  rk45Step,
  rk23Step,
  maxError,
  computeStepAdjustment,
  interpolate,
  vectorCopy,
  vectorScale,
  vectorAdd,
  wouldOvershoot,
  trimStep,
  arg,
  argArray,
  conj,
  conjArray,
  re,
  reArray,
  im,
  imArray,
  abs,
  absArray,
  addComplex,
  subComplex,
  mulComplex,
  divComplex,
  sqrtComplex,
  expComplex,
  logComplex,
  sinComplex,
  cosComplex,
  tanComplex,
  powComplexReal,
  distance2D,
  distance3D,
  distanceND,
  manhattanDistance2D,
  manhattanDistanceND,
  intersect2DLines,
  intersect2DInfiniteLines,
  intersectLinePlane,
  cross3D,
  dotND,
  angle2D,
  angle3D,
  triangleArea2D,
  pointInTriangle2D,
  normalizeND,
  and,
  or,
  not,
  xor,
  nand,
  nor,
  xnor,
  all,
  any,
  countTrue,
  findFirst,
  findLast,
  findAll,
  select,
  selectArray,
  andArray,
  orArray,
  notArray,
  xorArray,
  compare,
  compareArray,
  equal,
  nearlyEqual,
  equalArray,
  unequal,
  unequalArray,
  larger,
  largerArray,
  largerEq,
  largerEqArray,
  smaller,
  smallerArray,
  smallerEq,
  smallerEqArray,
  min,
  max,
  argmin,
  argmax,
  clamp,
  clampArray,
  inRange,
  inRangeArray,
  isPositive,
  isNegative,
  isZero,
  isNaN,
  isFinite,
  isInteger,
  sign,
  signArray,
  createSet,
  setUnion,
  setIntersect,
  setDifference,
  setSymDifference,
  setIsSubset,
  setIsProperSubset,
  setIsSuperset,
  setIsProperSuperset,
  setEquals,
  setIsDisjoint,
  setSize,
  setContains,
  setAdd,
  setRemove,
  setCartesian,
  setPowerSetSize,
  setGetSubset,
  erf,
  erfArray,
  erfc,
  erfcArray,
  gamma,
  gammaArray,
  lgamma,
  lgammaArray,
  zeta,
  zetaArray,
  beta,
  gammainc,
  digamma,
  digammaArray,
  besselJ0,
  besselJ1,
  besselY0,
  besselY1,
  isDigit,
  isLetter,
  isAlphanumeric,
  isWhitespace,
  toLowerCode,
  toUpperCode,
  parseIntFromCodes,
  parseFloatFromCodes,
  countDigits,
  formatIntToCodes,
  formatFloatToCodes,
  compareCodeArrays,
  hashCodes,
  findPattern,
  countPattern,
  utf8ByteLength,
  isNumericString,
  simdAddF64,
  simdSubF64,
  simdMulF64,
  simdDivF64,
  simdScaleF64,
  simdDotF64,
  simdSumF64,
  simdSumSquaresF64,
  simdNormF64,
  simdMinF64,
  simdMaxF64,
  simdAbsF64,
  simdSqrtF64,
  simdNegF64,
  simdMatVecMulF64,
  simdMatAddF64,
  simdMatSubF64,
  simdMatDotMulF64,
  simdMatScaleF64,
  simdMatMulF64,
  simdMatTransposeF64,
  simdMeanF64,
  simdVarianceF64,
  simdStdF64,
  simdAddF32,
  simdMulF32,
  simdDotF32,
  simdSumF32,
  simdAddI32,
  simdMulI32,
  simdComplexMulF64,
  simdComplexAddF64,
  simdSupported,
  simdVectorSizeF64,
  simdVectorSizeF32,
  statsMean,
  statsMedian,
  statsMedianUnsorted,
  statsVariance,
  statsStd,
  statsSum,
  statsProd,
  statsMad,
  statsKurtosis,
  statsSkewness,
  statsCV,
  statsCorrelation,
  statsCovariance,
  statsGeometricMean,
  statsHarmonicMean,
  statsRms,
  statsQuantile,
  statsPercentile,
  statsIQR,
  statsRange,
  statsCumsum,
  statsZscore,
  laDet,
  laInv,
  laInv2x2,
  laInv3x3,
  laNorm1,
  laNorm2,
  laNormP,
  laNormInf,
  laNormFro,
  laMatrixNorm1,
  laMatrixNormInf,
  laNormalize,
  laKron,
  laCross,
  laDot,
  laOuter,
  laCond1,
  laCondInf,
  laRank,
  laSolve,
  eigsSymmetric,
  powerIteration,
  spectralRadius,
  inverseIteration,
  eigsSymmetricSIMD,
  powerIterationSIMD,
  balanceMatrix,
  reduceToHessenberg,
  eigenvalues2x2,
  qrIterationStep,
  qrAlgorithm,
  hessenbergQRStep,
  expm,
  expmSmall,
  expmv,
  sqrtm,
  sqrtmNewtonSchulz,
  sqrtmCholesky,
  sparseLu,
  sparseForwardSolve,
  sparseBackwardSolve,
  sparseLuSolve,
  sparseChol,
  sparseCholSolve,
  eliminationTree,
  columnCounts,
  plainAbs,
  plainAdd,
  plainSubtract,
  plainMultiply,
  plainDivide,
  plainUnaryMinus,
  plainUnaryPlus,
  plainCbrt,
  plainCube,
  plainExp,
  plainExpm1,
  plainGcd,
  plainLcm,
  plainLog,
  plainLog2,
  plainLog10,
  plainLog1p,
  plainMod,
  plainNthRoot,
  plainSign,
  plainSqrt,
  plainSquare,
  plainPow,
  plainNorm,
  plainBitAnd,
  plainBitNot,
  plainBitOr,
  plainBitXor,
  plainLeftShift,
  plainRightArithShift,
  plainRightLogShift,
  plainCombinations,
  plainPI,
  plainTAU,
  plainE,
  plainPHI,
  plainNot,
  plainOr,
  plainXor,
  plainAnd,
  plainEqual,
  plainUnequal,
  plainSmaller,
  plainSmallerEq,
  plainLarger,
  plainLargerEq,
  plainCompare,
  plainGamma,
  plainLgamma,
  plainAcos,
  plainAcosh,
  plainAcot,
  plainAcoth,
  plainAcsc,
  plainAcsch,
  plainAsec,
  plainAsech,
  plainAsin,
  plainAsinh,
  plainAtan,
  plainAtan2,
  plainAtanh,
  plainCos,
  plainCosh,
  plainCot,
  plainCoth,
  plainCsc,
  plainCsch,
  plainSec,
  plainSech,
  plainSin,
  plainSinh,
  plainTan,
  plainTanh,
  plainIsIntegerValue,
  plainIsNegative,
  plainIsPositive,
  plainIsZero,
  plainIsNaN,
  WORK_EIGS_SYMMETRIC,
  WORK_POWER_ITERATION,
  WORK_INVERSE_ITERATION_VECTOR,
  WORK_INVERSE_ITERATION_MATRIX,
  WORK_QR_ALGORITHM_VECTOR,
  WORK_QR_ALGORITHM_MATRIX,
  WORK_BALANCE_MATRIX,
  WORK_EXPM,
  WORK_EXPMV,
  WORK_SQRTM,
  WORK_SQRTM_NEWTON_SCHULZ,
  WORK_SPARSE_LU_VECTOR,
  WORK_SPARSE_LU_INT,
  WORK_SPARSE_CHOL_VECTOR,
  WORK_SPARSE_CHOL_INT,
  WORK_COLUMN_COUNTS,
  WORK_LU_DECOMPOSITION,
  WORK_QR_DECOMPOSITION,
  WORK_CHOLESKY_DECOMPOSITION,
  WORK_FFT_2D,
  WORK_IRFFT,
  WORK_BLOCKED_MULTIPLY,
  eigsSymmetricWorkSize,
  powerIterationWorkSize,
  inverseIterationWorkSize,
  qrAlgorithmWorkSize,
  expmWorkSize,
  sqrtmWorkSize,
  sqrtmNewtonSchulzWorkSize,
  sparseLuWorkSize,
  sparseCholWorkSize,
  columnCountsWorkSize,
  fft2dWorkSize,
  irfftWorkSize,
  blockedMultiplyWorkSize,
  condWorkSize,
  validateWorkPtrSize,
  getWorkPtrRequirement,
} = await (async url => instantiate(
  await (async () => {
    const isNodeOrBun = typeof process != "undefined" && process.versions != null && (process.versions.node != null || process.versions.bun != null);
    if (isNodeOrBun) { return globalThis.WebAssembly.compile(await (await import("node:fs/promises")).readFile(url)); }
    else { return await globalThis.WebAssembly.compileStreaming(globalThis.fetch(url)); }
  })(), {
  }
))(new URL("index.wasm", import.meta.url));
