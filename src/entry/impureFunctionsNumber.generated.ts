/**
 * THIS FILE IS AUTO-GENERATED
 * DON'T MAKE CHANGES HERE
 */
/* eslint-disable @typescript-eslint/no-explicit-any */
import { config } from './configReadonly.js'
import {
  createChainClass,
  createNode,
  createObjectNode,
  createRangeNode,
  createRelationalNode,
  createReviver,
  createSymbolNode,
  createAccessorNode,
  createAssignmentNode,
  createChain,
  createConditionalNode,
  createFunctionNode,
  createIndexNode,
  createOperatorNode,
  createArrayNode,
  createFunctionAssignmentNode,
  createBlockNode,
  createConstantNode,
  createSimplifyConstant,
  createParenthesisNode,
  createParse,
  createResolve,
  createSimplifyCore,
  createCompile,
  createEvaluate,
  createHelpClass,
  createParserClass,
  createSimplify,
  createDerivative,
  createHelp,
  createParser,
  createRationalize,
  createCumSumTransform,
  createMapSlicesTransform,
  createFilterTransform,
  createForEachTransform,
  createMeanTransform,
  createSubsetTransform,
  createMapTransform,
  createStdTransform,
  createSumTransform,
  createVarianceTransform,
  createMaxTransform,
  createMinTransform,
  createRangeTransform
} from '../factoriesNumber.js'
import {
  e,
  _false,
  index,
  _Infinity,
  LN10,
  LOG10E,
  matrix,
  _NaN,
  _null,
  parseNumberWithConfig,
  phi,
  Range,
  replacer,
  ResultSet,
  SQRT1_2, // eslint-disable-line camelcase
  subset,
  tau,
  typed,
  unaryPlus,
  version,
  xor,
  abs,
  acos,
  acot,
  acsc,
  add,
  and,
  asec,
  asin,
  atan,
  atanh,
  bigint,
  bitNot,
  bitXor,
  boolean,
  cbrt,
  combinations,
  compare,
  compareText,
  cos,
  cot,
  csc,
  cube,
  divide,
  equalScalar,
  erf,
  exp,
  filter,
  forEach,
  format,
  gamma,
  isBounded,
  isInteger,
  isNegative,
  isPositive,
  isZero,
  LOG2E,
  largerEq,
  leftShift,
  log,
  log1p,
  map,
  mean,
  mod,
  multiply,
  not,
  number,
  or,
  pi,
  pow,
  random,
  rightLogShift,
  SQRT2,
  sech,
  sin,
  size,
  smallerEq,
  square,
  string,
  subtract,
  tanh,
  typeOf,
  unequal,
  xgcd,
  acoth,
  addScalar,
  asech,
  bernoulli,
  bitOr,
  combinationsWithRep,
  cosh,
  csch,
  divideScalar,
  equalText,
  expm1,
  isNaN,
  isPrime,
  larger,
  lgamma,
  log2,
  mapSlices,
  multiplyScalar,
  nthRoot,
  pickRandom,
  randomInt,
  rightArithShift,
  sec,
  sinh,
  sqrt,
  tan,
  unaryMinus,
  variance,
  acosh,
  atan2,
  bitAnd,
  catalan,
  clone,
  composition,
  coth,
  equal,
  factorial,
  isFinite,
  LN2,
  log10,
  multinomial,
  numeric,
  permutations,
  prod,
  round,
  smaller,
  subtractScalar,
  zeta,
  acsch,
  compareNatural,
  cumsum,
  floor,
  hypot,
  lcm,
  max,
  min,
  norm,
  print,
  range,
  sign,
  std,
  sum,
  asinh,
  ceil,
  corr,
  fix,
  isNumeric,
  partitionSelect,
  stirlingS2,
  bellNumbers,
  deepEqual,
  gcd,
  median,
  quantileSeq,
  mode,
  _true,
  hasNumericValue,
  mad
} from './pureFunctionsNumber.generated.js'

const math: Record<string, any> = {} // NOT pure!
const mathWithTransform: Record<string, any> = {} // NOT pure!
const classes: Record<string, any> = {} // NOT pure!

export const Chain: any = createChainClass({ math, typed })
export const Node: any = createNode({ mathWithTransform })
export const ObjectNode: any = createObjectNode({ Node })
export const RangeNode: any = createRangeNode({ Node })
export const RelationalNode: any = createRelationalNode({ Node })
export const reviver: any = createReviver({ classes })
export const SymbolNode: any = createSymbolNode({ Node, math })
export const AccessorNode: any = createAccessorNode({ Node, subset })
export const AssignmentNode: any = createAssignmentNode({
  matrix,
  Node,
  subset
})
export const chain: any = createChain({ Chain, typed })
export const ConditionalNode: any = createConditionalNode({ Node })
export const FunctionNode: any = createFunctionNode({ Node, SymbolNode, math })
export const IndexNode: any = createIndexNode({ Node, size })
export const OperatorNode: any = createOperatorNode({ Node })
export const ArrayNode: any = createArrayNode({ Node })
export const FunctionAssignmentNode: any = createFunctionAssignmentNode({
  Node,
  typed
})
export const BlockNode: any = createBlockNode({ Node, ResultSet })
export const ConstantNode: any = createConstantNode({ Node, isBounded })
export const simplifyConstant: any = createSimplifyConstant({
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  SymbolNode,
  config,
  isBounded,
  mathWithTransform,
  matrix,
  typed
})
export const ParenthesisNode: any = createParenthesisNode({ Node })
export const parse: any = createParse({
  AccessorNode,
  ArrayNode,
  AssignmentNode,
  BlockNode,
  ConditionalNode,
  ConstantNode,
  FunctionAssignmentNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  RangeNode,
  RelationalNode,
  SymbolNode,
  config,
  numeric,
  typed
})
export const resolve: any = createResolve({
  ConstantNode,
  FunctionNode,
  OperatorNode,
  ParenthesisNode,
  parse,
  typed
})
export const simplifyCore: any = createSimplifyCore({
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  add,
  divide,
  equal,
  isZero,
  multiply,
  parse,
  pow,
  subtract,
  typed
})
export const compile: any = createCompile({ parse, typed })
export const evaluate: any = createEvaluate({ parse, typed })
export const Help: any = createHelpClass({ evaluate })
export const Parser: any = createParserClass({ evaluate, parse })
export const simplify: any = createSimplify({
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  equal,
  parse,
  replacer,
  resolve,
  simplifyConstant,
  simplifyCore,
  typed
})
export const derivative: any = createDerivative({
  ConstantNode,
  FunctionNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  config,
  equal,
  isZero,
  numeric,
  parse,
  simplify,
  typed
})
export const help: any = createHelp({ Help, mathWithTransform, typed })
export const parser: any = createParser({ Parser, typed })
export const rationalize: any = createRationalize({
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  add,
  config,
  divide,
  equal,
  isZero,
  mathWithTransform,
  matrix,
  multiply,
  parse,
  pow,
  simplify,
  simplifyConstant,
  simplifyCore,
  subtract,
  typed
})

Object.assign(math, {
  e,
  false: _false,
  index,
  Infinity: _Infinity,
  LN10,
  LOG10E,
  matrix,
  NaN: _NaN,
  null: _null,
  parseNumberWithConfig,
  phi,
  replacer,
  SQRT1_2,
  subset,
  tau,
  typed,
  unaryPlus,
  E: e,
  version,
  xor,
  abs,
  acos,
  acot,
  acsc,
  add,
  and,
  asec,
  asin,
  atan,
  atanh,
  bigint,
  bitNot,
  bitXor,
  boolean,
  cbrt,
  combinations,
  compare,
  compareText,
  cos,
  cot,
  csc,
  cube,
  divide,
  equalScalar,
  erf,
  exp,
  filter,
  forEach,
  format,
  gamma,
  isBounded,
  isInteger,
  isNegative,
  isPositive,
  isZero,
  LOG2E,
  largerEq,
  leftShift,
  log,
  log1p,
  map,
  mean,
  mod,
  multiply,
  not,
  number,
  or,
  pi,
  pow,
  random,
  reviver,
  rightLogShift,
  SQRT2,
  sech,
  sin,
  size,
  smallerEq,
  square,
  string,
  subtract,
  tanh,
  typeOf,
  unequal,
  xgcd,
  acoth,
  addScalar,
  asech,
  bernoulli,
  bitOr,
  chain,
  combinationsWithRep,
  cosh,
  csch,
  divideScalar,
  equalText,
  expm1,
  isNaN,
  isPrime,
  larger,
  lgamma,
  log2,
  mapSlices,
  multiplyScalar,
  nthRoot,
  pickRandom,
  randomInt,
  rightArithShift,
  sec,
  sinh,
  sqrt,
  tan,
  unaryMinus,
  variance,
  acosh,
  atan2,
  bitAnd,
  catalan,
  clone,
  composition,
  coth,
  equal,
  factorial,
  isFinite,
  LN2,
  log10,
  multinomial,
  numeric,
  permutations,
  prod,
  round,
  smaller,
  subtractScalar,
  PI: pi,
  zeta,
  acsch,
  compareNatural,
  cumsum,
  floor,
  hypot,
  lcm,
  max,
  min,
  norm,
  print,
  range,
  sign,
  simplifyConstant,
  std,
  sum,
  asinh,
  ceil,
  corr,
  fix,
  isNumeric,
  partitionSelect,
  stirlingS2,
  bellNumbers,
  deepEqual,
  gcd,
  median,
  parse,
  quantileSeq,
  resolve,
  simplifyCore,
  compile,
  evaluate,
  mode,
  simplify,
  derivative,
  help,
  parser,
  true: _true,
  hasNumericValue,
  rationalize,
  mad,
  config
})

Object.assign(mathWithTransform, math, {
  cumsum: createCumSumTransform({ add, typed, unaryPlus }),
  mapSlices: createMapSlicesTransform({ isInteger, typed }),
  filter: createFilterTransform({ typed }),
  forEach: createForEachTransform({ typed }),
  mean: createMeanTransform({ add, divide, typed }),
  subset: createSubsetTransform({}),
  map: createMapTransform({ typed }),
  std: createStdTransform({ map, sqrt, typed, variance }),
  sum: createSumTransform({ add, config, numeric, typed }),
  variance: createVarianceTransform({
    add,
    divide,
    isNaN,
    mapSlices,
    multiply,
    subtract,
    typed
  }),
  max: createMaxTransform({ config, isNaN, larger, numeric, typed }),
  min: createMinTransform({ config, isNaN, numeric, smaller, typed }),
  range: createRangeTransform({
    matrix,
    add,
    config,
    equal,
    isPositive,
    isZero,
    larger,
    largerEq,
    smaller,
    smallerEq,
    typed
  })
})

Object.assign(classes, {
  Range,
  ResultSet,
  Chain,
  Node,
  ObjectNode,
  RangeNode,
  RelationalNode,
  SymbolNode,
  AccessorNode,
  AssignmentNode,
  ConditionalNode,
  FunctionNode,
  IndexNode,
  OperatorNode,
  ArrayNode,
  FunctionAssignmentNode,
  BlockNode,
  ConstantNode,
  ParenthesisNode,
  Help,
  Parser
})

Chain.createProxy(math)

export { embeddedDocs as docs } from '../expression/embeddedDocs/embeddedDocs.js'
