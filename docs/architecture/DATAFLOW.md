# Math.js Data Flow Documentation

This document describes how data flows through the math.js library, from user input to final output, covering all major pathways and transformations.

## Table of Contents

1. [High-Level Data Flow](#high-level-data-flow)
2. [Instance Creation Flow](#instance-creation-flow)
3. [Direct API Call Flow](#direct-api-call-flow)
4. [Expression Evaluation Flow](#expression-evaluation-flow)
5. [Type Conversion Flow](#type-conversion-flow)
6. [Matrix Operation Flow](#matrix-operation-flow)
7. [WASM Acceleration Flow](#wasm-acceleration-flow)
8. [Parallel Execution Flow](#parallel-execution-flow)
9. [Configuration Change Flow](#configuration-change-flow)
10. [Chain API Flow](#chain-api-flow)

---

## High-Level Data Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              USER APPLICATION                                │
│                                                                              │
│   math.add(2, 3)          math.evaluate('2 + 3')       math.chain(2).add(3) │
│         │                          │                            │            │
└─────────┼──────────────────────────┼────────────────────────────┼────────────┘
          │                          │                            │
          ▼                          ▼                            ▼
┌─────────────────────┐    ┌─────────────────────┐    ┌─────────────────────┐
│    DIRECT API       │    │   EXPRESSION API    │    │     CHAIN API       │
│  (function call)    │    │  (parse → compile   │    │  (fluent builder)   │
│                     │    │   → evaluate)       │    │                     │
└─────────┬───────────┘    └─────────┬───────────┘    └─────────┬───────────┘
          │                          │                          │
          │                          ▼                          │
          │               ┌─────────────────────┐               │
          │               │       PARSER        │               │
          │               │  String → AST       │               │
          │               └─────────┬───────────┘               │
          │                         │                           │
          │                         ▼                           │
          │               ┌─────────────────────┐               │
          │               │      COMPILER       │               │
          │               │  AST → JS Function  │               │
          │               └─────────┬───────────┘               │
          │                         │                           │
          └─────────────────────────┼───────────────────────────┘
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │      TYPED-FUNCTION           │
                    │  Type dispatch & conversion   │
                    └───────────────┬───────────────┘
                                    │
          ┌─────────────────────────┼─────────────────────────┐
          │                         │                         │
          ▼                         ▼                         ▼
┌─────────────────────┐  ┌─────────────────────┐  ┌─────────────────────┐
│  SCALAR OPERATION   │  │  MATRIX OPERATION   │  │  COMPLEX OPERATION  │
│  (plain JS)         │  │  (algorithm suite)  │  │  (Complex.js)       │
└─────────────────────┘  └─────────┬───────────┘  └─────────────────────┘
                                   │
                    ┌──────────────┼──────────────┐
                    │              │              │
                    ▼              ▼              ▼
          ┌───────────────┐ ┌───────────┐ ┌───────────────┐
          │   JAVASCRIPT  │ │   WASM    │ │   PARALLEL    │
          │   (default)   │ │ (>1K els) │ │  (>10K els)   │
          └───────────────┘ └───────────┘ └───────────────┘
                    │              │              │
                    └──────────────┼──────────────┘
                                   │
                                   ▼
                    ┌───────────────────────────────┐
                    │          RESULT               │
                    │  (typed according to config)  │
                    └───────────────────────────────┘
```

---

## Instance Creation Flow

When `create()` is called, the following sequence occurs:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  create(factories, config)                                                   │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  1. CONFIGURATION MERGE                                                      │
│     ┌─────────────────────────────────────────────────────────────────────┐ │
│     │  DEFAULT_CONFIG + user config                                        │ │
│     │  {                                                                    │ │
│     │    relTol: 1e-12,                                                    │ │
│     │    absTol: 1e-15,                                                    │ │
│     │    matrix: 'Matrix',                                                 │ │
│     │    number: 'number',                                                 │ │
│     │    precision: 64,                                                    │ │
│     │    ...                                                               │ │
│     │  }                                                                    │ │
│     └─────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  2. BARE INSTANCE CREATION                                                   │
│     ┌─────────────────────────────────────────────────────────────────────┐ │
│     │  math = {                                                            │ │
│     │    isNumber, isComplex, isBigNumber, isMatrix,                       │ │
│     │    isUnit, isFraction, ... (30+ type checkers)                       │ │
│     │  }                                                                    │ │
│     └─────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  3. DEPENDENCY SCOPE INITIALIZATION                                         │
│     ┌─────────────────────────────────────────────────────────────────────┐ │
│     │  scope = {                                                           │ │
│     │    math,                                                             │ │
│     │    config: _config,                                                  │ │
│     │    // Functions will be added here as they're instantiated          │ │
│     │  }                                                                    │ │
│     └─────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  4. CORE FUNCTIONS SETUP                                                     │
│     ┌─────────────────────────────────────────────────────────────────────┐ │
│     │  • config() - Configuration getter/setter                            │ │
│     │  • import() - Runtime function import                                │ │
│     │  • on(), off(), emit() - Event emitter                               │ │
│     │  • typed - Typed function factory                                    │ │
│     └─────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  5. FACTORY SORTING (Topological)                                           │
│     ┌─────────────────────────────────────────────────────────────────────┐ │
│     │  Input:  [createAdd, createMultiply, createAddScalar, ...]          │ │
│     │                                                                       │ │
│     │  Dependencies analyzed:                                               │ │
│     │    createAdd → needs [typed, addScalar, matrix, ...]                 │ │
│     │    createMultiply → needs [typed, multiplyScalar, matrix, ...]       │ │
│     │    createAddScalar → needs [typed]                                   │ │
│     │                                                                       │ │
│     │  Output: [createAddScalar, ..., createAdd, createMultiply, ...]     │ │
│     │  (sorted so dependencies come first)                                  │ │
│     └─────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  6. FACTORY INSTANTIATION                                                    │
│     ┌─────────────────────────────────────────────────────────────────────┐ │
│     │  For each factory in sorted order:                                   │ │
│     │                                                                       │ │
│     │    1. Extract dependencies from scope                                │ │
│     │       deps = pickShallow(scope, factory.dependencies)                │ │
│     │                                                                       │ │
│     │    2. Validate dependencies exist                                    │ │
│     │       assertDependencies(name, deps, scope)                          │ │
│     │                                                                       │ │
│     │    3. Call factory create function                                   │ │
│     │       fn = factory.create(deps)                                      │ │
│     │                                                                       │ │
│     │    4. Add to scope and math instance                                 │ │
│     │       scope[name] = fn                                               │ │
│     │       math[name] = fn                                                │ │
│     └─────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  7. CONFIG CHANGE LISTENER                                                   │
│     ┌─────────────────────────────────────────────────────────────────────┐ │
│     │  math.on('config', (curr, prev, changes) => {                        │ │
│     │    // Find factories with recreateOnConfigChange: true              │ │
│     │    // Re-instantiate those factories                                 │ │
│     │  })                                                                   │ │
│     └─────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  8. RETURN COMPLETE INSTANCE                                                 │
│     ┌─────────────────────────────────────────────────────────────────────┐ │
│     │  math = {                                                            │ │
│     │    // Type checkers (30+)                                            │ │
│     │    isNumber, isComplex, ...                                          │ │
│     │                                                                       │ │
│     │    // Core functions                                                 │ │
│     │    config, import, create, typed,                                    │ │
│     │    on, off, emit,                                                    │ │
│     │                                                                       │ │
│     │    // Error types                                                    │ │
│     │    ArgumentsError, DimensionError, IndexError,                       │ │
│     │                                                                       │ │
│     │    // All math functions (350+)                                      │ │
│     │    add, subtract, multiply, divide, ...                              │ │
│     │    sin, cos, tan, ...                                                │ │
│     │    matrix, det, inv, ...                                             │ │
│     │    parse, evaluate, simplify, ...                                    │ │
│     │  }                                                                    │ │
│     └─────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Direct API Call Flow

When calling a function directly like `math.add(2, 3)`:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  math.add(2, 3)                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  TYPED-FUNCTION DISPATCH                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  1. Examine argument types                                              ││
│  │     typeof 2 → 'number'                                                 ││
│  │     typeof 3 → 'number'                                                 ││
│  │                                                                          ││
│  │  2. Find matching signature                                             ││
│  │     'number, number' → (x, y) => x + y                                  ││
│  │                                                                          ││
│  │  3. If no exact match, try conversions                                  ││
│  │     number → BigNumber (if configured)                                  ││
│  │     number → Complex (for sqrt of negative)                             ││
│  │                                                                          ││
│  │  4. If still no match, throw TypeError                                  ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  SIGNATURE EXECUTION                                                         │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  // For 'number, number' signature:                                     ││
│  │  return x + y  // 2 + 3 = 5                                             ││
│  │                                                                          ││
│  │  // For 'Matrix, Matrix' signature:                                     ││
│  │  return matrixAlgorithm(x, y, addScalar)                                ││
│  │                                                                          ││
│  │  // For 'any, any, ...any' (variadic):                                  ││
│  │  result = addScalar(x, y)                                               ││
│  │  for (arg of rest) result = addScalar(result, arg)                      ││
│  │  return result                                                           ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  RESULT: 5                                                                   │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Expression Evaluation Flow

When evaluating `math.evaluate('2 * x + sin(y)', {x: 3, y: 0.5})`:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  math.evaluate('2 * x + sin(y)', {x: 3, y: 0.5})                            │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  PHASE 1: TOKENIZATION                                                       │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  Input: "2 * x + sin(y)"                                                ││
│  │                                                                          ││
│  │  Token stream:                                                           ││
│  │  ┌──────┬──────┬───────┬──────┬───────┬──────┬───────┬──────┬───────┐  ││
│  │  │NUMBER│DELIM │SYMBOL │DELIM │SYMBOL │DELIM │SYMBOL │DELIM │DELIM  │  ││
│  │  │  2   │  *   │   x   │  +   │  sin  │  (   │   y   │  )   │ EOF   │  ││
│  │  └──────┴──────┴───────┴──────┴───────┴──────┴───────┴──────┴───────┘  ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  PHASE 2: PARSING (Recursive Descent)                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  Operator Precedence:                                                    ││
│  │    * : 13 (higher, binds tighter)                                       ││
│  │    + : 12 (lower)                                                        ││
│  │    function call: highest                                                ││
│  │                                                                          ││
│  │  Parsing sequence:                                                       ││
│  │    1. parseAddition()                                                   ││
│  │       ├── parseMultiplication()                                         ││
│  │       │   ├── parseUnary() → ConstantNode(2)                           ││
│  │       │   ├── consume('*')                                              ││
│  │       │   └── parseUnary() → SymbolNode('x')                           ││
│  │       │   → OperatorNode('*', [ConstantNode(2), SymbolNode('x')])      ││
│  │       ├── consume('+')                                                  ││
│  │       └── parseMultiplication()                                         ││
│  │           └── parseUnary()                                              ││
│  │               └── parseFunctionCall()                                   ││
│  │                   → FunctionNode('sin', [SymbolNode('y')])              ││
│  │       → OperatorNode('+', [OperatorNode(*), FunctionNode(sin)])        ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  PHASE 3: AST CONSTRUCTION                                                   │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │                       OperatorNode('+')                                  ││
│  │                      /                \                                  ││
│  │           OperatorNode('*')      FunctionNode('sin')                    ││
│  │            /          \                  |                               ││
│  │  ConstantNode(2)  SymbolNode('x')  SymbolNode('y')                      ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  PHASE 4: COMPILATION                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  Each node generates a function:                                        ││
│  │                                                                          ││
│  │  ConstantNode(2)._compile()                                             ││
│  │    → (scope) => 2                                                       ││
│  │                                                                          ││
│  │  SymbolNode('x')._compile()                                             ││
│  │    → (scope) => scope.get('x')                                          ││
│  │                                                                          ││
│  │  OperatorNode('*')._compile()                                           ││
│  │    → (scope) => math.multiply(left(scope), right(scope))                ││
│  │                                                                          ││
│  │  FunctionNode('sin')._compile()                                         ││
│  │    → (scope) => math.sin(arg(scope))                                    ││
│  │                                                                          ││
│  │  Final compiled function:                                                ││
│  │    (scope) => {                                                          ││
│  │      const leftResult = math.multiply(2, scope.get('x'))                ││
│  │      const rightResult = math.sin(scope.get('y'))                       ││
│  │      return math.add(leftResult, rightResult)                           ││
│  │    }                                                                     ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  PHASE 5: EVALUATION                                                         │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  Scope: {x: 3, y: 0.5}                                                  ││
│  │                                                                          ││
│  │  Execution:                                                              ││
│  │    1. scope.get('x') → 3                                                ││
│  │    2. math.multiply(2, 3) → 6                                           ││
│  │    3. scope.get('y') → 0.5                                              ││
│  │    4. math.sin(0.5) → 0.479...                                          ││
│  │    5. math.add(6, 0.479...) → 6.479...                                  ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  RESULT: 6.479425538604203                                                   │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Type Conversion Flow

When types need conversion:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  math.add(math.bignumber(1), 2)                                              │
│           ↓                  ↓                                               │
│      BigNumber(1)        number(2)                                          │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  TYPED-FUNCTION SIGNATURE MATCHING                                           │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  Arguments: [BigNumber, number]                                         ││
│  │                                                                          ││
│  │  Available signatures:                                                   ││
│  │    'number, number'           → NO (first arg is BigNumber)             ││
│  │    'BigNumber, BigNumber'     → POSSIBLE (with conversion)              ││
│  │    'Complex, Complex'         → NO (neither is Complex)                 ││
│  │    ...                                                                   ││
│  │                                                                          ││
│  │  Best match: 'BigNumber, BigNumber'                                     ││
│  │  Required conversions: [none, number → BigNumber]                       ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  CONVERSION EXECUTION                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  Conversion chain lookup:                                                ││
│  │    from: 'number', to: 'BigNumber'                                      ││
│  │                                                                          ││
│  │  Conversion function:                                                    ││
│  │    (x) => new BigNumber(x)                                              ││
│  │                                                                          ││
│  │  Apply:                                                                  ││
│  │    2 → BigNumber(2)                                                     ││
│  │                                                                          ││
│  │  Final arguments: [BigNumber(1), BigNumber(2)]                          ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  SIGNATURE EXECUTION                                                         │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  'BigNumber, BigNumber': (x, y) => x.plus(y)                            ││
│  │                                                                          ││
│  │  BigNumber(1).plus(BigNumber(2)) → BigNumber(3)                         ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  RESULT: BigNumber(3)                                                        │
└─────────────────────────────────────────────────────────────────────────────┘
```

**Conversion Chain Hierarchy:**

```
         ┌─────────────────────────────────────────────────┐
         │                    any                          │
         └─────────────────────────────────────────────────┘
                              │
     ┌────────────┬───────────┼───────────┬────────────┐
     ▼            ▼           ▼           ▼            ▼
  number    BigNumber    Complex    Fraction     string
     │            ▲           ▲           ▲
     └────────────┼───────────┼───────────┘
                  │           │
            (conversions available)

Conversion paths:
  number → BigNumber   (via config or explicit)
  number → Complex     (for sqrt(-1), etc.)
  number → Fraction    (for exact arithmetic)
  string → number      (parsing)
  Array  → Matrix      (automatic for matrix ops)
```

---

## Matrix Operation Flow

When performing matrix operations like `math.multiply(A, B)`:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  math.multiply(A, B)   where A: 100x100, B: 100x100                         │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  TYPE DETECTION                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  isMatrix(A) → true (DenseMatrix)                                       ││
│  │  isMatrix(B) → true (DenseMatrix)                                       ││
│  │                                                                          ││
│  │  Signature match: 'Matrix, Matrix'                                      ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  MATRIX TYPE ANALYSIS                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  A.type → 'DenseMatrix'                                                 ││
│  │  B.type → 'DenseMatrix'                                                 ││
│  │                                                                          ││
│  │  Select algorithm: matAlgo13xDD (Dense-Dense multiply)                  ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  DIMENSION VALIDATION                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  A.size() → [100, 100]                                                  ││
│  │  B.size() → [100, 100]                                                  ││
│  │                                                                          ││
│  │  Check: A.cols (100) === B.rows (100) ✓                                 ││
│  │  Result size: [100, 100]                                                 ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  BACKEND SELECTION (MatrixWasmBridge)                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  totalElements = 100 * 100 = 10,000                                     ││
│  │                                                                          ││
│  │  if (totalElements >= 10,000 && ParallelMatrix.isAvailable())           ││
│  │    → Use PARALLEL                                                       ││
│  │  else if (totalElements >= 1,000 && WasmLoader.isLoaded())              ││
│  │    → Use WASM                                                           ││
│  │  else                                                                    ││
│  │    → Use JAVASCRIPT                                                     ││
│  │                                                                          ││
│  │  Selected: PARALLEL (10,000 >= 10,000)                                  ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
                    (See Parallel Execution Flow below)
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  RESULT CONSTRUCTION                                                         │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  resultData = [... 10,000 computed values ...]                          ││
│  │                                                                          ││
│  │  return new DenseMatrix({                                               ││
│  │    data: reshape(resultData, [100, 100]),                               ││
│  │    size: [100, 100]                                                     ││
│  │  })                                                                      ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## WASM Acceleration Flow

When WASM is selected for acceleration:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  Matrix multiply with WASM (1000+ elements)                                  │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  1. WASM MODULE CHECK                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  if (!WasmLoader.isLoaded()) {                                          ││
│  │    await WasmLoader.load('/lib/wasm/matrix.wasm')                       ││
│  │  }                                                                       ││
│  │                                                                          ││
│  │  // WASM module now available                                           ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  2. DATA MARSHALING (JS → WASM)                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  // Flatten matrices to 1D arrays                                       ││
│  │  aFlat = A._data.flat()    // [a00, a01, a02, ..., a99_99]             ││
│  │  bFlat = B._data.flat()    // [b00, b01, b02, ..., b99_99]             ││
│  │                                                                          ││
│  │  // Allocate WASM memory                                                ││
│  │  const { ptr: aPtr, array: aWasm } =                                    ││
│  │    WasmLoader.allocateFloat64Array(aFlat)                               ││
│  │  const { ptr: bPtr, array: bWasm } =                                    ││
│  │    WasmLoader.allocateFloat64Array(bFlat)                               ││
│  │                                                                          ││
│  │  // Copy data into WASM memory                                          ││
│  │  aWasm.set(aFlat)                                                       ││
│  │  bWasm.set(bFlat)                                                       ││
│  │                                                                          ││
│  │  Memory layout:                                                          ││
│  │  ┌────────────────────────────────────────────────────────────────────┐ ││
│  │  │ WASM Linear Memory                                                  │ ││
│  │  │ ┌─────────────┬─────────────┬─────────────┬──────────────────────┐ │ ││
│  │  │ │   aPtr      │   bPtr      │  resultPtr  │    (free space)      │ │ ││
│  │  │ │  80KB       │  80KB       │  80KB       │                      │ │ ││
│  │  │ └─────────────┴─────────────┴─────────────┴──────────────────────┘ │ ││
│  │  └────────────────────────────────────────────────────────────────────┘ ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  3. WASM EXECUTION                                                           │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  // Call WASM function                                                  ││
│  │  const resultPtr = WasmModule.multiplyDenseSIMD(                        ││
│  │    aPtr, 100, 100,   // A data, rows, cols                              ││
│  │    bPtr, 100, 100    // B data, rows, cols                              ││
│  │  )                                                                       ││
│  │                                                                          ││
│  │  // WASM internally uses:                                               ││
│  │  //  - Block multiplication (64x64 blocks for cache efficiency)        ││
│  │  //  - SIMD operations (2x f64 per instruction)                         ││
│  │  //  - Loop unrolling                                                   ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  4. DATA UNMARSHALING (WASM → JS)                                            │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  // Read result from WASM memory                                        ││
│  │  const resultArray = new Float64Array(                                  ││
│  │    WasmModule.memory.buffer,                                            ││
│  │    resultPtr,                                                           ││
│  │    100 * 100  // 10,000 elements                                        ││
│  │  )                                                                       ││
│  │                                                                          ││
│  │  // Copy to JavaScript (WASM memory may relocate on GC)                 ││
│  │  const resultData = Array.from(resultArray)                             ││
│  │                                                                          ││
│  │  // Free WASM memory                                                    ││
│  │  WasmLoader.free(aPtr)                                                  ││
│  │  WasmLoader.free(bPtr)                                                  ││
│  │  WasmLoader.free(resultPtr)                                             ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  5. RESULT CONSTRUCTION                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  return new DenseMatrix({                                               ││
│  │    data: reshape(resultData, [100, 100]),                               ││
│  │    size: [100, 100]                                                     ││
│  │  })                                                                      ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Parallel Execution Flow

When parallel execution is selected:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  Matrix multiply with Parallel (10,000+ elements)                            │
│  A: 1000x1000, B: 1000x1000                                                 │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  1. WORKER POOL INITIALIZATION                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  if (!ParallelMatrix.pool) {                                            ││
│  │    const numCores = navigator.hardwareConcurrency || 4                  ││
│  │    ParallelMatrix.pool = new WorkerPool(                                ││
│  │      'lib/workers/matrix-worker.js',                                    ││
│  │      numCores  // e.g., 8 workers                                       ││
│  │    )                                                                     ││
│  │  }                                                                       ││
│  │                                                                          ││
│  │  Pool state:                                                             ││
│  │  ┌─────────────────────────────────────────────────────────────────────┐││
│  │  │  workers: [W1, W2, W3, W4, W5, W6, W7, W8]                          │││
│  │  │  available: [W1, W2, W3, W4, W5, W6, W7, W8]                        │││
│  │  │  taskQueue: []                                                       │││
│  │  └─────────────────────────────────────────────────────────────────────┘││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  2. WORK PARTITIONING                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  totalRows = 1000                                                       ││
│  │  numWorkers = 8                                                          ││
│  │  rowsPerWorker = ceil(1000 / 8) = 125                                   ││
│  │                                                                          ││
│  │  Partitions:                                                             ││
│  │  ┌────────┬────────────────────────────────────────────────────────────┐││
│  │  │ Worker │ Rows                                                        │││
│  │  ├────────┼────────────────────────────────────────────────────────────┤││
│  │  │   W1   │ 0-124     (125 rows of A × all of B)                       │││
│  │  │   W2   │ 125-249   (125 rows of A × all of B)                       │││
│  │  │   W3   │ 250-374   (125 rows of A × all of B)                       │││
│  │  │   W4   │ 375-499   (125 rows of A × all of B)                       │││
│  │  │   W5   │ 500-624   (125 rows of A × all of B)                       │││
│  │  │   W6   │ 625-749   (125 rows of A × all of B)                       │││
│  │  │   W7   │ 750-874   (125 rows of A × all of B)                       │││
│  │  │   W8   │ 875-999   (125 rows of A × all of B)                       │││
│  │  └────────┴────────────────────────────────────────────────────────────┘││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  3. DATA PREPARATION                                                         │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  // Use SharedArrayBuffer for zero-copy (if available)                  ││
│  │  if (typeof SharedArrayBuffer !== 'undefined') {                        ││
│  │    sharedA = new SharedArrayBuffer(1000 * 1000 * 8)                     ││
│  │    sharedB = new SharedArrayBuffer(1000 * 1000 * 8)                     ││
│  │    sharedResult = new SharedArrayBuffer(1000 * 1000 * 8)                ││
│  │                                                                          ││
│  │    // Copy data once                                                    ││
│  │    new Float64Array(sharedA).set(A.flat())                              ││
│  │    new Float64Array(sharedB).set(B.flat())                              ││
│  │  }                                                                       ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  4. PARALLEL DISPATCH                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  const tasks = []                                                       ││
│  │                                                                          ││
│  │  for (let i = 0; i < numWorkers; i++) {                                 ││
│  │    const startRow = i * rowsPerWorker                                   ││
│  │    const endRow = min((i + 1) * rowsPerWorker, totalRows)               ││
│  │                                                                          ││
│  │    tasks.push(pool.execute({                                            ││
│  │      type: 'multiply',                                                  ││
│  │      sharedA,           // SharedArrayBuffer reference                  ││
│  │      sharedB,           // SharedArrayBuffer reference                  ││
│  │      sharedResult,      // SharedArrayBuffer reference                  ││
│  │      aCols: 1000,                                                       ││
│  │      bCols: 1000,                                                       ││
│  │      startRow,                                                           ││
│  │      endRow                                                              ││
│  │    }))                                                                   ││
│  │  }                                                                       ││
│  │                                                                          ││
│  │  // All tasks dispatched simultaneously                                 ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  5. PARALLEL EXECUTION                                                       │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │                                                                          ││
│  │  ┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐ ││
│  │  │  W1  │  │  W2  │  │  W3  │  │  W4  │  │  W5  │  │  W6  │  │  W7  │ ││
│  │  │rows  │  │rows  │  │rows  │  │rows  │  │rows  │  │rows  │  │rows  │ ││
│  │  │0-124 │  │125-  │  │250-  │  │375-  │  │500-  │  │625-  │  │750-  │ ││
│  │  │      │  │249   │  │374   │  │499   │  │624   │  │749   │  │874   │ ││
│  │  └──┬───┘  └──┬───┘  └──┬───┘  └──┬───┘  └──┬───┘  └──┬───┘  └──┬───┘ ││
│  │     │         │         │         │         │         │         │      ││
│  │     │         │         │         │         │         │         │      ││
│  │     ▼         ▼         ▼         ▼         ▼         ▼         ▼      ││
│  │  Writes to sharedResult (different row ranges, no conflicts)           ││
│  │                                                                          ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  6. SYNCHRONIZATION                                                          │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  // Wait for all workers to complete                                    ││
│  │  await Promise.all(tasks)                                               ││
│  │                                                                          ││
│  │  // All workers have written their portions to sharedResult            ││
│  │  // No explicit merge needed with SharedArrayBuffer                     ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  7. RESULT CONSTRUCTION                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  const resultArray = new Float64Array(sharedResult)                     ││
│  │                                                                          ││
│  │  return new DenseMatrix({                                               ││
│  │    data: reshape(Array.from(resultArray), [1000, 1000]),                ││
│  │    size: [1000, 1000]                                                   ││
│  │  })                                                                      ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Configuration Change Flow

When `math.config()` is called:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  math.config({ precision: 128, number: 'BigNumber' })                        │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  1. CONFIG VALIDATION                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  Validate:                                                               ││
│  │    precision: 128 (valid: positive integer)                             ││
│  │    number: 'BigNumber' (valid: 'number'|'BigNumber'|'bigint'|'Fraction')││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  2. CONFIG UPDATE                                                            │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  previousConfig = { precision: 64, number: 'number', ... }              ││
│  │  currentConfig = { precision: 128, number: 'BigNumber', ... }           ││
│  │  changedKeys = ['precision', 'number']                                  ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  3. EVENT EMISSION                                                           │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  math.emit('config', currentConfig, previousConfig, changedKeys)        ││
│  │                                                                          ││
│  │  Listeners invoked:                                                      ││
│  │    - Internal listener for factory recreation                           ││
│  │    - User-registered listeners (if any)                                 ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  4. FACTORY RECREATION                                                       │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  For each factory with meta.recreateOnConfigChange === true:            ││
│  │                                                                          ││
│  │  // Find affected factories                                             ││
│  │  affectedFactories = factories.filter(f =>                              ││
│  │    f.meta?.recreateOnConfigChange                                       ││
│  │  )                                                                       ││
│  │                                                                          ││
│  │  // Examples: numeric, parse, typed configurations                      ││
│  │  // These need fresh instances with new config                          ││
│  │                                                                          ││
│  │  affectedFactories.forEach(factory => {                                 ││
│  │    const newInstance = factory.create(scope)                            ││
│  │    math[factory.fn] = newInstance                                       ││
│  │    scope[factory.fn] = newInstance                                      ││
│  │  })                                                                      ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  5. RETURN NEW CONFIG                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  return Object.freeze({ ...currentConfig })                             ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘

Post-config behavior:

// Before config change:
math.evaluate('0.1 + 0.2')  // 0.30000000000000004 (number)

// After config change:
math.evaluate('0.1 + 0.2')  // BigNumber('0.3') (exact)
```

---

## Chain API Flow

When using the fluent chain API:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  math.chain(3).add(4).multiply(2).sqrt().done()                              │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  STEP 1: math.chain(3)                                                       │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  Creates new Chain instance:                                            ││
│  │                                                                          ││
│  │  chain = new Chain(3)                                                   ││
│  │  chain.value = 3                                                        ││
│  │                                                                          ││
│  │  Chain has proxy methods for all math functions                         ││
│  │  chain.add = function(...args) {                                        ││
│  │    return new Chain(math.add(this.value, ...args))                      ││
│  │  }                                                                       ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  STEP 2: .add(4)                                                             │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  chain.add(4)                                                           ││
│  │    ↓                                                                     ││
│  │  result = math.add(chain.value, 4)                                      ││
│  │         = math.add(3, 4)                                                ││
│  │         = 7                                                              ││
│  │    ↓                                                                     ││
│  │  return new Chain(7)                                                    ││
│  │                                                                          ││
│  │  New chain: { value: 7 }                                                ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  STEP 3: .multiply(2)                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  chain.multiply(2)                                                      ││
│  │    ↓                                                                     ││
│  │  result = math.multiply(7, 2)                                           ││
│  │         = 14                                                             ││
│  │    ↓                                                                     ││
│  │  return new Chain(14)                                                   ││
│  │                                                                          ││
│  │  New chain: { value: 14 }                                               ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  STEP 4: .sqrt()                                                             │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  chain.sqrt()                                                           ││
│  │    ↓                                                                     ││
│  │  result = math.sqrt(14)                                                 ││
│  │         = 3.7416573867739413                                            ││
│  │    ↓                                                                     ││
│  │  return new Chain(3.7416573867739413)                                   ││
│  │                                                                          ││
│  │  New chain: { value: 3.7416573867739413 }                               ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  STEP 5: .done()                                                             │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  chain.done()                                                           ││
│  │    ↓                                                                     ││
│  │  return chain.value                                                     ││
│  │         = 3.7416573867739413                                            ││
│  │                                                                          ││
│  │  Chain is unwrapped, plain value returned                               ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  RESULT: 3.7416573867739413                                                  │
└─────────────────────────────────────────────────────────────────────────────┘
```

**Chain Internals:**

```
Chain Object Structure:
┌─────────────────────────────────────────────────────────────────────────────┐
│  Chain {                                                                     │
│    value: <current value>                                                   │
│                                                                              │
│    // Extraction methods                                                    │
│    done(): value                                                            │
│    valueOf(): value                                                         │
│    toString(): math.format(value)                                           │
│    toJSON(): { mathjs: 'Chain', value: value }                              │
│                                                                              │
│    // Proxy methods for all 350+ math functions                             │
│    add(...args): new Chain(math.add(value, ...args))                        │
│    subtract(...args): new Chain(math.subtract(value, ...args))              │
│    multiply(...args): new Chain(math.multiply(value, ...args))              │
│    // ... etc                                                                │
│  }                                                                           │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Related Documentation

- [OVERVIEW.md](./OVERVIEW.md) - High-level architecture
- [ARCHITECTURE.md](./ARCHITECTURE.md) - Detailed design patterns
- [COMPONENTS.md](./COMPONENTS.md) - Component reference
