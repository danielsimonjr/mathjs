{
  "phase": 4,
  "sprint": 1,
  "title": "Unit Cancellation in Multiplication - Enhanced Implementation Guide",
  "priority": "MEDIUM",
  "effort": "8 hours",
  "status": "completed",
  "impact": "Implements algebraic simplification for compound units, enabling automatic cancellation of matching units in numerator and denominator. Fixes 2 skipped tests (JS/TS versions) and significantly improves Unit usability for complex calculations.",
  "currentBehavior": "math.evaluate('2 J/K/g * 2 g') returns '4 J*g / K / g' (no cancellation, redundant units)",
  "expectedBehavior": "math.evaluate('2 J/K/g * 2 g') returns '4 J / K' (grams cancel automatically)",
  "targetMetrics": {
    "testsFixed": {
      "current": "2 tests skipped (Unit cancellation)",
      "target": "Both tests passing"
    },
    "unitSimplification": {
      "current": "J/K/g * g = J*g/K/g (no cancellation)",
      "target": "J/K/g * g = J/K (grams cancel automatically)"
    }
  },
  "tasks": [
    {
      "id": "4.1.1",
      "category": "design",
      "title": "Design Unit Cancellation Algorithm",
      "description": "Design algorithm for identifying and canceling matching units in compound unit expressions, handling unit powers and fractional units.",
      "status": "pending",
      "estimatedHours": 2.0,
      "agent": "claude",
      "files": [
        "docs/architecture/UNIT_SIMPLIFICATION_DESIGN.md"
      ],
      "testCategories": ["design"],
      "implementation": {
        "purpose": "Create a clear algorithm specification before implementation. This design guides implementation and prevents bugs by handling all edge cases: matching units, powers, fractional units, and unit aliases.",
        "keyDecisions": [
          "How to represent compound units internally (numerator/denominator lists)",
          "How to detect matching units (handle aliases: m vs meter)",
          "How to handle unit powers (m^2/m = m)",
          "When to invoke simplification (auto after operations vs manual)",
          "How to preserve user-specified format vs auto-simplify"
        ]
      },
      "stepByStep": [
        {
          "step": 1,
          "action": "Analyze current Unit structure",
          "details": "Read src/type/unit/Unit.js and src/type/unit/Unit.ts to understand internal representation",
          "criticalNote": "**CRITICAL**: The structure below is an ASSUMPTION. You MUST verify the actual structure by reading Unit.js before proceeding with implementation. Do NOT skip this step!",
          "expectedStructure": {
            "description": "Units are stored with power notation",
            "example": {
              "unit": "J/K/g",
              "internalRepresentation": {
                "units": [
                  { "unit": { "name": "J" }, "prefix": { "name": "" }, "power": 1 },
                  { "unit": { "name": "K" }, "prefix": { "name": "" }, "power": -1 },
                  { "unit": { "name": "g" }, "prefix": { "name": "" }, "power": -1 }
                ]
              }
            }
          }
        },
        {
          "step": 2,
          "action": "Define simplification algorithm pseudocode",
          "algorithm": [
            "1. Parse unit structure into numerator (power > 0) and denominator (power < 0) lists",
            "2. For each unit in numerator:",
            "   a. Search for matching unit in denominator",
            "   b. If match found:",
            "      - Calculate cancel_amount = min(num_power, den_power)",
            "      - Reduce both powers by cancel_amount",
            "      - Remove unit if power becomes 0",
            "3. Reconstruct unit from simplified lists",
            "4. Return new Unit with simplified unit string"
          ],
          "code": "function simplifyUnit(unit) {\n  const { numerator, denominator } = parseCompoundUnit(unit)\n  \n  for (let i = numerator.length - 1; i >= 0; i--) {\n    for (let j = denominator.length - 1; j >= 0; j--) {\n      if (unitsMatch(numerator[i], denominator[j])) {\n        const cancelAmount = Math.min(numerator[i].power, denominator[j].power)\n        numerator[i].power -= cancelAmount\n        denominator[j].power -= cancelAmount\n        if (numerator[i].power === 0) numerator.splice(i, 1)\n        if (denominator[j].power === 0) denominator.splice(j, 1)\n        break\n      }\n    }\n  }\n  \n  return reconstructUnit(numerator, denominator)\n}"
        },
        {
          "step": 3,
          "action": "Define unit matching logic",
          "code": "function unitsMatch(unit1, unit2) {\n  // Normalize unit names (handle aliases)\n  const name1 = normalizeUnitName(unit1.unit.name)\n  const name2 = normalizeUnitName(unit2.unit.name)\n  \n  if (name1 !== name2) return false\n  \n  // Prefixes must match: km ≠ m\n  if (unit1.prefix.name !== unit2.prefix.name) return false\n  \n  return true\n}"
        },
        {
          "step": 4,
          "action": "Document edge cases with examples",
          "edgeCases": [
            {
              "case": "Power Reduction",
              "input": "m^2 / m",
              "expected": "m",
              "explanation": "m^(2-1) = m^1 = m"
            },
            {
              "case": "Dimensionless Result",
              "input": "m / m",
              "expected": "1 (empty unit)",
              "explanation": "All units cancel to dimensionless"
            },
            {
              "case": "Partial Cancellation",
              "input": "m^3 / m^2",
              "expected": "m",
              "explanation": "Cancel 2 powers, leaving 1"
            },
            {
              "case": "Prefix Preservation",
              "input": "km / m",
              "expected": "km / m (no cancellation)",
              "explanation": "Different prefixes don't cancel"
            },
            {
              "case": "Unit Aliases",
              "input": "meter / m",
              "expected": "1 (if aliases supported)",
              "explanation": "meter and m are the same unit"
            }
          ]
        },
        {
          "step": 5,
          "action": "Decide on auto-simplification strategy",
          "recommendation": "Auto-simplify after multiply/divide operations",
          "rationale": "Matches mathematical convention and user expectations. Alternative (manual simplify() method) is less intuitive.",
          "implementation": "class Unit {\n  multiply(other) {\n    const result = this._rawMultiply(other)\n    return result.simplify() // Auto-simplify\n  }\n}"
        },
        {
          "step": 6,
          "action": "Create design document",
          "file": "docs/architecture/UNIT_SIMPLIFICATION_DESIGN.md",
          "contents": "# Unit Simplification Design\n\n## Algorithm Specification\n[Include pseudocode from steps above]\n\n## Edge Cases\n[Include edge case table]\n\n## Implementation Decisions\n- Auto-simplification: YES\n- Alias handling: Basic normalization\n- Prefix matching: Required for cancellation"
        }
      ],
      "acceptanceCriteria": [
        "Complete simplification algorithm designed and documented",
        "Numerator/denominator representation defined",
        "Unit matching logic specified (with aliases)",
        "Power reduction algorithm detailed",
        "All edge cases identified with expected outputs",
        "Simplification timing decided (auto after multiply/divide)",
        "Design document created at docs/architecture/UNIT_SIMPLIFICATION_DESIGN.md",
        "Pseudocode provided for all core functions"
      ]
    },
    {
      "id": "4.1.2",
      "category": "implementation",
      "title": "Implement Unit Simplification",
      "description": "Implement the simplify() method in Unit class to perform algebraic cancellation of matching units. Add helper methods and integrate auto-simplification.",
      "status": "pending",
      "estimatedHours": 4.0,
      "agent": "claude",
      "files": [
        "src/type/unit/Unit.js",
        "src/type/unit/Unit.ts"
      ],
      "testCategories": ["unit"],
      "implementation": {
        "purpose": "Add simplification capability to Unit class. This is complex algebraic manipulation that requires careful handling of unit powers, aliases, and edge cases. Implementation must be applied to both .js and .ts versions.",
        "keyDecisions": [
          "Implement simplify() method on Unit.prototype",
          "Call simplify() automatically after multiply/divide",
          "Handle all edge cases from design phase",
          "Preserve value precision during simplification",
          "Maintain dual codebase (.js and .ts) synchronization"
        ]
      },
      "criticalPrerequisites": [
        "MUST verify Unit has clone() method (if not, use new Unit(this.value, this.units))",
        "MUST verify how Unit reconstructs unit strings (may need to use existing methods)",
        "MUST verify actual unit structure before implementing (see Task 4.1.1)",
        "DO NOT proceed with implementation until Task 4.1.1 is complete and verified"
      ],
      "stepByStep": [
        {
          "step": 1,
          "action": "Read and understand current Unit implementation",
          "files": ["src/type/unit/Unit.js", "src/type/unit/Unit.ts"],
          "lookFor": [
            "How units array is structured",
            "Existing parsing/formatting methods",
            "multiply() and divide() method implementations",
            "Unit power representation"
          ]
        },
        {
          "step": 2,
          "action": "Implement simplify() method in Unit.js",
          "code": "/**\n * Simplify this unit by canceling matching units in numerator and denominator.\n *\n * Performs algebraic cancellation on compound units. For example:\n * - J/K/g * g → J/K (grams cancel)\n * - m^2 / m → m (power reduction)\n * - m / m → 1 (dimensionless)\n *\n * @returns {Unit} A new simplified Unit\n *\n * @example\n * const energy = unit('2 J/K/g')\n * const mass = unit('2 g')\n * const result = energy.multiply(mass) // Auto-simplified to J/K\n *\n * @example\n * const area = unit('10 m^2')\n * const length = unit('2 m')\n * const result = area.divide(length) // Returns: 5 m\n */\nUnit.prototype.simplify = function() {\n  // Handle simple units (no simplification needed)\n  if (!this.units || this.units.length <= 1) {\n    return this.clone()\n  }\n\n  // Separate into numerator (power > 0) and denominator (power < 0)\n  const numerator = []\n  const denominator = []\n\n  for (const unitObj of this.units) {\n    if (unitObj.power > 0) {\n      numerator.push({ ...unitObj })\n    } else if (unitObj.power < 0) {\n      denominator.push({\n        ...unitObj,\n        power: Math.abs(unitObj.power)\n      })\n    }\n  }\n\n  // Cancel matching units\n  for (let i = numerator.length - 1; i >= 0; i--) {\n    for (let j = denominator.length - 1; j >= 0; j--) {\n      if (this._unitsEqual(numerator[i], denominator[j])) {\n        // Calculate how much to cancel\n        const cancelAmount = Math.min(\n          numerator[i].power,\n          denominator[j].power\n        )\n\n        // Reduce powers\n        numerator[i].power -= cancelAmount\n        denominator[j].power -= cancelAmount\n\n        // Remove if power becomes 0\n        if (numerator[i].power === 0) {\n          numerator.splice(i, 1)\n        }\n        if (denominator[j].power === 0) {\n          denominator.splice(j, 1)\n        }\n\n        break // Move to next numerator unit\n      }\n    }\n  }\n\n  // Reconstruct simplified unit array\n  const simplifiedUnits = [\n    ...numerator,\n    ...denominator.map(u => ({ ...u, power: -u.power }))\n  ]\n\n  // Create new Unit with simplified structure\n  if (simplifiedUnits.length === 0) {\n    // All units canceled - dimensionless result\n    return new Unit(this.value, null)\n  }\n\n  return new Unit(this.value, this._reconstructUnitString(simplifiedUnits))\n}"
        },
        {
          "step": 3,
          "action": "Implement _unitsEqual() helper method",
          "code": "/**\n * Check if two unit objects represent the same physical unit.\n * Handles unit aliases and requires matching prefixes.\n *\n * @param {Object} unit1 - First unit object\n * @param {Object} unit2 - Second unit object\n * @returns {boolean} True if units match\n * @private\n */\nUnit.prototype._unitsEqual = function(unit1, unit2) {\n  // Normalize unit names to handle aliases\n  const name1 = this._normalizeUnitName(unit1.unit.name)\n  const name2 = this._normalizeUnitName(unit2.unit.name)\n\n  // Names must match\n  if (name1 !== name2) {\n    return false\n  }\n\n  // Prefixes must match (km ≠ m)\n  if (unit1.prefix.name !== unit2.prefix.name) {\n    return false\n  }\n\n  return true\n}"
        },
        {
          "step": 4,
          "action": "Implement _normalizeUnitName() helper method",
          "code": "/**\n * Normalize unit names to handle aliases.\n *\n * @param {string} name - Unit name\n * @returns {string} Normalized name\n * @private\n */\nUnit.prototype._normalizeUnitName = function(name) {\n  const normalized = name.toLowerCase()\n\n  // Common aliases (extend as needed)\n  const aliasMap = {\n    'meter': 'm',\n    'meters': 'm',\n    'metre': 'm',\n    'metres': 'm',\n    'second': 's',\n    'seconds': 's',\n    'gram': 'g',\n    'grams': 'g',\n    'kilogram': 'kg',\n    'kilograms': 'kg'\n    // Add more aliases as discovered in testing\n  }\n\n  return aliasMap[normalized] || normalized\n}"
        },
        {
          "step": 5,
          "action": "Implement _reconstructUnitString() helper (if not exists)",
          "note": "This method likely already exists in Unit class. If not, implement based on Unit's internal format.",
          "code": "/**\n * Reconstruct unit string from simplified unit array.\n *\n * @param {Array} units - Simplified unit objects\n * @returns {string} Unit string representation\n * @private\n */\nUnit.prototype._reconstructUnitString = function(units) {\n  // Check if method already exists\n  // If yes, use existing implementation\n  // If no, implement based on observed Unit format\n  \n  const numerator = units.filter(u => u.power > 0)\n  const denominator = units.filter(u => u.power < 0)\n\n  let str = numerator\n    .map(u => this._formatUnitPart(u))\n    .join(' ')\n\n  if (denominator.length > 0) {\n    str += ' / ' + denominator\n      .map(u => this._formatUnitPart({ ...u, power: Math.abs(u.power) }))\n      .join(' / ')\n  }\n\n  return str\n}"
        },
        {
          "step": 6,
          "action": "Integrate auto-simplification in multiply()",
          "location": "Unit.prototype.multiply method",
          "code": "Unit.prototype.multiply = function(other) {\n  // ... existing multiplication logic ...\n  // (keep all existing code)\n  \n  const result = new Unit(newValue, newUnits)\n\n  // AUTO-SIMPLIFY after multiplication\n  return result.simplify()\n}"
        },
        {
          "step": 7,
          "action": "Integrate auto-simplification in divide()",
          "location": "Unit.prototype.divide method",
          "code": "Unit.prototype.divide = function(other) {\n  // ... existing division logic ...\n  // (keep all existing code)\n  \n  const result = new Unit(newValue, newUnits)\n\n  // AUTO-SIMPLIFY after division\n  return result.simplify()\n}"
        },
        {
          "step": 8,
          "action": "Replicate all changes to Unit.ts (TypeScript version)",
          "details": "Copy all implementations to TypeScript version with proper type annotations",
          "typeAnnotations": {
            "simplify": "simplify(): Unit",
            "_unitsEqual": "_unitsEqual(unit1: UnitPart, unit2: UnitPart): boolean",
            "_normalizeUnitName": "_normalizeUnitName(name: string): string",
            "_reconstructUnitString": "_reconstructUnitString(units: UnitPart[]): string"
          }
        },
        {
          "step": 9,
          "action": "Manual testing",
          "testScript": "// Quick verification\nconst math = require('./lib/cjs/index.js')\n\nconst test1 = math.evaluate('2 J/K/g * 2 g')\nconsole.log('Test 1:', test1.toString()) // Should be: \"4 J / K\"\n\nconst test2 = math.unit('10 m^2').divide(math.unit('2 m'))\nconsole.log('Test 2:', test2.toString()) // Should be: \"5 m\"\n\nconst test3 = math.unit('10 m').divide(math.unit('5 m'))\nconsole.log('Test 3:', test3.toString()) // Should be: \"2\" (dimensionless)"
        }
      ],
      "acceptanceCriteria": [
        "simplify() method implemented in Unit.js and Unit.ts",
        "Helper methods implemented: _unitsEqual(), _normalizeUnitName()",
        "_reconstructUnitString() implemented or existing method verified",
        "Matching units canceled correctly (J/K/g * g = J/K)",
        "Powers reduced appropriately (m^2/m = m)",
        "Unit aliases handled (meter === m where applicable)",
        "Dimensionless results handled (m/m = empty unit)",
        "Prefixes respected (km ≠ m, no false cancellation)",
        "Auto-simplification integrated in multiply()",
        "Auto-simplification integrated in divide()",
        "Both .js and .ts implementations complete and synchronized",
        "Manual testing confirms basic cancellation works",
        "No errors during compilation"
      ]
    },
    {
      "id": "4.1.3",
      "category": "testing",
      "title": "Enable and Verify Unit Cancellation Tests",
      "description": "Remove it.skip from Unit cancellation test and add comprehensive tests for simplification edge cases. Verify all tests pass.",
      "status": "pending",
      "estimatedHours": 2.0,
      "agent": "claude",
      "files": [
        "test/unit-tests/type/unit/Unit.test.ts",
        "test/unit-tests/type/unit/Unit.test.js"
      ],
      "testCategories": ["unit"],
      "implementation": {
        "purpose": "Verify unit cancellation works correctly for the test case and add comprehensive coverage for all edge cases identified in design. Tests validate the entire sprint's work.",
        "keyDecisions": [
          "Enable main cancellation test at line 1440",
          "Add tests for power reduction",
          "Add tests for dimensionless results",
          "Test unit aliases (if supported)",
          "Test that non-matching units don't cancel",
          "Verify both JS and TS test suites"
        ]
      },
      "stepByStep": [
        {
          "step": 1,
          "action": "Enable main cancellation test (line 1440)",
          "file": "test/unit-tests/type/unit/Unit.test.ts",
          "before": "it.skip('should cancel units in numerator and denominator', function () {",
          "after": "it('should cancel units in numerator and denominator', function () {\n  // Test case 1: J/K/g * g = J/K\n  assert.strictEqual(\n    mathTs.evaluate('2 J/K/g * 2 g').toString(),\n    '4 J / K'\n  )\n\n  // Test case 2: J/K/g * K = J/g\n  assert.strictEqual(\n    mathTs.evaluate('2 J/K/g * 2 K').toString(),\n    '4 J / g'\n  )\n})",
          "note": "Also update Unit.test.js with same changes"
        },
        {
          "step": 2,
          "action": "Add power reduction test",
          "location": "After main cancellation test",
          "code": "it('should reduce unit powers when simplifying', function () {\n  // m^2 / m = m\n  const area = mathTs.unit('10 m^2')\n  const length = mathTs.unit('2 m')\n  const result = mathTs.divide(area, length)\n\n  assert.strictEqual(result.toString(), '5 m')\n  assert(!result.toString().includes('m^2'))\n\n  // m^3 / m^2 = m\n  const volume = mathTs.unit('8 m^3')\n  const area2 = mathTs.unit('2 m^2')\n  const result2 = mathTs.divide(volume, area2)\n\n  assert.strictEqual(result2.toString(), '4 m')\n})"
        },
        {
          "step": 3,
          "action": "Add dimensionless result test",
          "code": "it('should produce dimensionless unit when all units cancel', function () {\n  // m / m = 1 (dimensionless)\n  const length1 = mathTs.unit('10 m')\n  const length2 = mathTs.unit('5 m')\n  const result = mathTs.divide(length1, length2)\n\n  assert.strictEqual(result.value, 2)\n  assert.strictEqual(result.toString(), '2') // No unit\n\n  // Verify units property is null or empty\n  assert(result.units === null || result.units.length === 0)\n})"
        },
        {
          "step": 4,
          "action": "Add prefix handling test",
          "code": "it('should not cancel units with different prefixes', function () {\n  // km and m should NOT cancel (different magnitudes)\n  const dist1 = mathTs.unit('10 km')\n  const dist2 = mathTs.unit('2 m')\n  const result = mathTs.divide(dist1, dist2)\n\n  // After conversion to same base, cancellation should work\n  // Expected: 10000m / 2m = 5000 (dimensionless)\n  assert.strictEqual(result.value, 5000)\n  assert.strictEqual(result.toString(), '5000')\n})"
        },
        {
          "step": 5,
          "action": "Add complex cancellation test",
          "code": "it('should handle complex multi-unit cancellation', function () {\n  // J*m/m = J (meters cancel)\n  const result1 = mathTs.evaluate('20 J * 4 m / 4 m')\n  assert.strictEqual(result1.toString(), '20 J')\n\n  // Verify no residual m units\n  assert(!result1.toString().includes(' m'))\n})"
        },
        {
          "step": 6,
          "action": "Add non-matching units test",
          "code": "it('should not cancel non-matching units', function () {\n  // m and s should not cancel (different dimensions)\n  const result1 = mathTs.evaluate('10 m / 2 s')\n  assert.strictEqual(result1.toString(), '5 m / s')\n\n  // Verify both units preserved\n  assert(result1.toString().includes('m'))\n  assert(result1.toString().includes('s'))\n})"
        },
        {
          "step": 7,
          "action": "Add optional alias test (if supported)",
          "code": "// OPTIONAL: Only if alias support is implemented\nit('should cancel unit aliases', function () {\n  // If implementation supports aliases:\n  // meter should cancel with m\n  const result = mathTs.divide(\n    mathTs.unit('10 meters'),\n    mathTs.unit('2 m')\n  )\n\n  assert.strictEqual(result.value, 5)\n  assert.strictEqual(result.toString(), '5') // Dimensionless\n})"
        },
        {
          "step": 8,
          "action": "Replicate all new tests to Unit.test.js",
          "details": "Copy all new tests from Unit.test.ts to Unit.test.js, changing mathTs to math"
        },
        {
          "step": 9,
          "action": "Run Unit test suite",
          "command": "npm test -- --grep \"Unit\"",
          "expectedResult": "All tests pass, including newly enabled cancellation tests"
        },
        {
          "step": 10,
          "action": "Run full test suite",
          "command": "npm run test:src",
          "expectedResult": "No regressions - all tests pass"
        }
      ],
      "acceptanceCriteria": [
        "Main cancellation test enabled (it.skip → it) in both TS and JS",
        "Test verifies 'J/K/g * g = J/K'",
        "Test verifies 'J/K/g * K = J/g'",
        "Power reduction test added (m^2/m = m)",
        "Dimensionless result test added (m/m = 1)",
        "Prefix handling test added (km vs m)",
        "Complex cancellation test added (J*m/m = J)",
        "Non-matching units test added (m/s preserved)",
        "Optional alias test added (if implemented)",
        "All new tests replicated to both .ts and .js versions",
        "All tests pass in TypeScript version",
        "All tests pass in JavaScript version",
        "No regressions in full test suite",
        "Total of 5-7 new test cases added"
      ]
    }
  ],
  "successCriteria": [
    "All three tasks completed successfully",
    "Unit cancellation algorithm designed and documented",
    "simplify() method implemented in Unit class",
    "Auto-simplification integrated in multiply/divide operations",
    "Helper methods implemented: _unitsEqual(), _normalizeUnitName()",
    "2 skipped tests enabled and passing (TS and JS)",
    "5-7 edge case tests added and passing",
    "Comprehensive test coverage for: power reduction, dimensionless, prefixes, complex cases",
    "Dual codebase (.js and .ts) maintained and synchronized",
    "No regressions in existing Unit functionality",
    "Documentation created: UNIT_SIMPLIFICATION_DESIGN.md"
  ],
  "filesCreated": [
    "docs/architecture/UNIT_SIMPLIFICATION_DESIGN.md"
  ],
  "filesModified": [
    "src/type/unit/Unit.js",
    "src/type/unit/Unit.ts",
    "test/unit-tests/type/unit/Unit.test.ts",
    "test/unit-tests/type/unit/Unit.test.js"
  ],
  "testsFixed": 2,
  "totalNewTests": 7,
  "totalEstimatedHours": 8,
  "dependencies": [],
  "notes": [
    "COMPLEX FEATURE: This is algebraic simplification - requires careful design first",
    "Design phase (Task 4.1.1) is CRITICAL - do not skip",
    "Unit internal structure must be understood before implementation",
    "Consider performance: simplification on every operation may be costly for large calculations",
    "Unit aliases may already be partially handled by Unit class - verify existing code",
    "Dimensionless results are important edge case - test thoroughly",
    "Update HISTORY.md with new simplification feature when complete",
    "This is a significant UX improvement - highlight in release notes",
    "Consider adding public simplify() API for manual control (in addition to auto)",
    "CRITICAL: This is a dual JS/TS codebase - ALL changes must be applied to BOTH .js and .ts source files",
    "JavaScript tests verify .js source, TypeScript tests verify .ts source - update both test files",
    "Prefix handling is important: km and m should NOT cancel (different units after prefix conversion)",
    "If implementation becomes too complex, consider deferring alias support to future iteration"
  ]
}
