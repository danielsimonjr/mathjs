'use strict';

var typedFunction = require('@danielsimonjr/typed-function');
var Decimal = require('decimal.js');
var ComplexJs = require('complex.js');
var FractionJs = require('fraction.js');
var naturalSort = require('javascript-natural-sort');
var escapeLatexLib = require('escape-latex');
var seedrandom = require('seedrandom');
var Emitter = require('tiny-emitter');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var typedFunction__default = /*#__PURE__*/_interopDefault(typedFunction);
var Decimal__default = /*#__PURE__*/_interopDefault(Decimal);
var ComplexJs__default = /*#__PURE__*/_interopDefault(ComplexJs);
var FractionJs__default = /*#__PURE__*/_interopDefault(FractionJs);
var naturalSort__default = /*#__PURE__*/_interopDefault(naturalSort);
var escapeLatexLib__default = /*#__PURE__*/_interopDefault(escapeLatexLib);
var seedrandom__default = /*#__PURE__*/_interopDefault(seedrandom);
var Emitter__default = /*#__PURE__*/_interopDefault(Emitter);

var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name323 in all)
    __defProp(target, name323, { get: all[name323], enumerable: true });
};

// src/factoriesAny.ts
var factoriesAny_exports = {};
__export(factoriesAny_exports, {
  createAbs: () => createAbs,
  createAccessorNode: () => createAccessorNode,
  createAcos: () => createAcos,
  createAcosh: () => createAcosh,
  createAcot: () => createAcot,
  createAcoth: () => createAcoth,
  createAcsc: () => createAcsc,
  createAcsch: () => createAcsch,
  createAdd: () => createAdd,
  createAddScalar: () => createAddScalar,
  createAnd: () => createAnd,
  createAndTransform: () => createAndTransform,
  createArg: () => createArg,
  createArrayNode: () => createArrayNode,
  createAsec: () => createAsec,
  createAsech: () => createAsech,
  createAsin: () => createAsin,
  createAsinh: () => createAsinh,
  createAssignmentNode: () => createAssignmentNode,
  createAtan: () => createAtan,
  createAtan2: () => createAtan2,
  createAtanh: () => createAtanh,
  createAtomicMass: () => createAtomicMass,
  createAvogadro: () => createAvogadro,
  createBellNumbers: () => createBellNumbers,
  createBernoulli: () => createBernoulli,
  createBigNumberClass: () => createBigNumberClass,
  createBigint: () => createBigint,
  createBignumber: () => createBignumber,
  createBin: () => createBin,
  createBitAnd: () => createBitAnd,
  createBitAndTransform: () => createBitAndTransform,
  createBitNot: () => createBitNot,
  createBitOr: () => createBitOr,
  createBitOrTransform: () => createBitOrTransform,
  createBitXor: () => createBitXor,
  createBlockNode: () => createBlockNode,
  createBohrMagneton: () => createBohrMagneton,
  createBohrRadius: () => createBohrRadius,
  createBoltzmann: () => createBoltzmann,
  createBoolean: () => createBoolean,
  createCatalan: () => createCatalan,
  createCbrt: () => createCbrt,
  createCeil: () => createCeil,
  createChain: () => createChain,
  createChainClass: () => createChainClass,
  createClassicalElectronRadius: () => createClassicalElectronRadius,
  createClone: () => createClone,
  createColumn: () => createColumn,
  createColumnTransform: () => createColumnTransform,
  createCombinations: () => createCombinations,
  createCombinationsWithRep: () => createCombinationsWithRep,
  createCompare: () => createCompare,
  createCompareNatural: () => createCompareNatural,
  createCompareText: () => createCompareText,
  createCompile: () => createCompile,
  createComplex: () => createComplex,
  createComplexClass: () => createComplexClass,
  createComposition: () => createComposition,
  createConcat: () => createConcat,
  createConcatTransform: () => createConcatTransform,
  createConditionalNode: () => createConditionalNode,
  createConductanceQuantum: () => createConductanceQuantum,
  createConj: () => createConj,
  createConstantNode: () => createConstantNode,
  createCorr: () => createCorr,
  createCos: () => createCos,
  createCosh: () => createCosh,
  createCot: () => createCot,
  createCoth: () => createCoth,
  createCoulomb: () => createCoulomb,
  createCoulombConstant: () => createCoulombConstant,
  createCount: () => createCount,
  createCreateUnit: () => createCreateUnit,
  createCross: () => createCross,
  createCsc: () => createCsc,
  createCsch: () => createCsch,
  createCtranspose: () => createCtranspose,
  createCube: () => createCube,
  createCumSum: () => createCumSum,
  createCumSumTransform: () => createCumSumTransform,
  createDeepEqual: () => createDeepEqual,
  createDenseMatrixClass: () => createDenseMatrixClass,
  createDerivative: () => createDerivative,
  createDet: () => createDet,
  createDeuteronMass: () => createDeuteronMass,
  createDiag: () => createDiag,
  createDiff: () => createDiff,
  createDiffTransform: () => createDiffTransform,
  createDistance: () => createDistance,
  createDivide: () => createDivide,
  createDivideScalar: () => createDivideScalar,
  createDot: () => createDot,
  createDotDivide: () => createDotDivide,
  createDotMultiply: () => createDotMultiply,
  createDotPow: () => createDotPow,
  createE: () => createE,
  createEfimovFactor: () => createEfimovFactor,
  createEigs: () => createEigs,
  createElectricConstant: () => createElectricConstant,
  createElectronMass: () => createElectronMass,
  createElementaryCharge: () => createElementaryCharge,
  createEqual: () => createEqual,
  createEqualScalar: () => createEqualScalar,
  createEqualText: () => createEqualText,
  createErf: () => createErf,
  createEvaluate: () => createEvaluate,
  createExp: () => createExp,
  createExpm: () => createExpm,
  createExpm1: () => createExpm1,
  createFactorial: () => createFactorial,
  createFalse: () => createFalse,
  createFaraday: () => createFaraday,
  createFermiCoupling: () => createFermiCoupling,
  createFft: () => createFft,
  createFibonacciHeapClass: () => createFibonacciHeapClass,
  createFilter: () => createFilter,
  createFilterTransform: () => createFilterTransform,
  createFineStructure: () => createFineStructure,
  createFirstRadiation: () => createFirstRadiation,
  createFix: () => createFix,
  createFlatten: () => createFlatten,
  createFloor: () => createFloor,
  createForEach: () => createForEach,
  createForEachTransform: () => createForEachTransform,
  createFormat: () => createFormat,
  createFraction: () => createFraction,
  createFractionClass: () => createFractionClass,
  createFreqz: () => createFreqz,
  createFunctionAssignmentNode: () => createFunctionAssignmentNode,
  createFunctionNode: () => createFunctionNode,
  createGamma: () => createGamma,
  createGasConstant: () => createGasConstant,
  createGcd: () => createGcd,
  createGetMatrixDataType: () => createGetMatrixDataType,
  createGravitationConstant: () => createGravitationConstant,
  createGravity: () => createGravity,
  createHartreeEnergy: () => createHartreeEnergy,
  createHasNumericValue: () => createHasNumericValue,
  createHelp: () => createHelp,
  createHelpClass: () => createHelpClass,
  createHex: () => createHex,
  createHypot: () => createHypot,
  createI: () => createI,
  createIdentity: () => createIdentity,
  createIfft: () => createIfft,
  createIm: () => createIm,
  createImmutableDenseMatrixClass: () => createImmutableDenseMatrixClass,
  createIndex: () => createIndex,
  createIndexClass: () => createIndexClass,
  createIndexNode: () => createIndexNode,
  createIndexTransform: () => createIndexTransform,
  createInfinity: () => createInfinity,
  createIntersect: () => createIntersect,
  createInv: () => createInv,
  createInverseConductanceQuantum: () => createInverseConductanceQuantum,
  createInvmod: () => createInvmod,
  createIsBounded: () => createIsBounded,
  createIsFinite: () => createIsFinite,
  createIsInteger: () => createIsInteger,
  createIsNaN: () => createIsNaN,
  createIsNegative: () => createIsNegative,
  createIsNumeric: () => createIsNumeric,
  createIsPositive: () => createIsPositive,
  createIsPrime: () => createIsPrime,
  createIsZero: () => createIsZero,
  createKldivergence: () => createKldivergence,
  createKlitzing: () => createKlitzing,
  createKron: () => createKron,
  createLN10: () => createLN10,
  createLN2: () => createLN2,
  createLOG10E: () => createLOG10E,
  createLOG2E: () => createLOG2E,
  createLarger: () => createLarger,
  createLargerEq: () => createLargerEq,
  createLcm: () => createLcm,
  createLeafCount: () => createLeafCount,
  createLeftShift: () => createLeftShift,
  createLgamma: () => createLgamma,
  createLog: () => createLog,
  createLog10: () => createLog10,
  createLog1p: () => createLog1p,
  createLog2: () => createLog2,
  createLoschmidt: () => createLoschmidt,
  createLsolve: () => createLsolve,
  createLsolveAll: () => createLsolveAll,
  createLup: () => createLup,
  createLusolve: () => createLusolve,
  createLyap: () => createLyap,
  createMad: () => createMad,
  createMagneticConstant: () => createMagneticConstant,
  createMagneticFluxQuantum: () => createMagneticFluxQuantum,
  createMap: () => createMap2,
  createMapSlices: () => createMapSlices,
  createMapSlicesTransform: () => createMapSlicesTransform,
  createMapTransform: () => createMapTransform,
  createMatrix: () => createMatrix,
  createMatrixClass: () => createMatrixClass,
  createMatrixFromColumns: () => createMatrixFromColumns,
  createMatrixFromFunction: () => createMatrixFromFunction,
  createMatrixFromRows: () => createMatrixFromRows,
  createMax: () => createMax,
  createMaxTransform: () => createMaxTransform,
  createMean: () => createMean,
  createMeanTransform: () => createMeanTransform,
  createMedian: () => createMedian,
  createMin: () => createMin,
  createMinTransform: () => createMinTransform,
  createMod: () => createMod,
  createMode: () => createMode,
  createMolarMass: () => createMolarMass,
  createMolarMassC12: () => createMolarMassC12,
  createMolarPlanckConstant: () => createMolarPlanckConstant,
  createMolarVolume: () => createMolarVolume,
  createMultinomial: () => createMultinomial,
  createMultiply: () => createMultiply,
  createMultiplyScalar: () => createMultiplyScalar,
  createNaN: () => createNaN,
  createNeutronMass: () => createNeutronMass,
  createNode: () => createNode,
  createNodeOperations: () => createNodeOperations,
  createNorm: () => createNorm,
  createNot: () => createNot,
  createNthRoot: () => createNthRoot,
  createNthRoots: () => createNthRoots,
  createNuclearMagneton: () => createNuclearMagneton,
  createNull: () => createNull,
  createNullish: () => createNullish,
  createNullishTransform: () => createNullishTransform,
  createNumber: () => createNumber,
  createNumeric: () => createNumeric,
  createObjectNode: () => createObjectNode,
  createOct: () => createOct,
  createOnes: () => createOnes,
  createOperatorNode: () => createOperatorNode,
  createOr: () => createOr,
  createOrTransform: () => createOrTransform,
  createParenthesisNode: () => createParenthesisNode,
  createParse: () => createParse,
  createParseNumberWithConfig: () => createParseNumberWithConfig,
  createParser: () => createParser,
  createParserClass: () => createParserClass,
  createPartitionSelect: () => createPartitionSelect,
  createPermutations: () => createPermutations,
  createPhi: () => createPhi,
  createPi: () => createPi,
  createPickRandom: () => createPickRandom,
  createPinv: () => createPinv,
  createPlanckCharge: () => createPlanckCharge,
  createPlanckConstant: () => createPlanckConstant,
  createPlanckLength: () => createPlanckLength,
  createPlanckMass: () => createPlanckMass,
  createPlanckTemperature: () => createPlanckTemperature,
  createPlanckTime: () => createPlanckTime,
  createPolynomialRoot: () => createPolynomialRoot,
  createPow: () => createPow,
  createPrint: () => createPrint,
  createPrintTransform: () => createPrintTransform,
  createProd: () => createProd,
  createProtonMass: () => createProtonMass,
  createQr: () => createQr,
  createQuantileSeq: () => createQuantileSeq,
  createQuantileSeqTransform: () => createQuantileSeqTransform,
  createQuantumOfCirculation: () => createQuantumOfCirculation,
  createRandom: () => createRandom,
  createRandomInt: () => createRandomInt,
  createRange: () => createRange,
  createRangeClass: () => createRangeClass,
  createRangeNode: () => createRangeNode,
  createRangeTransform: () => createRangeTransform,
  createRationalize: () => createRationalize,
  createRe: () => createRe,
  createReducedPlanckConstant: () => createReducedPlanckConstant,
  createRelationalNode: () => createRelationalNode,
  createReplacer: () => createReplacer,
  createReshape: () => createReshape,
  createResize: () => createResize,
  createResolve: () => createResolve,
  createResultSet: () => createResultSet,
  createReviver: () => createReviver,
  createRightArithShift: () => createRightArithShift,
  createRightLogShift: () => createRightLogShift,
  createRotate: () => createRotate,
  createRotationMatrix: () => createRotationMatrix,
  createRound: () => createRound,
  createRow: () => createRow,
  createRowTransform: () => createRowTransform,
  createRydberg: () => createRydberg,
  createSQRT1_2: () => createSQRT1_2,
  createSQRT2: () => createSQRT2,
  createSackurTetrode: () => createSackurTetrode,
  createSchur: () => createSchur,
  createSec: () => createSec,
  createSech: () => createSech,
  createSecondRadiation: () => createSecondRadiation,
  createSetCartesian: () => createSetCartesian,
  createSetDifference: () => createSetDifference,
  createSetDistinct: () => createSetDistinct,
  createSetIntersect: () => createSetIntersect,
  createSetIsSubset: () => createSetIsSubset,
  createSetMultiplicity: () => createSetMultiplicity,
  createSetPowerset: () => createSetPowerset,
  createSetSize: () => createSetSize,
  createSetSymDifference: () => createSetSymDifference,
  createSetUnion: () => createSetUnion,
  createSign: () => createSign,
  createSimplify: () => createSimplify,
  createSimplifyConstant: () => createSimplifyConstant,
  createSimplifyCore: () => createSimplifyCore,
  createSin: () => createSin,
  createSinh: () => createSinh,
  createSize: () => createSize,
  createSlu: () => createSlu,
  createSmaller: () => createSmaller,
  createSmallerEq: () => createSmallerEq,
  createSolveODE: () => createSolveODE,
  createSort: () => createSort,
  createSpaClass: () => createSpaClass,
  createSparse: () => createSparse,
  createSparseMatrixClass: () => createSparseMatrixClass,
  createSpeedOfLight: () => createSpeedOfLight,
  createSplitUnit: () => createSplitUnit,
  createSqrt: () => createSqrt,
  createSqrtm: () => createSqrtm,
  createSquare: () => createSquare,
  createSqueeze: () => createSqueeze,
  createStd: () => createStd,
  createStdTransform: () => createStdTransform,
  createStefanBoltzmann: () => createStefanBoltzmann,
  createStirlingS2: () => createStirlingS2,
  createString: () => createString,
  createSubset: () => createSubset,
  createSubsetTransform: () => createSubsetTransform,
  createSubtract: () => createSubtract,
  createSubtractScalar: () => createSubtractScalar,
  createSum: () => createSum,
  createSumTransform: () => createSumTransform,
  createSylvester: () => createSylvester,
  createSymbolNode: () => createSymbolNode,
  createSymbolicEqual: () => createSymbolicEqual,
  createTan: () => createTan,
  createTanh: () => createTanh,
  createTau: () => createTau,
  createThomsonCrossSection: () => createThomsonCrossSection,
  createTo: () => createTo,
  createToBest: () => createToBest,
  createTrace: () => createTrace,
  createTranspose: () => createTranspose,
  createTrue: () => createTrue,
  createTypeOf: () => createTypeOf,
  createTyped: () => createTyped,
  createUnaryMinus: () => createUnaryMinus,
  createUnaryPlus: () => createUnaryPlus,
  createUnequal: () => createUnequal,
  createUnitClass: () => createUnitClass,
  createUnitFunction: () => createUnitFunction,
  createUppercaseE: () => createUppercaseE,
  createUppercasePi: () => createUppercasePi,
  createUsolve: () => createUsolve,
  createUsolveAll: () => createUsolveAll,
  createVacuumImpedance: () => createVacuumImpedance,
  createVariance: () => createVariance,
  createVarianceTransform: () => createVarianceTransform,
  createVersion: () => createVersion,
  createWeakMixingAngle: () => createWeakMixingAngle,
  createWienDisplacement: () => createWienDisplacement,
  createXgcd: () => createXgcd,
  createXor: () => createXor,
  createZeros: () => createZeros,
  createZeta: () => createZeta,
  createZpk2tf: () => createZpk2tf
});

// src/utils/customs.ts
function getSafeProperty(object, prop) {
  if (isSafeProperty(object, prop)) {
    return object[prop];
  }
  if (typeof object[prop] === "function" && isSafeMethod(object, prop)) {
    throw new Error('Cannot access method "' + prop + '" as a property');
  }
  throw new Error('No access to property "' + prop + '"');
}
function setSafeProperty(object, prop, value) {
  if (isSafeProperty(object, prop)) {
    object[prop] = value;
    return value;
  }
  throw new Error('No access to property "' + prop + '"');
}
function isSafeProperty(object, prop) {
  if (!isPlainObject(object) && !Array.isArray(object)) {
    return false;
  }
  if (hasOwnProperty(safeNativeProperties, prop)) {
    return true;
  }
  if (prop in Object.prototype) {
    return false;
  }
  if (prop in Function.prototype) {
    return false;
  }
  return true;
}
function getSafeMethod(object, method) {
  if (!isSafeMethod(object, method)) {
    throw new Error('No access to method "' + method + '"');
  }
  return object[method];
}
function isSafeMethod(object, method) {
  if (object === null || object === void 0 || typeof object[method] !== "function") {
    return false;
  }
  if (hasOwnProperty(object, method) && Object.getPrototypeOf && method in Object.getPrototypeOf(object)) {
    return false;
  }
  if (hasOwnProperty(safeNativeMethods, method)) {
    return true;
  }
  if (method in Object.prototype) {
    return false;
  }
  if (method in Function.prototype) {
    return false;
  }
  return true;
}
function isPlainObject(object) {
  return typeof object === "object" && object && object.constructor === Object;
}
var safeNativeProperties = {
  length: true,
  name: true
};
var safeNativeMethods = {
  toString: true,
  valueOf: true,
  toLocaleString: true
};

// src/utils/map.ts
var _a;
_a = Symbol.toStringTag;
var ObjectWrappingMap = class {
  constructor(object) {
    this[_a] = "ObjectWrappingMap";
    this.wrappedObject = object;
    this[Symbol.iterator] = this.entries;
  }
  // @ts-expect-error: Implementation is compatible but TS can't infer it
  keys() {
    return Object.keys(this.wrappedObject).filter((key) => this.has(key)).values();
  }
  get(key) {
    return getSafeProperty(this.wrappedObject, key);
  }
  set(key, value) {
    setSafeProperty(this.wrappedObject, key, value);
    return this;
  }
  has(key) {
    return isSafeProperty(this.wrappedObject, key) && key in this.wrappedObject;
  }
  // @ts-expect-error: Implementation is compatible but TS can't infer it
  entries() {
    return mapIterator(this.keys(), (key) => [
      key,
      this.get(key)
    ]);
  }
  // @ts-expect-error: Implementation is compatible but TS can't infer it
  *values() {
    for (const key of this.keys()) {
      yield this.get(key);
    }
  }
  forEach(callback) {
    for (const key of this.keys()) {
      callback(this.get(key), key, this);
    }
  }
  delete(key) {
    if (isSafeProperty(this.wrappedObject, key)) {
      delete this.wrappedObject[key];
      return true;
    }
    return false;
  }
  clear() {
    for (const key of this.keys()) {
      this.delete(key);
    }
  }
  get size() {
    return Object.keys(this.wrappedObject).length;
  }
};
var _a2;
_a2 = Symbol.toStringTag;
var PartitionedMap = class {
  /**
   * @param a - Primary map
   * @param b - Secondary map
   * @param bKeys - Set of keys that should be read/written to map b
   */
  constructor(a, b, bKeys) {
    this[_a2] = "PartitionedMap";
    this.a = a;
    this.b = b;
    this.bKeys = bKeys;
    this[Symbol.iterator] = this.entries;
  }
  get(key) {
    return this.bKeys.has(key) ? this.b.get(key) : this.a.get(key);
  }
  set(key, value) {
    if (this.bKeys.has(key)) {
      this.b.set(key, value);
    } else {
      this.a.set(key, value);
    }
    return this;
  }
  has(key) {
    return this.b.has(key) || this.a.has(key);
  }
  // @ts-expect-error: Implementation is compatible but TS can't infer it
  keys() {
    return (/* @__PURE__ */ new Set([...this.a.keys(), ...this.b.keys()]))[Symbol.iterator]();
  }
  // @ts-expect-error: Implementation is compatible but TS can't infer it
  *values() {
    for (const key of this.keys()) {
      yield this.get(key);
    }
  }
  // @ts-expect-error: Implementation is compatible but TS can't infer it
  entries() {
    return mapIterator(this.keys(), (key) => [
      key,
      this.get(key)
    ]);
  }
  forEach(callback) {
    for (const key of this.keys()) {
      callback(this.get(key), key, this);
    }
  }
  delete(key) {
    return this.bKeys.has(key) ? this.b.delete(key) : this.a.delete(key);
  }
  clear() {
    this.a.clear();
    this.b.clear();
  }
  get size() {
    return [...this.keys()].length;
  }
};
function mapIterator(it, callback) {
  return {
    next: () => {
      const n = it.next();
      return n.done ? n : {
        value: callback(n.value),
        done: false
      };
    }
  };
}
function createEmptyMap() {
  return /* @__PURE__ */ new Map();
}
function createMap(mapOrObject) {
  if (!mapOrObject) {
    return createEmptyMap();
  }
  if (isMap(mapOrObject)) {
    return mapOrObject;
  }
  if (isObject(mapOrObject)) {
    return new ObjectWrappingMap(
      mapOrObject
    );
  }
  throw new Error("createMap can create maps from objects or Maps");
}
function toObject(map2) {
  if (map2 instanceof ObjectWrappingMap) {
    return map2.wrappedObject;
  }
  const object = {};
  for (const key of map2.keys()) {
    const value = map2.get(key);
    setSafeProperty(object, key, value);
  }
  return object;
}

// src/utils/is.ts
function isNumber(x) {
  return typeof x === "number";
}
function isBigNumber(x) {
  if (!x || typeof x !== "object" || typeof x.constructor !== "function") {
    return false;
  }
  const obj = x;
  if (obj.isBigNumber === true && typeof obj.constructor.prototype === "object" && obj.constructor.prototype?.isBigNumber === true) {
    return true;
  }
  if (typeof obj.constructor.isDecimal === "function" && obj.constructor.isDecimal(obj) === true) {
    return true;
  }
  return false;
}
function isBigInt(x) {
  return typeof x === "bigint";
}
function isComplex(x) {
  return x && typeof x === "object" && Object.getPrototypeOf(x).isComplex === true || false;
}
function isFraction(x) {
  return x && typeof x === "object" && Object.getPrototypeOf(x).isFraction === true || false;
}
function isUnit(x) {
  if (!x || typeof x !== "object") return false;
  const obj = x;
  return obj.constructor?.prototype?.isUnit === true;
}
function isString(x) {
  return typeof x === "string";
}
var isArray = Array.isArray;
function isMatrix(x) {
  if (!x || typeof x !== "object") return false;
  const obj = x;
  return obj.constructor?.prototype?.isMatrix === true;
}
function isCollection(x) {
  return Array.isArray(x) || isMatrix(x);
}
function isDenseMatrix(x) {
  if (!x || typeof x !== "object") return false;
  const obj = x;
  return obj.isDenseMatrix === true && obj.constructor?.prototype?.isMatrix === true;
}
function isSparseMatrix(x) {
  if (!x || typeof x !== "object") return false;
  const obj = x;
  return obj.isSparseMatrix === true && obj.constructor?.prototype?.isMatrix === true;
}
function isRange(x) {
  if (!x || typeof x !== "object") return false;
  const obj = x;
  return obj.constructor?.prototype?.isRange === true;
}
function isIndex(x) {
  if (!x || typeof x !== "object") return false;
  const obj = x;
  return obj.constructor?.prototype?.isIndex === true;
}
function isBoolean(x) {
  return typeof x === "boolean";
}
function isResultSet(x) {
  if (!x || typeof x !== "object") return false;
  const obj = x;
  return obj.constructor?.prototype?.isResultSet === true;
}
function isHelp(x) {
  if (!x || typeof x !== "object") return false;
  const obj = x;
  return obj.constructor?.prototype?.isHelp === true;
}
function isFunction(x) {
  return typeof x === "function";
}
function isDate(x) {
  return x instanceof Date;
}
function isRegExp(x) {
  return x instanceof RegExp;
}
function isObject(x) {
  return !!(x && typeof x === "object" && x.constructor === Object && !isComplex(x) && !isFraction(x));
}
function isMap(object) {
  if (!object) {
    return false;
  }
  if (object instanceof Map || object instanceof ObjectWrappingMap) {
    return true;
  }
  const mapLike = object;
  return typeof mapLike.set === "function" && typeof mapLike.get === "function" && typeof mapLike.keys === "function" && typeof mapLike.has === "function";
}
function isPartitionedMap(object) {
  if (!isMap(object)) return false;
  const partitioned = object;
  return isMap(partitioned.a) && isMap(partitioned.b);
}
function isObjectWrappingMap(object) {
  if (!isMap(object)) return false;
  const wrapper = object;
  return isObject(wrapper.wrappedObject);
}
function isNull(x) {
  return x === null;
}
function isUndefined(x) {
  return x === void 0;
}
function isAccessorNode(x) {
  if (!x || typeof x !== "object") return false;
  const obj = x;
  return obj.isAccessorNode === true && obj.constructor?.prototype?.isNode === true;
}
function isArrayNode(x) {
  if (!x || typeof x !== "object") return false;
  const obj = x;
  return obj.isArrayNode === true && obj.constructor?.prototype?.isNode === true;
}
function isAssignmentNode(x) {
  if (!x || typeof x !== "object") return false;
  const obj = x;
  return obj.isAssignmentNode === true && obj.constructor?.prototype?.isNode === true;
}
function isBlockNode(x) {
  if (!x || typeof x !== "object") return false;
  const obj = x;
  return obj.isBlockNode === true && obj.constructor?.prototype?.isNode === true;
}
function isConditionalNode(x) {
  if (!x || typeof x !== "object") return false;
  const obj = x;
  return obj.isConditionalNode === true && obj.constructor?.prototype?.isNode === true;
}
function isConstantNode(x) {
  if (!x || typeof x !== "object") return false;
  const obj = x;
  return obj.isConstantNode === true && obj.constructor?.prototype?.isNode === true;
}
function rule2Node(node) {
  return isConstantNode(node) || isOperatorNode(node) && node.args.length === 1 && isConstantNode(node.args[0]) && "-+~".includes(node.op);
}
function isFunctionAssignmentNode(x) {
  if (!x || typeof x !== "object") return false;
  const obj = x;
  return obj.isFunctionAssignmentNode === true && obj.constructor?.prototype?.isNode === true;
}
function isFunctionNode(x) {
  if (!x || typeof x !== "object") return false;
  const obj = x;
  return obj.isFunctionNode === true && obj.constructor?.prototype?.isNode === true;
}
function isIndexNode(x) {
  if (!x || typeof x !== "object") return false;
  const obj = x;
  return obj.isIndexNode === true && obj.constructor?.prototype?.isNode === true;
}
function isNode(x) {
  if (!x || typeof x !== "object") return false;
  const obj = x;
  return obj.isNode === true && obj.constructor?.prototype?.isNode === true;
}
function isObjectNode(x) {
  if (!x || typeof x !== "object") return false;
  const obj = x;
  return obj.isObjectNode === true && obj.constructor?.prototype?.isNode === true;
}
function isOperatorNode(x) {
  if (!x || typeof x !== "object") return false;
  const obj = x;
  return obj.isOperatorNode === true && obj.constructor?.prototype?.isNode === true;
}
function isParenthesisNode(x) {
  if (!x || typeof x !== "object") return false;
  const obj = x;
  return obj.isParenthesisNode === true && obj.constructor?.prototype?.isNode === true;
}
function isRangeNode(x) {
  if (!x || typeof x !== "object") return false;
  const obj = x;
  return obj.isRangeNode === true && obj.constructor?.prototype?.isNode === true;
}
function isRelationalNode(x) {
  if (!x || typeof x !== "object") return false;
  const obj = x;
  return obj.isRelationalNode === true && obj.constructor?.prototype?.isNode === true;
}
function isSymbolNode(x) {
  if (!x || typeof x !== "object") return false;
  const obj = x;
  return obj.isSymbolNode === true && obj.constructor?.prototype?.isNode === true;
}
function isChain(x) {
  if (!x || typeof x !== "object") return false;
  const obj = x;
  return obj.constructor?.prototype?.isChain === true;
}
function typeOf(x) {
  const t = typeof x;
  if (t === "object") {
    if (x === null) return "null";
    if (isBigNumber(x)) return "BigNumber";
    const obj = x;
    if (obj.constructor && obj.constructor.name) return obj.constructor.name;
    return "Object";
  }
  return t;
}

// src/utils/object.ts
function clone(x) {
  const type = typeof x;
  if (type === "number" || type === "bigint" || type === "string" || type === "boolean" || x === null || x === void 0) {
    return x;
  }
  const cloneable = x;
  if (typeof cloneable.clone === "function") {
    return cloneable.clone();
  }
  if (Array.isArray(x)) {
    return x.map((value) => clone(value));
  }
  if (x instanceof Date) return new Date(x.valueOf());
  if (isBigNumber(x)) return x;
  if (isObject(x)) {
    return mapObject(x, clone);
  }
  if (type === "function") {
    return x;
  }
  throw new TypeError(`Cannot clone: unknown type of value (value: ${x})`);
}
function mapObject(object, callback) {
  const clone3 = {};
  for (const key in object) {
    if (hasOwnProperty(object, key)) {
      clone3[key] = callback(object[key]);
    }
  }
  return clone3;
}
function extend(a, b) {
  for (const prop in b) {
    if (hasOwnProperty(b, prop)) {
      a[prop] = b[prop];
    }
  }
  return a;
}
function deepExtend(a, b) {
  if (Array.isArray(b)) {
    throw new TypeError("Arrays are not supported by deepExtend");
  }
  for (const prop in b) {
    if (hasOwnProperty(b, prop) && !(prop in Object.prototype) && !(prop in Function.prototype)) {
      const bValue = b[prop];
      const aValue = a[prop];
      if (bValue && bValue.constructor === Object) {
        if (aValue === void 0) {
          a[prop] = {};
        }
        if (aValue && aValue.constructor === Object) {
          deepExtend(aValue, bValue);
        } else {
          a[prop] = bValue;
        }
      } else if (Array.isArray(bValue)) {
        throw new TypeError("Arrays are not supported by deepExtend");
      } else {
        a[prop] = bValue;
      }
    }
  }
  return a;
}
function deepStrictEqual(a, b) {
  if (Array.isArray(a)) {
    if (!Array.isArray(b)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    for (let i = 0, len = a.length; i < len; i++) {
      if (!deepStrictEqual(a[i], b[i])) {
        return false;
      }
    }
    return true;
  } else if (typeof a === "function") {
    return a === b;
  } else if (a instanceof Object) {
    if (Array.isArray(b) || !(b instanceof Object)) {
      return false;
    }
    const objA = a;
    const objB = b;
    for (const prop in objA) {
      if (!(prop in objB) || !deepStrictEqual(objA[prop], objB[prop])) {
        return false;
      }
    }
    for (const prop in objB) {
      if (!(prop in objA)) {
        return false;
      }
    }
    return true;
  } else {
    return a === b;
  }
}
function deepFlatten(nestedObject) {
  const flattenedObject = {};
  _deepFlatten(nestedObject, flattenedObject);
  return flattenedObject;
}
function _deepFlatten(nestedObject, flattenedObject) {
  for (const prop in nestedObject) {
    if (hasOwnProperty(nestedObject, prop)) {
      const value = nestedObject[prop];
      if (typeof value === "object" && value !== null) {
        _deepFlatten(value, flattenedObject);
      } else {
        flattenedObject[prop] = value;
      }
    }
  }
}
function lazy(object, prop, valueResolver) {
  let _uninitialized = true;
  let _value;
  Object.defineProperty(object, prop, {
    get: function() {
      if (_uninitialized) {
        _value = valueResolver();
        _uninitialized = false;
      }
      return _value;
    },
    set: function(value) {
      _value = value;
      _uninitialized = false;
    },
    configurable: true,
    enumerable: true
  });
}
function hasOwnProperty(object, property) {
  return !!object && Object.hasOwnProperty.call(object, property);
}
function isLegacyFactory(object) {
  if (!object || typeof object !== "object") return false;
  const obj = object;
  return typeof obj.factory === "function";
}
function pickShallow(object, properties2) {
  const copy = {};
  for (let i = 0; i < properties2.length; i++) {
    const key = properties2[i];
    const value = object[key];
    if (value !== void 0) {
      copy[key] = value;
    }
  }
  return copy;
}

// src/utils/factory.ts
function factory(name323, dependencies324, create2, meta) {
  function assertAndCreate(scope) {
    const deps = pickShallow(
      scope,
      dependencies324.map(stripOptionalNotation)
    );
    assertDependencies(name323, dependencies324, scope);
    return create2(deps);
  }
  assertAndCreate.isFactory = true;
  assertAndCreate.fn = name323;
  assertAndCreate.dependencies = dependencies324.slice().sort();
  if (meta) {
    assertAndCreate.meta = meta;
  }
  return assertAndCreate;
}
function isFactory(obj) {
  return typeof obj === "function" && typeof obj.fn === "string" && Array.isArray(obj.dependencies);
}
function assertDependencies(name323, dependencies324, scope) {
  const allDefined = dependencies324.filter((dependency) => !isOptionalDependency(dependency)).every((dependency) => scope[dependency] !== void 0);
  if (!allDefined) {
    const missingDependencies = dependencies324.filter(
      (dependency) => scope[dependency] === void 0
    );
    throw new Error(
      `Cannot create function "${name323}", some dependencies are missing: ${missingDependencies.map((d) => `"${d}"`).join(", ")}.`
    );
  }
}
function isOptionalDependency(dependency) {
  return dependency && dependency[0] === "?";
}
function stripOptionalNotation(dependency) {
  return dependency && dependency[0] === "?" ? dependency.slice(1) : dependency;
}

// src/utils/number.ts
function isInteger(value) {
  if (typeof value === "boolean") {
    return true;
  }
  return isFinite(value) ? value === Math.round(value) : false;
}
function safeNumberType(numberStr, config) {
  if (config.number === "bigint") {
    try {
      BigInt(numberStr);
    } catch {
      return config.numberFallback;
    }
  }
  return config.number;
}
var sign = Math.sign || function(x) {
  if (x > 0) {
    return 1;
  } else if (x < 0) {
    return -1;
  } else {
    return 0;
  }
};
var log2 = Math.log2 || function log22(x) {
  return Math.log(x) / Math.LN2;
};
var log10 = Math.log10 || function log102(x) {
  return Math.log(x) / Math.LN10;
};
var log1p = Math.log1p || function(x) {
  return Math.log(x + 1);
};
var cbrt = Math.cbrt || function cbrt2(x) {
  if (x === 0) {
    return x;
  }
  const negate = x < 0;
  let result;
  if (negate) {
    x = -x;
  }
  if (isFinite(x)) {
    result = Math.exp(Math.log(x) / 3);
    result = (x / (result * result) + 2 * result) / 3;
  } else {
    result = x;
  }
  return negate ? -result : result;
};
var expm1 = Math.expm1 || function expm12(x) {
  return x >= 2e-4 || x <= -2e-4 ? Math.exp(x) - 1 : x + x * x / 2 + x * x * x / 6;
};
function formatNumberToBase(n, base, size) {
  const prefixes = { 2: "0b", 8: "0o", 16: "0x" };
  const prefix = prefixes[base];
  let suffix = "";
  if (size) {
    if (size < 1) {
      throw new Error("size must be in greater than 0");
    }
    if (!isInteger(size)) {
      throw new Error("size must be an integer");
    }
    if (n > 2 ** (size - 1) - 1 || n < -(2 ** (size - 1))) {
      throw new Error(
        `Value must be in range [-2^${size - 1}, 2^${size - 1}-1]`
      );
    }
    if (!isInteger(n)) {
      throw new Error("Value must be an integer");
    }
    if (n < 0) {
      n = n + 2 ** size;
    }
    suffix = `i${size}`;
  }
  let sign2 = "";
  if (n < 0) {
    n = -n;
    sign2 = "-";
  }
  return `${sign2}${prefix}${n.toString(base)}${suffix}`;
}
function format(value, options) {
  if (typeof options === "function") {
    return options(value);
  }
  if (value === Infinity) {
    return "Infinity";
  } else if (value === -Infinity) {
    return "-Infinity";
  } else if (isNaN(value)) {
    return "NaN";
  }
  const { notation, precision, wordSize } = normalizeFormatOptions(options);
  switch (notation) {
    case "fixed":
      return toFixed(value, precision);
    case "exponential":
      return toExponential(value, precision);
    case "engineering":
      return toEngineering(value, precision);
    case "bin":
      return formatNumberToBase(value, 2, wordSize);
    case "oct":
      return formatNumberToBase(value, 8, wordSize);
    case "hex":
      return formatNumberToBase(value, 16, wordSize);
    case "auto":
      return toPrecision(value, precision, options).replace(
        /((\.\d*?)(0+))($|e)/,
        function() {
          const digits2 = arguments[2];
          const e2 = arguments[4];
          return digits2 !== "." ? digits2 + e2 : e2;
        }
      );
    default:
      throw new Error(
        'Unknown notation "' + notation + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.'
      );
  }
}
function normalizeFormatOptions(options) {
  let notation = "auto";
  let precision;
  let wordSize;
  if (options !== void 0) {
    if (isNumber(options)) {
      precision = options;
    } else if (isBigNumber(options)) {
      precision = options.toNumber();
    } else if (isObject(options)) {
      if (options.precision !== void 0) {
        precision = _toNumberOrThrow(options.precision, () => {
          throw new Error('Option "precision" must be a number or BigNumber');
        });
      }
      if (options.wordSize !== void 0) {
        wordSize = _toNumberOrThrow(options.wordSize, () => {
          throw new Error('Option "wordSize" must be a number or BigNumber');
        });
      }
      if (options.notation) {
        notation = options.notation;
      }
    } else {
      throw new Error(
        "Unsupported type of options, number, BigNumber, or object expected"
      );
    }
  }
  return { notation, precision, wordSize };
}
function splitNumber(value) {
  const match = String(value).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
  if (!match) {
    throw new SyntaxError("Invalid number " + value);
  }
  const sign2 = match[1];
  const digits2 = match[2];
  let exponent = parseFloat(match[4] || "0");
  const dot = digits2.indexOf(".");
  exponent += dot !== -1 ? dot - 1 : digits2.length - 1;
  const coefficients = digits2.replace(".", "").replace(/^0*/, function(zeros2) {
    exponent -= zeros2.length;
    return "";
  }).replace(/0*$/, "").split("").map(function(d) {
    return parseInt(d);
  });
  if (coefficients.length === 0) {
    coefficients.push(0);
    exponent++;
  }
  return { sign: sign2, coefficients, exponent };
}
function toEngineering(value, precision) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  const split = splitNumber(value);
  const rounded = roundDigits(split, precision);
  const e2 = rounded.exponent;
  const c = rounded.coefficients;
  const newExp = e2 % 3 === 0 ? e2 : e2 < 0 ? e2 - 3 - e2 % 3 : e2 - e2 % 3;
  if (isNumber(precision)) {
    while (precision > c.length || e2 - newExp + 1 > c.length) {
      c.push(0);
    }
  } else {
    const missingZeros = Math.abs(e2 - newExp) - (c.length - 1);
    for (let i = 0; i < missingZeros; i++) {
      c.push(0);
    }
  }
  let expDiff = Math.abs(e2 - newExp);
  let decimalIdx = 1;
  while (expDiff > 0) {
    decimalIdx++;
    expDiff--;
  }
  const decimals = c.slice(decimalIdx).join("");
  const decimalVal = isNumber(precision) && decimals.length || decimals.match(/[1-9]/) ? "." + decimals : "";
  const str = c.slice(0, decimalIdx).join("") + decimalVal + "e" + (e2 >= 0 ? "+" : "") + newExp.toString();
  return rounded.sign + str;
}
function toFixed(value, precision) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  const splitValue = splitNumber(value);
  const rounded = typeof precision === "number" ? roundDigits(splitValue, splitValue.exponent + 1 + precision) : splitValue;
  let c = rounded.coefficients;
  let p = rounded.exponent + 1;
  const pp = p + (precision || 0);
  if (c.length < pp) {
    c = c.concat(zeros(pp - c.length));
  }
  if (p < 0) {
    c = zeros(-p + 1).concat(c);
    p = 1;
  }
  if (p < c.length) {
    c.splice(p, 0, p === 0 ? "0." : ".");
  }
  return rounded.sign + c.join("");
}
function toExponential(value, precision) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  const split = splitNumber(value);
  const rounded = precision ? roundDigits(split, precision) : split;
  let c = rounded.coefficients;
  const e2 = rounded.exponent;
  if (precision && c.length < precision) {
    c = c.concat(zeros(precision - c.length));
  }
  const first = c.shift();
  return rounded.sign + first + (c.length > 0 ? "." + c.join("") : "") + "e" + (e2 >= 0 ? "+" : "") + e2;
}
function toPrecision(value, precision, options) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  const lowerExp = _toNumberOrDefault(options?.lowerExp, -3);
  const upperExp = _toNumberOrDefault(options?.upperExp, 5);
  const split = splitNumber(value);
  const rounded = precision ? roundDigits(split, precision) : split;
  if (rounded.exponent < lowerExp || rounded.exponent >= upperExp) {
    return toExponential(value, precision);
  } else {
    let c = rounded.coefficients;
    const e2 = rounded.exponent;
    if (precision && c.length < precision) {
      c = c.concat(zeros(precision - c.length));
    }
    c = c.concat(
      zeros(
        e2 - c.length + 1 + (precision && c.length < precision ? precision - c.length : 0)
      )
    );
    c = zeros(-e2).concat(c);
    const dot = e2 > 0 ? e2 : 0;
    if (dot < c.length - 1) {
      c.splice(dot + 1, 0, ".");
    }
    return rounded.sign + c.join("");
  }
}
function roundDigits(split, precision) {
  const rounded = {
    sign: split.sign,
    coefficients: split.coefficients.slice(),
    exponent: split.exponent
  };
  const c = rounded.coefficients;
  if (precision !== void 0) {
    while (precision <= 0) {
      c.unshift(0);
      rounded.exponent++;
      precision++;
    }
    if (c.length > precision) {
      const removed = c.splice(precision, c.length - precision);
      if (removed[0] >= 5) {
        let i = precision - 1;
        c[i]++;
        while (c[i] === 10) {
          c.pop();
          if (i === 0) {
            c.unshift(0);
            rounded.exponent++;
            i++;
          }
          i--;
          c[i]++;
        }
      }
    }
  }
  return rounded;
}
function zeros(length) {
  const arr = [];
  for (let i = 0; i < length; i++) {
    arr.push(0);
  }
  return arr;
}
function digits(value) {
  return value.toExponential().replace(/e.*$/, "").replace(/^0\.?0*|\./, "").length;
}
function nearlyEqual(a, b, relTol = 1e-8, absTol = 0) {
  if (relTol <= 0) {
    throw new Error("Relative tolerance must be greater than 0");
  }
  if (absTol < 0) {
    throw new Error("Absolute tolerance must be at least 0");
  }
  if (isNaN(a) || isNaN(b)) {
    return false;
  }
  if (!isFinite(a) || !isFinite(b)) {
    return a === b;
  }
  if (a === b) {
    return true;
  }
  return Math.abs(a - b) <= Math.max(relTol * Math.max(Math.abs(a), Math.abs(b)), absTol);
}
var acosh = Math.acosh || function(x) {
  return Math.log(Math.sqrt(x * x - 1) + x);
};
var asinh = Math.asinh || function(x) {
  return Math.log(Math.sqrt(x * x + 1) + x);
};
var atanh = Math.atanh || function(x) {
  return Math.log((1 + x) / (1 - x)) / 2;
};
var cosh = Math.cosh || function(x) {
  return (Math.exp(x) + Math.exp(-x)) / 2;
};
var sinh = Math.sinh || function(x) {
  return (Math.exp(x) - Math.exp(-x)) / 2;
};
var tanh = Math.tanh || function(x) {
  const e2 = Math.exp(2 * x);
  return (e2 - 1) / (e2 + 1);
};
function copysign(x, y) {
  const signx = true ;
  const signy = y > 0 ? true : y < 0 ? false : 1 / y === Infinity;
  return signx !== signy ? -x : x;
}
function _toNumberOrThrow(value, onError) {
  if (isNumber(value)) {
    return value;
  } else if (isBigNumber(value)) {
    return value.toNumber();
  } else {
    onError();
    return 0;
  }
}
function _toNumberOrDefault(value, defaultValue) {
  if (isNumber(value)) {
    return value;
  } else if (isBigNumber(value)) {
    return value.toNumber();
  } else {
    return defaultValue;
  }
}

// src/core/function/typed.ts
var _createTyped = function() {
  _createTyped = typedFunction__default.default.create;
  return typedFunction__default.default;
};
var dependencies = ["?BigNumber", "?Complex", "?DenseMatrix", "?Fraction"];
var createTyped = /* @__PURE__ */ factory(
  "typed",
  dependencies,
  function createTyped2({
    BigNumber,
    Complex: Complex2,
    DenseMatrix,
    Fraction: Fraction2
  }) {
    const _typed = _createTyped();
    _typed.clear();
    _typed.addTypes([
      { name: "number", test: isNumber },
      { name: "Complex", test: isComplex },
      { name: "BigNumber", test: isBigNumber },
      { name: "bigint", test: isBigInt },
      { name: "Fraction", test: isFraction },
      { name: "Unit", test: isUnit },
      // The following type matches a valid variable name, i.e., an alphanumeric
      // string starting with an alphabetic character. It is used (at least)
      // in the definition of the derivative() function, as the argument telling
      // what to differentiate over must (currently) be a variable.
      // TODO: deprecate the identifier type (it's not used anymore, see https://github.com/josdejong/mathjs/issues/3253)
      {
        name: "identifier",
        // Using simpler regex for TS compatibility (original: /^\p{L}[\p{L}\d]*$/u)
        test: (s) => isString(s) && /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(s)
      },
      { name: "string", test: isString },
      { name: "Chain", test: isChain },
      { name: "Array", test: isArray },
      { name: "Matrix", test: isMatrix },
      { name: "DenseMatrix", test: isDenseMatrix },
      { name: "SparseMatrix", test: isSparseMatrix },
      { name: "Range", test: isRange },
      { name: "Index", test: isIndex },
      { name: "boolean", test: isBoolean },
      { name: "ResultSet", test: isResultSet },
      { name: "Help", test: isHelp },
      { name: "function", test: isFunction },
      { name: "Date", test: isDate },
      { name: "RegExp", test: isRegExp },
      { name: "null", test: isNull },
      { name: "undefined", test: isUndefined },
      { name: "AccessorNode", test: isAccessorNode },
      { name: "ArrayNode", test: isArrayNode },
      { name: "AssignmentNode", test: isAssignmentNode },
      { name: "BlockNode", test: isBlockNode },
      { name: "ConditionalNode", test: isConditionalNode },
      { name: "ConstantNode", test: isConstantNode },
      { name: "FunctionNode", test: isFunctionNode },
      { name: "FunctionAssignmentNode", test: isFunctionAssignmentNode },
      { name: "IndexNode", test: isIndexNode },
      { name: "Node", test: isNode },
      { name: "ObjectNode", test: isObjectNode },
      { name: "OperatorNode", test: isOperatorNode },
      { name: "ParenthesisNode", test: isParenthesisNode },
      { name: "RangeNode", test: isRangeNode },
      { name: "RelationalNode", test: isRelationalNode },
      { name: "SymbolNode", test: isSymbolNode },
      { name: "Map", test: isMap },
      { name: "Object", test: isObject }
      // order 'Object' last, it matches on other classes too
    ]);
    _typed.addConversions([
      {
        from: "number",
        to: "BigNumber",
        convert: function(x) {
          if (!BigNumber) {
            throwNoBignumber(x);
          }
          if (digits(x) > 15) {
            throw new TypeError(
              "Cannot implicitly convert a number with >15 significant digits to BigNumber (value: " + x + "). Use function bignumber(x) to convert to BigNumber."
            );
          }
          return new BigNumber(x);
        }
      },
      {
        from: "number",
        to: "Complex",
        convert: function(x) {
          if (!Complex2) {
            throwNoComplex(x);
          }
          return new Complex2(x, 0);
        }
      },
      {
        from: "BigNumber",
        to: "Complex",
        convert: function(x) {
          if (!Complex2) {
            throwNoComplex(x);
          }
          const bigNum = x;
          return new Complex2(bigNum.toNumber(), 0);
        }
      },
      {
        from: "bigint",
        to: "number",
        convert: function(x) {
          if (x > Number.MAX_SAFE_INTEGER) {
            throw new TypeError(
              "Cannot implicitly convert bigint to number: value exceeds the max safe integer value (value: " + x + ")"
            );
          }
          return Number(x);
        }
      },
      {
        from: "bigint",
        to: "BigNumber",
        convert: function(x) {
          if (!BigNumber) {
            throwNoBignumber(x);
          }
          return new BigNumber(x.toString());
        }
      },
      {
        from: "bigint",
        to: "Fraction",
        convert: function(x) {
          if (!Fraction2) {
            throwNoFraction(x);
          }
          return new Fraction2(x);
        }
      },
      {
        from: "Fraction",
        to: "BigNumber",
        convert: function(_x) {
          throw new TypeError(
            "Cannot implicitly convert a Fraction to BigNumber or vice versa. Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction."
          );
        }
      },
      {
        from: "Fraction",
        to: "Complex",
        convert: function(x) {
          if (!Complex2) {
            throwNoComplex(x);
          }
          const frac = x;
          return new Complex2(frac.valueOf(), 0);
        }
      },
      {
        from: "number",
        to: "Fraction",
        convert: function(x) {
          if (!Fraction2) {
            throwNoFraction(x);
          }
          const f = new Fraction2(x);
          if (f.valueOf() !== x) {
            throw new TypeError(
              "Cannot implicitly convert a number to a Fraction when there will be a loss of precision (value: " + x + "). Use function fraction(x) to convert to Fraction."
            );
          }
          return f;
        }
      },
      {
        // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`
        //  from: 'Fraction',
        //  to: 'number',
        //  convert: function (x) {
        //    return x.valueOf()
        //  }
        // }, {
        from: "string",
        to: "number",
        convert: function(x) {
          const n = Number(x);
          if (isNaN(n)) {
            throw new Error('Cannot convert "' + x + '" to a number');
          }
          return n;
        }
      },
      {
        from: "string",
        to: "BigNumber",
        convert: function(x) {
          if (!BigNumber) {
            throwNoBignumber(x);
          }
          try {
            return new BigNumber(x);
          } catch {
            throw new Error('Cannot convert "' + x + '" to BigNumber');
          }
        }
      },
      {
        from: "string",
        to: "bigint",
        convert: function(x) {
          try {
            return BigInt(x);
          } catch {
            throw new Error('Cannot convert "' + x + '" to BigInt');
          }
        }
      },
      {
        from: "string",
        to: "Fraction",
        convert: function(x) {
          if (!Fraction2) {
            throwNoFraction(x);
          }
          try {
            return new Fraction2(x);
          } catch {
            throw new Error('Cannot convert "' + x + '" to Fraction');
          }
        }
      },
      {
        from: "string",
        to: "Complex",
        convert: function(x) {
          if (!Complex2) {
            throwNoComplex(x);
          }
          try {
            return new Complex2(x);
          } catch {
            throw new Error('Cannot convert "' + x + '" to Complex');
          }
        }
      },
      {
        from: "boolean",
        to: "number",
        convert: function(x) {
          return +x;
        }
      },
      {
        from: "boolean",
        to: "BigNumber",
        convert: function(x) {
          if (!BigNumber) {
            throwNoBignumber(x);
          }
          return new BigNumber(+x);
        }
      },
      {
        from: "boolean",
        to: "bigint",
        convert: function(x) {
          return BigInt(+x);
        }
      },
      {
        from: "boolean",
        to: "Fraction",
        convert: function(x) {
          if (!Fraction2) {
            throwNoFraction(x);
          }
          return new Fraction2(+x);
        }
      },
      {
        from: "boolean",
        to: "string",
        convert: function(x) {
          return String(x);
        }
      },
      {
        from: "Array",
        to: "Matrix",
        convert: function(array) {
          if (!DenseMatrix) {
            throwNoMatrix();
          }
          return new DenseMatrix(array);
        }
      },
      {
        from: "Matrix",
        to: "Array",
        convert: function(matrix) {
          const mat = matrix;
          return mat.valueOf();
        }
      }
    ]);
    _typed.onMismatch = (name323, args, signatures) => {
      const usualError = _typed.createError(name323, args, signatures);
      if (["wrongType", "mismatch"].includes(usualError.data.category) && args.length === 1 && isCollection(args[0]) && // check if the function can be unary:
      Object.keys(signatures).some((sig) => !sig.includes(","))) {
        const err = new TypeError(
          `Function '${name323}' doesn't apply to matrices. To call it elementwise on a matrix 'M', try 'map(M, ${name323})'.`
        );
        err.data = usualError.data;
        throw err;
      }
      throw usualError;
    };
    return _typed;
  }
);
function throwNoBignumber(x) {
  throw new Error(
    `Cannot convert value ${x} into a BigNumber: no class 'BigNumber' provided`
  );
}
function throwNoComplex(x) {
  throw new Error(
    `Cannot convert value ${x} into a Complex number: no class 'Complex' provided`
  );
}
function throwNoMatrix() {
  throw new Error(
    "Cannot convert array into a Matrix: no class 'DenseMatrix' provided"
  );
}
function throwNoFraction(x) {
  throw new Error(
    `Cannot convert value ${x} into a Fraction, no class 'Fraction' provided.`
  );
}

// src/type/resultset/ResultSet.ts
var name = "ResultSet";
var dependencies2 = [];
var createResultSet = /* @__PURE__ */ factory(
  name,
  dependencies2,
  () => {
    function ResultSet(entries) {
      if (!(this instanceof ResultSet)) {
        throw new SyntaxError(
          "Constructor must be called with the new operator"
        );
      }
      this.entries = entries || [];
    }
    ResultSet.prototype.type = "ResultSet";
    ResultSet.prototype.isResultSet = true;
    ResultSet.prototype.valueOf = function() {
      return this.entries;
    };
    ResultSet.prototype.toString = function() {
      return "[" + this.entries.map(String).join(", ") + "]";
    };
    ResultSet.prototype.toJSON = function() {
      return {
        mathjs: "ResultSet",
        entries: this.entries
      };
    };
    ResultSet.fromJSON = function(json) {
      return new ResultSet(json.entries);
    };
    return ResultSet;
  },
  { isClass: true }
);
var EUCLID = 9;
var name2 = "BigNumber";
var dependencies3 = ["?on", "config"];
var createBigNumberClass = /* @__PURE__ */ factory(
  name2,
  dependencies3,
  ({ on, config }) => {
    const BigNumber = Decimal__default.default.clone({
      precision: config.precision,
      modulo: EUCLID
    });
    const prototype = BigNumber.prototype;
    BigNumber.prototype = Object.create(prototype);
    BigNumber.prototype.type = "BigNumber";
    BigNumber.prototype.isBigNumber = true;
    BigNumber.prototype.toJSON = function() {
      return {
        mathjs: "BigNumber",
        value: this.toString()
      };
    };
    BigNumber.fromJSON = function(json) {
      return new BigNumber(json.value);
    };
    if (on) {
      on("config", function(curr, prev) {
        if (curr.precision !== prev.precision) {
          BigNumber.config({ precision: curr.precision });
        }
      });
    }
    return BigNumber;
  },
  { isClass: true }
);
var Complex = ComplexJs__default.default;
var name3 = "Complex";
var dependencies4 = [];
var createComplexClass = /* @__PURE__ */ factory(
  name3,
  dependencies4,
  () => {
    Object.defineProperty(Complex, "name", { value: "Complex" });
    Complex.prototype.constructor = Complex;
    Complex.prototype.type = "Complex";
    Complex.prototype.isComplex = true;
    Complex.prototype.toJSON = function() {
      return {
        mathjs: "Complex",
        re: this.re,
        im: this.im
      };
    };
    Complex.prototype.toPolar = function() {
      return {
        r: this.abs(),
        phi: this.arg()
      };
    };
    Complex.prototype.format = function(options) {
      let str = "";
      let im = this.im;
      let re = this.re;
      const strRe = format(this.re, options);
      const strIm = format(this.im, options);
      const precision = isNumber(options) ? options : options && typeof options === "object" ? options.precision ?? null : null;
      if (precision !== null) {
        const epsilon = Math.pow(10, -precision);
        if (Math.abs(re / im) < epsilon) {
          re = 0;
        }
        if (Math.abs(im / re) < epsilon) {
          im = 0;
        }
      }
      if (im === 0) {
        str = strRe;
      } else if (re === 0) {
        if (im === 1) {
          str = "i";
        } else if (im === -1) {
          str = "-i";
        } else {
          str = strIm + "i";
        }
      } else {
        if (im < 0) {
          if (im === -1) {
            str = strRe + " - i";
          } else {
            str = strRe + " - " + strIm.substring(1) + "i";
          }
        } else {
          if (im === 1) {
            str = strRe + " + i";
          } else {
            str = strRe + " + " + strIm + "i";
          }
        }
      }
      return str;
    };
    Complex.fromPolar = function(_args) {
      switch (arguments.length) {
        case 1: {
          const arg = arguments[0];
          if (typeof arg === "object") {
            return Complex(arg);
          } else {
            throw new TypeError(
              "Input has to be an object with r and phi keys."
            );
          }
        }
        case 2: {
          const r = arguments[0];
          let phi2 = arguments[1];
          if (isNumber(r)) {
            if (isUnit(phi2) && phi2.hasBase("ANGLE")) {
              phi2 = phi2.toNumber("rad");
            }
            if (isNumber(phi2)) {
              return new Complex({ r, phi: phi2 });
            }
            throw new TypeError("Phi is not a number nor an angle unit.");
          } else {
            throw new TypeError("Radius r is not a number.");
          }
        }
        default:
          throw new SyntaxError(
            "Wrong number of arguments in function fromPolar"
          );
      }
    };
    Complex.prototype.valueOf = Complex.prototype.toString;
    Complex.fromJSON = function(json) {
      return new Complex(json);
    };
    Complex.compare = function(a, b) {
      if (a.re > b.re) {
        return 1;
      }
      if (a.re < b.re) {
        return -1;
      }
      if (a.im > b.im) {
        return 1;
      }
      if (a.im < b.im) {
        return -1;
      }
      return 0;
    };
    return Complex;
  },
  { isClass: true }
);
var Fraction = FractionJs__default.default;
var name4 = "Fraction";
var dependencies5 = [];
var createFractionClass = /* @__PURE__ */ factory(
  name4,
  dependencies5,
  () => {
    Object.defineProperty(Fraction, "name", { value: "Fraction" });
    Fraction.prototype.constructor = Fraction;
    Fraction.prototype.type = "Fraction";
    Fraction.prototype.isFraction = true;
    Fraction.prototype.toJSON = function() {
      const signedNumerator = typeof this.n === "bigint" ? BigInt(this.s) * this.n : this.s * this.n;
      return {
        mathjs: "Fraction",
        n: String(signedNumerator),
        d: String(this.d)
      };
    };
    Fraction.fromJSON = function(json) {
      return new Fraction(json);
    };
    return Fraction;
  },
  { isClass: true }
);

// src/type/matrix/Range.ts
var name5 = "Range";
var dependencies6 = [];
var createRangeClass = /* @__PURE__ */ factory(
  name5,
  dependencies6,
  () => {
    class Range {
      constructor(start, end, step) {
        /**
         * Type identifier
         */
        this.type = "Range";
        /**
         * Range type flag
         */
        this.isRange = true;
        if (!(this instanceof Range)) {
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        }
        const hasStart = start !== null && start !== void 0;
        const hasEnd = end !== null && end !== void 0;
        const hasStep = step !== null && step !== void 0;
        let startValue = 0;
        let endValue = 0;
        let stepValue = 1;
        if (hasStart) {
          if (isBigNumber(start)) {
            startValue = start.toNumber();
          } else if (typeof start !== "number" && !isBigInt(start)) {
            throw new TypeError("Parameter start must be a number or bigint");
          } else {
            startValue = start;
          }
        }
        if (hasEnd) {
          if (isBigNumber(end)) {
            endValue = end.toNumber();
          } else if (typeof end !== "number" && !isBigInt(end)) {
            throw new TypeError("Parameter end must be a number or bigint");
          } else {
            endValue = end;
          }
        }
        if (hasStep) {
          if (isBigNumber(step)) {
            stepValue = step.toNumber();
          } else if (typeof step !== "number" && !isBigInt(step)) {
            throw new TypeError("Parameter step must be a number or bigint");
          } else {
            stepValue = step;
          }
        }
        this.start = hasStart ? parseFloat(startValue.toString()) : 0;
        this.end = hasEnd ? parseFloat(endValue.toString()) : 0;
        this.step = hasStep ? parseFloat(stepValue.toString()) : 1;
        if (hasStep && nearlyEqual(this.step, 0)) {
          throw new Error("Step must not be zero");
        }
      }
      /**
       * Parse a string into a range,
       * The string contains the start, optional step, and end, separated by a colon.
       * If the string does not contain a valid range, null is returned.
       * For example str='0:2:11'.
       * @memberof Range
       * @param {string} str
       * @return {Range | null} range
       */
      static parse(str) {
        if (typeof str !== "string") {
          return null;
        }
        const args = str.split(":");
        const nums = args.map(function(arg) {
          return parseFloat(arg);
        });
        const invalid = nums.some(function(num) {
          return isNaN(num);
        });
        if (invalid) {
          return null;
        }
        switch (nums.length) {
          case 2:
            return new Range(nums[0], nums[1]);
          case 3:
            return new Range(nums[0], nums[2], nums[1]);
          default:
            return null;
        }
      }
      /**
       * Create a clone of the range
       * @return {Range} clone
       */
      clone() {
        return new Range(this.start, this.end, this.step);
      }
      /**
       * Retrieve the size of the range.
       * Returns an array containing one number, the number of elements in the range.
       * @memberof Range
       * @returns {[number]} size
       */
      size() {
        let len = 0;
        const start = this.start;
        const step = this.step;
        const end = this.end;
        const diff = end - start;
        if (sign(step) === sign(diff)) {
          len = Math.ceil(diff / step);
        } else if (diff === 0) {
          len = 0;
        }
        if (isNaN(len)) {
          len = 0;
        }
        return [len];
      }
      /**
       * Calculate the minimum value in the range
       * @memberof Range
       * @return {number | undefined} min
       */
      min() {
        const size = this.size()[0];
        if (size > 0) {
          if (this.step > 0) {
            return this.start;
          } else {
            return this.start + (size - 1) * this.step;
          }
        } else {
          return void 0;
        }
      }
      /**
       * Calculate the maximum value in the range
       * @memberof Range
       * @return {number | undefined} max
       */
      max() {
        const size = this.size()[0];
        if (size > 0) {
          if (this.step > 0) {
            return this.start + (size - 1) * this.step;
          } else {
            return this.start;
          }
        } else {
          return void 0;
        }
      }
      /**
       * Execute a callback function for each value in the range.
       * @memberof Range
       * @param {function} callback The callback method is invoked with three
       *                            parameters: the value of the element, the index
       *                            of the element, and the Range being traversed.
       */
      forEach(callback) {
        let x = this.start;
        const step = this.step;
        const end = this.end;
        let i = 0;
        if (step > 0) {
          while (x < end) {
            callback(x, [i], this);
            x += step;
            i++;
          }
        } else if (step < 0) {
          while (x > end) {
            callback(x, [i], this);
            x += step;
            i++;
          }
        }
      }
      /**
       * Execute a callback function for each value in the Range, and return the
       * results as an array
       * @memberof Range
       * @param {function} callback The callback method is invoked with three
       *                            parameters: the value of the element, the index
       *                            of the element, and the Matrix being traversed.
       * @returns {Array} array
       */
      map(callback) {
        const array = [];
        const self = this;
        this.forEach(function(value, index, _obj) {
          array[index[0]] = callback(value, index, self);
        });
        return array;
      }
      /**
       * Create an Array with a copy of the Ranges data
       * @memberof Range
       * @returns {Array} array
       */
      toArray() {
        const array = [];
        this.forEach(function(value, index) {
          array[index[0]] = value;
        });
        return array;
      }
      /**
       * Get the primitive value of the Range, a one dimensional array
       * @memberof Range
       * @returns {Array} array
       */
      valueOf() {
        return this.toArray();
      }
      /**
       * Get a string representation of the range, with optional formatting options.
       * Output is formatted as 'start:step:end', for example '2:6' or '0:0.2:11'
       * @memberof Range
       * @param {Object | number | function} [options] Formatting options. See
       *                                               lib/utils/number:format for a
       *                                               description of the available
       *                                               options.
       * @returns {string} str
       */
      format(options) {
        let str = format(this.start, options);
        if (this.step !== 1) {
          str += ":" + format(this.step, options);
        }
        str += ":" + format(this.end, options);
        return str;
      }
      /**
       * Get a string representation of the range.
       * @memberof Range
       * @returns {string}
       */
      toString() {
        return this.format();
      }
      /**
       * Get a JSON representation of the range
       * @memberof Range
       * @returns {Object} Returns a JSON object structured as:
       *                   `{"mathjs": "Range", "start": 2, "end": 4, "step": 1}`
       */
      toJSON() {
        return {
          mathjs: "Range",
          start: this.start,
          end: this.end,
          step: this.step
        };
      }
      /**
       * Instantiate a Range from a JSON object
       * @memberof Range
       * @param {Object} json A JSON object structured as:
       *                      `{"mathjs": "Range", "start": 2, "end": 4, "step": 1}`
       * @return {Range}
       */
      static fromJSON(json) {
        return new Range(json.start, json.end, json.step);
      }
    }
    Range.prototype.type = "Range";
    Range.prototype.isRange = true;
    return Range;
  },
  { isClass: true }
);

// src/type/matrix/Matrix.ts
var name6 = "Matrix";
var dependencies7 = [];
var createMatrixClass = /* @__PURE__ */ factory(
  name6,
  dependencies7,
  () => {
    class Matrix2 {
      constructor() {
        /**
         * Type identifier
         */
        this.type = "Matrix";
        /**
         * Matrix type flag
         */
        this.isMatrix = true;
        if (!(this instanceof Matrix2)) {
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        }
      }
      /**
       * Get the storage format used by the matrix.
       *
       * Usage:
       *     const format = matrix.storage()   // retrieve storage format
       *
       * @return {string} The storage format.
       */
      storage() {
        throw new Error("Cannot invoke storage on a Matrix interface");
      }
      /**
       * Get the datatype of the data stored in the matrix.
       *
       * Usage:
       *     const format = matrix.datatype()    // retrieve matrix datatype
       *
       * @return {string | undefined} The datatype.
       */
      datatype() {
        throw new Error("Cannot invoke datatype on a Matrix interface");
      }
      /**
       * Create a new Matrix With the type of the current matrix instance
       * @param {Array | Object} data
       * @param {string} [datatype]
       */
      create(_data, _datatype) {
        throw new Error("Cannot invoke create on a Matrix interface");
      }
      /**
       * Get a subset of the matrix, or replace a subset of the matrix.
       *
       * Usage:
       *     const subset = matrix.subset(index)               // retrieve subset
       *     const value = matrix.subset(index, replacement)   // replace subset
       *
       * @param {IndexInterface} index
       * @param {Array | Matrix | *} [replacement]
       * @param {*} [defaultValue=0] Default value, filled in on new entries when
       *                             the matrix is resized. If not provided,
       *                             new matrix elements will be filled with zeros.
       */
      subset(_index, _replacement, _defaultValue) {
        throw new Error("Cannot invoke subset on a Matrix interface");
      }
      /**
       * Get a single element from the matrix.
       * @param {number[]} index Zero-based index
       * @return {*} value
       */
      get(_index) {
        throw new Error("Cannot invoke get on a Matrix interface");
      }
      /**
       * Replace a single element in the matrix.
       * @param {number[]} index Zero-based index
       * @param {*} value
       * @param {*} [defaultValue] Default value, filled in on new entries when
       *                           the matrix is resized. If not provided,
       *                           new matrix elements will be left undefined.
       * @return {Matrix} self
       */
      set(_index, _value, _defaultValue) {
        throw new Error("Cannot invoke set on a Matrix interface");
      }
      /**
       * Resize the matrix to the given size. Returns a copy of the matrix when
       * `copy=true`, otherwise return the matrix itself (resize in place).
       *
       * @param {number[]} size The new size the matrix should have.
       * @param {*} [defaultValue=0] Default value, filled in on new entries.
       *                             If not provided, the matrix elements will
       *                             be filled with zeros.
       * @param {boolean} [copy] Return a resized copy of the matrix
       *
       * @return {Matrix} The resized matrix
       */
      resize(_size, _defaultValue, _copy) {
        throw new Error("Cannot invoke resize on a Matrix interface");
      }
      /**
       * Reshape the matrix to the given size. Returns a copy of the matrix when
       * `copy=true`, otherwise return the matrix itself (reshape in place).
       *
       * @param {number[]} size The new size the matrix should have.
       * @param {boolean} [copy] Return a reshaped copy of the matrix
       *
       * @return {Matrix} The reshaped matrix
       */
      reshape(_size, _copy) {
        throw new Error("Cannot invoke reshape on a Matrix interface");
      }
      /**
       * Create a clone of the matrix
       * @return {Matrix} clone
       */
      clone() {
        throw new Error("Cannot invoke clone on a Matrix interface");
      }
      /**
       * Retrieve the size of the matrix.
       * @returns {number[]} size
       */
      size() {
        throw new Error("Cannot invoke size on a Matrix interface");
      }
      /**
       * Create a new matrix with the results of the callback function executed on
       * each entry of the matrix.
       * @param {Function} callback The callback function is invoked with three
       *                            parameters: the value of the element, the index
       *                            of the element, and the Matrix being traversed.
       * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
       *
       * @return {Matrix} matrix
       */
      map(_callback, _skipZeros) {
        throw new Error("Cannot invoke map on a Matrix interface");
      }
      /**
       * Execute a callback function on each entry of the matrix.
       * @param {Function} callback The callback function is invoked with three
       *                            parameters: the value of the element, the index
       *                            of the element, and the Matrix being traversed.
       */
      forEach(_callback) {
        throw new Error("Cannot invoke forEach on a Matrix interface");
      }
      /**
       * Iterate over the matrix elements
       * @return {Iterable<{ value, index: number[] }>}
       */
      [Symbol.iterator]() {
        throw new Error("Cannot iterate a Matrix interface");
      }
      /**
       * Create an Array with a copy of the data of the Matrix
       * @returns {Array} array
       */
      toArray() {
        throw new Error("Cannot invoke toArray on a Matrix interface");
      }
      /**
       * Get the primitive value of the Matrix: a multidimensional array
       * @returns {Array} array
       */
      valueOf() {
        throw new Error("Cannot invoke valueOf on a Matrix interface");
      }
      /**
       * Get a string representation of the matrix, with optional formatting options.
       * @param {Object | number | Function} [options] Formatting options. See
       *                                               lib/utils/number:format for a
       *                                               description of the available
       *                                               options.
       * @returns {string} str
       */
      format(_options) {
        throw new Error("Cannot invoke format on a Matrix interface");
      }
      /**
       * Get a string representation of the matrix
       * @returns {string} str
       */
      toString() {
        throw new Error("Cannot invoke toString on a Matrix interface");
      }
    }
    Matrix2.prototype.type = "Matrix";
    Matrix2.prototype.isMatrix = true;
    return Matrix2;
  },
  { isClass: true }
);

// src/utils/bignumber/formatter.ts
function formatBigNumberToBase(n, base, size) {
  const BigNumberCtor = n.constructor;
  const big2 = new BigNumberCtor(2);
  let suffix = "";
  if (size) {
    if (size < 1) {
      throw new Error("size must be in greater than 0");
    }
    if (!isInteger(size)) {
      throw new Error("size must be an integer");
    }
    if (n.greaterThan(big2.pow(size - 1).sub(1)) || n.lessThan(big2.pow(size - 1).mul(-1))) {
      throw new Error(
        `Value must be in range [-2^${size - 1}, 2^${size - 1}-1]`
      );
    }
    if (!n.isInteger()) {
      throw new Error("Value must be an integer");
    }
    if (n.lessThan(0)) {
      n = n.add(big2.pow(size));
    }
    suffix = `i${size}`;
  }
  switch (base) {
    case 2:
      return `${n.toBinary()}${suffix}`;
    case 8:
      return `${n.toOctal()}${suffix}`;
    case 16:
      return `${n.toHexadecimal()}${suffix}`;
    default:
      throw new Error(`Base ${base} not supported `);
  }
}
function format2(value, options) {
  if (typeof options === "function") {
    return options(value);
  }
  if (!value.isFinite()) {
    return value.isNaN() ? "NaN" : value.gt(0) ? "Infinity" : "-Infinity";
  }
  const { notation, precision, wordSize } = normalizeFormatOptions(options);
  switch (notation) {
    case "fixed":
      return toFixed2(value, precision);
    case "exponential":
      return toExponential2(value, precision);
    case "engineering":
      return toEngineering2(value, precision);
    case "bin":
      return formatBigNumberToBase(value, 2, wordSize);
    case "oct":
      return formatBigNumberToBase(value, 8, wordSize);
    case "hex":
      return formatBigNumberToBase(value, 16, wordSize);
    case "auto": {
      const lowerExp = _toNumberOrDefault2(options?.lowerExp, -3);
      const upperExp = _toNumberOrDefault2(options?.upperExp, 5);
      if (value.isZero()) return "0";
      let str;
      const rounded = value.toSignificantDigits(precision);
      const exp = rounded.e;
      if (exp >= lowerExp && exp < upperExp) {
        str = rounded.toFixed();
      } else {
        str = toExponential2(value, precision);
      }
      return str.replace(/((\.\d*?)(0+))($|e)/, function() {
        const digits2 = arguments[2];
        const e2 = arguments[4];
        return digits2 !== "." ? digits2 + e2 : e2;
      });
    }
    default:
      throw new Error(
        'Unknown notation "' + notation + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.'
      );
  }
}
function toEngineering2(value, precision) {
  const e2 = value.e;
  const newExp = e2 % 3 === 0 ? e2 : e2 < 0 ? e2 - 3 - e2 % 3 : e2 - e2 % 3;
  const valueWithoutExp = value.mul(Math.pow(10, -newExp));
  let valueStr = valueWithoutExp.toPrecision(precision);
  if (valueStr.includes("e")) {
    const BigNumber = value.constructor;
    valueStr = new BigNumber(valueStr).toFixed();
  }
  return valueStr + "e" + (e2 >= 0 ? "+" : "") + newExp.toString();
}
function toExponential2(value, precision) {
  if (precision !== void 0) {
    return value.toExponential(precision - 1);
  } else {
    return value.toExponential();
  }
}
function toFixed2(value, precision) {
  return value.toFixed(precision);
}
function _toNumberOrDefault2(value, defaultValue) {
  if (isNumber(value)) {
    return value;
  } else if (isBigNumber(value)) {
    return value.toNumber();
  } else {
    return defaultValue;
  }
}

// src/utils/string.ts
function endsWith(text, search) {
  const start = text.length - search.length;
  const end = text.length;
  return text.substring(start, end) === search;
}
function format3(value, options) {
  const result = _format(value, options);
  if (options && typeof options === "object" && "truncate" in options && result.length > options.truncate) {
    return result.substring(0, options.truncate - 3) + "...";
  }
  return result;
}
function _format(value, options) {
  if (typeof value === "number") {
    return format(value, options);
  }
  if (isBigNumber(value)) {
    return format2(value, options);
  }
  if (looksLikeFraction(value)) {
    if (!options || options.fraction !== "decimal") {
      const signedNumerator = typeof value.n === "bigint" ? BigInt(value.s) * value.n : value.s * value.n;
      return `${signedNumerator}/${value.d}`;
    } else {
      return value.toString();
    }
  }
  if (Array.isArray(value)) {
    return formatArray(value, options);
  }
  if (isString(value)) {
    return stringify(value);
  }
  if (typeof value === "function") {
    return value.syntax ? String(value.syntax) : "function";
  }
  if (value && typeof value === "object") {
    if (typeof value.format === "function") {
      return value.format(options);
    } else if (value && value.toString(options) !== {}.toString()) {
      return value.toString(options);
    } else {
      const entries = Object.keys(value).map((key) => {
        return stringify(key) + ": " + format3(value[key], options);
      });
      return "{" + entries.join(", ") + "}";
    }
  }
  return String(value);
}
function stringify(value) {
  const text = String(value);
  let escaped = "";
  let i = 0;
  while (i < text.length) {
    const c = text.charAt(i);
    escaped += c in controlCharacters ? controlCharacters[c] : c;
    i++;
  }
  return '"' + escaped + '"';
}
var controlCharacters = {
  '"': '\\"',
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t"
};
function escape(value) {
  let text = String(value);
  text = text.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  return text;
}
function formatArray(array, options) {
  if (Array.isArray(array)) {
    let str = "[";
    const len = array.length;
    for (let i = 0; i < len; i++) {
      if (i !== 0) {
        str += ", ";
      }
      str += formatArray(array[i], options);
    }
    str += "]";
    return str;
  } else {
    return format3(array, options);
  }
}
function looksLikeFraction(value) {
  return value && typeof value === "object" && typeof value.s === "bigint" && typeof value.n === "bigint" && typeof value.d === "bigint" || false;
}
function compareText(x, y) {
  if (!isString(x)) {
    throw new TypeError(
      "Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " + typeOf(x) + ", index: 0)"
    );
  }
  if (!isString(y)) {
    throw new TypeError(
      "Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " + typeOf(y) + ", index: 1)"
    );
  }
  return x === y ? 0 : x > y ? 1 : -1;
}

// src/error/DimensionError.ts
var DimensionError = class _DimensionError extends RangeError {
  /**
   * @param actual - The actual size or custom error message
   * @param expected - The expected size (optional if actual is a custom message)
   * @param relation - Optional relation between actual and expected size: '!=', '<', etc.
   */
  constructor(actual, expected, relation) {
    let message;
    if (typeof actual === "string" && expected === void 0) {
      message = actual;
    } else {
      message = "Dimension mismatch (" + (Array.isArray(actual) ? "[" + actual.join(", ") + "]" : actual) + " " + (relation || "!=") + " " + (Array.isArray(expected) ? "[" + expected.join(", ") + "]" : expected) + ")";
    }
    super(message);
    this.isDimensionError = true;
    this.name = "DimensionError";
    if (typeof actual === "string" && expected === void 0) {
      this.actual = void 0;
      this.expected = void 0;
      this.relation = void 0;
    } else {
      this.actual = actual;
      this.expected = expected;
      this.relation = relation;
    }
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _DimensionError);
    }
  }
};

// src/error/IndexError.ts
var IndexError = class _IndexError extends RangeError {
  /**
   * Create an IndexError
   *
   * Can be called in two ways:
   * - IndexError(index, max) - assumes min=0
   * - IndexError(index, min, max)
   *
   * @param index  The actual index
   * @param min    Minimum index (included), or max if only 2 args provided
   * @param max    Maximum index (excluded)
   */
  constructor(index, min, max) {
    let actualMin;
    let actualMax;
    if (max === void 0) {
      actualMin = 0;
      actualMax = min;
    } else {
      actualMin = min;
      actualMax = max;
    }
    let message;
    if (actualMin !== void 0 && index < actualMin) {
      message = "Index out of range (" + index + " < " + actualMin + ")";
    } else if (actualMax !== void 0 && index >= actualMax) {
      message = "Index out of range (" + index + " > " + (actualMax - 1) + ")";
    } else {
      message = "Index out of range (" + index + ")";
    }
    super(message);
    this.isIndexError = true;
    this.index = index;
    this.min = actualMin;
    this.max = actualMax;
    this.name = "IndexError";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _IndexError);
    }
  }
};

// src/utils/array.ts
function arraySize(x) {
  const s = [];
  let current = x;
  while (Array.isArray(current)) {
    s.push(current.length);
    current = current[0];
  }
  return s;
}
function _validate(array, size, dim) {
  let i;
  const len = array.length;
  if (len !== size[dim]) {
    throw new DimensionError(len, size[dim]);
  }
  if (dim < size.length - 1) {
    const dimNext = dim + 1;
    for (i = 0; i < len; i++) {
      const child = array[i];
      if (!Array.isArray(child)) {
        throw new DimensionError(size.length - 1, size.length, "<");
      }
      _validate(array[i], size, dimNext);
    }
  } else {
    for (i = 0; i < len; i++) {
      if (Array.isArray(array[i])) {
        throw new DimensionError(size.length + 1, size.length, ">");
      }
    }
  }
}
function validate(array, size) {
  const isScalar = size.length === 0;
  if (isScalar) {
    if (Array.isArray(array)) {
      throw new DimensionError(array.length, 0);
    }
  } else {
    _validate(array, size, 0);
  }
}
function validateIndexSourceSize(value, index) {
  const valueSize = value.isMatrix ? value._size : arraySize(value);
  const sourceSize = index._sourceSize;
  sourceSize.forEach((sourceDim, i) => {
    if (sourceDim !== null && sourceDim !== valueSize[i]) {
      throw new DimensionError(sourceDim, valueSize[i]);
    }
  });
}
function validateIndex(index, length) {
  if (index !== void 0) {
    if (!isNumber(index) || !isInteger(index)) {
      throw new TypeError("Index must be an integer (value: " + index + ")");
    }
    if (index < 0 || typeof length === "number" && index >= length) {
      throw new IndexError(index, length);
    }
  }
}
function isEmptyIndex(index) {
  for (let i = 0; i < index._dimensions.length; ++i) {
    const dimension = index._dimensions[i];
    if (isString(dimension)) {
      if (dimension.length === 0) {
        return true;
      }
    } else {
      const dim = dimension;
      if (dim._data && isArray(dim._data)) {
        if (dim._size[0] === 0) {
          return true;
        }
      } else if (dim.isRange) {
        if (dim.start === dim.end) {
          return true;
        }
      }
    }
  }
  return false;
}
function resize(array, size, defaultValue) {
  if (!Array.isArray(size)) {
    throw new TypeError("Array expected");
  }
  if (size.length === 0) {
    throw new Error("Resizing to scalar is not supported");
  }
  size.forEach(function(value) {
    if (!isNumber(value) || !isInteger(value) || value < 0) {
      throw new TypeError(
        "Invalid size, must contain positive integers (size: " + format3(size, {}) + ")"
      );
    }
  });
  let arr = array;
  if (isNumber(array) || isBigNumber(array)) {
    arr = [array];
  }
  const _defaultValue = defaultValue !== void 0 ? defaultValue : 0;
  _resize(arr, size, 0, _defaultValue);
  return arr;
}
function _resize(array, size, dim, defaultValue) {
  let i;
  let elem;
  const oldLen = array.length;
  const newLen = size[dim];
  const minLen = Math.min(oldLen, newLen);
  array.length = newLen;
  if (dim < size.length - 1) {
    const dimNext = dim + 1;
    for (i = 0; i < minLen; i++) {
      let current = array[i];
      if (!Array.isArray(current)) {
        current = [current];
        array[i] = current;
      }
      _resize(current, size, dimNext, defaultValue);
    }
    for (i = minLen; i < newLen; i++) {
      elem = [];
      array[i] = elem;
      _resize(elem, size, dimNext, defaultValue);
    }
  } else {
    for (i = 0; i < minLen; i++) {
      let value = array[i];
      while (Array.isArray(value)) {
        value = value[0];
      }
      array[i] = value;
    }
    for (i = minLen; i < newLen; i++) {
      array[i] = defaultValue;
    }
  }
}
function reshape(array, sizes) {
  const flatArray = flatten(array, true);
  const currentLength = flatArray.length;
  if (!Array.isArray(array) || !Array.isArray(sizes)) {
    throw new TypeError("Array expected");
  }
  if (sizes.length === 0) {
    throw new DimensionError(0, currentLength, "!=");
  }
  const processedSizes = processSizesWildcard(sizes, currentLength);
  const newLength = product(processedSizes);
  if (currentLength !== newLength) {
    throw new DimensionError(newLength, currentLength, "!=");
  }
  try {
    return _reshape(flatArray, processedSizes);
  } catch (e2) {
    if (e2 instanceof DimensionError) {
      throw new DimensionError(newLength, currentLength, "!=");
    }
    throw e2;
  }
}
function processSizesWildcard(sizes, currentLength) {
  const newLength = product(sizes);
  const processedSizes = sizes.slice();
  const WILDCARD = -1;
  const wildCardIndex = sizes.indexOf(WILDCARD);
  const isMoreThanOneWildcard = sizes.indexOf(WILDCARD, wildCardIndex + 1) >= 0;
  if (isMoreThanOneWildcard) {
    throw new Error("More than one wildcard in sizes");
  }
  const hasWildcard = wildCardIndex >= 0;
  const canReplaceWildcard = currentLength % newLength === 0;
  if (hasWildcard) {
    if (canReplaceWildcard) {
      processedSizes[wildCardIndex] = -currentLength / newLength;
    } else {
      throw new Error(
        "Could not replace wildcard, since " + currentLength + " is no multiple of " + -newLength
      );
    }
  }
  return processedSizes;
}
function product(array) {
  return array.reduce((prev, curr) => prev * curr, 1);
}
function _reshape(array, sizes) {
  let tmpArray = array;
  let tmpArray2;
  for (let sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {
    const size = sizes[sizeIndex];
    tmpArray2 = [];
    const length = tmpArray.length / size;
    for (let i = 0; i < length; i++) {
      tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size));
    }
    tmpArray = tmpArray2;
  }
  return tmpArray;
}
function squeeze(array, size) {
  const s = arraySize(array);
  let arr = array;
  while (Array.isArray(arr) && arr.length === 1) {
    arr = arr[0];
    s.shift();
  }
  let dims = s.length;
  while (s[dims - 1] === 1) {
    dims--;
  }
  if (dims < s.length) {
    arr = _squeeze(arr, dims, 0);
    s.length = dims;
  }
  return arr;
}
function _squeeze(array, dims, dim) {
  if (dim < dims) {
    const next = dim + 1;
    const arr = array;
    for (let i = 0, ii = arr.length; i < ii; i++) {
      arr[i] = _squeeze(arr[i], dims, next);
    }
    return arr;
  } else {
    let result = array;
    while (Array.isArray(result)) {
      result = result[0];
    }
    return result;
  }
}
function unsqueeze(array, dims, outer, size) {
  const s = size || arraySize(array);
  let arr = array;
  if (outer) {
    for (let i = 0; i < outer; i++) {
      arr = [arr];
      s.unshift(1);
    }
  }
  arr = _unsqueeze(arr, dims, 0);
  while (s.length < dims) {
    s.push(1);
  }
  return arr;
}
function _unsqueeze(array, dims, dim) {
  if (Array.isArray(array)) {
    const next = dim + 1;
    const arr = array;
    for (let i = 0, ii = arr.length; i < ii; i++) {
      arr[i] = _unsqueeze(arr[i], dims, next);
    }
    return arr;
  } else {
    let result = array;
    for (let d = dim; d < dims; d++) {
      result = [result];
    }
    return result;
  }
}
function flatten(array, isRectangular = false) {
  if (!Array.isArray(array)) {
    return array;
  }
  if (typeof isRectangular !== "boolean") {
    throw new TypeError("Boolean expected for second argument of flatten");
  }
  const flat = [];
  if (isRectangular) {
    _flattenRectangular(array);
  } else {
    _flatten(array);
  }
  return flat;
  function _flatten(arr) {
    for (let i = 0; i < arr.length; i++) {
      const item = arr[i];
      if (Array.isArray(item)) {
        _flatten(item);
      } else {
        flat.push(item);
      }
    }
  }
  function _flattenRectangular(arr) {
    if (Array.isArray(arr[0])) {
      for (let i = 0; i < arr.length; i++) {
        _flattenRectangular(arr[i]);
      }
    } else {
      for (let i = 0; i < arr.length; i++) {
        flat.push(arr[i]);
      }
    }
  }
}
function map(array, callback) {
  return Array.prototype.map.call(array, callback);
}
function forEach(array, callback) {
  Array.prototype.forEach.call(array, callback);
}
function filter(array, callback) {
  if (arraySize(array).length !== 1) {
    throw new Error("Only one dimensional matrices supported");
  }
  return Array.prototype.filter.call(array, callback);
}
function filterRegExp(array, regexp) {
  if (arraySize(array).length !== 1) {
    throw new Error("Only one dimensional matrices supported");
  }
  return Array.prototype.filter.call(
    array,
    (entry) => regexp.test(entry)
  );
}
function join(array, separator) {
  return Array.prototype.join.call(array, separator);
}
function identify(a) {
  if (!Array.isArray(a)) {
    throw new TypeError("Array input expected");
  }
  if (a.length === 0) {
    return [];
  }
  const b = [];
  let count = 0;
  b[0] = { value: a[0], identifier: 0 };
  for (let i = 1; i < a.length; i++) {
    if (a[i] === a[i - 1]) {
      count++;
    } else {
      count = 0;
    }
    b.push({ value: a[i], identifier: count });
  }
  return b;
}
function generalize(a) {
  if (!Array.isArray(a)) {
    throw new TypeError("Array input expected");
  }
  if (a.length === 0) {
    return [];
  }
  const b = [];
  for (let i = 0; i < a.length; i++) {
    b.push(a[i].value);
  }
  return b;
}
function getArrayDataType(array, typeOf2) {
  let type;
  let length = 0;
  for (let i = 0; i < array.length; i++) {
    const item = array[i];
    const isArray2 = Array.isArray(item);
    if (i === 0 && isArray2) {
      length = item.length;
    }
    if (isArray2 && item.length !== length) {
      return void 0;
    }
    const itemType = isArray2 ? getArrayDataType(item, typeOf2) : typeOf2(item);
    if (type === void 0) {
      type = itemType;
    } else if (type !== itemType) {
      return "mixed";
    } else ;
  }
  return type;
}
function concatRecursive(a, b, concatDim, dim) {
  if (dim < concatDim) {
    if (a.length !== b.length) {
      throw new DimensionError(a.length, b.length);
    }
    const c = [];
    for (let i = 0; i < a.length; i++) {
      c[i] = concatRecursive(
        a[i],
        b[i],
        concatDim,
        dim + 1
      );
    }
    return c;
  } else {
    return a.concat(b);
  }
}
function concat(...args) {
  const arrays = Array.prototype.slice.call(args, 0, -1);
  const concatDim = Array.prototype.slice.call(args, -1)[0];
  if (arrays.length === 1) {
    return arrays[0];
  }
  if (arrays.length > 1) {
    return arrays.slice(1).reduce(function(A, B) {
      return concatRecursive(A, B, concatDim, 0);
    }, arrays[0]);
  } else {
    throw new Error("Wrong number of arguments in function concat");
  }
}
function broadcastSizes(...sizes) {
  const dimensions = sizes.map((s) => s.length);
  const N = Math.max(...dimensions);
  const sizeMax = new Array(N).fill(null);
  for (let i = 0; i < sizes.length; i++) {
    const size = sizes[i];
    const dim = dimensions[i];
    for (let j = 0; j < dim; j++) {
      const n = N - dim + j;
      if (size[j] > sizeMax[n]) {
        sizeMax[n] = size[j];
      }
    }
  }
  for (let i = 0; i < sizes.length; i++) {
    checkBroadcastingRules(sizes[i], sizeMax);
  }
  return sizeMax;
}
function checkBroadcastingRules(size, toSize) {
  const N = toSize.length;
  const dim = size.length;
  for (let j = 0; j < dim; j++) {
    const n = N - dim + j;
    if (size[j] < toSize[n] && size[j] > 1 || size[j] > toSize[n]) {
      throw new Error(
        `shape mismatch: mismatch is found in arg with shape (${size}) not possible to broadcast dimension ${dim} with size ${size[j]} to size ${toSize[n]}`
      );
    }
  }
}
function broadcastTo(array, toSize) {
  let Asize = arraySize(array);
  if (deepStrictEqual(Asize, toSize)) {
    return array;
  }
  checkBroadcastingRules(Asize, toSize);
  const broadcastedSize = broadcastSizes(Asize, toSize);
  const N = broadcastedSize.length;
  const paddedSize = [...Array(N - Asize.length).fill(1), ...Asize];
  let A = clone2(array);
  if (Asize.length < N) {
    A = reshape(A, paddedSize);
    Asize = arraySize(A);
  }
  for (let dim = 0; dim < N; dim++) {
    if (Asize[dim] < broadcastedSize[dim]) {
      A = stretch(A, broadcastedSize[dim], dim);
      Asize = arraySize(A);
    }
  }
  return A;
}
function stretch(arrayToStretch, sizeToStretch, dimToStretch) {
  return concat(...Array(sizeToStretch).fill(arrayToStretch), dimToStretch);
}
function get(array, index) {
  if (!Array.isArray(array)) {
    throw new Error("Array expected");
  }
  const size = arraySize(array);
  if (index.length !== size.length) {
    throw new DimensionError(index.length, size.length);
  }
  for (let x = 0; x < index.length; x++) {
    validateIndex(index[x], size[x]);
  }
  return index.reduce((acc, curr) => acc[curr], array);
}
function deepMap(array, callback, skipIndex = false) {
  if (Array.isArray(array) && array.length === 0) {
    return [];
  }
  if (skipIndex) {
    return recursiveMap(array);
  }
  const index = [];
  return recursiveMapWithIndex(array, 0);
  function recursiveMapWithIndex(value, depth) {
    if (Array.isArray(value)) {
      const N = value.length;
      const result = Array(N);
      for (let i = 0; i < N; i++) {
        index[depth] = i;
        result[i] = recursiveMapWithIndex(value[i], depth + 1);
      }
      return result;
    } else {
      return callback(
        value,
        index.slice(0, depth),
        array
      );
    }
  }
  function recursiveMap(value) {
    if (Array.isArray(value)) {
      const N = value.length;
      const result = Array(N);
      for (let i = 0; i < N; i++) {
        result[i] = recursiveMap(value[i]);
      }
      return result;
    } else {
      return callback(value);
    }
  }
}
function deepForEach(array, callback, skipIndex = false) {
  if (Array.isArray(array) && array.length === 0) {
    return;
  }
  if (skipIndex) {
    recursiveForEach(array);
    return;
  }
  const index = [];
  recursiveForEachWithIndex(array, 0);
  function recursiveForEachWithIndex(value, depth) {
    if (Array.isArray(value)) {
      const N = value.length;
      for (let i = 0; i < N; i++) {
        index[depth] = i;
        recursiveForEachWithIndex(value[i], depth + 1);
      }
    } else {
      callback(
        value,
        index.slice(0, depth),
        array
      );
    }
  }
  function recursiveForEach(value) {
    if (Array.isArray(value)) {
      const N = value.length;
      for (let i = 0; i < N; i++) {
        recursiveForEach(value[i]);
      }
    } else {
      callback(value);
    }
  }
}
function clone2(array) {
  return Object.assign([], array);
}
function optimizeCallback(callback, array, name323, isUnary) {
  const typedAny = typedFunction__default.default;
  if (typedAny.isTypedFunction(callback)) {
    let numberOfArguments;
    if (isUnary) {
      numberOfArguments = 1;
    } else {
      const size = array.isMatrix ? array.size() : arraySize(array);
      const isEmpty = size.length ? size[size.length - 1] === 0 : true;
      if (isEmpty) {
        return { isUnary: false, fn: callback };
      }
      const firstIndex = size.map(() => 0);
      const firstValue = array.isMatrix ? array.get(firstIndex) : get(array, firstIndex);
      numberOfArguments = _findNumberOfArgumentsTyped(
        callback,
        firstValue,
        firstIndex,
        array,
        typedAny
      );
    }
    let fastCallback;
    if (array.isMatrix && array.dataType !== "mixed" && array.dataType !== void 0) {
      const singleSignature = _findSingleSignatureWithArity(
        callback,
        numberOfArguments
      );
      fastCallback = singleSignature !== void 0 ? singleSignature : callback;
    } else {
      fastCallback = callback;
    }
    if (numberOfArguments >= 1 && numberOfArguments <= 3) {
      return {
        isUnary: numberOfArguments === 1,
        fn: (...args) => _tryFunctionWithArgs(
          fastCallback,
          args.slice(0, numberOfArguments),
          name323,
          callback.name
        )
      };
    }
    return {
      isUnary: false,
      fn: (...args) => _tryFunctionWithArgs(
        fastCallback,
        args,
        name323,
        callback.name
      )
    };
  }
  if (isUnary === void 0) {
    return {
      isUnary: _findIfCallbackIsUnary(callback),
      fn: callback
    };
  } else {
    return { isUnary, fn: callback };
  }
}
function _findSingleSignatureWithArity(callback, arity) {
  const matchingFunctions = [];
  Object.entries(callback.signatures).forEach(([signature, func]) => {
    if (signature.split(",").length === arity) {
      matchingFunctions.push(func);
    }
  });
  if (matchingFunctions.length === 1) {
    return matchingFunctions[0];
  }
  return void 0;
}
function _findIfCallbackIsUnary(callback) {
  if (callback.length !== 1) return false;
  const callbackStr = callback.toString();
  if (/arguments/.test(callbackStr)) return false;
  const paramsStr = callbackStr.match(/\(.*?\)/);
  if (paramsStr && /\.\.\./.test(paramsStr[0])) return false;
  return true;
}
function _findNumberOfArgumentsTyped(callback, value, index, array, typedAny) {
  const testArgs = [value, index, array];
  for (let i = 3; i > 0; i--) {
    const args = testArgs.slice(0, i);
    if (typedAny.resolve(callback, args) !== null) {
      return i;
    }
  }
  return void 0;
}
function _tryFunctionWithArgs(func, args, mappingFnName, callbackName) {
  try {
    return func(...args);
  } catch (err) {
    _createCallbackError(err, args, mappingFnName, callbackName);
  }
}
function _createCallbackError(err, args, mappingFnName, callbackName) {
  const errWithData = err;
  if (err instanceof TypeError && errWithData.data?.category === "wrongType") {
    const argsDesc = [];
    argsDesc.push(`value: ${typeOf(args[0])}`);
    if (args.length >= 2) {
      argsDesc.push(`index: ${typeOf(args[1])}`);
    }
    if (args.length >= 3) {
      argsDesc.push(`array: ${typeOf(args[2])}`);
    }
    throw new TypeError(
      `Function ${mappingFnName} cannot apply callback arguments ${callbackName}(${argsDesc.join(", ")}) at index ${JSON.stringify(args[1])}`
    );
  } else {
    throw new TypeError(
      `Function ${mappingFnName} cannot apply callback arguments to function ${callbackName}: ${err.message}`
    );
  }
}

// src/type/matrix/DenseMatrix.ts
var name7 = "DenseMatrix";
var dependencies8 = ["Matrix", "config"];
var createDenseMatrixClass = /* @__PURE__ */ factory(
  name7,
  dependencies8,
  ({ Matrix: Matrix2, config }) => {
    class DenseMatrix extends Matrix2 {
      constructor(data, datatype) {
        super();
        this.type = "DenseMatrix";
        this.isDenseMatrix = true;
        if (!(this instanceof DenseMatrix)) {
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        }
        if (datatype && !isString(datatype)) {
          throw new Error("Invalid datatype: " + datatype);
        }
        if (isMatrix(data)) {
          if (data.type === "DenseMatrix") {
            this._data = clone(data._data);
            this._size = clone(data._size);
            this._datatype = datatype || data._datatype;
          } else {
            this._data = data.toArray();
            this._size = data.size();
            this._datatype = datatype || data._datatype;
          }
        } else if (data && isArray(data.data) && isArray(data.size)) {
          const constructorData = data;
          this._data = constructorData.data;
          this._size = constructorData.size;
          validate(this._data, this._size);
          this._datatype = datatype || constructorData.datatype;
        } else if (isArray(data)) {
          this._data = preprocess(data);
          this._size = arraySize(this._data);
          validate(this._data, this._size);
          this._datatype = datatype;
        } else if (data) {
          throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
        } else {
          this._data = [];
          this._size = [0];
          this._datatype = datatype;
        }
      }
      /**
       * Create a new DenseMatrix
       */
      createDenseMatrix(data, datatype) {
        return new DenseMatrix(data, datatype);
      }
      /**
       * Get the matrix type
       *
       * Usage:
       *    const matrixType = matrix.getDataType()  // retrieves the matrix type
       *
       * @memberOf DenseMatrix
       * @return {string}   type information; if multiple types are found from the Matrix, it will return "mixed"
       */
      getDataType() {
        return getArrayDataType(this._data, typeOf);
      }
      /**
       * Get the storage format used by the matrix.
       *
       * Usage:
       *     const format = matrix.storage()  // retrieve storage format
       *
       * @memberof DenseMatrix
       * @return {string}           The storage format.
       */
      storage() {
        return "dense";
      }
      /**
       * Get the datatype of the data stored in the matrix.
       *
       * Usage:
       *     const format = matrix.datatype()   // retrieve matrix datatype
       *
       * @memberof DenseMatrix
       * @return {DataType}           The datatype.
       */
      datatype() {
        return this._datatype;
      }
      /**
       * Create a new DenseMatrix
       * @memberof DenseMatrix
       * @param {Array} data
       * @param {DataType} [datatype]
       */
      create(data, datatype) {
        return new DenseMatrix(data, datatype);
      }
      /**
       * Get a subset of the matrix, or replace a subset of the matrix.
       *
       * Usage:
       *     const subset = matrix.subset(index)               // retrieve subset
       *     const value = matrix.subset(index, replacement)   // replace subset
       *
       * @memberof DenseMatrix
       * @param {Index} index
       * @param {Array | Matrix | *} [replacement]
       * @param {*} [defaultValue=0]      Default value, filled in on new entries when
       *                                  the matrix is resized. If not provided,
       *                                  new matrix elements will be filled with zeros.
       */
      subset(index, replacement, defaultValue) {
        switch (arguments.length) {
          case 1:
            return _get(this, index);
          // intentional fall through
          case 2:
          case 3:
            return _set(this, index, replacement, defaultValue);
          default:
            throw new SyntaxError("Wrong number of arguments");
        }
      }
      /**
       * Get a single element from the matrix.
       * @memberof DenseMatrix
       * @param {number[]} index   Zero-based index
       * @return {MatrixValue} value
       */
      get(index) {
        return get(this._data, index);
      }
      /**
       * Replace a single element in the matrix.
       * @memberof DenseMatrix
       * @param {number[]} index   Zero-based index
       * @param {MatrixValue} value
       * @param {MatrixValue} [defaultValue]        Default value, filled in on new entries when
       *                                  the matrix is resized. If not provided,
       *                                  new matrix elements will be left undefined.
       * @return {DenseMatrix} self
       */
      set(index, value, defaultValue) {
        if (!isArray(index)) {
          throw new TypeError("Array expected");
        }
        if (index.length < this._size.length) {
          throw new DimensionError(index.length, this._size.length, "<");
        }
        let i, ii, indexI;
        const size = index.map(function(i2) {
          return i2 + 1;
        });
        _fit(this, size, defaultValue);
        let data = this._data;
        for (i = 0, ii = index.length - 1; i < ii; i++) {
          indexI = index[i];
          validateIndex(indexI, data.length);
          data = data[indexI];
        }
        indexI = index[index.length - 1];
        validateIndex(indexI, data.length);
        data[indexI] = value;
        return this;
      }
      /**
       * Resize the matrix to the given size. Returns a copy of the matrix when
       * `copy=true`, otherwise return the matrix itself (resize in place).
       *
       * @memberof DenseMatrix
       * @param {number[] | Matrix} size The new size the matrix should have.
       * @param {MatrixValue} [defaultValue=0]      Default value, filled in on new entries.
       *                                  If not provided, the matrix elements will
       *                                  be filled with zeros.
       * @param {boolean} [copy]          Return a resized copy of the matrix
       *
       * @return {DenseMatrix | MatrixValue}                 The resized matrix or scalar
       */
      resize(size, defaultValue, copy) {
        if (!isCollection(size)) {
          throw new TypeError("Array or Matrix expected");
        }
        const sizeArray = size.valueOf().map((value) => {
          return Array.isArray(value) && value.length === 1 ? value[0] : value;
        });
        const m = copy ? this.clone() : this;
        return _resize2(m, sizeArray, defaultValue);
      }
      /**
       * Reshape the matrix to the given size. Returns a copy of the matrix when
       * `copy=true`, otherwise return the matrix itself (reshape in place).
       *
       * NOTE: This might be better suited to copy by default, instead of modifying
       *       in place. For now, it operates in place to remain consistent with
       *       resize().
       *
       * @memberof DenseMatrix
       * @param {number[]} size           The new size the matrix should have.
       * @param {boolean} [copy]          Return a reshaped copy of the matrix
       *
       * @return {Matrix}                 The reshaped matrix
       */
      reshape(size, copy) {
        const m = copy ? this.clone() : this;
        m._data = reshape(m._data, size);
        const currentLength = m._size.reduce((length, size2) => length * size2);
        m._size = processSizesWildcard(size, currentLength);
        return m;
      }
      /**
       * Create a clone of the matrix
       * @memberof DenseMatrix
       * @return {DenseMatrix} clone
       */
      clone() {
        const m = new DenseMatrix({
          data: clone(this._data),
          size: clone(this._size),
          datatype: this._datatype
        });
        return m;
      }
      /**
       * Retrieve the size of the matrix.
       * @memberof DenseMatrix
       * @returns {number[]} size
       */
      size() {
        return this._size.slice(0);
      }
      /**
       * Create a new matrix with the results of the callback function executed on
       * each entry of the matrix.
       * @memberof DenseMatrix
       * @param {Function} callback   The callback function is invoked with three
       *                              parameters: the value of the element, the index
       *                              of the element, and the Matrix being traversed.
       * @param {boolean} skipZeros   If true, the callback function is invoked only for non-zero entries
       * @param {boolean} isUnary     If true, the callback function is invoked with one parameter
       *
       * @return {DenseMatrix} matrix
       */
      map(callback, _skipZeros = false, isUnary = false) {
        const me = this;
        const maxDepth = me._size.length - 1;
        if (maxDepth < 0) return me.clone();
        const fastCallback = optimizeCallback(
          callback,
          me,
          "map",
          isUnary
        );
        const fastCallbackFn = fastCallback.fn;
        const result = me.create(void 0, me._datatype);
        result._size = me._size;
        if (isUnary || fastCallback.isUnary) {
          result._data = iterateUnary(me._data);
          return result;
        }
        if (maxDepth === 0) {
          const inputData = me.valueOf();
          const data = Array(inputData.length);
          for (let i = 0; i < inputData.length; i++) {
            data[i] = fastCallbackFn(inputData[i], [i], me);
          }
          result._data = data;
          return result;
        }
        const index = [];
        result._data = iterate(me._data);
        return result;
        function iterate(data, depth = 0) {
          const result2 = Array(data.length);
          if (depth < maxDepth) {
            for (let i = 0; i < data.length; i++) {
              index[depth] = i;
              result2[i] = iterate(data[i], depth + 1);
            }
          } else {
            for (let i = 0; i < data.length; i++) {
              index[depth] = i;
              result2[i] = fastCallbackFn(data[i], index.slice(), me);
            }
          }
          return result2;
        }
        function iterateUnary(data, depth = 0) {
          const result2 = Array(data.length);
          if (depth < maxDepth) {
            for (let i = 0; i < data.length; i++) {
              result2[i] = iterateUnary(data[i], depth + 1);
            }
          } else {
            for (let i = 0; i < data.length; i++) {
              result2[i] = fastCallbackFn(data[i]);
            }
          }
          return result2;
        }
      }
      /**
       * Execute a callback function on each entry of the matrix.
       * @memberof DenseMatrix
       * @param {Function} callback   The callback function is invoked with three
       *                              parameters: the value of the element, the index
       *                              of the element, and the Matrix being traversed.
       * @param {boolean} skipZeros   If true, the callback function is invoked only for non-zero entries
       * @param {boolean} isUnary     If true, the callback function is invoked with one parameter
       */
      forEach(callback, _skipZeros = false, isUnary = false) {
        const me = this;
        const maxDepth = me._size.length - 1;
        if (maxDepth < 0) return;
        const fastCallback = optimizeCallback(
          callback,
          me,
          "map",
          isUnary
        );
        const fastCallbackFn = fastCallback.fn;
        if (isUnary || fastCallback.isUnary) {
          iterateUnary(me._data);
          return;
        }
        if (maxDepth === 0) {
          for (let i = 0; i < me._data.length; i++) {
            fastCallbackFn(me._data[i], [i], me);
          }
          return;
        }
        const index = [];
        iterate(me._data);
        function iterate(data, depth = 0) {
          if (depth < maxDepth) {
            for (let i = 0; i < data.length; i++) {
              index[depth] = i;
              iterate(data[i], depth + 1);
            }
          } else {
            for (let i = 0; i < data.length; i++) {
              index[depth] = i;
              fastCallbackFn(data[i], index.slice(), me);
            }
          }
        }
        function iterateUnary(data, depth = 0) {
          if (depth < maxDepth) {
            for (let i = 0; i < data.length; i++) {
              iterateUnary(data[i], depth + 1);
            }
          } else {
            for (let i = 0; i < data.length; i++) {
              fastCallbackFn(data[i]);
            }
          }
        }
      }
      /**
       * Iterate over the matrix elements
       * @return {Iterable<{ value, index: number[] }>}
       */
      *[Symbol.iterator]() {
        const maxDepth = this._size.length - 1;
        if (maxDepth < 0) {
          return;
        }
        if (maxDepth === 0) {
          for (let i = 0; i < this._data.length; i++) {
            yield { value: this._data[i], index: [i] };
          }
          return;
        }
        const index = [];
        const recurse = function* (value, depth) {
          if (depth < maxDepth) {
            for (let i = 0; i < value.length; i++) {
              index[depth] = i;
              yield* recurse(value[i], depth + 1);
            }
          } else {
            for (let i = 0; i < value.length; i++) {
              index[depth] = i;
              yield { value: value[i], index: index.slice() };
            }
          }
        };
        yield* recurse(this._data, 0);
      }
      /**
       * Returns an array containing the rows of a 2D matrix
       * @returns {Array<Matrix>}
       */
      rows() {
        const result = [];
        const s = this.size();
        if (s.length !== 2) {
          throw new TypeError("Rows can only be returned for a 2D matrix.");
        }
        const data = this._data;
        for (const row of data) {
          result.push(new DenseMatrix([row], this._datatype));
        }
        return result;
      }
      /**
       * Returns an array containing the columns of a 2D matrix
       * @returns {Array<Matrix>}
       */
      columns() {
        const result = [];
        const s = this.size();
        if (s.length !== 2) {
          throw new TypeError("Rows can only be returned for a 2D matrix.");
        }
        const data = this._data;
        for (let i = 0; i < s[1]; i++) {
          const col = data.map((row) => [row[i]]);
          result.push(new DenseMatrix(col, this._datatype));
        }
        return result;
      }
      /**
       * Create an Array with a copy of the data of the DenseMatrix
       * @memberof DenseMatrix
       * @returns {DenseMatrixData} array
       */
      toArray() {
        return clone(this._data);
      }
      /**
       * Get the primitive value of the DenseMatrix: a multidimensional array
       * @memberof DenseMatrix
       * @returns {DenseMatrixData} array
       */
      valueOf() {
        return this._data;
      }
      /**
       * Get a string representation of the matrix, with optional formatting options.
       * @memberof DenseMatrix
       * @param {MatrixFormatOptions | number | Function} [options]  Formatting options. See
       *                                                lib/utils/number:format for a
       *                                                description of the available
       *                                                options.
       * @returns {string} str
       */
      format(options) {
        return format3(this._data, options);
      }
      /**
       * Get a string representation of the matrix
       * @memberof DenseMatrix
       * @returns {string} str
       */
      toString() {
        return format3(this._data, {});
      }
      /**
       * Get a JSON representation of the matrix
       * @memberof DenseMatrix
       * @returns {DenseMatrixJSON}
       */
      toJSON() {
        return {
          mathjs: "DenseMatrix",
          data: this._data,
          size: this._size,
          datatype: this._datatype
        };
      }
      /**
       * Get the kth Matrix diagonal.
       *
       * @memberof DenseMatrix
       * @param {number | BigNumberLike} [k=0]     The kth diagonal where the vector will retrieved.
       *
       * @returns {DenseMatrix}                     The matrix with the diagonal values.
       */
      diagonal(k) {
        if (k) {
          if (isBigNumber(k)) {
            k = k.toNumber();
          }
          if (!isNumber(k) || !isInteger(k)) {
            throw new TypeError("The parameter k must be an integer number");
          }
        } else {
          k = 0;
        }
        const kSuper = k > 0 ? k : 0;
        const kSub = k < 0 ? -k : 0;
        const rows = this._size[0];
        const columns = this._size[1];
        const n = Math.min(rows - kSub, columns - kSuper);
        const data = [];
        for (let i = 0; i < n; i++) {
          data[i] = this._data[i + kSub][i + kSuper];
        }
        return new DenseMatrix({
          data,
          size: [n],
          datatype: this._datatype
        });
      }
      /**
       * Swap rows i and j in Matrix.
       *
       * @memberof DenseMatrix
       * @param {number} i       Matrix row index 1
       * @param {number} j       Matrix row index 2
       *
       * @return {Matrix}        The matrix reference
       */
      swapRows(i, j) {
        if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
          throw new Error("Row index must be positive integers");
        }
        if (this._size.length !== 2) {
          throw new Error("Only two dimensional matrix is supported");
        }
        validateIndex(i, this._size[0]);
        validateIndex(j, this._size[0]);
        DenseMatrix._swapRows(i, j, this._data);
        return this;
      }
      /**
       * Create a diagonal matrix.
       *
       * @memberof DenseMatrix
       * @param {Array} size                     The matrix size.
       * @param {number | Matrix | Array } value The values for the diagonal.
       * @param {number | BigNumberLike} [k=0]       The kth diagonal where the vector will be filled in.
       * @param {MatrixValue} [defaultValue]          The default value for non-diagonal
       *
       * @returns {DenseMatrix}
       */
      static diagonal(size, value, k, defaultValue) {
        if (!isArray(size)) {
          throw new TypeError("Array expected, size parameter");
        }
        if (size.length !== 2) {
          throw new Error("Only two dimensions matrix are supported");
        }
        const mappedSize = size.map(function(s) {
          if (isBigNumber(s)) {
            s = s.toNumber();
          }
          if (!isNumber(s) || !isInteger(s) || s < 1) {
            throw new Error("Size values must be positive integers");
          }
          return s;
        });
        if (k) {
          if (isBigNumber(k)) {
            k = k.toNumber();
          }
          if (!isNumber(k) || !isInteger(k)) {
            throw new TypeError("The parameter k must be an integer number");
          }
        } else {
          k = 0;
        }
        const kSuper = k > 0 ? k : 0;
        const kSub = k < 0 ? -k : 0;
        const rows = mappedSize[0];
        const columns = mappedSize[1];
        const n = Math.min(rows - kSub, columns - kSuper);
        let _value;
        if (isArray(value)) {
          if (value.length !== n) {
            throw new Error("Invalid value array length");
          }
          _value = function(i) {
            return value[i];
          };
        } else if (isMatrix(value)) {
          const ms = value.size();
          if (ms.length !== 1 || ms[0] !== n) {
            throw new Error("Invalid matrix length");
          }
          _value = function(i) {
            return value.get([i]);
          };
        } else {
          _value = function() {
            return value;
          };
        }
        if (!defaultValue) {
          defaultValue = isBigNumber(_value(0)) ? _value(0).mul(0) : 0;
        }
        let data = [];
        if (mappedSize.length > 0) {
          data = resize(data, mappedSize, defaultValue);
          for (let d = 0; d < n; d++) {
            data[d + kSub][d + kSuper] = _value(d);
          }
        }
        return new DenseMatrix({
          data,
          size: [rows, columns]
        });
      }
      /**
       * Generate a matrix from a JSON object
       * @memberof DenseMatrix
       * @param {Object} json  An object structured like
       *                       `{"mathjs": "DenseMatrix", data: [], size: []}`,
       *                       where mathjs is optional
       * @returns {DenseMatrix}
       */
      static fromJSON(json) {
        return new DenseMatrix(json);
      }
      /**
       * Swap rows i and j in Dense Matrix data structure.
       *
       * @param {number} i       Matrix row index 1
       * @param {number} j       Matrix row index 2
       * @param {Array} data     Matrix data
       */
      static _swapRows(i, j, data) {
        const vi = data[i];
        data[i] = data[j];
        data[j] = vi;
      }
    }
    const MatrixPrototype = Matrix2.prototype || Matrix2;
    Object.setPrototypeOf(DenseMatrix.prototype, MatrixPrototype);
    Object.defineProperty(DenseMatrix, "name", { value: "DenseMatrix" });
    Object.defineProperty(DenseMatrix.prototype, "constructor", {
      value: DenseMatrix,
      writable: true,
      configurable: true
    });
    function _get(matrix, index) {
      if (!isIndex(index)) {
        throw new TypeError("Invalid index");
      }
      const isScalar = config.legacySubset ? index.size().every((idx) => idx === 1) : index.isScalar();
      if (isScalar) {
        return matrix.get(index.min());
      } else {
        const size = index.size();
        if (size.length !== matrix._size.length) {
          throw new DimensionError(size.length, matrix._size.length);
        }
        const min = index.min();
        const max = index.max();
        for (let i = 0, ii = matrix._size.length; i < ii; i++) {
          validateIndex(min[i], matrix._size[i]);
          validateIndex(max[i], matrix._size[i]);
        }
        const returnMatrix = new DenseMatrix();
        const submatrix = _getSubmatrix(matrix._data, index);
        returnMatrix._size = submatrix.size;
        returnMatrix._datatype = matrix._datatype;
        returnMatrix._data = submatrix.data;
        return config.legacySubset ? returnMatrix.reshape(index.size()) : returnMatrix;
      }
    }
    function _getSubmatrix(data, index) {
      const maxDepth = index.size().length - 1;
      const size = Array(maxDepth);
      return {
        data: getSubmatrixRecursive(data),
        size: size.filter((x) => x !== null)
      };
      function getSubmatrixRecursive(data2, depth = 0) {
        const dims = index.dimension(depth);
        function _mapIndex(dim, callback) {
          if (isNumber(dim)) return callback(dim);
          else return dim.map(callback).valueOf();
        }
        if (isNumber(dims)) {
          size[depth] = null;
        } else {
          size[depth] = dims.size()[0];
        }
        if (depth < maxDepth) {
          return _mapIndex(dims, (dimIndex) => {
            validateIndex(dimIndex, data2.length);
            return getSubmatrixRecursive(data2[dimIndex], depth + 1);
          });
        } else {
          return _mapIndex(dims, (dimIndex) => {
            validateIndex(dimIndex, data2.length);
            return data2[dimIndex];
          });
        }
      }
    }
    function _set(matrix, index, submatrix, defaultValue) {
      if (!index || index.isIndex !== true) {
        throw new TypeError("Invalid index");
      }
      const iSize = index.size();
      const isScalar = index.isScalar();
      let sSize;
      if (isMatrix(submatrix)) {
        sSize = submatrix.size();
        submatrix = submatrix.valueOf();
      } else {
        sSize = arraySize(submatrix);
      }
      if (isScalar) {
        if (sSize.length !== 0) {
          throw new TypeError("Scalar expected");
        }
        matrix.set(index.min(), submatrix, defaultValue);
      } else {
        if (!deepStrictEqual(sSize, iSize)) {
          try {
            if (sSize.length === 0) {
              submatrix = broadcastTo([submatrix], iSize);
            } else {
              submatrix = broadcastTo(submatrix, iSize);
            }
            sSize = arraySize(submatrix);
          } catch {
          }
        }
        if (iSize.length < matrix._size.length) {
          throw new DimensionError(iSize.length, matrix._size.length, "<");
        }
        if (sSize.length < iSize.length) {
          let i = 0;
          let outer = 0;
          while (iSize[i] === 1 && sSize[i] === 1) {
            i++;
          }
          while (iSize[i] === 1) {
            outer++;
            i++;
          }
          submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
        }
        if (!deepStrictEqual(iSize, sSize)) {
          throw new DimensionError(iSize, sSize, ">");
        }
        const size = index.max().map(function(i) {
          return i + 1;
        });
        _fit(matrix, size, defaultValue);
        _setSubmatrix(matrix._data, index, submatrix);
      }
      return matrix;
    }
    function _setSubmatrix(data, index, submatrix) {
      const maxDepth = index.size().length - 1;
      setSubmatrixRecursive(data, submatrix);
      function setSubmatrixRecursive(data2, submatrix2, depth = 0) {
        const range = index.dimension(depth);
        const recursiveCallback = (rangeIndex, i) => {
          validateIndex(rangeIndex, data2.length);
          setSubmatrixRecursive(data2[rangeIndex], submatrix2[i[0]], depth + 1);
        };
        const finalCallback = (rangeIndex, i) => {
          validateIndex(rangeIndex, data2.length);
          data2[rangeIndex] = submatrix2[i[0]];
        };
        if (depth < maxDepth) {
          if (isNumber(range)) recursiveCallback(range, [0]);
          else range.forEach(recursiveCallback);
        } else {
          if (isNumber(range)) finalCallback(range, [0]);
          else range.forEach(finalCallback);
        }
      }
    }
    function _resize2(matrix, size, defaultValue) {
      if (size.length === 0) {
        let v = matrix._data;
        while (isArray(v)) {
          v = v[0];
        }
        return v;
      }
      matrix._size = size.slice(0);
      matrix._data = resize(matrix._data, matrix._size, defaultValue);
      return matrix;
    }
    function _fit(matrix, size, defaultValue) {
      const newSize = matrix._size.slice(0);
      let changed = false;
      while (newSize.length < size.length) {
        newSize.push(0);
        changed = true;
      }
      for (let i = 0, ii = size.length; i < ii; i++) {
        if (size[i] > newSize[i]) {
          newSize[i] = size[i];
          changed = true;
        }
      }
      if (changed) {
        _resize2(matrix, newSize, defaultValue);
      }
    }
    function preprocess(data) {
      if (isMatrix(data)) {
        return preprocess(data.valueOf());
      }
      if (isArray(data)) {
        return data.map(preprocess);
      }
      return data;
    }
    return DenseMatrix;
  },
  { isClass: true }
);

// src/function/utils/clone.ts
var name8 = "clone";
var dependencies9 = ["typed"];
var createClone = /* @__PURE__ */ factory(
  name8,
  dependencies9,
  ({ typed: typed2 }) => {
    return typed2(name8, {
      any: clone
    });
  }
);

// src/utils/switch.ts
function _switch(mat) {
  const I = mat.length;
  const J = mat[0].length;
  let i, j;
  const ret = [];
  for (j = 0; j < J; j++) {
    const tmp = [];
    for (i = 0; i < I; i++) {
      tmp.push(mat[i][j]);
    }
    ret.push(tmp);
  }
  return ret;
}

// src/utils/collection.ts
function containsCollections(array) {
  for (let i = 0; i < array.length; i++) {
    if (isCollection(array[i])) {
      return true;
    }
  }
  return false;
}
function deepForEach2(array, callback) {
  if (isMatrix(array)) {
    array.forEach((x) => callback(x), false, true);
  } else {
    deepForEach(array, callback, true);
  }
}
function deepMap2(array, callback, skipZeros) {
  if (!skipZeros) {
    if (isMatrix(array)) {
      return array.map((x) => callback(x), false, true);
    } else {
      return deepMap(array, callback, true);
    }
  }
  const skipZerosCallback = (x) => x === 0 ? x : callback(x);
  if (isMatrix(array)) {
    return array.map((x) => skipZerosCallback(x), false, true);
  } else {
    return deepMap(array, skipZerosCallback, true);
  }
}
function reduce(mat, dim, callback) {
  const size = Array.isArray(mat) ? arraySize(mat) : mat.size();
  if (dim < 0 || dim >= size.length) {
    throw new IndexError(dim, 0, size.length);
  }
  if (isMatrix(mat)) {
    const reduced = _reduce(mat.valueOf(), dim, callback);
    return mat.create(
      reduced,
      mat.datatype()
    );
  } else {
    return _reduce(mat, dim, callback);
  }
}
function _reduce(mat, dim, callback) {
  let i;
  let ret;
  let val;
  let tran;
  if (dim <= 0) {
    if (!Array.isArray(mat[0])) {
      val = mat[0];
      for (i = 1; i < mat.length; i++) {
        val = callback(val, mat[i]);
      }
      return val;
    } else {
      tran = _switch(mat);
      ret = [];
      for (i = 0; i < tran.length; i++) {
        ret[i] = _reduce(tran[i], dim - 1, callback);
      }
      return ret;
    }
  } else {
    ret = [];
    for (i = 0; i < mat.length; i++) {
      ret[i] = _reduce(mat[i], dim - 1, callback);
    }
    return ret;
  }
}
function scatter(a, j, w, x, u, mark, cindex, f, inverse, update, value) {
  const avalues = a._values;
  const aindex = a._index;
  const aptr = a._ptr;
  let k;
  let k0;
  let k1;
  let i;
  if (x) {
    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
      i = aindex[k];
      if (w[i] !== mark) {
        w[i] = mark;
        cindex.push(i);
        {
          x[i] = avalues[k];
        }
      } else {
        if (f) {
          x[i] = f(x[i], avalues[k]);
        }
        u[i] = mark;
      }
    }
  } else {
    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
      i = aindex[k];
      if (w[i] !== mark) {
        w[i] = mark;
        cindex.push(i);
      } else {
        u[i] = mark;
      }
    }
  }
}

// src/function/utils/isInteger.ts
var name9 = "isInteger";
var dependencies10 = ["typed", "equal"];
var createIsInteger = /* @__PURE__ */ factory(
  name9,
  dependencies10,
  ({ typed: typed2, equal }) => {
    return typed2(name9, {
      number: (n) => Number.isFinite(n) ? equal(n, Math.round(n)) : false,
      BigNumber: (b) => b.isFinite() ? equal(b.round(), b) : false,
      bigint: (_b) => true,
      Fraction: (r) => r.d === 1n,
      "Array | Matrix": typed2.referToSelf(
        (self) => (x) => deepMap2(x, self)
      )
    });
  }
);

// src/plain/number/arithmetic.ts
var n1 = "number";
var n2 = "number, number";
function absNumber(a) {
  return Math.abs(a);
}
absNumber.signature = n1;
function addNumber(a, b) {
  return a + b;
}
addNumber.signature = n2;
function subtractNumber(a, b) {
  return a - b;
}
subtractNumber.signature = n2;
function multiplyNumber(a, b) {
  return a * b;
}
multiplyNumber.signature = n2;
function unaryMinusNumber(x) {
  return -x;
}
unaryMinusNumber.signature = n1;
function unaryPlusNumber(x) {
  return x;
}
unaryPlusNumber.signature = n1;
function cbrtNumber(x) {
  return cbrt(x);
}
cbrtNumber.signature = n1;
function cubeNumber(x) {
  return x * x * x;
}
cubeNumber.signature = n1;
function expNumber(x) {
  return Math.exp(x);
}
expNumber.signature = n1;
function expm1Number(x) {
  return expm1(x);
}
expm1Number.signature = n1;
function lcmNumber(a, b) {
  if (!isInteger(a) || !isInteger(b)) {
    throw new Error("Parameters in function lcm must be integer numbers");
  }
  if (a === 0 || b === 0) {
    return 0;
  }
  let t;
  const prod = a * b;
  while (b !== 0) {
    t = b;
    b = a % t;
    a = t;
  }
  return Math.abs(prod / a);
}
lcmNumber.signature = n2;
function logNumber(x, y) {
  if (y) {
    return Math.log(x) / Math.log(y);
  }
  return Math.log(x);
}
function log10Number(x) {
  return log10(x);
}
log10Number.signature = n1;
function log2Number(x) {
  return log2(x);
}
log2Number.signature = n1;
function nthRootNumber(a, root = 2) {
  const inv = root < 0;
  if (inv) {
    root = -root;
  }
  if (root === 0) {
    throw new Error("Root must be non-zero");
  }
  if (a < 0 && Math.abs(root) % 2 !== 1) {
    throw new Error("Root must be odd when a is negative.");
  }
  if (a === 0) {
    return inv ? Infinity : 0;
  }
  if (!isFinite(a)) {
    return inv ? 0 : a;
  }
  let x = Math.pow(Math.abs(a), 1 / root);
  x = a < 0 ? -x : x;
  return inv ? 1 / x : x;
}
function signNumber(x) {
  return sign(x);
}
signNumber.signature = n1;
function squareNumber(x) {
  return x * x;
}
squareNumber.signature = n1;
function xgcdNumber(a, b) {
  let t;
  let q;
  let r;
  let x = 0;
  let lastx = 1;
  let y = 1;
  let lasty = 0;
  if (!isInteger(a) || !isInteger(b)) {
    throw new Error("Parameters in function xgcd must be integer numbers");
  }
  while (b) {
    q = Math.floor(a / b);
    r = a - q * b;
    t = x;
    x = lastx - q * x;
    lastx = t;
    t = y;
    y = lasty - q * y;
    lasty = t;
    a = b;
    b = r;
  }
  let res;
  if (a < 0) {
    res = [-a, -lastx, -lasty];
  } else {
    res = [a, a ? lastx : 0, lasty];
  }
  return res;
}
xgcdNumber.signature = n2;
function powNumber(x, y) {
  if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
    return 0;
  }
  return Math.pow(x, y);
}
powNumber.signature = n2;
function roundNumber(value, decimals = 0) {
  if (!isInteger(decimals) || decimals < 0 || decimals > 15) {
    throw new Error(
      "Number of decimals in function round must be an integer from 0 to 15 inclusive"
    );
  }
  return parseFloat(toFixed(value, decimals));
}

// src/plain/number/bitwise.ts
var n12 = "number";
var n22 = "number, number";
function bitAndNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function bitAnd");
  }
  return x & y;
}
bitAndNumber.signature = n22;
function bitNotNumber(x) {
  if (!isInteger(x)) {
    throw new Error("Integer expected in function bitNot");
  }
  return ~x;
}
bitNotNumber.signature = n12;
function bitOrNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function bitOr");
  }
  return x | y;
}
bitOrNumber.signature = n22;
function bitXorNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function bitXor");
  }
  return x ^ y;
}
bitXorNumber.signature = n22;
function leftShiftNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function leftShift");
  }
  return x << y;
}
leftShiftNumber.signature = n22;
function rightArithShiftNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function rightArithShift");
  }
  return x >> y;
}
rightArithShiftNumber.signature = n22;
function rightLogShiftNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function rightLogShift");
  }
  return x >>> y;
}
rightLogShiftNumber.signature = n22;

// src/utils/product.ts
function product2(i, n) {
  if (n < i) {
    return 1;
  }
  if (n === i) {
    return n;
  }
  const half = n + i >> 1;
  return product2(i, half) * product2(half + 1, n);
}

// src/plain/number/combinations.ts
function combinationsNumber(n, k) {
  if (!isInteger(n) || n < 0) {
    throw new TypeError(
      "Positive integer value expected in function combinations"
    );
  }
  if (!isInteger(k) || k < 0) {
    throw new TypeError(
      "Positive integer value expected in function combinations"
    );
  }
  if (k > n) {
    throw new TypeError("k must be less than or equal to n");
  }
  const nMinusk = n - k;
  let answer = 1;
  const firstnumerator = k < nMinusk ? nMinusk + 1 : k + 1;
  let nextdivisor = 2;
  const lastdivisor = k < nMinusk ? k : nMinusk;
  for (let nextnumerator = firstnumerator; nextnumerator <= n; ++nextnumerator) {
    answer *= nextnumerator;
    while (nextdivisor <= lastdivisor && answer % nextdivisor === 0) {
      answer /= nextdivisor;
      ++nextdivisor;
    }
  }
  if (nextdivisor <= lastdivisor) {
    answer /= product2(nextdivisor, lastdivisor);
  }
  return answer;
}
combinationsNumber.signature = "number, number";

// src/plain/number/constants.ts
var pi = Math.PI;
var tau = 2 * Math.PI;
var e = Math.E;
var phi = 1.618033988749895;

// src/plain/number/logical.ts
var n13 = "number";
var n23 = "number, number";
function notNumber(x) {
  return !x;
}
notNumber.signature = n13;
function orNumber(x, y) {
  return !!(x || y);
}
orNumber.signature = n23;
function xorNumber(x, y) {
  return !!x !== !!y;
}
xorNumber.signature = n23;
function andNumber(x, y) {
  return !!(x && y);
}
andNumber.signature = n23;

// src/plain/number/probability.ts
function gammaNumber(n) {
  let x;
  if (isInteger(n)) {
    if (n <= 0) {
      return Number.isFinite(n) ? Infinity : NaN;
    }
    if (n > 171) {
      return Infinity;
    }
    return product2(1, n - 1);
  }
  if (n < 0.5) {
    return Math.PI / (Math.sin(Math.PI * n) * gammaNumber(1 - n));
  }
  if (n >= 171.35) {
    return Infinity;
  }
  if (n > 85) {
    const twoN = n * n;
    const threeN = twoN * n;
    const fourN = threeN * n;
    const fiveN = fourN * n;
    return Math.sqrt(2 * Math.PI / n) * Math.pow(n / Math.E, n) * (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) - 571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) + 5246819 / (75246796800 * fiveN * n));
  }
  --n;
  x = gammaP[0];
  for (let i = 1; i < gammaP.length; ++i) {
    x += gammaP[i] / (n + i);
  }
  const t = n + gammaG + 0.5;
  return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
}
gammaNumber.signature = "number";
var gammaG = 4.7421875;
var gammaP = [
  0.9999999999999971,
  57.15623566586292,
  -59.59796035547549,
  14.136097974741746,
  -0.4919138160976202,
  3399464998481189e-20,
  4652362892704858e-20,
  -9837447530487956e-20,
  1580887032249125e-19,
  -21026444172410488e-20,
  21743961811521265e-20,
  -1643181065367639e-19,
  8441822398385275e-20,
  -26190838401581408e-21,
  36899182659531625e-22
];
var lnSqrt2PI = 0.9189385332046728;
var lgammaG = 5;
var lgammaN = 7;
var lgammaSeries = [
  1.000000000190015,
  76.18009172947146,
  -86.50532032941678,
  24.01409824083091,
  -1.231739572450155,
  0.001208650973866179,
  -5395239384953e-18
];
function lgammaNumber(n) {
  if (n < 0) return NaN;
  if (n === 0) return Infinity;
  if (!Number.isFinite(n)) return n;
  if (n < 0.5) {
    return Math.log(Math.PI / Math.sin(Math.PI * n)) - lgammaNumber(1 - n);
  }
  n = n - 1;
  const base = n + lgammaG + 0.5;
  let sum = lgammaSeries[0];
  for (let i = lgammaN - 1; i >= 1; i--) {
    sum += lgammaSeries[i] / (n + i);
  }
  return lnSqrt2PI + (n + 0.5) * Math.log(base) - base + Math.log(sum);
}
lgammaNumber.signature = "number";

// src/plain/number/trigonometry.ts
var n14 = "number";
function acoshNumber(x) {
  return acosh(x);
}
acoshNumber.signature = n14;
function acotNumber(x) {
  return Math.atan(1 / x);
}
acotNumber.signature = n14;
function acothNumber(x) {
  return Number.isFinite(x) ? (Math.log((x + 1) / x) + Math.log(x / (x - 1))) / 2 : 0;
}
acothNumber.signature = n14;
function acscNumber(x) {
  return Math.asin(1 / x);
}
acscNumber.signature = n14;
function acschNumber(x) {
  const xInv = 1 / x;
  return Math.log(xInv + Math.sqrt(xInv * xInv + 1));
}
acschNumber.signature = n14;
function asecNumber(x) {
  return Math.acos(1 / x);
}
asecNumber.signature = n14;
function asechNumber(x) {
  const xInv = 1 / x;
  const ret = Math.sqrt(xInv * xInv - 1);
  return Math.log(ret + xInv);
}
asechNumber.signature = n14;
function asinhNumber(x) {
  return asinh(x);
}
asinhNumber.signature = n14;
function atanhNumber(x) {
  return atanh(x);
}
atanhNumber.signature = n14;
function cotNumber(x) {
  return 1 / Math.tan(x);
}
cotNumber.signature = n14;
function cothNumber(x) {
  const e2 = Math.exp(2 * x);
  return (e2 + 1) / (e2 - 1);
}
cothNumber.signature = n14;
function cscNumber(x) {
  return 1 / Math.sin(x);
}
cscNumber.signature = n14;
function cschNumber(x) {
  if (x === 0) {
    return Number.POSITIVE_INFINITY;
  } else {
    return Math.abs(2 / (Math.exp(x) - Math.exp(-x))) * sign(x);
  }
}
cschNumber.signature = n14;
function secNumber(x) {
  return 1 / Math.cos(x);
}
secNumber.signature = n14;
function sechNumber(x) {
  return 2 / (Math.exp(x) + Math.exp(-x));
}
sechNumber.signature = n14;
function sinhNumber(x) {
  return sinh(x);
}
sinhNumber.signature = n14;

// src/plain/number/utils.ts
var n15 = "number";
function isNegativeNumber(x) {
  return x < 0;
}
isNegativeNumber.signature = n15;
function isPositiveNumber(x) {
  return x > 0;
}
isPositiveNumber.signature = n15;
function isNaNNumber(x) {
  return Number.isNaN(x);
}
isNaNNumber.signature = n15;

// src/utils/bignumber/nearlyEqual.ts
function nearlyEqual2(a, b, relTol = 1e-9, absTol = 0) {
  if (relTol <= 0) {
    throw new Error("Relative tolerance must be greater than 0");
  }
  if (absTol < 0) {
    throw new Error("Absolute tolerance must be at least 0");
  }
  if (a.isNaN() || b.isNaN()) {
    return false;
  }
  if (!a.isFinite() || !b.isFinite()) {
    return a.eq(b);
  }
  if (a.eq(b)) {
    return true;
  }
  return a.minus(b).abs().lte(
    a.constructor.max(a.constructor.max(a.abs(), b.abs()).mul(relTol), absTol)
  );
}

// src/function/utils/isNegative.ts
var name10 = "isNegative";
var dependencies11 = ["typed", "config"];
var createIsNegative = /* @__PURE__ */ factory(
  name10,
  dependencies11,
  ({ typed: typed2, config }) => {
    return typed2(name10, {
      number: (x) => nearlyEqual(x, 0, config.relTol, config.absTol) ? false : isNegativeNumber(x),
      BigNumber: (x) => nearlyEqual2(x, new x.constructor(0), config.relTol, config.absTol) ? false : x.isNeg() && !x.isZero() && !x.isNaN(),
      bigint: (x) => x < 0n,
      Fraction: (x) => x.s < 0n,
      // It's enough to decide on the sign
      Unit: typed2.referToSelf(
        (self) => (x) => typed2.find(self, x.valueType())(x.value)
      ),
      "Array | Matrix": typed2.referToSelf(
        (self) => (x) => deepMap2(x, self)
      )
    });
  }
);

// src/function/utils/isNumeric.ts
var name11 = "isNumeric";
var dependencies12 = ["typed"];
var createIsNumeric = /* @__PURE__ */ factory(
  name11,
  dependencies12,
  ({ typed: typed2 }) => {
    return typed2(name11, {
      "number | BigNumber | bigint | Fraction | boolean": () => true,
      "Complex | Unit | string | null | undefined | Node": () => false,
      "Array | Matrix": typed2.referToSelf(
        (self) => (x) => deepMap2(x, self)
      )
    });
  }
);

// src/function/utils/hasNumericValue.ts
var name12 = "hasNumericValue";
var dependencies13 = ["typed", "isNumeric"];
var createHasNumericValue = /* @__PURE__ */ factory(
  name12,
  dependencies13,
  ({ typed: typed2, isNumeric }) => {
    return typed2(name12, {
      boolean: () => true,
      string: function(x) {
        return x.trim().length > 0 && !isNaN(Number(x));
      },
      any: function(x) {
        return isNumeric(x);
      }
    });
  }
);

// src/function/utils/isPositive.ts
var name13 = "isPositive";
var dependencies14 = ["typed", "config"];
var createIsPositive = /* @__PURE__ */ factory(
  name13,
  dependencies14,
  ({ typed: typed2, config }) => {
    return typed2(name13, {
      number: (x) => nearlyEqual(x, 0, config.relTol, config.absTol) ? false : isPositiveNumber(x),
      BigNumber: (x) => nearlyEqual2(x, new x.constructor(0), config.relTol, config.absTol) ? false : !x.isNeg() && !x.isZero() && !x.isNaN(),
      bigint: (x) => x > 0n,
      Fraction: (x) => x.s > 0n && x.n > 0n,
      Unit: typed2.referToSelf(
        (self) => (x) => typed2.find(self, x.valueType())(x.value)
      ),
      "Array | Matrix": typed2.referToSelf(
        (self) => (x) => deepMap2(x, self)
      )
    });
  }
);

// src/function/utils/isZero.ts
var name14 = "isZero";
var dependencies15 = ["typed", "equalScalar"];
var createIsZero = /* @__PURE__ */ factory(
  name14,
  dependencies15,
  ({ typed: typed2, equalScalar }) => {
    return typed2(name14, {
      "number | BigNumber | Complex | Fraction": (x) => equalScalar(x, 0),
      bigint: (x) => x === 0n,
      Unit: typed2.referToSelf(
        (self) => (x) => typed2.find(self, x.valueType())(x.value)
      ),
      "Array | Matrix": typed2.referToSelf(
        (self) => (x) => deepMap2(x, self)
      )
    });
  }
);

// src/function/utils/isNaN.ts
var name15 = "isNaN";
var dependencies16 = ["typed"];
var createIsNaN = /* @__PURE__ */ factory(
  name15,
  dependencies16,
  ({ typed: typed2 }) => {
    return typed2(name15, {
      number: isNaNNumber,
      BigNumber: function(x) {
        return x.isNaN();
      },
      bigint: function(_x) {
        return false;
      },
      Fraction: function(_x) {
        return false;
      },
      Complex: function(x) {
        return x.isNaN();
      },
      Unit: function(x) {
        return Number.isNaN(x.value);
      },
      "Array | Matrix": typed2.referToSelf(
        (self) => (x) => deepMap2(x, self)
      )
    });
  }
);

// src/function/utils/isBounded.ts
var name16 = "isBounded";
var dependencies17 = ["typed"];
var createIsBounded = /* @__PURE__ */ factory(
  name16,
  dependencies17,
  ({ typed: typed2 }) => {
    return typed2(name16, {
      number: (n) => Number.isFinite(n),
      "BigNumber | Complex": (x) => x.isFinite(),
      "bigint | Fraction": () => true,
      "null | undefined": () => false,
      Unit: typed2.referToSelf((self) => (x) => self(x.value)),
      "Array | Matrix": typed2.referToSelf((self) => (A) => {
        const arr = Array.isArray(A) ? A : A.valueOf();
        return arr.every((entry) => self(entry));
      })
    });
  }
);

// src/function/utils/isFinite.ts
var name17 = "isFinite";
var dependencies18 = ["typed", "isBounded", "map"];
var createIsFinite = /* @__PURE__ */ factory(
  name17,
  dependencies18,
  ({
    typed: typed2,
    isBounded,
    map: map2
  }) => {
    return typed2(name17, {
      "Array | Matrix": (A) => map2(A, isBounded),
      any: (x) => isBounded(x)
    });
  }
);

// src/function/utils/typeOf.ts
var name18 = "typeOf";
var dependencies19 = ["typed"];
var createTypeOf = /* @__PURE__ */ factory(
  name18,
  dependencies19,
  ({ typed: typed2 }) => {
    return typed2(name18, {
      any: typeOf
    });
  }
);

// src/utils/complex.ts
function complexEquals(x, y, relTol, absTol) {
  return nearlyEqual(x.re, y.re, relTol, absTol) && nearlyEqual(x.im, y.im, relTol, absTol);
}

// src/function/relational/compareUnits.ts
var createCompareUnits = /* @__PURE__ */ factory(
  "compareUnits",
  ["typed"],
  ({ typed: typed2 }) => ({
    "Unit, Unit": typed2.referToSelf((self) => (x, y) => {
      const unitX = x;
      const unitY = y;
      if (!unitX.equalBase(unitY)) {
        throw new Error("Cannot compare units with different base");
      }
      const fn = typed2.find(self, [unitX.valueType(), unitY.valueType()]);
      return fn ? fn(unitX.value, unitY.value) : void 0;
    })
  })
);

// src/function/relational/equalScalar.ts
var name19 = "equalScalar";
var dependencies20 = ["typed", "config"];
var createEqualScalar = /* @__PURE__ */ factory(
  name19,
  dependencies20,
  ({
    typed: typed2,
    config
  }) => {
    const compareUnits = createCompareUnits({ typed: typed2 });
    return typed2(
      name19,
      {
        "boolean, boolean": function(x, y) {
          return x === y;
        },
        "number, number": function(x, y) {
          return nearlyEqual(x, y, config.relTol, config.absTol);
        },
        "BigNumber, BigNumber": function(x, y) {
          return x.eq(y) || nearlyEqual2(x, y, config.relTol, config.absTol);
        },
        "bigint, bigint": function(x, y) {
          return x === y;
        },
        "Fraction, Fraction": function(x, y) {
          return x.equals(y);
        },
        "Complex, Complex": function(x, y) {
          return complexEquals(x, y, config.relTol, config.absTol);
        }
      },
      compareUnits
    );
  }
);
factory(
  name19,
  ["typed", "config"],
  ({
    typed: typed2,
    config
  }) => {
    return typed2(name19, {
      "number, number": function(x, y) {
        return nearlyEqual(x, y, config.relTol, config.absTol);
      }
    });
  }
);

// src/type/matrix/SparseMatrix.ts
var name20 = "SparseMatrix";
var dependencies21 = ["typed", "equalScalar", "Matrix"];
var createSparseMatrixClass = /* @__PURE__ */ factory(
  name20,
  dependencies21,
  ({ typed: typed2, equalScalar, Matrix: _Matrix }) => {
    const _SparseMatrix = class _SparseMatrix extends _Matrix {
      constructor(data, datatype) {
        super();
        this.type = "SparseMatrix";
        this.isSparseMatrix = true;
        if (datatype && !isString(datatype)) {
          throw new Error("Invalid datatype: " + datatype);
        }
        if (data && isMatrix(data)) {
          _createFromMatrix(this, data, datatype);
        } else if (data && typeof data === "object" && "index" in data && "ptr" in data && "size" in data && isArray(data.index) && isArray(data.ptr) && isArray(data.size)) {
          const sparseData = data;
          this._values = sparseData.values;
          this._index = sparseData.index;
          this._ptr = sparseData.ptr;
          this._size = sparseData.size;
          this._datatype = datatype || sparseData.datatype;
        } else if (data && isArray(data)) {
          _createFromArray(this, data, datatype);
        } else if (data) {
          throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
        } else {
          this._values = [];
          this._index = [];
          this._ptr = [0];
          this._size = [0, 0];
          this._datatype = datatype;
        }
      }
      /**
       * Create a new SparseMatrix
       */
      createSparseMatrix(data, datatype) {
        return new _SparseMatrix(data, datatype);
      }
      /**
       * Get the matrix type
       *
       * Usage:
       *    const matrixType = matrix.getDataType()  // retrieves the matrix type
       *
       * @memberOf SparseMatrix
       * @return {string}   type information; if multiple types are found from the Matrix, it will return "mixed"
       */
      getDataType() {
        return getArrayDataType(this._values, typeOf);
      }
      /**
       * Get the storage format used by the matrix.
       *
       * Usage:
       *     const format = matrix.storage()   // retrieve storage format
       *
       * @memberof SparseMatrix
       * @return {string}           The storage format.
       */
      storage() {
        return "sparse";
      }
      /**
       * Get the datatype of the data stored in the matrix.
       *
       * Usage:
       *     const format = matrix.datatype()    // retrieve matrix datatype
       *
       * @memberof SparseMatrix
       * @return {string | undefined}           The datatype.
       */
      datatype() {
        return this._datatype;
      }
      /**
       * Create a new SparseMatrix
       * @memberof SparseMatrix
       * @param {Array} data
       * @param {DataType} [datatype]
       */
      create(data, datatype) {
        return new _SparseMatrix(data, datatype);
      }
      /**
       * Get the matrix density.
       *
       * Usage:
       *     const density = matrix.density()                   // retrieve matrix density
       *
       * @memberof SparseMatrix
       * @return {number}           The matrix density.
       */
      density() {
        const rows = this._size[0];
        const columns = this._size[1];
        return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;
      }
      /**
       * Get a subset of the matrix, or replace a subset of the matrix.
       *
       * Usage:
       *     const subset = matrix.subset(index)               // retrieve subset
       *     const value = matrix.subset(index, replacement)   // replace subset
       *
       * @memberof SparseMatrix
       * @param {Index} index
       * @param {Array | Matrix | *} [replacement]
       * @param {*} [defaultValue=0]      Default value, filled in on new entries when
       *                                  the matrix is resized. If not provided,
       *                                  new matrix elements will be filled with zeros.
       */
      subset(index, replacement, defaultValue) {
        if (!this._values) {
          throw new Error("Cannot invoke subset on a Pattern only matrix");
        }
        if (arguments.length === 1) {
          return _getsubset(this, index);
        } else if (arguments.length === 2 || arguments.length === 3) {
          return _setsubset(this, index, replacement, defaultValue);
        } else {
          throw new SyntaxError("Wrong number of arguments");
        }
      }
      /**
       * Get a single element from the matrix.
       * @memberof SparseMatrix
       * @param {number[]} index   Zero-based index
       * @return {*} value
       */
      get(index) {
        if (!isArray(index)) {
          throw new TypeError("Array expected");
        }
        if (index.length !== this._size.length) {
          throw new DimensionError(index.length, this._size.length);
        }
        if (!this._values) {
          throw new Error("Cannot invoke get on a Pattern only matrix");
        }
        const i = index[0];
        const j = index[1];
        validateIndex(i, this._size[0]);
        validateIndex(j, this._size[1]);
        const k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
        if (k < this._ptr[j + 1] && this._index[k] === i) {
          return this._values[k];
        }
        return 0;
      }
      /**
       * Replace a single element in the matrix.
       * @memberof SparseMatrix
       * @param {number[]} index   Zero-based index
       * @param {*} v
       * @param {*} [defaultValue]        Default value, filled in on new entries when
       *                                  the matrix is resized. If not provided,
       *                                  new matrix elements will be set to zero.
       * @return {SparseMatrix} self
       */
      set(index, v, defaultValue) {
        if (!isArray(index)) {
          throw new TypeError("Array expected");
        }
        if (index.length !== this._size.length) {
          throw new DimensionError(index.length, this._size.length);
        }
        if (!this._values) {
          throw new Error("Cannot invoke set on a Pattern only matrix");
        }
        const i = index[0];
        const j = index[1];
        let rows = this._size[0];
        let columns = this._size[1];
        let eq = equalScalar;
        let zero = 0;
        if (isString(this._datatype)) {
          eq = typed2.find(equalScalar, [
            this._datatype,
            this._datatype
          ]) || equalScalar;
          zero = typed2.convert(0, this._datatype);
        }
        if (i > rows - 1 || j > columns - 1) {
          _resize2(
            this,
            Math.max(i + 1, rows),
            Math.max(j + 1, columns),
            defaultValue
          );
          rows = this._size[0];
          columns = this._size[1];
        }
        validateIndex(i, rows);
        validateIndex(j, columns);
        const k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
        if (k < this._ptr[j + 1] && this._index[k] === i) {
          if (!eq(v, zero)) {
            this._values[k] = v;
          } else {
            _remove(k, j, this._values, this._index, this._ptr);
          }
        } else {
          if (!eq(v, zero)) {
            _insert(k, i, j, v, this._values, this._index, this._ptr);
          }
        }
        return this;
      }
      /**
       * Resize the matrix to the given size. Returns a copy of the matrix when
       * `copy=true`, otherwise return the matrix itself (resize in place).
       *
       * @memberof SparseMatrix
       * @param {number[] | Matrix} size  The new size the matrix should have.
       *                                  Since sparse matrices are always two-dimensional,
       *                                  size must be two numbers in either an array or a matrix
       * @param {*} [defaultValue=0]      Default value, filled in on new entries.
       *                                  If not provided, the matrix elements will
       *                                  be filled with zeros.
       * @param {boolean} [copy]          Return a resized copy of the matrix
       *
       * @return {SparseMatrix}           The resized matrix
       */
      resize(size, defaultValue, copy) {
        if (!isCollection(size)) {
          throw new TypeError("Array or Matrix expected");
        }
        const sizeArray = size.valueOf().map((value) => {
          return Array.isArray(value) && value.length === 1 ? value[0] : value;
        });
        if (sizeArray.length !== 2) {
          throw new Error("Only two dimensions matrix are supported");
        }
        sizeArray.forEach(function(value) {
          if (!isNumber(value) || !isInteger(value) || value < 0) {
            throw new TypeError(
              "Invalid size, must contain positive integers (size: " + format3(sizeArray, {}) + ")"
            );
          }
        });
        const m = copy ? this.clone() : this;
        return _resize2(m, sizeArray[0], sizeArray[1], defaultValue);
      }
      /**
       * Reshape the matrix to the given size. Returns a copy of the matrix when
       * `copy=true`, otherwise return the matrix itself (reshape in place).
       *
       * NOTE: This might be better suited to copy by default, instead of modifying
       *       in place. For now, it operates in place to remain consistent with
       *       resize().
       *
       * @memberof SparseMatrix
       * @param {number[]} sizes          The new size the matrix should have.
       *                                  Since sparse matrices are always two-dimensional,
       *                                  size must be two numbers in either an array or a matrix
       * @param {boolean} [copy]          Return a reshaped copy of the matrix
       *
       * @return {SparseMatrix}           The reshaped matrix
       */
      reshape(sizes, copy) {
        if (!isArray(sizes)) {
          throw new TypeError("Array expected");
        }
        if (sizes.length !== 2) {
          throw new Error(
            "Sparse matrices can only be reshaped in two dimensions"
          );
        }
        sizes.forEach(function(value) {
          if (!isNumber(value) || !isInteger(value) || value <= -2 || value === 0) {
            throw new TypeError(
              "Invalid size, must contain positive integers or -1 (size: " + format3(sizes, {}) + ")"
            );
          }
        });
        const currentLength = this._size[0] * this._size[1];
        sizes = processSizesWildcard(sizes, currentLength);
        const newLength = sizes[0] * sizes[1];
        if (currentLength !== newLength) {
          throw new Error(
            "Reshaping sparse matrix will result in the wrong number of elements"
          );
        }
        const m = copy ? this.clone() : this;
        if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {
          return m;
        }
        const colIndex = [];
        for (let i = 0; i < m._ptr.length; i++) {
          for (let j = 0; j < m._ptr[i + 1] - m._ptr[i]; j++) {
            colIndex.push(i);
          }
        }
        const values = m._values.slice();
        const rowIndex = m._index.slice();
        for (let i = 0; i < m._index.length; i++) {
          const r1 = rowIndex[i];
          const c1 = colIndex[i];
          const flat = r1 * m._size[1] + c1;
          colIndex[i] = flat % sizes[1];
          rowIndex[i] = Math.floor(flat / sizes[1]);
        }
        m._values.length = 0;
        m._index.length = 0;
        m._ptr.length = sizes[1] + 1;
        m._size = sizes;
        for (let i = 0; i < m._ptr.length; i++) {
          m._ptr[i] = 0;
        }
        for (let h = 0; h < values.length; h++) {
          const i = rowIndex[h];
          const j = colIndex[h];
          const v = values[h];
          const k = _getValueIndex(i, m._ptr[j], m._ptr[j + 1], m._index);
          _insert(k, i, j, v, m._values, m._index, m._ptr);
        }
        return m;
      }
      /**
       * Create a clone of the matrix
       * @memberof SparseMatrix
       * @return {SparseMatrix} clone
       */
      clone() {
        const m = new _SparseMatrix({
          values: this._values ? clone(this._values) : void 0,
          index: clone(this._index),
          ptr: clone(this._ptr),
          size: clone(this._size),
          datatype: this._datatype
        });
        return m;
      }
      /**
       * Retrieve the size of the matrix.
       * @memberof SparseMatrix
       * @returns {number[]} size
       */
      size() {
        return this._size.slice(0);
      }
      /**
       * Create a new matrix with the results of the callback function executed on
       * each entry of the matrix.
       * @memberof SparseMatrix
       * @param {Function} callback   The callback function is invoked with three
       *                              parameters: the value of the element, the index
       *                              of the element, and the Matrix being traversed.
       * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
       *
       * @return {SparseMatrix} matrix
       */
      map(callback, skipZeros) {
        if (!this._values) {
          throw new Error("Cannot invoke map on a Pattern only matrix");
        }
        const me = this;
        const rows = this._size[0];
        const columns = this._size[1];
        const fastCallback = optimizeCallback(callback, me, "map");
        const invoke = function(v, i, j) {
          return fastCallback.fn(v, [i, j], me);
        };
        return _map(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);
      }
      /**
       * Execute a callback function on each entry of the matrix.
       * @memberof SparseMatrix
       * @param {Function} callback   The callback function is invoked with three
       *                              parameters: the value of the element, the index
       *                              of the element, and the Matrix being traversed.
       * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
       *                              If false, the indices are guaranteed to be in order,
       *                              if true, the indices can be unordered.
       */
      forEach(callback, skipZeros) {
        if (!this._values) {
          throw new Error("Cannot invoke forEach on a Pattern only matrix");
        }
        const me = this;
        const rows = this._size[0];
        const columns = this._size[1];
        const fastCallback = optimizeCallback(callback, me, "forEach");
        for (let j = 0; j < columns; j++) {
          const k0 = this._ptr[j];
          const k1 = this._ptr[j + 1];
          if (skipZeros) {
            for (let k = k0; k < k1; k++) {
              const i = this._index[k];
              fastCallback.fn(this._values[k], [i, j], me);
            }
          } else {
            const values = {};
            for (let k = k0; k < k1; k++) {
              const i = this._index[k];
              values[i] = this._values[k];
            }
            for (let i = 0; i < rows; i++) {
              const value = i in values ? values[i] : 0;
              fastCallback.fn(value, [i, j], me);
            }
          }
        }
      }
      /**
       * Iterate over the matrix elements, skipping zeros
       * @return {Iterable<{ value, index: number[] }>}
       */
      *[Symbol.iterator]() {
        if (!this._values) {
          throw new Error("Cannot iterate a Pattern only matrix");
        }
        const columns = this._size[1];
        for (let j = 0; j < columns; j++) {
          const k0 = this._ptr[j];
          const k1 = this._ptr[j + 1];
          for (let k = k0; k < k1; k++) {
            const i = this._index[k];
            yield { value: this._values[k], index: [i, j] };
          }
        }
      }
      /**
       * Create an Array with a copy of the data of the SparseMatrix
       * @memberof SparseMatrix
       * @returns {Array} array
       */
      toArray() {
        return _toArray(this._values, this._index, this._ptr, this._size, true);
      }
      /**
       * Get the primitive value of the SparseMatrix: a two dimensions array
       * @memberof SparseMatrix
       * @returns {Array} array
       */
      valueOf() {
        return _toArray(this._values, this._index, this._ptr, this._size, false);
      }
      /**
       * Get a string representation of the matrix, with optional formatting options.
       * @memberof SparseMatrix
       * @param {MatrixFormatOptions | number | Function} [options]  Formatting options. See
       *                                                lib/utils/number:format for a
       *                                                description of the available
       *                                                options.
       * @returns {string} str
       */
      format(options) {
        const rows = this._size[0];
        const columns = this._size[1];
        const density = this.density();
        let str = "Sparse Matrix [" + format3(rows, options) + " x " + format3(columns, options) + "] density: " + format3(density, options) + "\n";
        for (let j = 0; j < columns; j++) {
          const k0 = this._ptr[j];
          const k1 = this._ptr[j + 1];
          for (let k = k0; k < k1; k++) {
            const i = this._index[k];
            str += "\n    (" + format3(i, options) + ", " + format3(j, options) + ") ==> " + (this._values ? format3(this._values[k], options) : "X");
          }
        }
        return str;
      }
      /**
       * Get a string representation of the matrix
       * @memberof SparseMatrix
       * @returns {string} str
       */
      toString() {
        return format3(this.toArray(), {});
      }
      /**
       * Get a JSON representation of the matrix
       * @memberof SparseMatrix
       * @returns {SparseMatrixJSON}
       */
      toJSON() {
        return {
          mathjs: "SparseMatrix",
          values: this._values,
          index: this._index,
          ptr: this._ptr,
          size: this._size,
          datatype: this._datatype
        };
      }
      /**
       * Get the kth Matrix diagonal.
       *
       * @memberof SparseMatrix
       * @param {number | BigNumberLike} [k=0]     The kth diagonal where the vector will retrieved.
       *
       * @returns {SparseMatrix}               The matrix vector with the diagonal values.
       */
      diagonal(k) {
        if (k) {
          if (isBigNumber(k)) {
            k = k.toNumber();
          }
          if (!isNumber(k) || !isInteger(k)) {
            throw new TypeError("The parameter k must be an integer number");
          }
        } else {
          k = 0;
        }
        const kSuper = k > 0 ? k : 0;
        const kSub = k < 0 ? -k : 0;
        const rows = this._size[0];
        const columns = this._size[1];
        const n = Math.min(rows - kSub, columns - kSuper);
        const values = [];
        const index = [];
        const ptr = [];
        ptr[0] = 0;
        for (let j = kSuper; j < columns && values.length < n; j++) {
          const k0 = this._ptr[j];
          const k1 = this._ptr[j + 1];
          for (let x = k0; x < k1; x++) {
            const i = this._index[x];
            if (i === j - kSuper + kSub) {
              values.push(this._values[x]);
              index[values.length - 1] = i - kSub;
              break;
            }
          }
        }
        ptr.push(values.length);
        return new _SparseMatrix({
          values,
          index,
          ptr,
          size: [n, 1]
        });
      }
      /**
       * Generate a matrix from a JSON object
       * @memberof SparseMatrix
       * @param {Object} json  An object structured like
       *                       `{"mathjs": "SparseMatrix", "values": [], "index": [], "ptr": [], "size": []}`,
       *                       where mathjs is optional
       * @returns {SparseMatrix}
       */
      static fromJSON(json) {
        return new _SparseMatrix(json);
      }
      /**
       * Create a diagonal matrix.
       *
       * @memberof SparseMatrix
       * @param {Array} size                       The matrix size.
       * @param {number | Array | Matrix } value   The values for the diagonal.
       * @param {number | BigNumberLike} [k=0]         The kth diagonal where the vector will be filled in.
       * @param {MatrixValue} [defaultValue]            The default value for non-diagonal
       * @param {DataType} [datatype]                The Matrix datatype, values must be of this datatype.
       *
       * @returns {SparseMatrix}
       */
      static diagonal(size, value, k, defaultValue, datatype) {
        if (!isArray(size)) {
          throw new TypeError("Array expected, size parameter");
        }
        if (size.length !== 2) {
          throw new Error("Only two dimensions matrix are supported");
        }
        const sizeNumbers = size.map(function(s) {
          if (isBigNumber(s)) {
            s = s.toNumber();
          }
          if (!isNumber(s) || !isInteger(s) || s < 1) {
            throw new Error("Size values must be positive integers");
          }
          return s;
        });
        if (k) {
          if (isBigNumber(k)) {
            k = k.toNumber();
          }
          if (!isNumber(k) || !isInteger(k)) {
            throw new TypeError("The parameter k must be an integer number");
          }
        } else {
          k = 0;
        }
        let eq = equalScalar;
        let zero = 0;
        if (isString(datatype)) {
          eq = typed2.find(equalScalar, [datatype, datatype]) || equalScalar;
          zero = typed2.convert(0, datatype);
        }
        const kSuper = k > 0 ? k : 0;
        const kSub = k < 0 ? -k : 0;
        const rows = sizeNumbers[0];
        const columns = sizeNumbers[1];
        const n = Math.min(rows - kSub, columns - kSuper);
        let _value;
        if (isArray(value)) {
          if (value.length !== n) {
            throw new Error("Invalid value array length");
          }
          _value = function(i) {
            return value[i];
          };
        } else if (isMatrix(value)) {
          const ms = value.size();
          if (ms.length !== 1 || ms[0] !== n) {
            throw new Error("Invalid matrix length");
          }
          _value = function(i) {
            return value.get([i]);
          };
        } else {
          _value = function() {
            return value;
          };
        }
        const values = [];
        const index = [];
        const ptr = [];
        for (let j = 0; j < columns; j++) {
          ptr.push(values.length);
          const i = j - kSuper;
          if (i >= 0 && i < n) {
            const v = _value(i);
            if (!eq(v, zero)) {
              index.push(i + kSub);
              values.push(v);
            }
          }
        }
        ptr.push(values.length);
        return new _SparseMatrix({
          values,
          index,
          ptr,
          size: [rows, columns]
        });
      }
      /**
       * Swap rows i and j in Matrix.
       *
       * @memberof SparseMatrix
       * @param {number} i       Matrix row index 1
       * @param {number} j       Matrix row index 2
       *
       * @return {SparseMatrix}  The matrix reference
       */
      swapRows(i, j) {
        if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
          throw new Error("Row index must be positive integers");
        }
        if (this._size.length !== 2) {
          throw new Error("Only two dimensional matrix is supported");
        }
        validateIndex(i, this._size[0]);
        validateIndex(j, this._size[0]);
        _SparseMatrix._swapRows(
          i,
          j,
          this._size[1],
          this._values,
          this._index,
          this._ptr
        );
        return this;
      }
      /**
       * Loop rows with data in column j.
       *
       * @param {number} j            Column
       * @param {Array} values        Matrix values
       * @param {Array} index         Matrix row indeces
       * @param {Array} ptr           Matrix column pointers
       * @param {Function} callback   Callback function invoked for every row in column j
       */
      static _forEachRow(j, values, index, ptr, callback) {
        const k0 = ptr[j];
        const k1 = ptr[j + 1];
        for (let k = k0; k < k1; k++) {
          callback(index[k], values[k]);
        }
      }
      /**
       * Swap rows x and y in Sparse Matrix data structures.
       *
       * @param {number} x         Matrix row index 1
       * @param {number} y         Matrix row index 2
       * @param {number} columns   Number of columns in matrix
       * @param {Array} values     Matrix values
       * @param {Array} index      Matrix row indeces
       * @param {Array} ptr        Matrix column pointers
       */
      static _swapRows(x, y, columns, values, index, ptr) {
        for (let j = 0; j < columns; j++) {
          const k0 = ptr[j];
          const k1 = ptr[j + 1];
          const kx = _getValueIndex(x, k0, k1, index);
          const ky = _getValueIndex(y, k0, k1, index);
          if (kx < k1 && ky < k1 && index[kx] === x && index[ky] === y) {
            if (values) {
              const v = values[kx];
              values[kx] = values[ky];
              values[ky] = v;
            }
            continue;
          }
          if (kx < k1 && index[kx] === x && (ky >= k1 || index[ky] !== y)) {
            const vx = values ? values[kx] : void 0;
            index.splice(ky, 0, y);
            if (values) {
              values.splice(ky, 0, vx);
            }
            index.splice(ky <= kx ? kx + 1 : kx, 1);
            if (values) {
              values.splice(ky <= kx ? kx + 1 : kx, 1);
            }
            continue;
          }
          if (ky < k1 && index[ky] === y && (kx >= k1 || index[kx] !== x)) {
            const vy = values ? values[ky] : void 0;
            index.splice(kx, 0, x);
            if (values) {
              values.splice(kx, 0, vy);
            }
            index.splice(kx <= ky ? ky + 1 : ky, 1);
            if (values) {
              values.splice(kx <= ky ? ky + 1 : ky, 1);
            }
          }
        }
      }
    };
    /**
     * Attach type information
     */
    _SparseMatrix.displayName = "SparseMatrix";
    let SparseMatrix = _SparseMatrix;
    function _createFromMatrix(matrix, source, datatype) {
      if (source.type === "SparseMatrix") {
        matrix._values = source._values ? clone(source._values) : void 0;
        matrix._index = clone(source._index);
        matrix._ptr = clone(source._ptr);
        matrix._size = clone(source._size);
        matrix._datatype = datatype || source._datatype;
      } else {
        _createFromArray(matrix, source.valueOf(), datatype || source._datatype);
      }
    }
    function _createFromArray(matrix, data, datatype) {
      matrix._values = [];
      matrix._index = [];
      matrix._ptr = [];
      matrix._datatype = datatype;
      const rows = data.length;
      let columns = 0;
      let expectedColumns = null;
      for (let i = 0; i < rows; i++) {
        const row = data[i];
        if (isArray(row)) {
          for (let k = 0; k < row.length; k++) {
            if (isArray(row[k])) {
              throw new DimensionError("Two dimensional array expected");
            }
          }
          if (expectedColumns === null) {
            expectedColumns = row.length;
          } else if (row.length !== expectedColumns) {
            throw new DimensionError(row.length, expectedColumns);
          }
        }
      }
      let eq = equalScalar;
      let zero = 0;
      if (isString(datatype)) {
        eq = typed2.find(equalScalar, [datatype, datatype]) || equalScalar;
        zero = typed2.convert(0, datatype);
      }
      if (rows > 0) {
        let j = 0;
        do {
          matrix._ptr.push(matrix._index.length);
          for (let i = 0; i < rows; i++) {
            const row = data[i];
            if (isArray(row)) {
              if (j === 0 && columns < row.length) {
                columns = row.length;
              }
              if (j < row.length) {
                const v = row[j];
                if (!eq(v, zero)) {
                  matrix._values.push(v);
                  matrix._index.push(i);
                }
              }
            } else {
              if (j === 0 && columns < 1) {
                columns = 1;
              }
              if (!eq(row, zero)) {
                matrix._values.push(row);
                matrix._index.push(i);
              }
            }
          }
          j++;
        } while (j < columns);
      }
      matrix._ptr.push(matrix._index.length);
      matrix._size = [rows, columns];
    }
    function _getsubset(matrix, idx) {
      if (!isIndex(idx)) {
        throw new TypeError("Invalid index");
      }
      const isScalar = idx.isScalar();
      if (isScalar) {
        return matrix.get(idx.min());
      }
      const size = idx.size();
      if (size.length !== matrix._size.length) {
        throw new DimensionError(size.length, matrix._size.length);
      }
      let i, ii, k, kk;
      const min = idx.min();
      const max = idx.max();
      for (i = 0, ii = matrix._size.length; i < ii; i++) {
        validateIndex(min[i], matrix._size[i]);
        validateIndex(max[i], matrix._size[i]);
      }
      const mvalues = matrix._values;
      const mindex = matrix._index;
      const mptr = matrix._ptr;
      const rows = idx.dimension(0);
      const columns = idx.dimension(1);
      const w = [];
      const pv = [];
      function rowsCallback(i2, r) {
        pv[i2] = r[0];
        w[i2] = true;
      }
      if (Number.isInteger(rows)) rowsCallback(rows, [0]);
      else rows.forEach(rowsCallback);
      const values = mvalues ? [] : void 0;
      const index = [];
      const ptr = [];
      function columnsCallback(j) {
        ptr.push(index.length);
        for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {
          i = mindex[k];
          if (w[i] === true) {
            index.push(pv[i]);
            if (values) {
              values.push(mvalues[k]);
            }
          }
        }
      }
      if (Number.isInteger(columns)) columnsCallback(columns);
      else columns.forEach(columnsCallback);
      ptr.push(index.length);
      return new SparseMatrix({
        values,
        index,
        ptr,
        size,
        datatype: matrix._datatype
      });
    }
    function _setsubset(matrix, index, submatrix, defaultValue) {
      if (!index || index.isIndex !== true) {
        throw new TypeError("Invalid index");
      }
      const iSize = index.size();
      const isScalar = index.isScalar();
      let sSize;
      if (isMatrix(submatrix)) {
        sSize = submatrix.size();
        submatrix = submatrix.valueOf();
      } else {
        sSize = arraySize(submatrix);
      }
      if (isScalar) {
        if (sSize.length !== 0) {
          throw new TypeError("Scalar expected");
        }
        matrix.set(index.min(), submatrix, defaultValue);
      } else {
        if (iSize.length !== 1 && iSize.length !== 2) {
          throw new DimensionError(iSize.length, matrix._size.length, "<");
        }
        if (sSize.length < iSize.length) {
          let i = 0;
          let outer = 0;
          while (iSize[i] === 1 && sSize[i] === 1) {
            i++;
          }
          while (iSize[i] === 1) {
            outer++;
            i++;
          }
          submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
        }
        if (!deepStrictEqual(iSize, sSize)) {
          throw new DimensionError(iSize, sSize, ">");
        }
        const _forEachIndex = (idx, callback) => {
          if (isNumber(idx)) callback(idx, [0]);
          else idx.forEach(callback);
        };
        if (iSize.length === 1) {
          const range = index.dimension(0);
          _forEachIndex(range, (dataIndex, subIndex) => {
            validateIndex(dataIndex);
            matrix.set(
              [dataIndex, 0],
              submatrix[subIndex[0]],
              defaultValue
            );
          });
        } else {
          const firstDimensionRange = index.dimension(0);
          const secondDimensionRange = index.dimension(1);
          _forEachIndex(
            firstDimensionRange,
            (firstDataIndex, firstSubIndex) => {
              validateIndex(firstDataIndex);
              _forEachIndex(
                secondDimensionRange,
                (secondDataIndex, secondSubIndex) => {
                  validateIndex(secondDataIndex);
                  matrix.set(
                    [firstDataIndex, secondDataIndex],
                    submatrix[firstSubIndex[0]][secondSubIndex[0]],
                    defaultValue
                  );
                }
              );
            }
          );
        }
      }
      return matrix;
    }
    function _getValueIndex(i, top, bottom, index) {
      if (bottom - top === 0) {
        return bottom;
      }
      for (let r = top; r < bottom; r++) {
        if (index[r] === i) {
          return r;
        }
      }
      return top;
    }
    function _remove(k, j, values, index, ptr) {
      values.splice(k, 1);
      index.splice(k, 1);
      for (let x = j + 1; x < ptr.length; x++) {
        ptr[x]--;
      }
    }
    function _insert(k, i, j, v, values, index, ptr) {
      values.splice(k, 0, v);
      index.splice(k, 0, i);
      for (let x = j + 1; x < ptr.length; x++) {
        ptr[x]++;
      }
    }
    function _resize2(matrix, rows, columns, defaultValue) {
      let value = defaultValue || 0;
      let eq = equalScalar;
      let zero = 0;
      if (isString(matrix._datatype)) {
        eq = typed2.find(equalScalar, [
          matrix._datatype,
          matrix._datatype
        ]) || equalScalar;
        zero = typed2.convert(0, matrix._datatype);
        value = typed2.convert(value, matrix._datatype);
      }
      const ins = !eq(value, zero);
      const r = matrix._size[0];
      let c = matrix._size[1];
      let i, j, k;
      if (columns > c) {
        for (j = c; j < columns; j++) {
          matrix._ptr[j] = matrix._values.length;
          if (ins) {
            for (i = 0; i < r; i++) {
              matrix._values.push(value);
              matrix._index.push(i);
            }
          }
        }
        matrix._ptr[columns] = matrix._values.length;
      } else if (columns < c) {
        matrix._ptr.splice(columns + 1, c - columns);
        matrix._values.splice(matrix._ptr[columns], matrix._values.length);
        matrix._index.splice(matrix._ptr[columns], matrix._index.length);
      }
      c = columns;
      if (rows > r) {
        if (ins) {
          let n = 0;
          for (j = 0; j < c; j++) {
            matrix._ptr[j] = matrix._ptr[j] + n;
            k = matrix._ptr[j + 1] + n;
            let p = 0;
            for (i = r; i < rows; i++, p++) {
              matrix._values.splice(k + p, 0, value);
              matrix._index.splice(k + p, 0, i);
              n++;
            }
          }
          matrix._ptr[c] = matrix._values.length;
        }
      } else if (rows < r) {
        let d = 0;
        for (j = 0; j < c; j++) {
          matrix._ptr[j] = matrix._ptr[j] - d;
          const k0 = matrix._ptr[j];
          const k1 = matrix._ptr[j + 1] - d;
          for (k = k0; k < k1; k++) {
            i = matrix._index[k];
            if (i > rows - 1) {
              matrix._values.splice(k, 1);
              matrix._index.splice(k, 1);
              d++;
            }
          }
        }
        matrix._ptr[j] = matrix._values.length;
      }
      matrix._size[0] = rows;
      matrix._size[1] = columns;
      return matrix;
    }
    function _map(matrix, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {
      const values = [];
      const index = [];
      const ptr = [];
      let eq = equalScalar;
      let zero = 0;
      if (isString(matrix._datatype)) {
        eq = typed2.find(equalScalar, [
          matrix._datatype,
          matrix._datatype
        ]) || equalScalar;
        zero = typed2.convert(0, matrix._datatype);
      }
      const invoke = function(v, x, y) {
        const value = callback(v, x, y);
        if (!eq(value, zero)) {
          values.push(value);
          index.push(x);
        }
      };
      for (let j = minColumn; j <= maxColumn; j++) {
        ptr.push(values.length);
        const k0 = matrix._ptr[j];
        const k1 = matrix._ptr[j + 1];
        if (skipZeros) {
          for (let k = k0; k < k1; k++) {
            const i = matrix._index[k];
            if (i >= minRow && i <= maxRow) {
              invoke(matrix._values[k], i - minRow, j - minColumn);
            }
          }
        } else {
          const valuesCache = {};
          for (let k = k0; k < k1; k++) {
            const i = matrix._index[k];
            valuesCache[i] = matrix._values[k];
          }
          for (let i = minRow; i <= maxRow; i++) {
            const value = i in valuesCache ? valuesCache[i] : 0;
            invoke(value, i - minRow, j - minColumn);
          }
        }
      }
      if (minRow <= maxRow && minColumn > maxColumn) {
        ptr.push(values.length);
      }
      ptr.push(values.length);
      return new SparseMatrix({
        values,
        index,
        ptr,
        size: [maxRow - minRow + 1, maxColumn - minColumn + 1]
      });
    }
    function _toArray(values, index, ptr, size, copy) {
      const rows = size[0];
      const columns = size[1];
      const a = [];
      let i, j;
      for (i = 0; i < rows; i++) {
        a[i] = [];
        for (j = 0; j < columns; j++) {
          a[i][j] = 0;
        }
      }
      for (j = 0; j < columns; j++) {
        const k0 = ptr[j];
        const k1 = ptr[j + 1];
        for (let k = k0; k < k1; k++) {
          i = index[k];
          a[i][j] = values ? copy ? clone(values[k]) : values[k] : 1;
        }
      }
      return a;
    }
    Object.defineProperty(SparseMatrix, "name", {
      value: name20,
      configurable: true
    });
    SparseMatrix.prototype.type = "SparseMatrix";
    SparseMatrix.prototype.isSparseMatrix = true;
    SparseMatrix.prototype.isMatrix = true;
    return SparseMatrix;
  },
  { isClass: true }
);

// src/type/number.ts
var name21 = "number";
var dependencies22 = ["typed"];
function getNonDecimalNumberParts(input) {
  const nonDecimalWithRadixMatch = input.match(
    /(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/
  );
  if (nonDecimalWithRadixMatch) {
    const radix = { "0b": 2, "0o": 8, "0x": 16 }[nonDecimalWithRadixMatch[1]];
    const integerPart = nonDecimalWithRadixMatch[2];
    const fractionalPart = nonDecimalWithRadixMatch[3];
    return { input, radix, integerPart, fractionalPart };
  } else {
    return null;
  }
}
function makeNumberFromNonDecimalParts(parts) {
  const n = parseInt(parts.integerPart, parts.radix);
  let f = 0;
  for (let i = 0; i < parts.fractionalPart.length; i++) {
    const digitValue = parseInt(parts.fractionalPart[i], parts.radix);
    f += digitValue / Math.pow(parts.radix, i + 1);
  }
  const result = n + f;
  if (isNaN(result)) {
    throw new SyntaxError('String "' + parts.input + '" is not a valid number');
  }
  return result;
}
var createNumber = /* @__PURE__ */ factory(
  name21,
  dependencies22,
  ({ typed: typed2 }) => {
    const number = typed2("number", {
      "": function() {
        return 0;
      },
      number: function(x) {
        return x;
      },
      string: function(x) {
        if (x === "NaN") return NaN;
        const nonDecimalNumberParts = getNonDecimalNumberParts(x);
        if (nonDecimalNumberParts) {
          return makeNumberFromNonDecimalParts(nonDecimalNumberParts);
        }
        let size = 0;
        const wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
        if (wordSizeSuffixMatch) {
          size = Number(wordSizeSuffixMatch[2]);
          x = wordSizeSuffixMatch[1];
        }
        let num = Number(x);
        if (isNaN(num)) {
          throw new SyntaxError('String "' + x + '" is not a valid number');
        }
        if (wordSizeSuffixMatch) {
          if (num > 2 ** size - 1) {
            throw new SyntaxError(`String "${x}" is out of range`);
          }
          if (num >= 2 ** (size - 1)) {
            num = num - 2 ** size;
          }
        }
        return num;
      },
      BigNumber: function(x) {
        return x.toNumber();
      },
      bigint: function(x) {
        return Number(x);
      },
      Fraction: function(x) {
        return x.valueOf();
      },
      Unit: typed2.referToSelf((self) => (x) => {
        const clone3 = x.clone();
        clone3.value = self(x.value);
        return clone3;
      }),
      null: function(_x) {
        return 0;
      },
      "Unit, string | Unit": function(unit, valuelessUnit) {
        return unit.toNumber(valuelessUnit);
      },
      "Array | Matrix": typed2.referToSelf(
        (self) => (x) => deepMap2(x, self)
      )
    });
    number.fromJSON = function(json) {
      return parseFloat(json.value);
    };
    return number;
  }
);

// src/type/bigint.ts
var name22 = "bigint";
var dependencies23 = ["typed"];
var createBigint = /* @__PURE__ */ factory(
  name22,
  dependencies23,
  ({ typed: typed2 }) => {
    const bigint = typed2("bigint", {
      "": function() {
        return 0n;
      },
      bigint: function(x) {
        return x;
      },
      number: function(x) {
        return BigInt(x.toFixed());
      },
      BigNumber: function(x) {
        return BigInt(x.round().toString());
      },
      Fraction: function(x) {
        return BigInt(x.valueOf().toFixed());
      },
      "string | boolean": function(x) {
        return BigInt(x);
      },
      null: function(_x) {
        return 0n;
      },
      "Array | Matrix": typed2.referToSelf(
        (self) => (x) => deepMap2(x, self)
      )
    });
    bigint.fromJSON = function(json) {
      return BigInt(json.value);
    };
    return bigint;
  }
);

// src/type/string.ts
var name23 = "string";
var dependencies24 = ["typed"];
var createString = /* @__PURE__ */ factory(
  name23,
  dependencies24,
  ({ typed: typed2 }) => {
    return typed2(name23, {
      "": function() {
        return "";
      },
      number: format,
      null: function(_x) {
        return "null";
      },
      boolean: function(x) {
        return x + "";
      },
      string: function(x) {
        return x;
      },
      "Array | Matrix": typed2.referToSelf(
        (self) => (x) => deepMap2(x, self)
      ),
      any: function(x) {
        return String(x);
      }
    });
  }
);

// src/type/boolean.ts
var name24 = "boolean";
var dependencies25 = ["typed"];
var createBoolean = /* @__PURE__ */ factory(
  name24,
  dependencies25,
  ({ typed: typed2 }) => {
    return typed2(name24, {
      "": function() {
        return false;
      },
      boolean: function(x) {
        return x;
      },
      number: function(x) {
        return !!x;
      },
      null: function(_x) {
        return false;
      },
      BigNumber: function(x) {
        return !x.isZero();
      },
      string: function(x) {
        const lcase = x.toLowerCase();
        if (lcase === "true") {
          return true;
        } else if (lcase === "false") {
          return false;
        }
        const num = Number(x);
        if (x !== "" && !isNaN(num)) {
          return !!num;
        }
        throw new Error('Cannot convert "' + x + '" to a boolean');
      },
      "Array | Matrix": typed2.referToSelf(
        (self) => (x) => deepMap2(x, self)
      )
    });
  }
);

// src/type/bignumber/function/bignumber.ts
var name25 = "bignumber";
var dependencies26 = ["typed", "BigNumber"];
var createBignumber = /* @__PURE__ */ factory(
  name25,
  dependencies26,
  ({ typed: typed2, BigNumber }) => {
    return typed2("bignumber", {
      "": function() {
        return new BigNumber(0);
      },
      number: function(x) {
        return new BigNumber(x + "");
      },
      string: function(x) {
        const wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
        if (wordSizeSuffixMatch) {
          const size = wordSizeSuffixMatch[2];
          const n = new BigNumber(wordSizeSuffixMatch[1]);
          const twoPowSize = new BigNumber(2).pow(Number(size));
          if (n.gt(twoPowSize.sub(1))) {
            throw new SyntaxError(`String "${x}" is out of range`);
          }
          const twoPowSizeSubOne = new BigNumber(2).pow(Number(size) - 1);
          if (n.gte(twoPowSizeSubOne)) {
            return n.sub(twoPowSize);
          } else {
            return n;
          }
        }
        return new BigNumber(x);
      },
      BigNumber: function(x) {
        return x;
      },
      bigint: function(x) {
        return new BigNumber(x.toString());
      },
      Unit: typed2.referToSelf((self) => (x) => {
        const clone3 = x.clone();
        clone3.value = self(x.value);
        return clone3;
      }),
      Fraction: function(x) {
        return new BigNumber(String(x.n)).div(String(x.d)).times(String(x.s));
      },
      null: function(_x) {
        return new BigNumber(0);
      },
      "Array | Matrix": typed2.referToSelf(
        (self) => (x) => deepMap2(x, self)
      )
    });
  }
);

// src/type/complex/function/complex.ts
var name26 = "complex";
var dependencies27 = ["typed", "Complex"];
var createComplex = /* @__PURE__ */ factory(
  name26,
  dependencies27,
  ({ typed: typed2, Complex: Complex2 }) => {
    return typed2("complex", {
      "": function() {
        return Complex2.ZERO;
      },
      number: function(x) {
        return new Complex2(x, 0);
      },
      "number, number": function(re, im) {
        return new Complex2(re, im);
      },
      // TODO: this signature should be redundant
      "BigNumber, BigNumber": function(re, im) {
        return new Complex2(re.toNumber(), im.toNumber());
      },
      Fraction: function(x) {
        return new Complex2(x.valueOf(), 0);
      },
      Complex: function(x) {
        return x.clone();
      },
      string: function(x) {
        return Complex2(x);
      },
      null: function(_x) {
        return Complex2(0);
      },
      Object: function(x) {
        if ("re" in x && "im" in x) {
          return new Complex2(x.re, x.im);
        }
        if ("r" in x && "phi" in x || "abs" in x && "arg" in x) {
          return new Complex2(x);
        }
        throw new Error(
          "Expected object with properties (re and im) or (r and phi) or (abs and arg)"
        );
      },
      "Array | Matrix": typed2.referToSelf(
        (self) => (x) => deepMap2(x, self)
      )
    });
  }
);

// src/type/fraction/function/fraction.ts
var name27 = "fraction";
var dependencies28 = ["typed", "Fraction"];
var createFraction = /* @__PURE__ */ factory(
  name27,
  dependencies28,
  ({ typed: typed2, Fraction: Fraction2 }) => {
    return typed2("fraction", {
      number: function(x) {
        if (!Number.isFinite(x) || isNaN(x)) {
          throw new Error(x + " cannot be represented as a fraction");
        }
        return new Fraction2(x);
      },
      string: function(x) {
        return new Fraction2(x);
      },
      "number, number": function(numerator, denominator) {
        return new Fraction2(numerator, denominator);
      },
      "bigint, bigint": function(numerator, denominator) {
        return new Fraction2(numerator, denominator);
      },
      null: function(_x) {
        return new Fraction2(0);
      },
      BigNumber: function(x) {
        return new Fraction2(x.toString());
      },
      bigint: function(x) {
        return new Fraction2(x.toString());
      },
      Fraction: function(x) {
        return x;
      },
      Unit: typed2.referToSelf((self) => (x) => {
        const clone3 = x.clone();
        clone3.value = self(x.value);
        return clone3;
      }),
      Object: function(x) {
        return new Fraction2(x);
      },
      "Array | Matrix": typed2.referToSelf(
        (self) => (x) => deepMap2(x, self)
      )
    });
  }
);

// src/type/matrix/function/matrix.ts
var name28 = "matrix";
var dependencies29 = ["typed", "Matrix", "DenseMatrix", "SparseMatrix"];
var createMatrix = /* @__PURE__ */ factory(
  name28,
  dependencies29,
  ({
    typed: typed2,
    Matrix: _Matrix,
    DenseMatrix,
    SparseMatrix
  }) => {
    return typed2(name28, {
      "": function() {
        return _create([]);
      },
      string: function(format4) {
        return _create([], format4);
      },
      "string, string": function(format4, datatype) {
        return _create([], format4, datatype);
      },
      Array: function(data) {
        return _create(data);
      },
      Matrix: function(data) {
        return _create(data, data.storage());
      },
      "Array | Matrix, string": _create,
      "Array | Matrix, string, string": _create
    });
    function _create(data, format4, datatype) {
      if (format4 === "dense" || format4 === "default" || format4 === void 0) {
        return new DenseMatrix(data, datatype);
      }
      if (format4 === "sparse") {
        return new SparseMatrix(data, datatype);
      }
      throw new TypeError("Unknown matrix type " + JSON.stringify(format4) + ".");
    }
  }
);

// src/function/matrix/matrixFromFunction.ts
var name29 = "matrixFromFunction";
var dependencies30 = ["typed", "matrix", "isZero"];
var createMatrixFromFunction = /* @__PURE__ */ factory(
  name29,
  dependencies30,
  ({
    typed: typed2,
    matrix,
    isZero
  }) => {
    return typed2(name29, {
      "Array | Matrix, function, string, string": function(size, fn, format4, datatype) {
        return _create(size, fn, format4, datatype);
      },
      "Array | Matrix, function, string": function(size, fn, format4) {
        return _create(size, fn, format4, void 0);
      },
      "Matrix, function": function(size, fn) {
        return _create(size, fn, "dense", void 0);
      },
      "Array, function": function(size, fn) {
        return _create(size, fn, "dense", void 0).toArray();
      },
      "Array | Matrix, string, function": function(size, format4, fn) {
        return _create(size, fn, format4, void 0);
      },
      "Array | Matrix, string, string, function": function(size, format4, datatype, fn) {
        return _create(size, fn, format4, datatype);
      }
    });
    function _create(size, fn, format4, datatype) {
      let m;
      if (datatype !== void 0) {
        m = matrix(format4, datatype);
      } else {
        m = matrix(format4);
      }
      m.resize(size);
      m.forEach(function(_, index) {
        const val = fn(index);
        if (isZero(val)) return;
        m.set(index, val);
      });
      return m;
    }
  }
);

// src/function/matrix/matrixFromRows.ts
var name30 = "matrixFromRows";
var dependencies31 = ["typed", "matrix", "flatten", "size"];
var createMatrixFromRows = /* @__PURE__ */ factory(
  name30,
  dependencies31,
  ({ typed: typed2, matrix, flatten: flatten2, size }) => {
    return typed2(name30, {
      // Single variadic handler for arrays, matrices, and mixed types
      "...": function(arr) {
        if (arr.length === 0) {
          throw new TypeError(
            "At least one row is needed to construct a matrix."
          );
        }
        const allMatrix = arr.every(
          (item) => typeof item.toArray === "function"
        );
        const hasArray = arr.some((item) => Array.isArray(item));
        const arrays = arr.map(
          (item) => typeof item.toArray === "function" ? item.toArray() : item
        );
        const result = _createArray(arrays);
        if (allMatrix && !hasArray) {
          return matrix(result);
        }
        return result;
      }
      // TODO implement this properly for SparseMatrix
    });
    function _createArray(arr) {
      if (arr.length === 0)
        throw new TypeError("At least one row is needed to construct a matrix.");
      const N = checkVectorTypeAndReturnLength(arr[0]);
      const result = [];
      for (const row of arr) {
        const rowLength = checkVectorTypeAndReturnLength(row);
        if (rowLength !== N) {
          throw new TypeError(
            "The vectors had different length: " + (N | 0) + " \u2260 " + (rowLength | 0)
          );
        }
        result.push(flatten2(row));
      }
      return result;
    }
    function checkVectorTypeAndReturnLength(vec) {
      const s = size(vec);
      if (s.length === 1) {
        return s[0];
      } else if (s.length === 2) {
        if (s[0] === 1) {
          return s[1];
        } else if (s[1] === 1) {
          return s[0];
        } else {
          throw new TypeError("At least one of the arguments is not a vector.");
        }
      } else {
        throw new TypeError(
          "Only one- or two-dimensional vectors are supported."
        );
      }
    }
  }
);

// src/function/matrix/matrixFromColumns.ts
var name31 = "matrixFromColumns";
var dependencies32 = ["typed", "matrix", "flatten", "size"];
var createMatrixFromColumns = /* @__PURE__ */ factory(
  name31,
  dependencies32,
  ({ typed: typed2, matrix, flatten: flatten2, size }) => {
    return typed2(name31, {
      // Single variadic handler for arrays, matrices, and mixed types
      "...": function(arr) {
        if (arr.length === 0) {
          throw new TypeError(
            "At least one column is needed to construct a matrix."
          );
        }
        const allMatrix = arr.every(
          (item) => typeof item.toArray === "function"
        );
        const hasArray = arr.some((item) => Array.isArray(item));
        const arrays = arr.map(
          (item) => typeof item.toArray === "function" ? item.toArray() : item
        );
        const result = _createArray(arrays);
        if (allMatrix && !hasArray) {
          return matrix(result);
        }
        return result;
      }
      // TODO implement this properly for SparseMatrix
    });
    function _createArray(arr) {
      if (arr.length === 0)
        throw new TypeError(
          "At least one column is needed to construct a matrix."
        );
      const N = checkVectorTypeAndReturnLength(arr[0]);
      const result = [];
      for (let i = 0; i < N; i++) {
        result[i] = [];
      }
      for (const col of arr) {
        const colLength = checkVectorTypeAndReturnLength(col);
        if (colLength !== N) {
          throw new TypeError(
            "The vectors had different length: " + (N | 0) + " \u2260 " + (colLength | 0)
          );
        }
        const f = flatten2(col);
        for (let i = 0; i < N; i++) {
          result[i].push(f[i]);
        }
      }
      return result;
    }
    function checkVectorTypeAndReturnLength(vec) {
      const s = size(vec);
      if (s.length === 1) {
        return s[0];
      } else if (s.length === 2) {
        if (s[0] === 1) {
          return s[1];
        } else if (s[1] === 1) {
          return s[0];
        } else {
          throw new TypeError("At least one of the arguments is not a vector.");
        }
      } else {
        throw new TypeError(
          "Only one- or two-dimensional vectors are supported."
        );
      }
    }
  }
);

// src/type/unit/function/splitUnit.ts
var name32 = "splitUnit";
var dependencies33 = ["typed"];
var createSplitUnit = /* @__PURE__ */ factory(
  name32,
  dependencies33,
  ({ typed: typed2 }) => {
    return typed2(name32, {
      "Unit, Array": function(unit, parts) {
        return unit.splitUnit(parts);
      }
    });
  }
);

// src/function/arithmetic/unaryMinus.ts
var name33 = "unaryMinus";
var dependencies34 = ["typed", "config", "?bignumber"];
var createUnaryMinus = /* @__PURE__ */ factory(
  name33,
  dependencies34,
  ({
    typed: typed2,
    config,
    bignumber
  }) => {
    return typed2(name33, {
      number: unaryMinusNumber,
      "Complex | BigNumber | Fraction": (x) => x.neg(),
      bigint: (x) => -x,
      Unit: typed2.referToSelf((self) => (x) => {
        const res = x.clone();
        res.value = typed2.find(self, res.valueType())(x.value);
        return res;
      }),
      boolean: function(x) {
        const numValue = x ? 1 : 0;
        const negValue = -numValue;
        const numberType = config?.number || "number";
        switch (numberType) {
          case "BigNumber":
            if (!bignumber) {
              throw new Error(
                "BigNumber not available. Configure mathjs with BigNumber support."
              );
            }
            return bignumber(negValue);
          case "bigint":
            return BigInt(negValue);
          case "Fraction":
            return negValue;
          case "number":
          default:
            return negValue;
        }
      },
      // deep map collection, skip zeros since unaryMinus(0) = 0
      "Array | Matrix": typed2.referToSelf(
        (self) => (x) => deepMap2(x, self, true)
      )
      // TODO: add support for string
    });
  }
);

// src/function/arithmetic/unaryPlus.ts
var name34 = "unaryPlus";
var dependencies35 = ["typed", "config", "numeric"];
var createUnaryPlus = /* @__PURE__ */ factory(
  name34,
  dependencies35,
  ({ typed: typed2, config, numeric }) => {
    return typed2(name34, {
      number: unaryPlusNumber,
      Complex: function(x) {
        return x;
      },
      BigNumber: function(x) {
        return x;
      },
      bigint: function(x) {
        return x;
      },
      Fraction: function(x) {
        return x;
      },
      Unit: function(x) {
        return x.clone();
      },
      // deep map collection, skip zeros since unaryPlus(0) = 0
      "Array | Matrix": typed2.referToSelf(
        (self) => (x) => deepMap2(x, self, true)
      ),
      boolean: function(x) {
        return numeric(x ? 1 : 0, config.number);
      },
      string: function(x) {
        return numeric(x, safeNumberType(x, config));
      }
    });
  }
);

// src/function/arithmetic/abs.ts
var name35 = "abs";
var dependencies36 = ["typed"];
var createAbs = /* @__PURE__ */ factory(
  name35,
  dependencies36,
  ({ typed: typed2 }) => {
    return typed2(name35, {
      number: absNumber,
      "Complex | BigNumber | Fraction | Unit": (x) => x.abs(),
      bigint: (x) => x < 0n ? -x : x,
      // deep map collection, skip zeros since abs(0) = 0
      "Array | Matrix": typed2.referToSelf(
        (self) => (x) => deepMap2(x, self, true)
      )
    });
  }
);

// src/function/matrix/mapSlices.ts
var name36 = "mapSlices";
var dependencies37 = ["typed", "isInteger"];
var createMapSlices = /* @__PURE__ */ factory(
  name36,
  dependencies37,
  ({
    typed: typed2,
    isInteger: isInteger2
  }) => {
    return typed2(name36, {
      "Array | Matrix, number | BigNumber, function": function(mat, dim, callback) {
        if (!isInteger2(dim)) {
          throw new TypeError("Integer number expected for dimension");
        }
        const dimNum = typeof dim === "number" ? dim : dim.toNumber();
        const size = Array.isArray(mat) ? arraySize(mat) : mat.size();
        if (dimNum < 0 || dimNum >= size.length) {
          throw new IndexError(dimNum, 0, size.length);
        }
        if (isMatrix(mat)) {
          return mat.create(
            _mapSlices(mat.valueOf(), dimNum, callback),
            mat.datatype()
          );
        } else {
          return _mapSlices(mat, dimNum, callback);
        }
      }
    });
  },
  { formerly: "apply" }
);
function _mapSlices(mat, dim, callback) {
  let i, ret, tran;
  if (dim <= 0) {
    if (!Array.isArray(mat[0])) {
      return callback(mat);
    } else {
      tran = _switch2(mat);
      ret = [];
      for (i = 0; i < tran.length; i++) {
        ret[i] = _mapSlices(tran[i], dim - 1, callback);
      }
      return ret;
    }
  } else {
    ret = [];
    for (i = 0; i < mat.length; i++) {
      ret[i] = _mapSlices(mat[i], dim - 1, callback);
    }
    return ret;
  }
}
function _switch2(mat) {
  const I = mat.length;
  const J = mat[0].length;
  let i, j;
  const ret = [];
  for (j = 0; j < J; j++) {
    const tmp = [];
    for (i = 0; i < I; i++) {
      tmp.push(mat[i][j]);
    }
    ret.push(tmp);
  }
  return ret;
}

// src/function/arithmetic/addScalar.ts
var name37 = "addScalar";
var dependencies38 = ["typed"];
var createAddScalar = /* @__PURE__ */ factory(
  name37,
  dependencies38,
  ({ typed: typed2 }) => {
    return typed2(name37, {
      "number, number": addNumber,
      "Complex, Complex": function(x, y) {
        return x.add(y);
      },
      "BigNumber, BigNumber": function(x, y) {
        return x.plus(y);
      },
      "bigint, bigint": function(x, y) {
        return x + y;
      },
      "Fraction, Fraction": function(x, y) {
        return x.add(y);
      },
      "Unit, Unit": typed2.referToSelf((self) => (x, y) => {
        if (x.value === null || x.value === void 0) {
          throw new Error("Parameter x contains a unit with undefined value");
        }
        if (y.value === null || y.value === void 0) {
          throw new Error("Parameter y contains a unit with undefined value");
        }
        if (!x.equalBase(y)) throw new Error("Units do not match");
        const res = x.clone();
        res.value = typed2.find(self, [res.valueType(), y.valueType()])(
          res.value,
          y.value
        );
        res.fixPrefix = false;
        return res;
      })
    });
  }
);

// src/function/arithmetic/subtractScalar.ts
var name38 = "subtractScalar";
var dependencies39 = ["typed"];
var createSubtractScalar = /* @__PURE__ */ factory(
  name38,
  dependencies39,
  ({ typed: typed2 }) => {
    return typed2(name38, {
      "number, number": subtractNumber,
      "Complex, Complex": function(x, y) {
        return x.sub(y);
      },
      "BigNumber, BigNumber": function(x, y) {
        return x.minus(y);
      },
      "bigint, bigint": function(x, y) {
        return x - y;
      },
      "Fraction, Fraction": function(x, y) {
        return x.sub(y);
      },
      "Unit, Unit": typed2.referToSelf((self) => (x, y) => {
        if (x.value === null || x.value === void 0) {
          throw new Error("Parameter x contains a unit with undefined value");
        }
        if (y.value === null || y.value === void 0) {
          throw new Error("Parameter y contains a unit with undefined value");
        }
        if (!x.equalBase(y)) throw new Error("Units do not match");
        const res = x.clone();
        res.value = typed2.find(self, [res.valueType(), y.valueType()])(
          res.value,
          y.value
        );
        res.fixPrefix = false;
        return res;
      })
    });
  }
);

// src/function/arithmetic/cbrt.ts
var name39 = "cbrt";
var dependencies40 = [
  "config",
  "typed",
  "isNegative",
  "unaryMinus",
  "matrix",
  "Complex",
  "BigNumber",
  "Fraction"
];
var createCbrt = /* @__PURE__ */ factory(
  name39,
  dependencies40,
  ({
    config,
    typed: typed2,
    isNegative,
    unaryMinus,
    matrix,
    Complex: Complex2,
    BigNumber,
    Fraction: Fraction2
  }) => {
    return typed2(name39, {
      number: cbrtNumber,
      // note: signature 'number, boolean' is also supported,
      //       created by typed as it knows how to convert number to Complex
      Complex: _cbrtComplex,
      "Complex, boolean": _cbrtComplex,
      BigNumber: function(x) {
        return x.cbrt();
      },
      Unit: _cbrtUnit
    });
    function _cbrtComplex(x, allRoots) {
      const arg3 = x.arg() / 3;
      const abs = x.abs();
      const principal = new Complex2(cbrtNumber(abs), 0).mul(
        new Complex2(0, arg3).exp()
      );
      if (allRoots) {
        const all = [
          principal,
          new Complex2(cbrtNumber(abs), 0).mul(
            new Complex2(0, arg3 + Math.PI * 2 / 3).exp()
          ),
          new Complex2(cbrtNumber(abs), 0).mul(
            new Complex2(0, arg3 - Math.PI * 2 / 3).exp()
          )
        ];
        return config.matrix === "Array" ? all : matrix(all);
      } else {
        return principal;
      }
    }
    function _cbrtUnit(x) {
      if (x.value && isComplex(x.value)) {
        let result = x.clone();
        result.value = 1;
        result = result.pow(1 / 3);
        result.value = _cbrtComplex(x.value);
        return result;
      } else {
        const negate = isNegative(x.value);
        if (negate) {
          x.value = unaryMinus(x.value);
        }
        let third;
        if (isBigNumber(x.value)) {
          third = new BigNumber(1).div(3);
        } else if (isFraction(x.value)) {
          third = new Fraction2(1, 3);
        } else {
          third = 1 / 3;
        }
        const result = x.pow(third);
        if (negate) {
          result.value = unaryMinus(result.value);
        }
        return result;
      }
    }
  }
);

// src/type/matrix/utils/matAlgo11xS0s.ts
var name40 = "matAlgo11xS0s";
var dependencies41 = ["typed", "equalScalar"];
var createMatAlgo11xS0s = /* @__PURE__ */ factory(
  name40,
  dependencies41,
  ({
    typed: typed2,
    equalScalar
  }) => {
    return function matAlgo11xS0s(s, b, callback, inverse) {
      const avalues = s._values;
      const aindex = s._index;
      const aptr = s._ptr;
      const asize = s._size;
      const adt = s._datatype;
      if (!avalues) {
        throw new Error(
          "Cannot perform operation on Pattern Sparse Matrix and Scalar value"
        );
      }
      const rows = asize[0];
      const columns = asize[1];
      let dt;
      let eq = equalScalar;
      let zero = 0;
      let cf = callback;
      if (typeof adt === "string") {
        dt = adt;
        eq = typed2.find(equalScalar, [dt, dt]);
        zero = typed2.convert(0, dt);
        b = typed2.convert(b, dt);
        cf = typed2.find(callback, [dt, dt]);
      }
      const cvalues = [];
      const cindex = [];
      const cptr = [];
      for (let j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        for (let k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          const i = aindex[k];
          const v = inverse ? cf(b, avalues[k]) : cf(avalues[k], b);
          if (!eq(v, zero)) {
            cindex.push(i);
            cvalues.push(v);
          }
        }
      }
      cptr[columns] = cindex.length;
      return s.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  }
);

// src/type/matrix/utils/matAlgo12xSfs.ts
var name41 = "matAlgo12xSfs";
var dependencies42 = ["typed", "DenseMatrix"];
var createMatAlgo12xSfs = /* @__PURE__ */ factory(
  name41,
  dependencies42,
  ({
    typed: typed2,
    DenseMatrix
  }) => {
    return function matAlgo12xSfs(s, b, callback, inverse) {
      const avalues = s._values;
      const aindex = s._index;
      const aptr = s._ptr;
      const asize = s._size;
      const adt = s._datatype;
      if (!avalues) {
        throw new Error(
          "Cannot perform operation on Pattern Sparse Matrix and Scalar value"
        );
      }
      const rows = asize[0];
      const columns = asize[1];
      let dt;
      let cf = callback;
      if (typeof adt === "string") {
        dt = adt;
        b = typed2.convert(b, dt);
        cf = typed2.find(callback, [dt, dt]);
      }
      const cdata = [];
      const x = [];
      const w = [];
      for (let j = 0; j < columns; j++) {
        const mark = j + 1;
        for (let k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          const r = aindex[k];
          x[r] = avalues[k];
          w[r] = mark;
        }
        for (let i = 0; i < rows; i++) {
          if (j === 0) {
            cdata[i] = [];
          }
          if (w[i] === mark) {
            cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
          } else {
            cdata[i][j] = inverse ? cf(b, 0) : cf(0, b);
          }
        }
      }
      return new DenseMatrix({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
  }
);

// src/type/matrix/utils/matAlgo14xDs.ts
var name42 = "matAlgo14xDs";
var dependencies43 = ["typed"];
var createMatAlgo14xDs = /* @__PURE__ */ factory(
  name42,
  dependencies43,
  ({ typed: typed2 }) => {
    return function matAlgo14xDs(a, b, callback, inverse) {
      const adata = a._data;
      const asize = a._size;
      const adt = a._datatype;
      let dt;
      let cf = callback;
      if (typeof adt === "string") {
        dt = adt;
        b = typed2.convert(b, dt);
        cf = typed2.find(callback, [dt, dt]) || callback;
      }
      const cdata = asize.length > 0 ? _iterate(cf, 0, asize, asize[0], adata, b, inverse) : [];
      return a.createDenseMatrix({
        data: cdata,
        size: clone(asize),
        datatype: dt
      });
    };
    function _iterate(f, level, s, n, av, bv, inverse) {
      const cv = [];
      if (level === s.length - 1) {
        for (let i = 0; i < n; i++) {
          cv[i] = inverse ? f(bv, av[i]) : f(av[i], bv);
        }
      } else {
        for (let j = 0; j < n; j++) {
          cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv, inverse);
        }
      }
      return cv;
    }
  }
);

// src/function/arithmetic/ceil.ts
var name43 = "ceil";
var dependencies44 = [
  "typed",
  "config",
  "round",
  "matrix",
  "equalScalar",
  "zeros",
  "DenseMatrix"
];
var bigTen = new Decimal__default.default(10);
var createCeilNumber = /* @__PURE__ */ factory(
  name43,
  ["typed", "config", "round"],
  ({ typed: typed2, config, round }) => {
    function _ceilNumber(x) {
      const c = Math.ceil(x);
      const r = round(x);
      if (c === r) return c;
      if (nearlyEqual(x, r, config.relTol, config.absTol) && !nearlyEqual(x, c, config.relTol, config.absTol)) {
        return r;
      }
      return c;
    }
    return typed2(name43, {
      number: _ceilNumber,
      "number, number": function(x, n) {
        if (!isInteger(n)) {
          throw new RangeError(
            "number of decimals in function ceil must be an integer"
          );
        }
        if (n < 0 || n > 15) {
          throw new RangeError(
            "number of decimals in ceil number must be in range 0-15"
          );
        }
        const shift = 10 ** n;
        return _ceilNumber(x * shift) / shift;
      }
    });
  }
);
var createCeil = /* @__PURE__ */ factory(
  name43,
  dependencies44,
  ({
    typed: typed2,
    config,
    round,
    matrix,
    equalScalar,
    zeros: zeros2,
    DenseMatrix
  }) => {
    const matAlgo11xS0s = createMatAlgo11xS0s({ typed: typed2, equalScalar });
    const matAlgo12xSfs = createMatAlgo12xSfs({ typed: typed2, DenseMatrix });
    const matAlgo14xDs = createMatAlgo14xDs({ typed: typed2 });
    const ceilNumber = createCeilNumber({ typed: typed2, config, round });
    function _bigCeil(x) {
      const bne = (a, b) => nearlyEqual2(a, b, config.relTol, config.absTol);
      const c = x.ceil();
      const r = round(x);
      if (c.eq(r)) return c;
      if (bne(x, r) && !bne(x, c)) return r;
      return c;
    }
    return typed2("ceil", {
      number: ceilNumber.signatures.number,
      "number,number": ceilNumber.signatures["number,number"],
      Complex: function(x) {
        return x.ceil();
      },
      "Complex, number": function(x, n) {
        return x.ceil(n);
      },
      "Complex, BigNumber": function(x, n) {
        return x.ceil(n.toNumber());
      },
      BigNumber: _bigCeil,
      "BigNumber, BigNumber": function(x, n) {
        const shift = bigTen.pow(n);
        return _bigCeil(x.mul(shift)).div(shift);
      },
      bigint: (b) => b,
      "bigint, number": (b, _dummy) => b,
      "bigint, BigNumber": (b, _dummy) => b,
      Fraction: function(x) {
        return x.ceil();
      },
      "Fraction, number": function(x, n) {
        return x.ceil(n);
      },
      "Fraction, BigNumber": function(x, n) {
        return x.ceil(n.toNumber());
      },
      "Unit, number, Unit": typed2.referToSelf(
        (self) => function(x, n, unit) {
          const valueless = x.toNumeric(unit);
          return unit.multiply(self(valueless, n));
        }
      ),
      "Unit, BigNumber, Unit": typed2.referToSelf(
        (self) => (x, n, unit) => self(x, n.toNumber(), unit)
      ),
      "Array | Matrix, number | BigNumber, Unit": typed2.referToSelf(
        (self) => (x, n, unit) => {
          return deepMap2(x, (value) => self(value, n, unit), true);
        }
      ),
      "Array | Matrix | Unit, Unit": typed2.referToSelf(
        (self) => (x, unit) => self(x, 0, unit)
      ),
      "Array | Matrix": typed2.referToSelf((self) => (x) => {
        return deepMap2(x, self, true);
      }),
      "Array, number | BigNumber": typed2.referToSelf(
        (self) => (x, n) => {
          return deepMap2(x, (i) => self(i, n), true);
        }
      ),
      "SparseMatrix, number | BigNumber": typed2.referToSelf(
        (self) => (x, y) => {
          return matAlgo11xS0s(x, y, self, false);
        }
      ),
      "DenseMatrix, number | BigNumber": typed2.referToSelf(
        (self) => (x, y) => {
          return matAlgo14xDs(x, y, self, false);
        }
      ),
      "number | Complex | Fraction | BigNumber, Array": typed2.referToSelf(
        (self) => (x, y) => {
          return matAlgo14xDs(matrix(y), x, self, true).valueOf();
        }
      ),
      "number | Complex | Fraction | BigNumber, Matrix": typed2.referToSelf(
        (self) => (x, y) => {
          if (equalScalar(x, 0)) return zeros2(y.size(), y.storage());
          if (y.storage() === "dense") {
            return matAlgo14xDs(y, x, self, true);
          }
          return matAlgo12xSfs(y, x, self, true);
        }
      )
    });
  }
);

// src/function/arithmetic/cube.ts
var name44 = "cube";
var dependencies45 = ["typed"];
var createCube = /* @__PURE__ */ factory(
  name44,
  dependencies45,
  ({ typed: typed2 }) => {
    return typed2(name44, {
      number: cubeNumber,
      Complex: function(x) {
        return x.mul(x).mul(x);
      },
      BigNumber: function(x) {
        return x.times(x).times(x);
      },
      bigint: function(x) {
        return x * x * x;
      },
      Fraction: function(x) {
        return x.pow(3);
      },
      Unit: function(x) {
        return x.pow(3);
      }
    });
  }
);

// src/function/arithmetic/exp.ts
var name45 = "exp";
var dependencies46 = ["typed"];
var createExp = /* @__PURE__ */ factory(
  name45,
  dependencies46,
  ({ typed: typed2 }) => {
    return typed2(name45, {
      number: expNumber,
      Complex: function(x) {
        return x.exp();
      },
      BigNumber: function(x) {
        return x.exp();
      }
    });
  }
);

// src/function/arithmetic/expm1.ts
var name46 = "expm1";
var dependencies47 = ["typed", "Complex"];
var createExpm1 = /* @__PURE__ */ factory(
  name46,
  dependencies47,
  ({ typed: typed2, Complex: Complex2 }) => {
    return typed2(name46, {
      number: expm1Number,
      Complex: function(x) {
        const r = Math.exp(x.re);
        return new Complex2(r * Math.cos(x.im) - 1, r * Math.sin(x.im));
      },
      BigNumber: function(x) {
        return x.exp().minus(1);
      }
    });
  }
);

// src/function/arithmetic/fix.ts
var name47 = "fix";
var dependencies48 = [
  "typed",
  "Complex",
  "matrix",
  "ceil",
  "floor",
  "equalScalar",
  "zeros",
  "DenseMatrix"
];
var createFixNumber = /* @__PURE__ */ factory(
  name47,
  ["typed", "ceil", "floor"],
  ({ typed: typed2, ceil, floor }) => {
    return typed2(name47, {
      number: function(x) {
        return x > 0 ? floor(x) : ceil(x);
      },
      "number, number": function(x, n) {
        return x > 0 ? floor(x, n) : ceil(x, n);
      }
    });
  }
);
var createFix = /* @__PURE__ */ factory(
  name47,
  dependencies48,
  ({
    typed: typed2,
    Complex: Complex2,
    matrix,
    ceil,
    floor,
    equalScalar,
    zeros: zeros2,
    DenseMatrix
  }) => {
    const matAlgo12xSfs = createMatAlgo12xSfs({ typed: typed2, DenseMatrix });
    const matAlgo14xDs = createMatAlgo14xDs({ typed: typed2 });
    const fixNumber = createFixNumber({ typed: typed2, ceil, floor });
    return typed2("fix", {
      number: fixNumber.signatures.number,
      "number, number | BigNumber": fixNumber.signatures["number,number"],
      Complex: function(x) {
        return new Complex2(
          x.re > 0 ? Math.floor(x.re) : Math.ceil(x.re),
          x.im > 0 ? Math.floor(x.im) : Math.ceil(x.im)
        );
      },
      "Complex, number": function(x, n) {
        return new Complex2(
          x.re > 0 ? floor(x.re, n) : ceil(x.re, n),
          x.im > 0 ? floor(x.im, n) : ceil(x.im, n)
        );
      },
      "Complex, BigNumber": function(x, bn) {
        const n = bn.toNumber();
        return new Complex2(
          x.re > 0 ? floor(x.re, n) : ceil(x.re, n),
          x.im > 0 ? floor(x.im, n) : ceil(x.im, n)
        );
      },
      BigNumber: function(x) {
        return x.isNegative() ? ceil(x) : floor(x);
      },
      "BigNumber, number | BigNumber": function(x, n) {
        return x.isNegative() ? ceil(x, n) : floor(x, n);
      },
      bigint: (b) => b,
      "bigint, number": (b, _dummy) => b,
      "bigint, BigNumber": (b, _dummy) => b,
      Fraction: function(x) {
        return x.s < 0n ? x.ceil() : x.floor();
      },
      "Fraction, number | BigNumber": function(x, n) {
        return x.s < 0n ? ceil(x, n) : floor(x, n);
      },
      "Unit, number, Unit": typed2.referToSelf(
        (self) => function(x, n, unit) {
          const valueless = x.toNumeric(unit);
          return unit.multiply(self(valueless, n));
        }
      ),
      "Unit, BigNumber, Unit": typed2.referToSelf(
        (self) => (x, n, unit) => self(x, n.toNumber(), unit)
      ),
      "Array | Matrix, number | BigNumber, Unit": typed2.referToSelf(
        (self) => (x, n, unit) => {
          return deepMap2(x, (value) => self(value, n, unit), true);
        }
      ),
      "Array | Matrix | Unit, Unit": typed2.referToSelf(
        (self) => (x, unit) => self(x, 0, unit)
      ),
      "Array | Matrix": typed2.referToSelf((self) => (x) => {
        return deepMap2(x, self, true);
      }),
      "Array | Matrix, number | BigNumber": typed2.referToSelf(
        (self) => (x, n) => {
          return deepMap2(x, (i) => self(i, n), true);
        }
      ),
      "number | Complex | Fraction | BigNumber, Array": typed2.referToSelf(
        (self) => (x, y) => {
          return matAlgo14xDs(matrix(y), x, self, true).valueOf();
        }
      ),
      "number | Complex | Fraction | BigNumber, Matrix": typed2.referToSelf(
        (self) => (x, y) => {
          if (equalScalar(x, 0)) return zeros2(y.size(), y.storage());
          if (y.storage() === "dense") {
            return matAlgo14xDs(y, x, self, true);
          }
          return matAlgo12xSfs(y, x, self, true);
        }
      )
    });
  }
);
var name48 = "floor";
var dependencies49 = [
  "typed",
  "config",
  "round",
  "matrix",
  "equalScalar",
  "zeros",
  "DenseMatrix"
];
var bigTen2 = new Decimal__default.default(10);
var createFloorNumber = /* @__PURE__ */ factory(
  name48,
  ["typed", "config", "round"],
  ({ typed: typed2, config, round }) => {
    function _floorNumber(x) {
      const f = Math.floor(x);
      const r = round(x);
      if (f === r) return f;
      if (nearlyEqual(x, r, config.relTol, config.absTol) && !nearlyEqual(x, f, config.relTol, config.absTol)) {
        return r;
      }
      return f;
    }
    return typed2(name48, {
      number: _floorNumber,
      "number, number": function(x, n) {
        if (!isInteger(n)) {
          throw new RangeError(
            "number of decimals in function floor must be an integer"
          );
        }
        if (n < 0 || n > 15) {
          throw new RangeError(
            "number of decimals in floor number must be in range 0 - 15"
          );
        }
        const shift = 10 ** n;
        return _floorNumber(x * shift) / shift;
      }
    });
  }
);
var createFloor = /* @__PURE__ */ factory(
  name48,
  dependencies49,
  ({
    typed: typed2,
    config,
    round,
    matrix,
    equalScalar,
    zeros: zeros2,
    DenseMatrix
  }) => {
    const matAlgo11xS0s = createMatAlgo11xS0s({ typed: typed2, equalScalar });
    const matAlgo12xSfs = createMatAlgo12xSfs({ typed: typed2, DenseMatrix });
    const matAlgo14xDs = createMatAlgo14xDs({ typed: typed2 });
    const floorNumber = createFloorNumber({ typed: typed2, config, round });
    function _bigFloor(x) {
      const bne = (a, b) => nearlyEqual2(a, b, config.relTol, config.absTol);
      const f = x.floor();
      const r = round(x);
      if (f.eq(r)) return f;
      if (bne(x, r) && !bne(x, f)) return r;
      return f;
    }
    return typed2("floor", {
      number: floorNumber.signatures.number,
      "number,number": floorNumber.signatures["number,number"],
      Complex: function(x) {
        return x.floor();
      },
      "Complex, number": function(x, n) {
        return x.floor(n);
      },
      "Complex, BigNumber": function(x, n) {
        return x.floor(n.toNumber());
      },
      BigNumber: _bigFloor,
      "BigNumber, BigNumber": function(x, n) {
        const shift = bigTen2.pow(n);
        return _bigFloor(x.mul(shift)).div(shift);
      },
      bigint: (b) => b,
      "bigint, number": (b, _dummy) => b,
      "bigint, BigNumber": (b, _dummy) => b,
      Fraction: function(x) {
        return x.floor();
      },
      "Fraction, number": function(x, n) {
        return x.floor(n);
      },
      "Fraction, BigNumber": function(x, n) {
        return x.floor(n.toNumber());
      },
      "Unit, number, Unit": typed2.referToSelf(
        (self) => function(x, n, unit) {
          const valueless = x.toNumeric(unit);
          return unit.multiply(self(valueless, n));
        }
      ),
      "Unit, BigNumber, Unit": typed2.referToSelf(
        (self) => (x, n, unit) => self(x, n.toNumber(), unit)
      ),
      "Array | Matrix, number | BigNumber, Unit": typed2.referToSelf(
        (self) => (x, n, unit) => {
          return deepMap2(x, (value) => self(value, n, unit), true);
        }
      ),
      "Array | Matrix | Unit, Unit": typed2.referToSelf(
        (self) => (x, unit) => self(x, 0, unit)
      ),
      "Array | Matrix": typed2.referToSelf((self) => (x) => {
        return deepMap2(x, self, true);
      }),
      "Array, number | BigNumber": typed2.referToSelf(
        (self) => (x, n) => {
          return deepMap2(x, (i) => self(i, n), true);
        }
      ),
      "SparseMatrix, number | BigNumber": typed2.referToSelf(
        (self) => (x, y) => {
          return matAlgo11xS0s(x, y, self, false);
        }
      ),
      "DenseMatrix, number | BigNumber": typed2.referToSelf(
        (self) => (x, y) => {
          return matAlgo14xDs(x, y, self, false);
        }
      ),
      "number | Complex | Fraction | BigNumber, Array": typed2.referToSelf(
        (self) => (x, y) => {
          return matAlgo14xDs(matrix(y), x, self, true).valueOf();
        }
      ),
      "number | Complex | Fraction | BigNumber, Matrix": typed2.referToSelf(
        (self) => (x, y) => {
          if (equalScalar(x, 0)) return zeros2(y.size(), y.storage());
          if (y.storage() === "dense") {
            return matAlgo14xDs(y, x, self, true);
          }
          return matAlgo12xSfs(y, x, self, true);
        }
      )
    });
  }
);

// src/type/matrix/utils/matAlgo02xDS0.ts
var name49 = "matAlgo02xDS0";
var dependencies50 = ["typed", "equalScalar"];
var createMatAlgo02xDS0 = /* @__PURE__ */ factory(
  name49,
  dependencies50,
  ({
    typed: typed2,
    equalScalar
  }) => {
    return function matAlgo02xDS0(denseMatrix, sparseMatrix, callback, inverse) {
      const adata = denseMatrix._data;
      const asize = denseMatrix._size;
      const adt = denseMatrix._datatype || denseMatrix.getDataType();
      const bvalues = sparseMatrix._values;
      const bindex = sparseMatrix._index;
      const bptr = sparseMatrix._ptr;
      const bsize = sparseMatrix._size;
      const bdt = sparseMatrix._datatype || sparseMatrix._data === void 0 ? sparseMatrix._datatype : sparseMatrix.getDataType();
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError(
          "Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")"
        );
      }
      if (!bvalues) {
        throw new Error(
          "Cannot perform operation on Dense Matrix and Pattern Sparse Matrix"
        );
      }
      const rows = asize[0];
      const columns = asize[1];
      let dt;
      let eq = equalScalar;
      let zero = 0;
      let cf = callback;
      if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
        dt = adt;
        eq = typed2.find(equalScalar, [dt, dt]);
        zero = typed2.convert(0, dt);
        cf = typed2.find(callback, [dt, dt]);
      }
      const cvalues = [];
      const cindex = [];
      const cptr = [];
      for (let j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        for (let k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          const i = bindex[k];
          const cij = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
          if (!eq(cij, zero)) {
            cindex.push(i);
            cvalues.push(cij);
          }
        }
      }
      cptr[columns] = cindex.length;
      return sparseMatrix.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: adt === denseMatrix._datatype && bdt === sparseMatrix._datatype ? dt : void 0
      });
    };
  }
);

// src/type/matrix/utils/matAlgo03xDSf.ts
var name50 = "matAlgo03xDSf";
var dependencies51 = ["typed"];
var createMatAlgo03xDSf = /* @__PURE__ */ factory(
  name50,
  dependencies51,
  ({ typed: typed2 }) => {
    return function matAlgo03xDSf(denseMatrix, sparseMatrix, callback, inverse) {
      const adata = denseMatrix._data;
      const asize = denseMatrix._size;
      const adt = denseMatrix._datatype || denseMatrix.getDataType();
      const bvalues = sparseMatrix._values;
      const bindex = sparseMatrix._index;
      const bptr = sparseMatrix._ptr;
      const bsize = sparseMatrix._size;
      const bdt = sparseMatrix._datatype || sparseMatrix._data === void 0 ? sparseMatrix._datatype : sparseMatrix.getDataType();
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError(
          "Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")"
        );
      }
      if (!bvalues) {
        throw new Error(
          "Cannot perform operation on Dense Matrix and Pattern Sparse Matrix"
        );
      }
      const rows = asize[0];
      const columns = asize[1];
      let dt;
      let zero = 0;
      let cf = callback;
      if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
        dt = adt;
        zero = typed2.convert(0, dt);
        cf = typed2.find(callback, [dt, dt]);
      }
      const cdata = [];
      for (let z = 0; z < rows; z++) {
        cdata[z] = [];
      }
      const x = [];
      const w = [];
      for (let j = 0; j < columns; j++) {
        const mark = j + 1;
        for (let k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          const i = bindex[k];
          x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
          w[i] = mark;
        }
        for (let y = 0; y < rows; y++) {
          if (w[y] === mark) {
            cdata[y][j] = x[y];
          } else {
            cdata[y][j] = inverse ? cf(zero, adata[y][j]) : cf(adata[y][j], zero);
          }
        }
      }
      return denseMatrix.createDenseMatrix({
        data: cdata,
        size: [rows, columns],
        datatype: adt === denseMatrix._datatype && bdt === sparseMatrix._datatype ? dt : void 0
      });
    };
  }
);

// src/type/matrix/utils/matAlgo05xSfSf.ts
var name51 = "matAlgo05xSfSf";
var dependencies52 = ["typed", "equalScalar"];
var createMatAlgo05xSfSf = /* @__PURE__ */ factory(
  name51,
  dependencies52,
  ({
    typed: typed2,
    equalScalar
  }) => {
    return function matAlgo05xSfSf(a, b, callback) {
      const avalues = a._values;
      const aindex = a._index;
      const aptr = a._ptr;
      const asize = a._size;
      const adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
      const bvalues = b._values;
      const bindex = b._index;
      const bptr = b._ptr;
      const bsize = b._size;
      const bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError(
          "Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")"
        );
      }
      const rows = asize[0];
      const columns = asize[1];
      let dt;
      let eq = equalScalar;
      let zero = 0;
      let cf = callback;
      if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
        dt = adt;
        eq = typed2.find(equalScalar, [dt, dt]);
        zero = typed2.convert(0, dt);
        cf = typed2.find(callback, [dt, dt]);
      }
      const cvalues = avalues && bvalues ? [] : void 0;
      const cindex = [];
      const cptr = [];
      const xa = cvalues ? [] : void 0;
      const xb = cvalues ? [] : void 0;
      const wa = [];
      const wb = [];
      let i, j, k, k1;
      for (j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        const mark = j + 1;
        for (k = aptr[j], k1 = aptr[j + 1]; k < k1; k++) {
          i = aindex[k];
          cindex.push(i);
          wa[i] = mark;
          if (xa && avalues) {
            xa[i] = avalues[k];
          }
        }
        for (k = bptr[j], k1 = bptr[j + 1]; k < k1; k++) {
          i = bindex[k];
          if (wa[i] !== mark) {
            cindex.push(i);
          }
          wb[i] = mark;
          if (xb && bvalues) {
            xb[i] = bvalues[k];
          }
        }
        if (cvalues) {
          k = cptr[j];
          while (k < cindex.length) {
            i = cindex[k];
            const wai = wa[i];
            const wbi = wb[i];
            if (wai === mark || wbi === mark) {
              const va = wai === mark ? xa[i] : zero;
              const vb = wbi === mark ? xb[i] : zero;
              const vc = cf(va, vb);
              if (!eq(vc, zero)) {
                cvalues.push(vc);
                k++;
              } else {
                cindex.splice(k, 1);
              }
            }
          }
        }
      }
      cptr[columns] = cindex.length;
      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
      });
    };
  }
);

// src/type/matrix/utils/matAlgo13xDD.ts
var name52 = "matAlgo13xDD";
var dependencies53 = ["typed"];
var createMatAlgo13xDD = /* @__PURE__ */ factory(
  name52,
  dependencies53,
  ({ typed: typed2 }) => {
    return function matAlgo13xDD(a, b, callback) {
      const adata = a._data;
      const asize = a._size;
      const adt = a._datatype;
      const bdata = b._data;
      const bsize = b._size;
      const bdt = b._datatype;
      const csize = [];
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      for (let s = 0; s < asize.length; s++) {
        if (asize[s] !== bsize[s]) {
          throw new RangeError(
            "Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")"
          );
        }
        csize[s] = asize[s];
      }
      let dt;
      let cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        cf = typed2.find(callback, [dt, dt]) || callback;
      }
      const cdata = csize.length > 0 ? _iterate(cf, 0, csize, csize[0], adata, bdata) : [];
      return a.createDenseMatrix({
        data: cdata,
        size: csize,
        datatype: dt
      });
    };
    function _iterate(f, level, s, n, av, bv) {
      const cv = [];
      if (level === s.length - 1) {
        for (let i = 0; i < n; i++) {
          cv[i] = f(av[i], bv[i]);
        }
      } else {
        for (let j = 0; j < n; j++) {
          cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv[j]);
        }
      }
      return cv;
    }
  }
);

// src/type/matrix/utils/broadcast.ts
function broadcast(A, B) {
  if (deepStrictEqual(A.size(), B.size())) {
    return [A, B];
  }
  const newSize = broadcastSizes(A.size(), B.size());
  return [A, B].map((M) => _broadcastTo(M, newSize));
}
function _broadcastTo(M, size) {
  if (deepStrictEqual(M.size(), size)) {
    return M;
  }
  return M.create(broadcastTo(M.valueOf(), size), M.datatype());
}

// src/type/matrix/utils/matrixAlgorithmSuite.ts
var name53 = "matrixAlgorithmSuite";
var dependencies54 = ["typed", "matrix"];
var createMatrixAlgorithmSuite = /* @__PURE__ */ factory(
  name53,
  dependencies54,
  ({ typed: typed2, matrix }) => {
    const matAlgo13xDD = createMatAlgo13xDD({ typed: typed2 });
    const matAlgo14xDs = createMatAlgo14xDs({ typed: typed2 });
    return function matrixAlgorithmSuite(options) {
      const elop = options.elop;
      const SD = options.SD || options.DS;
      let matrixSignatures;
      if (elop) {
        matrixSignatures = {
          "DenseMatrix, DenseMatrix": (x, y) => matAlgo13xDD(...broadcast(x, y), elop),
          "Array, Array": (x, y) => matAlgo13xDD(
            ...broadcast(matrix(x), matrix(y)),
            elop
          ).valueOf(),
          "Array, DenseMatrix": (x, y) => matAlgo13xDD(
            ...broadcast(matrix(x), y),
            elop
          ),
          "DenseMatrix, Array": (x, y) => matAlgo13xDD(
            ...broadcast(x, matrix(y)),
            elop
          )
        };
        if (options.SS) {
          matrixSignatures["SparseMatrix, SparseMatrix"] = (x, y) => options.SS(...broadcast(x, y), elop, false);
        }
        if (options.DS) {
          matrixSignatures["DenseMatrix, SparseMatrix"] = (x, y) => options.DS(...broadcast(x, y), elop, false);
          matrixSignatures["Array, SparseMatrix"] = (x, y) => options.DS(...broadcast(matrix(x), y), elop, false);
        }
        if (SD) {
          matrixSignatures["SparseMatrix, DenseMatrix"] = (x, y) => SD(...broadcast(y, x), elop, true);
          matrixSignatures["SparseMatrix, Array"] = (x, y) => SD(...broadcast(matrix(y), x), elop, true);
        }
      } else {
        matrixSignatures = {
          "DenseMatrix, DenseMatrix": typed2.referToSelf(
            (self) => (x, y) => {
              return matAlgo13xDD(...broadcast(x, y), self);
            }
          ),
          "Array, Array": typed2.referToSelf(
            (self) => (x, y) => {
              return matAlgo13xDD(
                ...broadcast(matrix(x), matrix(y)),
                self
              ).valueOf();
            }
          ),
          "Array, DenseMatrix": typed2.referToSelf(
            (self) => (x, y) => {
              return matAlgo13xDD(
                ...broadcast(matrix(x), y),
                self
              );
            }
          ),
          "DenseMatrix, Array": typed2.referToSelf(
            (self) => (x, y) => {
              return matAlgo13xDD(
                ...broadcast(x, matrix(y)),
                self
              );
            }
          )
        };
        if (options.SS) {
          matrixSignatures["SparseMatrix, SparseMatrix"] = typed2.referToSelf(
            (self) => (x, y) => {
              return options.SS(...broadcast(x, y), self, false);
            }
          );
        }
        if (options.DS) {
          matrixSignatures["DenseMatrix, SparseMatrix"] = typed2.referToSelf(
            (self) => (x, y) => {
              return options.DS(...broadcast(x, y), self, false);
            }
          );
          matrixSignatures["Array, SparseMatrix"] = typed2.referToSelf(
            (self) => (x, y) => {
              return options.DS(
                ...broadcast(matrix(x), y),
                self,
                false
              );
            }
          );
        }
        if (SD) {
          matrixSignatures["SparseMatrix, DenseMatrix"] = typed2.referToSelf(
            (self) => (x, y) => {
              return SD(...broadcast(y, x), self, true);
            }
          );
          matrixSignatures["SparseMatrix, Array"] = typed2.referToSelf(
            (self) => (x, y) => {
              return SD(...broadcast(matrix(y), x), self, true);
            }
          );
        }
      }
      const scalar = options.scalar || "any";
      const Ds = options.Ds || options.Ss;
      if (Ds) {
        if (elop) {
          matrixSignatures["DenseMatrix," + scalar] = (x, y) => matAlgo14xDs(x, y, elop, false);
          matrixSignatures[scalar + ", DenseMatrix"] = (x, y) => matAlgo14xDs(y, x, elop, true);
          matrixSignatures["Array," + scalar] = (x, y) => matAlgo14xDs(matrix(x), y, elop, false).valueOf();
          matrixSignatures[scalar + ", Array"] = (x, y) => matAlgo14xDs(matrix(y), x, elop, true).valueOf();
        } else {
          matrixSignatures["DenseMatrix," + scalar] = typed2.referToSelf(
            (self) => (x, y) => {
              return matAlgo14xDs(x, y, self, false);
            }
          );
          matrixSignatures[scalar + ", DenseMatrix"] = typed2.referToSelf(
            (self) => (x, y) => {
              return matAlgo14xDs(y, x, self, true);
            }
          );
          matrixSignatures["Array," + scalar] = typed2.referToSelf(
            (self) => (x, y) => {
              return matAlgo14xDs(matrix(x), y, self, false).valueOf();
            }
          );
          matrixSignatures[scalar + ", Array"] = typed2.referToSelf(
            (self) => (x, y) => {
              return matAlgo14xDs(matrix(y), x, self, true).valueOf();
            }
          );
        }
      }
      const sS = options.sS !== void 0 ? options.sS : options.Ss;
      if (elop) {
        if (options.Ss) {
          matrixSignatures["SparseMatrix," + scalar] = (x, y) => options.Ss(x, y, elop, false);
        }
        if (sS) {
          matrixSignatures[scalar + ", SparseMatrix"] = (x, y) => sS(y, x, elop, true);
        }
      } else {
        if (options.Ss) {
          matrixSignatures["SparseMatrix," + scalar] = typed2.referToSelf(
            (self) => (x, y) => {
              return options.Ss(x, y, self, false);
            }
          );
        }
        if (sS) {
          matrixSignatures[scalar + ", SparseMatrix"] = typed2.referToSelf(
            (self) => (x, y) => {
              return sS(y, x, self, true);
            }
          );
        }
      }
      if (elop && elop.signatures) {
        extend(matrixSignatures, elop.signatures);
      }
      return matrixSignatures;
    };
  }
);

// src/function/arithmetic/mod.ts
var name54 = "mod";
var dependencies55 = [
  "typed",
  "config",
  "round",
  "matrix",
  "equalScalar",
  "zeros",
  "DenseMatrix",
  "concat"
];
var createMod = /* @__PURE__ */ factory(
  name54,
  dependencies55,
  ({
    typed: typed2,
    config,
    round,
    matrix,
    equalScalar,
    zeros: zeros2,
    DenseMatrix,
    concat: concat2
  }) => {
    const floor = createFloor({
      typed: typed2,
      config,
      round,
      matrix,
      equalScalar,
      zeros: zeros2,
      DenseMatrix
    });
    const matAlgo02xDS0 = createMatAlgo02xDS0({ typed: typed2, equalScalar });
    const matAlgo03xDSf = createMatAlgo03xDSf({ typed: typed2 });
    const matAlgo05xSfSf = createMatAlgo05xSfSf({ typed: typed2, equalScalar });
    const matAlgo11xS0s = createMatAlgo11xS0s({ typed: typed2, equalScalar });
    const matAlgo12xSfs = createMatAlgo12xSfs({ typed: typed2, DenseMatrix });
    const matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed2,
      matrix,
      concat: concat2
    });
    return typed2(
      name54,
      {
        "number, number": _modNumber,
        "BigNumber, BigNumber": function(x, y) {
          return y.isZero() ? x : x.sub(y.mul(floor(x.div(y))));
        },
        "bigint, bigint": function(x, y) {
          if (y === 0n) {
            return x;
          }
          if (x < 0) {
            const m = x % y;
            return m === 0n ? m : m + y;
          }
          return x % y;
        },
        "Fraction, Fraction": function(x, y) {
          return y.equals(0) ? x : x.sub(y.mul(floor(x.div(y))));
        }
      },
      matrixAlgorithmSuite({
        SS: matAlgo05xSfSf,
        DS: matAlgo03xDSf,
        SD: matAlgo02xDS0,
        Ss: matAlgo11xS0s,
        sS: matAlgo12xSfs
      })
    );
    function _modNumber(x, y) {
      return y === 0 ? x : x - y * floor(x / y);
    }
  }
);

// src/type/matrix/utils/matAlgo01xDSid.ts
var name55 = "matAlgo01xDSid";
var dependencies56 = ["typed"];
var createMatAlgo01xDSid = /* @__PURE__ */ factory(
  name55,
  dependencies56,
  ({ typed: typed2 }) => {
    return function algorithm1(denseMatrix, sparseMatrix, callback, inverse) {
      const adata = denseMatrix._data;
      const asize = denseMatrix._size;
      const adt = denseMatrix._datatype || denseMatrix.getDataType();
      const bvalues = sparseMatrix._values;
      const bindex = sparseMatrix._index;
      const bptr = sparseMatrix._ptr;
      const bsize = sparseMatrix._size;
      const bdt = sparseMatrix._datatype || sparseMatrix._data === void 0 ? sparseMatrix._datatype : sparseMatrix.getDataType();
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError(
          "Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")"
        );
      }
      if (!bvalues) {
        throw new Error(
          "Cannot perform operation on Dense Matrix and Pattern Sparse Matrix"
        );
      }
      const rows = asize[0];
      const columns = asize[1];
      const dt = typeof adt === "string" && adt !== "mixed" && adt === bdt ? adt : void 0;
      const cf = dt ? typed2.find(callback, [dt, dt]) || callback : callback;
      let i, j;
      const cdata = [];
      for (i = 0; i < rows; i++) {
        cdata[i] = [];
      }
      const x = [];
      const w = [];
      for (j = 0; j < columns; j++) {
        const mark = j + 1;
        for (let k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          i = bindex[k];
          x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
          w[i] = mark;
        }
        for (i = 0; i < rows; i++) {
          if (w[i] === mark) {
            cdata[i][j] = x[i];
          } else {
            cdata[i][j] = adata[i][j];
          }
        }
      }
      return denseMatrix.createDenseMatrix({
        data: cdata,
        size: [rows, columns],
        datatype: adt === denseMatrix._datatype && bdt === sparseMatrix._datatype ? dt : void 0
      });
    };
  }
);

// src/type/matrix/utils/matAlgo04xSidSid.ts
var name56 = "matAlgo04xSidSid";
var dependencies57 = ["typed", "equalScalar"];
var createMatAlgo04xSidSid = /* @__PURE__ */ factory(
  name56,
  dependencies57,
  ({
    typed: typed2,
    equalScalar
  }) => {
    return function matAlgo04xSidSid(a, b, callback) {
      const avalues = a._values;
      const aindex = a._index;
      const aptr = a._ptr;
      const asize = a._size;
      const adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
      const bvalues = b._values;
      const bindex = b._index;
      const bptr = b._ptr;
      const bsize = b._size;
      const bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError(
          "Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")"
        );
      }
      const rows = asize[0];
      const columns = asize[1];
      let dt;
      let eq = equalScalar;
      let zero = 0;
      let cf = callback;
      if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
        dt = adt;
        eq = typed2.find(equalScalar, [dt, dt]);
        zero = typed2.convert(0, dt);
        cf = typed2.find(callback, [dt, dt]);
      }
      const cvalues = avalues && bvalues ? [] : void 0;
      const cindex = [];
      const cptr = [];
      const xa = avalues && bvalues ? [] : void 0;
      const xb = avalues && bvalues ? [] : void 0;
      const wa = [];
      const wb = [];
      let i, j, k, k0, k1;
      for (j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        const mark = j + 1;
        for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          i = aindex[k];
          cindex.push(i);
          wa[i] = mark;
          if (xa && avalues) {
            xa[i] = avalues[k];
          }
        }
        for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          i = bindex[k];
          if (wa[i] === mark) {
            if (xa && bvalues) {
              const v = cf(xa[i], bvalues[k]);
              if (!eq(v, zero)) {
                xa[i] = v;
              } else {
                wa[i] = null;
              }
            }
          } else {
            cindex.push(i);
            wb[i] = mark;
            if (xb && bvalues) {
              xb[i] = bvalues[k];
            }
          }
        }
        if (xa && xb) {
          k = cptr[j];
          while (k < cindex.length) {
            i = cindex[k];
            if (wa[i] === mark) {
              cvalues[k] = xa[i];
              k++;
            } else if (wb[i] === mark) {
              cvalues[k] = xb[i];
              k++;
            } else {
              cindex.splice(k, 1);
            }
          }
        }
      }
      cptr[columns] = cindex.length;
      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
      });
    };
  }
);

// src/type/matrix/utils/matAlgo10xSids.ts
var name57 = "matAlgo10xSids";
var dependencies58 = ["typed", "DenseMatrix"];
var createMatAlgo10xSids = /* @__PURE__ */ factory(
  name57,
  dependencies58,
  ({
    typed: typed2,
    DenseMatrix
  }) => {
    return function matAlgo10xSids(s, b, callback, inverse) {
      const avalues = s._values;
      const aindex = s._index;
      const aptr = s._ptr;
      const asize = s._size;
      const adt = s._datatype;
      if (!avalues) {
        throw new Error(
          "Cannot perform operation on Pattern Sparse Matrix and Scalar value"
        );
      }
      const rows = asize[0];
      const columns = asize[1];
      let dt;
      let cf = callback;
      if (typeof adt === "string") {
        dt = adt;
        b = typed2.convert(b, dt);
        cf = typed2.find(callback, [dt, dt]);
      }
      const cdata = [];
      const x = [];
      const w = [];
      for (let j = 0; j < columns; j++) {
        const mark = j + 1;
        for (let k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          const r = aindex[k];
          x[r] = avalues[k];
          w[r] = mark;
        }
        for (let i = 0; i < rows; i++) {
          if (j === 0) {
            cdata[i] = [];
          }
          if (w[i] === mark) {
            cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
          } else {
            cdata[i][j] = b;
          }
        }
      }
      return new DenseMatrix({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
  }
);

// src/error/ArgumentsError.ts
var ArgumentsError = class _ArgumentsError extends Error {
  /**
   * Create an ArgumentsError
   * @param fn     Function name
   * @param count  Actual argument count
   * @param min    Minimum required argument count
   * @param max    Maximum required argument count (optional)
   */
  constructor(fn, count, min, max) {
    const message = "Wrong number of arguments in function " + fn + " (" + count + " provided, " + min + (max !== void 0 && max !== null ? "-" + max : "") + " expected)";
    super(message);
    this.isArgumentsError = true;
    this.fn = fn;
    this.count = count;
    this.min = min;
    this.max = max;
    this.name = "ArgumentsError";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _ArgumentsError);
    }
  }
};

// src/function/arithmetic/gcd.ts
var name58 = "gcd";
var dependencies59 = [
  "typed",
  "config",
  "round",
  "matrix",
  "equalScalar",
  "zeros",
  "BigNumber",
  "DenseMatrix",
  "concat"
];
var gcdTypes = "number | BigNumber | Fraction | Matrix | Array";
var gcdManyTypesSignature = `${gcdTypes}, ${gcdTypes}, ...${gcdTypes}`;
function is1d(array) {
  return !array.some((element) => Array.isArray(element));
}
var createGcd = /* @__PURE__ */ factory(
  name58,
  dependencies59,
  ({
    typed: typed2,
    matrix,
    config,
    round,
    equalScalar,
    zeros: zeros2,
    BigNumber,
    DenseMatrix,
    concat: concat2
  }) => {
    const mod = createMod({
      typed: typed2,
      config,
      round,
      matrix,
      equalScalar,
      zeros: zeros2,
      DenseMatrix,
      concat: concat2
    });
    const matAlgo01xDSid = createMatAlgo01xDSid({ typed: typed2 });
    const matAlgo04xSidSid = createMatAlgo04xSidSid({ typed: typed2, equalScalar });
    const matAlgo10xSids = createMatAlgo10xSids({ typed: typed2, DenseMatrix });
    const matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed2,
      matrix,
      concat: concat2
    });
    return typed2(
      name58,
      {
        "number, number": _gcdNumber,
        "BigNumber, BigNumber": _gcdBigNumber,
        "Fraction, Fraction": (x, y) => x.gcd(y)
      },
      matrixAlgorithmSuite({
        SS: matAlgo04xSidSid,
        DS: matAlgo01xDSid,
        Ss: matAlgo10xSids
      }),
      {
        [gcdManyTypesSignature]: typed2.referToSelf(
          (self) => (a, b, args) => {
            let res = self(a, b);
            for (let i = 0; i < args.length; i++) {
              res = self(res, args[i]);
            }
            return res;
          }
        ),
        Array: typed2.referToSelf((self) => (array) => {
          if (array.length === 1 && Array.isArray(array[0]) && is1d(array[0])) {
            return self(...array[0]);
          }
          if (is1d(array)) {
            return self(...array);
          }
          throw new ArgumentsError("gcd() supports only 1d matrices!");
        }),
        Matrix: typed2.referToSelf((self) => (matrixArg) => {
          return self(matrixArg.toArray());
        })
      }
    );
    function _gcdNumber(a, b) {
      if (!isInteger(a) || !isInteger(b)) {
        throw new Error("Parameters in function gcd must be integer numbers");
      }
      let r;
      while (b !== 0) {
        r = mod(a, b);
        a = b;
        b = r;
      }
      return a < 0 ? -a : a;
    }
    function _gcdBigNumber(a, b) {
      if (!a.isInt() || !b.isInt()) {
        throw new Error("Parameters in function gcd must be integer numbers");
      }
      const zero = new BigNumber(0);
      while (!b.isZero()) {
        const r = mod(a, b);
        a = b;
        b = r;
      }
      return a.lt(zero) ? a.neg() : a;
    }
  }
);

// src/type/matrix/utils/matAlgo06xS0S0.ts
var name59 = "matAlgo06xS0S0";
var dependencies60 = ["typed", "equalScalar"];
var createMatAlgo06xS0S0 = /* @__PURE__ */ factory(
  name59,
  dependencies60,
  ({
    typed: typed2,
    equalScalar
  }) => {
    return function matAlgo06xS0S0(a, b, callback) {
      const avalues = a._values;
      const asize = a._size;
      const adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
      const bvalues = b._values;
      const bsize = b._size;
      const bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError(
          "Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")"
        );
      }
      const rows = asize[0];
      const columns = asize[1];
      let dt;
      let eq = equalScalar;
      let zero = 0;
      let cf = callback;
      if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
        dt = adt;
        eq = typed2.find(equalScalar, [dt, dt]);
        zero = typed2.convert(0, dt);
        cf = typed2.find(callback, [dt, dt]);
      }
      const cvalues = avalues && bvalues ? [] : void 0;
      const cindex = [];
      const cptr = [];
      const x = cvalues ? [] : void 0;
      const w = [];
      const u = [];
      for (let j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        const mark = j + 1;
        scatter(a, j, w, x, u, mark, cindex, cf);
        scatter(b, j, w, x, u, mark, cindex, cf);
        if (x) {
          let k = cptr[j];
          while (k < cindex.length) {
            const i = cindex[k];
            if (u[i] === mark) {
              const v = x[i];
              if (!eq(v, zero)) {
                cvalues.push(v);
                k++;
              } else {
                cindex.splice(k, 1);
              }
            } else {
              cindex.splice(k, 1);
            }
          }
        } else {
          let p = cptr[j];
          while (p < cindex.length) {
            const r = cindex[p];
            if (u[r] !== mark) {
              cindex.splice(p, 1);
            } else {
              p++;
            }
          }
        }
      }
      cptr[columns] = cindex.length;
      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
      });
    };
  }
);

// src/function/arithmetic/lcm.ts
var name60 = "lcm";
var dependencies61 = ["typed", "matrix", "equalScalar", "concat"];
var createLcm = /* @__PURE__ */ factory(
  name60,
  dependencies61,
  ({ typed: typed2, matrix, equalScalar, concat: concat2 }) => {
    const matAlgo02xDS0 = createMatAlgo02xDS0({ typed: typed2, equalScalar });
    const matAlgo06xS0S0 = createMatAlgo06xS0S0({ typed: typed2, equalScalar });
    const matAlgo11xS0s = createMatAlgo11xS0s({ typed: typed2, equalScalar });
    const matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed2,
      matrix,
      concat: concat2
    });
    const lcmTypes = "number | BigNumber | Fraction | Matrix | Array";
    const lcmManySignature = {};
    lcmManySignature[`${lcmTypes}, ${lcmTypes}, ...${lcmTypes}`] = typed2.referToSelf((self) => (a, b, args) => {
      let res = self(a, b);
      for (let i = 0; i < args.length; i++) {
        res = self(res, args[i]);
      }
      return res;
    });
    return typed2(
      name60,
      {
        "number, number": lcmNumber,
        "BigNumber, BigNumber": _lcmBigNumber,
        "Fraction, Fraction": (x, y) => x.lcm(y)
      },
      matrixAlgorithmSuite({
        SS: matAlgo06xS0S0,
        DS: matAlgo02xDS0,
        Ss: matAlgo11xS0s
      }),
      lcmManySignature
    );
    function _lcmBigNumber(a, b) {
      if (!a.isInt() || !b.isInt()) {
        throw new Error("Parameters in function lcm must be integer numbers");
      }
      if (a.isZero()) {
        return a;
      }
      if (b.isZero()) {
        return b;
      }
      const prod = a.times(b);
      while (!b.isZero()) {
        const t = b;
        b = a.mod(t);
        a = t;
      }
      return prod.div(a).abs();
    }
  }
);

// src/utils/bigint.ts
function promoteLogarithm(log162, numberLog, config, cplx) {
  return function(b) {
    if (b > 0 || config.predictable) {
      if (b <= 0) return NaN;
      const s = b.toString(16);
      const s15 = s.substring(0, 15);
      return log162 * (s.length - s15.length) + numberLog(Number("0x" + s15));
    }
    return cplx(b.toNumber());
  };
}

// src/function/arithmetic/log10.ts
var name61 = "log10";
var dependencies62 = ["typed", "config", "Complex"];
var log16 = log10Number(16);
var createLog10 = /* @__PURE__ */ factory(
  name61,
  dependencies62,
  ({
    typed: typed2,
    config,
    Complex: Complex2
  }) => {
    function complexLog(c) {
      return c.log().div(Math.LN10);
    }
    function complexLogNumber(x) {
      return complexLog(new Complex2(x, 0));
    }
    return typed2(name61, {
      number: function(x) {
        if (x >= 0 || config.predictable) {
          return log10Number(x);
        } else {
          return complexLogNumber(x);
        }
      },
      bigint: promoteLogarithm(log16, log10Number, config, complexLogNumber),
      Complex: complexLog,
      BigNumber: function(x) {
        if (!x.isNegative() || config.predictable) {
          return x.log();
        } else {
          return complexLogNumber(x.toNumber());
        }
      },
      "Array | Matrix": typed2.referToSelf(
        (self) => (x) => deepMap2(x, self)
      )
    });
  }
);

// src/function/arithmetic/log2.ts
var name62 = "log2";
var dependencies63 = ["typed", "config", "Complex"];
var createLog2 = /* @__PURE__ */ factory(
  name62,
  dependencies63,
  ({
    typed: typed2,
    config,
    Complex: Complex2
  }) => {
    function complexLog2Number(x) {
      return _log2Complex(new Complex2(x, 0));
    }
    return typed2(name62, {
      number: function(x) {
        if (x >= 0 || config.predictable) {
          return log2Number(x);
        } else {
          return complexLog2Number(x);
        }
      },
      bigint: promoteLogarithm(4, log2Number, config, complexLog2Number),
      Complex: _log2Complex,
      BigNumber: function(x) {
        if (!x.isNegative() || config.predictable) {
          return x.log(2);
        } else {
          return complexLog2Number(x.toNumber());
        }
      },
      "Array | Matrix": typed2.referToSelf(
        (self) => (x) => deepMap2(x, self)
      )
    });
    function _log2Complex(x) {
      const newX = Math.sqrt(x.re * x.re + x.im * x.im);
      return new Complex2(
        Math.log2 ? Math.log2(newX) : Math.log(newX) / Math.LN2,
        Math.atan2(x.im, x.re) / Math.LN2
      );
    }
  }
);

// src/function/arithmetic/multiplyScalar.ts
var name63 = "multiplyScalar";
var dependencies64 = ["typed"];
var createMultiplyScalar = /* @__PURE__ */ factory(
  name63,
  dependencies64,
  ({ typed: typed2 }) => {
    return typed2("multiplyScalar", {
      "number, number": multiplyNumber,
      "Complex, Complex": function(x, y) {
        return x.mul(y);
      },
      "BigNumber, BigNumber": function(x, y) {
        return x.times(y);
      },
      "bigint, bigint": function(x, y) {
        return x * y;
      },
      "Fraction, Fraction": function(x, y) {
        return x.mul(y);
      },
      "number | Fraction | Complex, Unit": (x, y) => y.multiply(x),
      "Unit, number | Fraction | Complex | Unit": (x, y) => x.multiply(y)
    });
  }
);

// src/function/arithmetic/multiply.ts
var name64 = "multiply";
var dependencies65 = [
  "typed",
  "matrix",
  "addScalar",
  "multiplyScalar",
  "equalScalar",
  "dot",
  "nodeOperations"
];
var createMultiply = /* @__PURE__ */ factory(
  name64,
  dependencies65,
  ({
    typed: typed2,
    matrix,
    addScalar,
    multiplyScalar,
    equalScalar,
    dot,
    nodeOperations
  }) => {
    const matAlgo11xS0s = createMatAlgo11xS0s({ typed: typed2, equalScalar });
    const matAlgo14xDs = createMatAlgo14xDs({ typed: typed2 });
    function _validateMatrixDimensions(size1, size2) {
      switch (size1.length) {
        case 1:
          switch (size2.length) {
            case 1:
              if (size1[0] !== size2[0]) {
                throw new RangeError(
                  "Dimension mismatch in multiplication. Vectors must have the same length"
                );
              }
              break;
            case 2:
              if (size1[0] !== size2[0]) {
                throw new RangeError(
                  "Dimension mismatch in multiplication. Vector length (" + size1[0] + ") must match Matrix rows (" + size2[0] + ")"
                );
              }
              break;
            default:
              throw new Error(
                "Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)"
              );
          }
          break;
        case 2:
          switch (size2.length) {
            case 1:
              if (size1[1] !== size2[0]) {
                throw new RangeError(
                  "Dimension mismatch in multiplication. Matrix columns (" + size1[1] + ") must match Vector length (" + size2[0] + ")"
                );
              }
              break;
            case 2:
              if (size1[1] !== size2[0]) {
                throw new RangeError(
                  "Dimension mismatch in multiplication. Matrix A columns (" + size1[1] + ") must match Matrix B rows (" + size2[0] + ")"
                );
              }
              break;
            default:
              throw new Error(
                "Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)"
              );
          }
          break;
        default:
          throw new Error(
            "Can only multiply a 1 or 2 dimensional matrix (Matrix A has " + size1.length + " dimensions)"
          );
      }
    }
    function _multiplyVectorVector(a, b, n) {
      if (n === 0) {
        throw new Error("Cannot multiply two empty vectors");
      }
      return dot(a, b);
    }
    function _multiplyVectorMatrix(a, b) {
      if (b.storage() !== "dense") {
        throw new Error("Support for SparseMatrix not implemented");
      }
      return _multiplyVectorDenseMatrix(a, b);
    }
    function _multiplyVectorDenseMatrix(a, b) {
      const adata = a._data;
      const asize = a._size;
      const adt = a._datatype || a.getDataType();
      const bdata = b._data;
      const bsize = b._size;
      const bdt = b._datatype || b.getDataType();
      const alength = asize[0];
      const bcolumns = bsize[1];
      let dt;
      let af = addScalar;
      let mf = multiplyScalar;
      if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
        dt = adt;
        af = typed2.find(addScalar, [dt, dt]);
        mf = typed2.find(multiplyScalar, [dt, dt]);
      }
      const c = [];
      for (let j = 0; j < bcolumns; j++) {
        let sum = mf(adata[0], bdata[0][j]);
        for (let i = 1; i < alength; i++) {
          sum = af(sum, mf(adata[i], bdata[i][j]));
        }
        c[j] = sum;
      }
      return a.createDenseMatrix({
        data: c,
        size: [bcolumns],
        datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
      });
    }
    const _multiplyMatrixVector = typed2("_multiplyMatrixVector", {
      "DenseMatrix, any": _multiplyDenseMatrixVector,
      "SparseMatrix, any": _multiplySparseMatrixVector
    });
    const _multiplyMatrixMatrix = typed2("_multiplyMatrixMatrix", {
      "DenseMatrix, DenseMatrix": _multiplyDenseMatrixDenseMatrix,
      "DenseMatrix, SparseMatrix": _multiplyDenseMatrixSparseMatrix,
      "SparseMatrix, DenseMatrix": _multiplySparseMatrixDenseMatrix,
      "SparseMatrix, SparseMatrix": _multiplySparseMatrixSparseMatrix
    });
    function _multiplyDenseMatrixVector(a, b) {
      const adata = a._data;
      const asize = a._size;
      const adt = a._datatype || a.getDataType();
      const bdata = b._data;
      const bdt = b._datatype || b.getDataType();
      const arows = asize[0];
      const acolumns = asize[1];
      let dt;
      let af = addScalar;
      let mf = multiplyScalar;
      if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
        dt = adt;
        af = typed2.find(addScalar, [dt, dt]);
        mf = typed2.find(multiplyScalar, [dt, dt]);
      }
      const c = [];
      for (let i = 0; i < arows; i++) {
        const row = adata[i];
        let sum = mf(row[0], bdata[0]);
        for (let j = 1; j < acolumns; j++) {
          sum = af(sum, mf(row[j], bdata[j]));
        }
        c[i] = sum;
      }
      return a.createDenseMatrix({
        data: c,
        size: [arows],
        datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
      });
    }
    function _multiplyDenseMatrixDenseMatrix(a, b) {
      const adata = a._data;
      const asize = a._size;
      const adt = a._datatype || a.getDataType();
      const bdata = b._data;
      const bsize = b._size;
      const bdt = b._datatype || b.getDataType();
      const arows = asize[0];
      const acolumns = asize[1];
      const bcolumns = bsize[1];
      let dt;
      let af = addScalar;
      let mf = multiplyScalar;
      if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed" && adt !== "mixed") {
        dt = adt;
        af = typed2.find(addScalar, [dt, dt]);
        mf = typed2.find(multiplyScalar, [dt, dt]);
      }
      const c = [];
      for (let i = 0; i < arows; i++) {
        const row = adata[i];
        c[i] = [];
        for (let j = 0; j < bcolumns; j++) {
          let sum = mf(row[0], bdata[0][j]);
          for (let x = 1; x < acolumns; x++) {
            sum = af(sum, mf(row[x], bdata[x][j]));
          }
          c[i][j] = sum;
        }
      }
      return a.createDenseMatrix({
        data: c,
        size: [arows, bcolumns],
        datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
      });
    }
    function _multiplyDenseMatrixSparseMatrix(a, b) {
      const adata = a._data;
      const asize = a._size;
      const adt = a._datatype || a.getDataType();
      const bvalues = b._values;
      const bindex = b._index;
      const bptr = b._ptr;
      const bsize = b._size;
      const bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
      if (!bvalues) {
        throw new Error(
          "Cannot multiply Dense Matrix times Pattern only Matrix"
        );
      }
      const arows = asize[0];
      const bcolumns = bsize[1];
      let dt;
      let af = addScalar;
      let mf = multiplyScalar;
      let eq = equalScalar;
      let zero = 0;
      if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
        dt = adt;
        af = typed2.find(addScalar, [dt, dt]);
        mf = typed2.find(multiplyScalar, [dt, dt]);
        eq = typed2.find(equalScalar, [dt, dt]);
        zero = typed2.convert(0, dt);
      }
      const cvalues = [];
      const cindex = [];
      const cptr = [];
      const c = b.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, bcolumns],
        datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
      });
      for (let jb = 0; jb < bcolumns; jb++) {
        cptr[jb] = cindex.length;
        const kb0 = bptr[jb];
        const kb1 = bptr[jb + 1];
        if (kb1 > kb0) {
          let last = 0;
          for (let i = 0; i < arows; i++) {
            const mark = i + 1;
            let cij;
            for (let kb = kb0; kb < kb1; kb++) {
              const ib = bindex[kb];
              if (last !== mark) {
                cij = mf(adata[i][ib], bvalues[kb]);
                last = mark;
              } else {
                cij = af(cij, mf(adata[i][ib], bvalues[kb]));
              }
            }
            if (last === mark && !eq(cij, zero)) {
              cindex.push(i);
              cvalues.push(cij);
            }
          }
        }
      }
      cptr[bcolumns] = cindex.length;
      return c;
    }
    function _multiplySparseMatrixVector(a, b) {
      const avalues = a._values;
      const aindex = a._index;
      const aptr = a._ptr;
      const adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
      if (!avalues) {
        throw new Error(
          "Cannot multiply Pattern only Matrix times Dense Matrix"
        );
      }
      const bdata = b._data;
      const bdt = b._datatype || b.getDataType();
      const arows = a._size[0];
      const brows = b._size[0];
      const cvalues = [];
      const cindex = [];
      const cptr = [];
      let dt;
      let af = addScalar;
      let mf = multiplyScalar;
      let eq = equalScalar;
      let zero = 0;
      if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
        dt = adt;
        af = typed2.find(addScalar, [dt, dt]);
        mf = typed2.find(multiplyScalar, [dt, dt]);
        eq = typed2.find(equalScalar, [dt, dt]);
        zero = typed2.convert(0, dt);
      }
      const x = [];
      const w = [];
      cptr[0] = 0;
      for (let ib = 0; ib < brows; ib++) {
        const vbi = bdata[ib];
        if (!eq(vbi, zero)) {
          for (let ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            const ia = aindex[ka];
            if (!w[ia]) {
              w[ia] = true;
              cindex.push(ia);
              x[ia] = mf(vbi, avalues[ka]);
            } else {
              x[ia] = af(x[ia], mf(vbi, avalues[ka]));
            }
          }
        }
      }
      for (let p1 = cindex.length, p = 0; p < p1; p++) {
        const ic = cindex[p];
        cvalues[p] = x[ic];
      }
      cptr[1] = cindex.length;
      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, 1],
        datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
      });
    }
    function _multiplySparseMatrixDenseMatrix(a, b) {
      const avalues = a._values;
      const aindex = a._index;
      const aptr = a._ptr;
      const adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
      if (!avalues) {
        throw new Error(
          "Cannot multiply Pattern only Matrix times Dense Matrix"
        );
      }
      const bdata = b._data;
      const bdt = b._datatype || b.getDataType();
      const arows = a._size[0];
      const brows = b._size[0];
      const bcolumns = b._size[1];
      let dt;
      let af = addScalar;
      let mf = multiplyScalar;
      let eq = equalScalar;
      let zero = 0;
      if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
        dt = adt;
        af = typed2.find(addScalar, [dt, dt]);
        mf = typed2.find(multiplyScalar, [dt, dt]);
        eq = typed2.find(equalScalar, [dt, dt]);
        zero = typed2.convert(0, dt);
      }
      const cvalues = [];
      const cindex = [];
      const cptr = [];
      const c = a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, bcolumns],
        datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
      });
      const x = [];
      const w = [];
      for (let jb = 0; jb < bcolumns; jb++) {
        cptr[jb] = cindex.length;
        const mark = jb + 1;
        for (let ib = 0; ib < brows; ib++) {
          const vbij = bdata[ib][jb];
          if (!eq(vbij, zero)) {
            for (let ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
              const ia = aindex[ka];
              if (w[ia] !== mark) {
                w[ia] = mark;
                cindex.push(ia);
                x[ia] = mf(vbij, avalues[ka]);
              } else {
                x[ia] = af(x[ia], mf(vbij, avalues[ka]));
              }
            }
          }
        }
        for (let p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
          const ic = cindex[p];
          cvalues[p] = x[ic];
        }
      }
      cptr[bcolumns] = cindex.length;
      return c;
    }
    function _multiplySparseMatrixSparseMatrix(a, b) {
      const avalues = a._values;
      const aindex = a._index;
      const aptr = a._ptr;
      const adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
      const bvalues = b._values;
      const bindex = b._index;
      const bptr = b._ptr;
      const bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
      const arows = a._size[0];
      const bcolumns = b._size[1];
      const values = avalues && bvalues;
      let dt;
      let af = addScalar;
      let mf = multiplyScalar;
      if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
        dt = adt;
        af = typed2.find(addScalar, [dt, dt]);
        mf = typed2.find(multiplyScalar, [dt, dt]);
      }
      const cvalues = values ? [] : void 0;
      const cindex = [];
      const cptr = [];
      const c = a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, bcolumns],
        datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
      });
      const x = values ? [] : void 0;
      const w = [];
      let ka, ka0, ka1, kb, kb0, kb1, ia, ib;
      for (let jb = 0; jb < bcolumns; jb++) {
        cptr[jb] = cindex.length;
        const mark = jb + 1;
        for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {
          ib = bindex[kb];
          if (values) {
            for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
              ia = aindex[ka];
              if (w[ia] !== mark) {
                w[ia] = mark;
                cindex.push(ia);
                x[ia] = mf(bvalues[kb], avalues[ka]);
              } else {
                x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));
              }
            }
          } else {
            for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
              ia = aindex[ka];
              if (w[ia] !== mark) {
                w[ia] = mark;
                cindex.push(ia);
              }
            }
          }
        }
        if (values) {
          for (let p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
            const ic = cindex[p];
            cvalues[p] = x[ic];
          }
        }
      }
      cptr[bcolumns] = cindex.length;
      return c;
    }
    return typed2(name64, multiplyScalar, {
      // we extend the signatures of multiplyScalar with signatures dealing with matrices
      "Array, Array": typed2.referTo("Matrix, Matrix", ((selfMM) => (x, y) => {
        _validateMatrixDimensions(arraySize(x), arraySize(y));
        const m = selfMM(matrix(x), matrix(y));
        return isMatrix(m) ? m.valueOf() : m;
      })),
      "Matrix, Matrix": function(x, y) {
        const xsize = x.size();
        const ysize = y.size();
        _validateMatrixDimensions(xsize, ysize);
        if (xsize.length === 1) {
          if (ysize.length === 1) {
            return _multiplyVectorVector(x, y, xsize[0]);
          }
          return _multiplyVectorMatrix(x, y);
        }
        if (ysize.length === 1) {
          return _multiplyMatrixVector(x, y);
        }
        return _multiplyMatrixMatrix(x, y);
      },
      "Matrix, Array": typed2.referTo(
        "Matrix,Matrix",
        ((selfMM) => (x, y) => selfMM(x, matrix(y)))
      ),
      "Array, Matrix": typed2.referToSelf(
        (self) => (x, y) => {
          return self(matrix(x, y.storage()), y);
        }
      ),
      "SparseMatrix, any": function(x, y) {
        return matAlgo11xS0s(x, y, multiplyScalar, false);
      },
      "DenseMatrix, any": function(x, y) {
        return matAlgo14xDs(x, y, multiplyScalar, false);
      },
      "any, SparseMatrix": function(x, y) {
        return matAlgo11xS0s(y, x, multiplyScalar, true);
      },
      "any, DenseMatrix": function(x, y) {
        return matAlgo14xDs(y, x, multiplyScalar, true);
      },
      "Array, any": function(x, y) {
        return matAlgo14xDs(
          matrix(x),
          y,
          multiplyScalar,
          false
        ).valueOf();
      },
      "any, Array": function(x, y) {
        return matAlgo14xDs(
          matrix(y),
          x,
          multiplyScalar,
          true
        ).valueOf();
      },
      // =========================================================================
      // NODE SIGNATURES - Must be BEFORE 'any, any'
      // When any operand is a Node, return an OperatorNode for symbolic computation
      // =========================================================================
      "Node, Node": (x, y) => nodeOperations.createBinaryNode("*", "multiply", x, y),
      "number, Node": (x, y) => nodeOperations.createBinaryNode("*", "multiply", x, y),
      "Node, number": (x, y) => nodeOperations.createBinaryNode("*", "multiply", x, y),
      "BigNumber, Node": (x, y) => nodeOperations.createBinaryNode("*", "multiply", x, y),
      "Node, BigNumber": (x, y) => nodeOperations.createBinaryNode("*", "multiply", x, y),
      "Complex, Node": (x, y) => nodeOperations.createBinaryNode("*", "multiply", x, y),
      "Node, Complex": (x, y) => nodeOperations.createBinaryNode("*", "multiply", x, y),
      "Fraction, Node": (x, y) => nodeOperations.createBinaryNode("*", "multiply", x, y),
      "Node, Fraction": (x, y) => nodeOperations.createBinaryNode("*", "multiply", x, y),
      "Unit, Node": (x, y) => nodeOperations.createBinaryNode("*", "multiply", x, y),
      "Node, Unit": (x, y) => nodeOperations.createBinaryNode("*", "multiply", x, y),
      "string, Node": (x, y) => nodeOperations.createBinaryNode("*", "multiply", x, y),
      "Node, string": (x, y) => nodeOperations.createBinaryNode("*", "multiply", x, y),
      // =========================================================================
      // BIGNUMBER-UNIT SIGNATURES - Preserve BigNumber precision
      // =========================================================================
      "BigNumber, Unit": function(x, y) {
        const result = y.clone();
        if (y.value === null) {
          result.value = result._normalize(x);
        } else {
          result.value = multiplyScalar(x, y.value);
        }
        return result;
      },
      "Unit, BigNumber": function(x, y) {
        const result = x.clone();
        if (x.value === null) {
          result.value = result._normalize(y);
        } else {
          result.value = multiplyScalar(x.value, y);
        }
        return result;
      },
      // =========================================================================
      // EXISTING SIGNATURES - Keep after Node signatures
      // =========================================================================
      "any, any": multiplyScalar,
      "any, any, ...any": typed2.referToSelf(
        (self) => (x, y, rest) => {
          let result = self(x, y);
          for (let i = 0; i < rest.length; i++) {
            result = self(result, rest[i]);
          }
          return result;
        }
      )
    });
  }
);

// src/function/arithmetic/nthRoot.ts
var name65 = "nthRoot";
var dependencies66 = ["typed", "matrix", "equalScalar", "BigNumber", "concat"];
var createNthRoot = /* @__PURE__ */ factory(
  name65,
  dependencies66,
  ({
    typed: typed2,
    matrix,
    equalScalar,
    BigNumber,
    concat: concat2
  }) => {
    const matAlgo01xDSid = createMatAlgo01xDSid({ typed: typed2 });
    const matAlgo02xDS0 = createMatAlgo02xDS0({ typed: typed2, equalScalar });
    const matAlgo06xS0S0 = createMatAlgo06xS0S0({ typed: typed2, equalScalar });
    const matAlgo11xS0s = createMatAlgo11xS0s({ typed: typed2, equalScalar });
    const matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed2,
      matrix,
      concat: concat2
    });
    function complexErr() {
      throw new Error(
        "Complex number not supported in function nthRoot. Use nthRoots instead."
      );
    }
    return typed2(
      name65,
      {
        number: nthRootNumber,
        "number, number": nthRootNumber,
        BigNumber: (x) => _bigNthRoot(x, new BigNumber(2)),
        "BigNumber, BigNumber": _bigNthRoot,
        Complex: complexErr,
        "Complex, number": complexErr,
        Array: typed2.referTo(
          "DenseMatrix,number",
          (selfDn) => (x) => selfDn(matrix(x), 2).valueOf()
        ),
        DenseMatrix: typed2.referTo(
          "DenseMatrix,number",
          (selfDn) => (x) => selfDn(x, 2)
        ),
        SparseMatrix: typed2.referTo(
          "SparseMatrix,number",
          (selfSn) => (x) => selfSn(x, 2)
        ),
        "SparseMatrix, SparseMatrix": typed2.referToSelf(
          (self) => (x, y) => {
            if (y.density() === 1) {
              return matAlgo06xS0S0(x, y, self);
            } else {
              throw new Error("Root must be non-zero");
            }
          }
        ),
        "DenseMatrix, SparseMatrix": typed2.referToSelf(
          (self) => (x, y) => {
            if (y.density() === 1) {
              return matAlgo01xDSid(x, y, self, false);
            } else {
              throw new Error("Root must be non-zero");
            }
          }
        ),
        "Array, SparseMatrix": typed2.referTo(
          "DenseMatrix,SparseMatrix",
          (selfDS) => (x, y) => selfDS(matrix(x), y)
        ),
        "number | BigNumber, SparseMatrix": typed2.referToSelf(
          (self) => (x, y) => {
            if (y.density() === 1) {
              return matAlgo11xS0s(y, x, self, true);
            } else {
              throw new Error("Root must be non-zero");
            }
          }
        )
      },
      matrixAlgorithmSuite({
        scalar: "number | BigNumber",
        SD: matAlgo02xDS0,
        Ss: matAlgo11xS0s,
        sS: false
      })
    );
    function _bigNthRoot(a, root) {
      const precision = BigNumber.precision;
      const Big = BigNumber.clone({ precision: precision + 2 });
      const zero = new BigNumber(0);
      const one = new Big(1);
      const inv = root.isNegative();
      if (inv) {
        root = root.neg();
      }
      if (root.isZero()) {
        throw new Error("Root must be non-zero");
      }
      if (a.isNegative() && !root.abs().mod(2).equals(1)) {
        throw new Error("Root must be odd when a is negative.");
      }
      if (a.isZero()) {
        return inv ? new Big(Infinity) : 0;
      }
      if (!a.isFinite()) {
        return inv ? zero : a;
      }
      let x = a.abs().pow(one.div(root));
      x = a.isNeg() ? x.neg() : x;
      return new BigNumber((inv ? one.div(x) : x).toPrecision(precision));
    }
  }
);

// src/function/arithmetic/sign.ts
var name66 = "sign";
var dependencies67 = ["typed", "BigNumber", "complex", "Fraction"];
var createSign = /* @__PURE__ */ factory(
  name66,
  dependencies67,
  ({ typed: typed2, BigNumber, complex, Fraction: Fraction2 }) => {
    return typed2(name66, {
      number: signNumber,
      Complex: function(x) {
        return x.im === 0 ? complex(signNumber(x.re)) : x.sign();
      },
      BigNumber: function(x) {
        return new BigNumber(x.cmp(0));
      },
      bigint: function(x) {
        return x > 0n ? 1n : x < 0n ? -1n : 0n;
      },
      Fraction: function(x) {
        return x.n === 0n ? new Fraction2(0) : new Fraction2(x.s);
      },
      // deep map collection, skip zeros since sign(0) = 0
      "Array | Matrix": typed2.referToSelf(
        (self) => (x) => deepMap2(x, self, true)
      ),
      Unit: typed2.referToSelf((self) => (x) => {
        if (!x._isDerived() && x.units[0].unit.offset !== 0) {
          throw new TypeError("sign is ambiguous for units with offset");
        }
        return typed2.find(self, x.valueType())(x.value);
      })
    });
  }
);

// src/function/arithmetic/sqrt.ts
var name67 = "sqrt";
var dependencies68 = ["config", "typed", "Complex"];
var createSqrt = /* @__PURE__ */ factory(
  name67,
  dependencies68,
  ({ config, typed: typed2, Complex: Complex2 }) => {
    return typed2("sqrt", {
      number: _sqrtNumber,
      Complex: function(x) {
        return x.sqrt();
      },
      BigNumber: function(x) {
        if (!x.isNegative() || config.predictable) {
          return x.sqrt();
        } else {
          return _sqrtNumber(x.toNumber());
        }
      },
      Unit: function(x) {
        return x.pow(0.5);
      }
    });
    function _sqrtNumber(x) {
      if (isNaN(x)) {
        return NaN;
      } else if (x >= 0 || config.predictable) {
        return Math.sqrt(x);
      } else {
        return new Complex2(x, 0).sqrt();
      }
    }
  }
);

// src/function/arithmetic/square.ts
var name68 = "square";
var dependencies69 = ["typed"];
var createSquare = /* @__PURE__ */ factory(
  name68,
  dependencies69,
  ({ typed: typed2 }) => {
    return typed2(name68, {
      number: squareNumber,
      Complex: function(x) {
        return x.mul(x);
      },
      BigNumber: function(x) {
        return x.times(x);
      },
      bigint: function(x) {
        return x * x;
      },
      Fraction: function(x) {
        return x.mul(x);
      },
      Unit: function(x) {
        return x.pow(2);
      }
    });
  }
);

// src/function/arithmetic/subtract.ts
var name69 = "subtract";
var dependencies70 = [
  "typed",
  "matrix",
  "equalScalar",
  "subtractScalar",
  "unaryMinus",
  "DenseMatrix",
  "concat",
  "nodeOperations"
];
var createSubtract = /* @__PURE__ */ factory(
  name69,
  dependencies70,
  ({
    typed: typed2,
    matrix,
    equalScalar,
    subtractScalar,
    unaryMinus: _unaryMinus,
    DenseMatrix,
    concat: concat2,
    nodeOperations
  }) => {
    const matAlgo01xDSid = createMatAlgo01xDSid({ typed: typed2 });
    const matAlgo03xDSf = createMatAlgo03xDSf({ typed: typed2 });
    const matAlgo05xSfSf = createMatAlgo05xSfSf({ typed: typed2, equalScalar });
    const matAlgo10xSids = createMatAlgo10xSids({ typed: typed2, DenseMatrix });
    const matAlgo12xSfs = createMatAlgo12xSfs({ typed: typed2, DenseMatrix });
    const matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed2,
      matrix,
      concat: concat2
    });
    return typed2(
      name69,
      {
        // =========================================================================
        // NODE SIGNATURES - Must be FIRST (before 'any, any')
        // When any operand is a Node, return an OperatorNode for symbolic computation
        // =========================================================================
        "Node, Node": (x, y) => nodeOperations.createBinaryNode("-", "subtract", x, y),
        "number, Node": (x, y) => nodeOperations.createBinaryNode("-", "subtract", x, y),
        "Node, number": (x, y) => nodeOperations.createBinaryNode("-", "subtract", x, y),
        "BigNumber, Node": (x, y) => nodeOperations.createBinaryNode("-", "subtract", x, y),
        "Node, BigNumber": (x, y) => nodeOperations.createBinaryNode("-", "subtract", x, y),
        "Complex, Node": (x, y) => nodeOperations.createBinaryNode("-", "subtract", x, y),
        "Node, Complex": (x, y) => nodeOperations.createBinaryNode("-", "subtract", x, y),
        "Fraction, Node": (x, y) => nodeOperations.createBinaryNode("-", "subtract", x, y),
        "Node, Fraction": (x, y) => nodeOperations.createBinaryNode("-", "subtract", x, y),
        "Unit, Node": (x, y) => nodeOperations.createBinaryNode("-", "subtract", x, y),
        "Node, Unit": (x, y) => nodeOperations.createBinaryNode("-", "subtract", x, y),
        // =========================================================================
        // EXISTING SIGNATURES - Keep after Node signatures
        // =========================================================================
        "any, any": subtractScalar
      },
      matrixAlgorithmSuite({
        elop: subtractScalar,
        SS: matAlgo05xSfSf,
        DS: matAlgo01xDSid,
        SD: matAlgo03xDSf,
        Ss: matAlgo12xSfs,
        sS: matAlgo10xSids
      })
    );
  }
);

// src/function/arithmetic/xgcd.ts
var name70 = "xgcd";
var dependencies71 = ["typed", "config", "matrix", "BigNumber"];
var createXgcd = /* @__PURE__ */ factory(
  name70,
  dependencies71,
  ({ typed: typed2, config, matrix, BigNumber }) => {
    return typed2(name70, {
      "number, number": function(a, b) {
        const res = xgcdNumber(a, b);
        return config.matrix === "Array" ? res : matrix(res);
      },
      "BigNumber, BigNumber": _xgcdBigNumber
      // TODO: implement support for Fraction
    });
    function _xgcdBigNumber(a, b) {
      let t;
      let q;
      let r;
      const zero = new BigNumber(0);
      const one = new BigNumber(1);
      let x = zero;
      let lastx = one;
      let y = one;
      let lasty = zero;
      if (!a.isInt() || !b.isInt()) {
        throw new Error("Parameters in function xgcd must be integer numbers");
      }
      while (!b.isZero()) {
        q = a.div(b).floor();
        r = a.mod(b);
        t = x;
        x = lastx.minus(q.times(x));
        lastx = t;
        t = y;
        y = lasty.minus(q.times(y));
        lasty = t;
        a = b;
        b = r;
      }
      let res;
      if (a.lt(zero)) {
        res = [a.neg(), lastx.neg(), lasty.neg()];
      } else {
        res = [a, !a.isZero() ? lastx : 0, lasty];
      }
      return config.matrix === "Array" ? res : matrix(res);
    }
  }
);

// src/function/arithmetic/invmod.ts
var name71 = "invmod";
var dependencies72 = [
  "typed",
  "config",
  "BigNumber",
  "xgcd",
  "equal",
  "smaller",
  "mod",
  "add",
  "isInteger"
];
var createInvmod = /* @__PURE__ */ factory(
  name71,
  dependencies72,
  ({
    typed: typed2,
    config: _config,
    BigNumber,
    xgcd,
    equal,
    smaller,
    mod,
    add,
    isInteger: isInteger2
  }) => {
    return typed2(name71, {
      "number, number": invmod,
      "BigNumber, BigNumber": invmod
    });
    function invmod(a, b) {
      if (!isInteger2(a) || !isInteger2(b))
        throw new Error("Parameters in function invmod must be integer numbers");
      a = mod(a, b);
      if (equal(b, 0)) throw new Error("Divisor must be non zero");
      let res = xgcd(a, b);
      const resVal = res.valueOf();
      const [gcd, invValue] = resVal;
      if (!equal(gcd, BigNumber(1))) return NaN;
      let inv = mod(invValue, b);
      if (smaller(inv, BigNumber(0))) inv = add(inv, b);
      return inv;
    }
  }
);

// src/type/matrix/utils/matAlgo09xS0Sf.ts
var name72 = "matAlgo09xS0Sf";
var dependencies73 = ["typed", "equalScalar"];
var createMatAlgo09xS0Sf = /* @__PURE__ */ factory(
  name72,
  dependencies73,
  ({
    typed: typed2,
    equalScalar
  }) => {
    return function matAlgo09xS0Sf(a, b, callback) {
      const avalues = a._values;
      const aindex = a._index;
      const aptr = a._ptr;
      const asize = a._size;
      const adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType?.();
      const bvalues = b._values;
      const bindex = b._index;
      const bptr = b._ptr;
      const bsize = b._size;
      const bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType?.();
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError(
          "Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")"
        );
      }
      const rows = asize[0];
      const columns = asize[1];
      let dt;
      let eq = equalScalar;
      let zero = 0;
      let cf = callback;
      if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
        dt = adt;
        eq = typed2.find(equalScalar, [dt, dt]);
        zero = typed2.convert(0, dt);
        cf = typed2.find(callback, [dt, dt]);
      }
      const cvalues = avalues && bvalues ? [] : void 0;
      const cindex = [];
      const cptr = [];
      const x = cvalues ? [] : void 0;
      const w = [];
      let i, j, k, k0, k1;
      for (j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        const mark = j + 1;
        if (x) {
          for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
            i = bindex[k];
            w[i] = mark;
            x[i] = bvalues[k];
          }
        }
        for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          i = aindex[k];
          if (x && cvalues) {
            const vb = w[i] === mark ? x[i] : zero;
            const vc = cf(avalues[k], vb);
            if (!eq(vc, zero)) {
              cindex.push(i);
              cvalues.push(vc);
            }
          } else {
            cindex.push(i);
          }
        }
      }
      cptr[columns] = cindex.length;
      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
      });
    };
  }
);

// src/function/arithmetic/dotMultiply.ts
var name73 = "dotMultiply";
var dependencies74 = [
  "typed",
  "matrix",
  "equalScalar",
  "multiplyScalar",
  "concat"
];
var createDotMultiply = /* @__PURE__ */ factory(
  name73,
  dependencies74,
  ({
    typed: typed2,
    matrix,
    equalScalar,
    multiplyScalar,
    concat: concat2
  }) => {
    const matAlgo02xDS0 = createMatAlgo02xDS0({ typed: typed2, equalScalar });
    const matAlgo09xS0Sf = createMatAlgo09xS0Sf({ typed: typed2, equalScalar });
    const matAlgo11xS0s = createMatAlgo11xS0s({ typed: typed2, equalScalar });
    const matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed2,
      matrix,
      concat: concat2
    });
    return typed2(
      name73,
      matrixAlgorithmSuite({
        elop: multiplyScalar,
        SS: matAlgo09xS0Sf,
        DS: matAlgo02xDS0,
        Ss: matAlgo11xS0s
      })
    );
  }
);

// src/function/arithmetic/utils/nodeOperations.ts
var name74 = "nodeOperations";
var dependencies75 = ["ConstantNode", "OperatorNode"];
var createNodeOperations = /* @__PURE__ */ factory(
  name74,
  dependencies75,
  ({ ConstantNode, OperatorNode }) => {
    const OPERATOR_MAP = {
      add: "+",
      subtract: "-",
      multiply: "*",
      divide: "/",
      pow: "^",
      mod: "%"
    };
    function getOperator2(fn) {
      return OPERATOR_MAP[fn] || fn;
    }
    function wrapInNode(value) {
      if (isNode(value)) {
        return value;
      }
      return new ConstantNode(value);
    }
    function createBinaryNode(op, fn, left, right) {
      const leftNode = wrapInNode(left);
      const rightNode = wrapInNode(right);
      return new OperatorNode(op, fn, [leftNode, rightNode]);
    }
    function createNaryNode(op, fn, args) {
      if (args.length < 2) {
        throw new Error(`${fn} requires at least 2 arguments`);
      }
      let result = createBinaryNode(op, fn, args[0], args[1]);
      for (let i = 2; i < args.length; i++) {
        result = createBinaryNode(op, fn, result, args[i]);
      }
      return result;
    }
    function hasNodeArg(...args) {
      return args.some((arg) => isNode(arg));
    }
    return {
      wrapInNode,
      createBinaryNode,
      createNaryNode,
      hasNodeArg,
      getOperator: getOperator2,
      OPERATOR_MAP
    };
  }
);

// src/utils/bignumber/bitwise.ts
function bitAndBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function bitAnd");
  }
  const BigNumber = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber(NaN);
  }
  if (x.isZero() || y.eq(-1) || x.eq(y)) {
    return x;
  }
  if (y.isZero() || x.eq(-1)) {
    return y;
  }
  if (!x.isFinite() || !y.isFinite()) {
    if (!x.isFinite() && !y.isFinite()) {
      if (x.isNegative() === y.isNegative()) {
        return x;
      }
      return new BigNumber(0);
    }
    if (!x.isFinite()) {
      if (y.isNegative()) {
        return x;
      }
      if (x.isNegative()) {
        return new BigNumber(0);
      }
      return y;
    }
    if (!y.isFinite()) {
      if (x.isNegative()) {
        return y;
      }
      if (y.isNegative()) {
        return new BigNumber(0);
      }
      return x;
    }
  }
  return bitwise(x, y, function(a, b) {
    return a & b;
  });
}
function bitNotBigNumber(x) {
  if (x.isFinite() && !x.isInteger()) {
    throw new Error("Integer expected in function bitNot");
  }
  const BigNumber = x.constructor;
  const prevPrec = BigNumber.precision;
  BigNumber.config({ precision: 1e9 });
  const result = x.plus(new BigNumber(1));
  result.s = -result.s || null;
  BigNumber.config({ precision: prevPrec });
  return result;
}
function bitOrBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function bitOr");
  }
  const BigNumber = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber(NaN);
  }
  const negOne = new BigNumber(-1);
  if (x.isZero() || y.eq(negOne) || x.eq(y)) {
    return y;
  }
  if (y.isZero() || x.eq(negOne)) {
    return x;
  }
  if (!x.isFinite() || !y.isFinite()) {
    if (!x.isFinite() && !x.isNegative() && y.isNegative() || x.isNegative() && !y.isNegative() && !y.isFinite()) {
      return negOne;
    }
    if (x.isNegative() && y.isNegative()) {
      return x.isFinite() ? x : y;
    }
    return x.isFinite() ? y : x;
  }
  return bitwise(x, y, function(a, b) {
    return a | b;
  });
}
function bitwise(x, y, func) {
  const BigNumber = x.constructor;
  let xBits, yBits;
  const xSign = +(x.s < 0);
  const ySign = +(y.s < 0);
  if (xSign) {
    xBits = decCoefficientToBinaryString(bitNotBigNumber(x));
    for (let i = 0; i < xBits.length; ++i) {
      xBits[i] ^= 1;
    }
  } else {
    xBits = decCoefficientToBinaryString(x);
  }
  if (ySign) {
    yBits = decCoefficientToBinaryString(bitNotBigNumber(y));
    for (let i = 0; i < yBits.length; ++i) {
      yBits[i] ^= 1;
    }
  } else {
    yBits = decCoefficientToBinaryString(y);
  }
  let minBits, maxBits, minSign;
  if (xBits.length <= yBits.length) {
    minBits = xBits;
    maxBits = yBits;
    minSign = xSign;
  } else {
    minBits = yBits;
    maxBits = xBits;
    minSign = ySign;
  }
  let shortLen = minBits.length;
  let longLen = maxBits.length;
  const expFuncVal = func(xSign, ySign) ^ 1;
  let outVal = new BigNumber(expFuncVal ^ 1);
  let twoPower = new BigNumber(1);
  const two = new BigNumber(2);
  const prevPrec = BigNumber.precision;
  BigNumber.config({ precision: 1e9 });
  while (shortLen > 0) {
    if (func(minBits[--shortLen], maxBits[--longLen]) === expFuncVal) {
      outVal = outVal.plus(twoPower);
    }
    twoPower = twoPower.times(two);
  }
  while (longLen > 0) {
    if (func(minSign, maxBits[--longLen]) === expFuncVal) {
      outVal = outVal.plus(twoPower);
    }
    twoPower = twoPower.times(two);
  }
  BigNumber.config({ precision: prevPrec });
  if (expFuncVal === 0) {
    outVal.s = -outVal.s;
  }
  return outVal;
}
function decCoefficientToBinaryString(x) {
  const a = x.d;
  let r = a[0] + "";
  for (let i = 1; i < a.length; ++i) {
    let s = a[i] + "";
    for (let z = 7 - s.length; z--; ) {
      s = "0" + s;
    }
    r += s;
  }
  let j = r.length;
  while (r.charAt(j) === "0") {
    j--;
  }
  let xe = x.e;
  let str = r.slice(0, j + 1 || 1);
  const strL = str.length;
  if (xe > 0) {
    if (++xe > strL) {
      xe -= strL;
      while (xe--) {
        str += "0";
      }
    } else if (xe < strL) {
      str = str.slice(0, xe) + "." + str.slice(xe);
    }
  }
  const arr = [0];
  for (let i = 0; i < str.length; ) {
    let arrL = arr.length;
    while (arrL--) {
      arr[arrL] *= 10;
    }
    arr[0] += parseInt(str.charAt(i++));
    for (let j2 = 0; j2 < arr.length; ++j2) {
      if (arr[j2] > 1) {
        if (arr[j2 + 1] === null || arr[j2 + 1] === void 0) {
          arr[j2 + 1] = 0;
        }
        arr[j2 + 1] += arr[j2] >> 1;
        arr[j2] &= 1;
      }
    }
  }
  return arr.reverse();
}
function bitXor(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function bitXor");
  }
  const BigNumber = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber(NaN);
  }
  if (x.isZero()) {
    return y;
  }
  if (y.isZero()) {
    return x;
  }
  if (x.eq(y)) {
    return new BigNumber(0);
  }
  const negOne = new BigNumber(-1);
  if (x.eq(negOne)) {
    return bitNotBigNumber(y);
  }
  if (y.eq(negOne)) {
    return bitNotBigNumber(x);
  }
  if (!x.isFinite() || !y.isFinite()) {
    if (!x.isFinite() && !y.isFinite()) {
      return negOne;
    }
    return new BigNumber(
      x.isNegative() === y.isNegative() ? Infinity : -Infinity
    );
  }
  return bitwise(x, y, function(a, b) {
    return a ^ b;
  });
}
function leftShiftBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function leftShift");
  }
  const BigNumber = x.constructor;
  if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
    return new BigNumber(NaN);
  }
  if (x.isZero() || y.isZero()) {
    return x;
  }
  if (!x.isFinite() && !y.isFinite()) {
    return new BigNumber(NaN);
  }
  if (y.lt(55)) {
    return x.times(Math.pow(2, y.toNumber()) + "");
  }
  return x.times(new BigNumber(2).pow(y));
}
function rightArithShiftBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function rightArithShift");
  }
  const BigNumber = x.constructor;
  if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
    return new BigNumber(NaN);
  }
  if (x.isZero() || y.isZero()) {
    return x;
  }
  if (!y.isFinite()) {
    if (x.isNegative()) {
      return new BigNumber(-1);
    }
    if (!x.isFinite()) {
      return new BigNumber(NaN);
    }
    return new BigNumber(0);
  }
  if (y.lt(55)) {
    return x.div(Math.pow(2, y.toNumber()) + "").floor();
  }
  return x.div(new BigNumber(2).pow(y)).floor();
}

// src/function/bitwise/bitAnd.ts
var name75 = "bitAnd";
var dependencies76 = ["typed", "matrix", "equalScalar", "concat"];
var createBitAnd = /* @__PURE__ */ factory(
  name75,
  dependencies76,
  ({ typed: typed2, matrix, equalScalar, concat: concat2 }) => {
    const matAlgo02xDS0 = createMatAlgo02xDS0({ typed: typed2, equalScalar });
    const matAlgo06xS0S0 = createMatAlgo06xS0S0({ typed: typed2, equalScalar });
    const matAlgo11xS0s = createMatAlgo11xS0s({ typed: typed2, equalScalar });
    const matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed2,
      matrix,
      concat: concat2
    });
    return typed2(
      name75,
      {
        "number, number": bitAndNumber,
        "BigNumber, BigNumber": bitAndBigNumber,
        "bigint, bigint": (x, y) => x & y
      },
      matrixAlgorithmSuite({
        SS: matAlgo06xS0S0,
        DS: matAlgo02xDS0,
        Ss: matAlgo11xS0s
      })
    );
  }
);

// src/function/bitwise/bitNot.ts
var name76 = "bitNot";
var dependencies77 = ["typed"];
var createBitNot = /* @__PURE__ */ factory(
  name76,
  dependencies77,
  ({ typed: typed2 }) => {
    return typed2(name76, {
      number: bitNotNumber,
      BigNumber: bitNotBigNumber,
      bigint: (x) => ~x,
      "Array | Matrix": typed2.referToSelf(
        (self) => (x) => deepMap2(x, self)
      )
    });
  }
);

// src/function/bitwise/bitOr.ts
var name77 = "bitOr";
var dependencies78 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
var createBitOr = /* @__PURE__ */ factory(
  name77,
  dependencies78,
  ({ typed: typed2, matrix, equalScalar, DenseMatrix, concat: concat2 }) => {
    const matAlgo01xDSid = createMatAlgo01xDSid({ typed: typed2 });
    const matAlgo04xSidSid = createMatAlgo04xSidSid({ typed: typed2, equalScalar });
    const matAlgo10xSids = createMatAlgo10xSids({ typed: typed2, DenseMatrix });
    const matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed2,
      matrix,
      concat: concat2
    });
    return typed2(
      name77,
      {
        "number, number": bitOrNumber,
        "BigNumber, BigNumber": bitOrBigNumber,
        "bigint, bigint": (x, y) => x | y
      },
      matrixAlgorithmSuite({
        SS: matAlgo04xSidSid,
        DS: matAlgo01xDSid,
        Ss: matAlgo10xSids
      })
    );
  }
);

// src/type/matrix/utils/matAlgo07xSSf.ts
var name78 = "matAlgo07xSSf";
var dependencies79 = ["typed", "SparseMatrix"];
var createMatAlgo07xSSf = /* @__PURE__ */ factory(
  name78,
  dependencies79,
  ({
    typed: typed2,
    SparseMatrix
  }) => {
    return function matAlgo07xSSf(a, b, callback) {
      const asize = a._size;
      const adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
      const bsize = b._size;
      const bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError(
          "Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")"
        );
      }
      const rows = asize[0];
      const columns = asize[1];
      let dt;
      let zero = 0;
      let cf = callback;
      if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
        dt = adt;
        zero = typed2.convert(0, dt);
        cf = typed2.find(callback, [dt, dt]);
      }
      const cvalues = [];
      const cindex = [];
      const cptr = new Array(columns + 1).fill(0);
      const xa = [];
      const xb = [];
      const wa = [];
      const wb = [];
      for (let j = 0; j < columns; j++) {
        const mark = j + 1;
        let nonZeroCount = 0;
        _scatter(a, j, wa, xa, mark);
        _scatter(b, j, wb, xb, mark);
        for (let i = 0; i < rows; i++) {
          const va = wa[i] === mark ? xa[i] : zero;
          const vb = wb[i] === mark ? xb[i] : zero;
          const cij = cf(va, vb);
          if (cij !== 0 && cij !== false) {
            cindex.push(i);
            cvalues.push(cij);
            nonZeroCount++;
          }
        }
        cptr[j + 1] = cptr[j] + nonZeroCount;
      }
      return new SparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
      });
    };
    function _scatter(m, j, w, x, mark) {
      const values = m._values;
      const index = m._index;
      const ptr = m._ptr;
      for (let k = ptr[j], k1 = ptr[j + 1]; k < k1; k++) {
        const i = index[k];
        w[i] = mark;
        if (values) {
          x[i] = values[k];
        }
      }
    }
  }
);

// src/function/bitwise/bitXor.ts
var name79 = "bitXor";
var dependencies80 = [
  "typed",
  "matrix",
  "DenseMatrix",
  "concat",
  "SparseMatrix"
];
var createBitXor = /* @__PURE__ */ factory(
  name79,
  dependencies80,
  ({ typed: typed2, matrix, DenseMatrix, concat: concat2, SparseMatrix }) => {
    const matAlgo03xDSf = createMatAlgo03xDSf({ typed: typed2 });
    const matAlgo07xSSf = createMatAlgo07xSSf({ typed: typed2, SparseMatrix });
    const matAlgo12xSfs = createMatAlgo12xSfs({ typed: typed2, DenseMatrix });
    const matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed2,
      matrix,
      concat: concat2
    });
    return typed2(
      name79,
      {
        "number, number": bitXorNumber,
        "BigNumber, BigNumber": bitXor,
        "bigint, bigint": (x, y) => x ^ y
      },
      matrixAlgorithmSuite({
        SS: matAlgo07xSSf,
        DS: matAlgo03xDSf,
        Ss: matAlgo12xSfs
      })
    );
  }
);

// src/function/complex/arg.ts
var name80 = "arg";
var dependencies81 = ["typed"];
var createArg = /* @__PURE__ */ factory(
  name80,
  dependencies81,
  ({ typed: typed2 }) => {
    return typed2(name80, {
      number: function(x) {
        return Math.atan2(0, x);
      },
      BigNumber: function(x) {
        return x.constructor.atan2(0, x);
      },
      Complex: function(x) {
        return x.arg();
      },
      // TODO: implement BigNumber support for function arg
      "Array | Matrix": typed2.referToSelf(
        (self) => (x) => deepMap2(x, self)
      )
    });
  }
);

// src/function/complex/conj.ts
var name81 = "conj";
var dependencies82 = ["typed"];
var createConj = /* @__PURE__ */ factory(
  name81,
  dependencies82,
  ({ typed: typed2 }) => {
    return typed2(name81, {
      "number | BigNumber | Fraction": (x) => x,
      Complex: (x) => x.conjugate(),
      Unit: typed2.referToSelf(
        (self) => (x) => new x.constructor(self(x.toNumeric()), x.formatUnits())
      ),
      "Array | Matrix": typed2.referToSelf(
        (self) => (x) => deepMap2(x, self)
      )
    });
  }
);

// src/function/complex/im.ts
var name82 = "im";
var dependencies83 = ["typed"];
var createIm = /* @__PURE__ */ factory(
  name82,
  dependencies83,
  ({ typed: typed2 }) => {
    return typed2(name82, {
      number: () => 0,
      "BigNumber | Fraction": (x) => x.mul(0),
      Complex: (x) => x.im,
      "Array | Matrix": typed2.referToSelf(
        (self) => (x) => deepMap2(x, self)
      )
    });
  }
);

// src/function/complex/re.ts
var name83 = "re";
var dependencies84 = ["typed"];
var createRe = /* @__PURE__ */ factory(
  name83,
  dependencies84,
  ({ typed: typed2 }) => {
    return typed2(name83, {
      "number | BigNumber | Fraction": (x) => x,
      Complex: (x) => x.re,
      "Array | Matrix": typed2.referToSelf(
        (self) => (x) => deepMap2(x, self)
      )
    });
  }
);

// src/function/logical/not.ts
var name84 = "not";
var dependencies85 = ["typed"];
var createNot = /* @__PURE__ */ factory(
  name84,
  dependencies85,
  ({ typed: typed2 }) => {
    return typed2(name84, {
      "null | undefined": () => true,
      number: notNumber,
      Complex: function(x) {
        return x.re === 0 && x.im === 0;
      },
      BigNumber: function(x) {
        return x.isZero() || x.isNaN();
      },
      bigint: (x) => !x,
      Unit: typed2.referToSelf(
        (self) => (x) => typed2.find(self, x.valueType())(x.value)
      ),
      "Array | Matrix": typed2.referToSelf(
        (self) => (x) => deepMap2(x, self)
      )
    });
  }
);

// src/function/logical/nullish.ts
var name85 = "nullish";
var dependencies86 = ["typed", "matrix", "size", "flatten", "deepEqual"];
var createNullish = /* @__PURE__ */ factory(
  name85,
  dependencies86,
  ({
    typed: typed2,
    matrix,
    size,
    flatten: _flatten,
    deepEqual
  }) => {
    const matAlgo03xDSf = createMatAlgo03xDSf({ typed: typed2 });
    const matAlgo14xDs = createMatAlgo14xDs({ typed: typed2 });
    const matAlgo13xDD = createMatAlgo13xDD({ typed: typed2 });
    const toMatrix = (arr) => {
      return matrix(arr);
    };
    return typed2(name85, {
      // Scalar and SparseMatrix-first short-circuit handlers
      "number|bigint|Complex|BigNumber|Fraction|Unit|string|boolean|SparseMatrix, any": (x, _y) => x,
      "null, any": (_x, y) => y,
      "undefined, any": (_x, y) => y,
      // SparseMatrix-first with collection RHS: enforce exact shape match
      "SparseMatrix, Array | Matrix": (x, y) => {
        const sx = size(x);
        const sy = size(y);
        if (deepEqual(sx, sy)) return x;
        throw new DimensionError(sx, sy);
      },
      // DenseMatrix-first handlers (no broadcasting between collections)
      "DenseMatrix, DenseMatrix": typed2.referToSelf(
        (self) => (x, y) => matAlgo13xDD(x, y, self)
      ),
      "DenseMatrix, SparseMatrix": typed2.referToSelf(
        (self) => (x, y) => matAlgo03xDSf(x, y, self, false)
      ),
      "DenseMatrix, Array": typed2.referToSelf(
        (self) => (x, y) => matAlgo13xDD(x, toMatrix(y), self)
      ),
      "DenseMatrix, any": typed2.referToSelf(
        (self) => (x, y) => matAlgo14xDs(x, y, self, false)
      ),
      // Array-first handlers (bridge via matrix() where needed)
      "Array, Array": typed2.referToSelf(
        (self) => (x, y) => matAlgo13xDD(toMatrix(x), toMatrix(y), self).valueOf()
      ),
      "Array, DenseMatrix": typed2.referToSelf(
        (self) => (x, y) => matAlgo13xDD(toMatrix(x), y, self)
      ),
      "Array, SparseMatrix": typed2.referToSelf(
        (self) => (x, y) => matAlgo03xDSf(toMatrix(x), y, self, false)
      ),
      "Array, any": typed2.referToSelf(
        (self) => (x, y) => matAlgo14xDs(toMatrix(x), y, self, false).valueOf()
      )
    });
  }
);

// src/function/logical/or.ts
var name86 = "or";
var dependencies87 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
var createOr = /* @__PURE__ */ factory(
  name86,
  dependencies87,
  ({ typed: typed2, matrix, equalScalar, DenseMatrix, concat: concat2 }) => {
    const matAlgo03xDSf = createMatAlgo03xDSf({ typed: typed2 });
    const matAlgo05xSfSf = createMatAlgo05xSfSf({ typed: typed2, equalScalar });
    const matAlgo12xSfs = createMatAlgo12xSfs({ typed: typed2, DenseMatrix });
    const matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed2,
      matrix,
      concat: concat2
    });
    return typed2(
      name86,
      {
        "number, number": orNumber,
        "Complex, Complex": function(x, y) {
          return x.re !== 0 || x.im !== 0 || y.re !== 0 || y.im !== 0;
        },
        "BigNumber, BigNumber": function(x, y) {
          return !x.isZero() && !x.isNaN() || !y.isZero() && !y.isNaN();
        },
        "bigint, bigint": orNumber,
        "Unit, Unit": typed2.referToSelf(
          (self) => (x, y) => self(x.value || 0, y.value || 0)
        )
      },
      matrixAlgorithmSuite({
        SS: matAlgo05xSfSf,
        DS: matAlgo03xDSf,
        Ss: matAlgo12xSfs
      })
    );
  }
);

// src/function/logical/xor.ts
var name87 = "xor";
var dependencies88 = [
  "typed",
  "matrix",
  "DenseMatrix",
  "concat",
  "SparseMatrix"
];
var createXor = /* @__PURE__ */ factory(
  name87,
  dependencies88,
  ({ typed: typed2, matrix, DenseMatrix, concat: concat2, SparseMatrix }) => {
    const matAlgo03xDSf = createMatAlgo03xDSf({ typed: typed2 });
    const matAlgo07xSSf = createMatAlgo07xSSf({ typed: typed2, SparseMatrix });
    const matAlgo12xSfs = createMatAlgo12xSfs({ typed: typed2, DenseMatrix });
    const matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed2,
      matrix,
      concat: concat2
    });
    return typed2(
      name87,
      {
        "number, number": xorNumber,
        "Complex, Complex": function(x, y) {
          return (x.re !== 0 || x.im !== 0) !== (y.re !== 0 || y.im !== 0);
        },
        "bigint, bigint": xorNumber,
        "BigNumber, BigNumber": function(x, y) {
          return (!x.isZero() && !x.isNaN()) !== (!y.isZero() && !y.isNaN());
        },
        "Unit, Unit": typed2.referToSelf(
          (self) => (x, y) => self(x.value || 0, y.value || 0)
        )
      },
      matrixAlgorithmSuite({
        SS: matAlgo07xSSf,
        DS: matAlgo03xDSf,
        Ss: matAlgo12xSfs
      })
    );
  }
);

// src/function/matrix/concat.ts
var name88 = "concat";
var dependencies89 = ["typed", "matrix", "isInteger"];
var createConcat = /* @__PURE__ */ factory(
  name88,
  dependencies89,
  ({
    typed: typed2,
    matrix,
    isInteger: isInteger2
  }) => {
    return typed2(name88, {
      // TODO: change signature to '...Array | Matrix, dim?' when supported
      "...Array | Matrix | number | BigNumber": function(args) {
        let i;
        const len = args.length;
        let dim = -1;
        let prevDim;
        let asMatrix = false;
        const matrices = [];
        for (i = 0; i < len; i++) {
          const arg = args[i];
          if (isMatrix(arg)) {
            asMatrix = true;
          }
          if (isNumber(arg) || isBigNumber(arg)) {
            if (i !== len - 1) {
              throw new Error("Dimension must be specified as last argument");
            }
            prevDim = dim;
            dim = arg.valueOf();
            if (!isInteger2(dim)) {
              throw new TypeError("Integer number expected for dimension");
            }
            if (dim < 0 || i > 0 && dim > prevDim) {
              throw new IndexError(dim, prevDim + 1);
            }
          } else {
            const m = clone(arg).valueOf();
            const size = arraySize(m);
            matrices[i] = m;
            prevDim = dim;
            dim = size.length - 1;
            if (i > 0 && dim !== prevDim) {
              throw new DimensionError(prevDim + 1, dim + 1);
            }
          }
        }
        if (matrices.length === 0) {
          throw new SyntaxError("At least one matrix expected");
        }
        let res = matrices.shift();
        while (matrices.length) {
          res = concat(res, matrices.shift(), dim);
        }
        return asMatrix ? matrix(res) : res;
      },
      "...string": function(args) {
        return args.join("");
      }
    });
  }
);

// src/function/matrix/column.ts
var name89 = "column";
var dependencies90 = ["typed", "Index", "matrix", "range"];
var createColumn = /* @__PURE__ */ factory(
  name89,
  dependencies90,
  ({ typed: typed2, Index: Index2, matrix, range }) => {
    return typed2(name89, {
      "Matrix, number": _column,
      "Array, number": function(value, column) {
        return _column(matrix(clone(value)), column).valueOf();
      }
    });
    function _column(value, column) {
      if (value.size().length !== 2) {
        throw new Error("Only two dimensional matrix is supported");
      }
      validateIndex(column, value.size()[1]);
      const rowRange = range(0, value.size()[0]);
      const index = new Index2(rowRange, [column]);
      const result = value.subset(index);
      return isMatrix(result) ? result : matrix([[result]]);
    }
  }
);

// src/function/matrix/count.ts
var name90 = "count";
var dependencies91 = ["typed", "size", "prod"];
var createCount = /* @__PURE__ */ factory(
  name90,
  dependencies91,
  ({ typed: typed2, size, prod }) => {
    return typed2(name90, {
      string: function(x) {
        return x.length;
      },
      "Matrix | Array": function(x) {
        return prod(size(x));
      }
    });
  }
);

// src/function/matrix/cross.ts
var name91 = "cross";
var dependencies92 = ["typed", "matrix", "subtract", "multiply"];
var createCross = /* @__PURE__ */ factory(
  name91,
  dependencies92,
  ({
    typed: typed2,
    matrix,
    subtract,
    multiply
  }) => {
    return typed2(name91, {
      "Matrix, Matrix": function(x, y) {
        return matrix(_cross(x.toArray(), y.toArray()));
      },
      "Matrix, Array": function(x, y) {
        return matrix(_cross(x.toArray(), y));
      },
      "Array, Matrix": function(x, y) {
        return matrix(_cross(x, y.toArray()));
      },
      "Array, Array": _cross
    });
    function _cross(x, y) {
      const highestDimension = Math.max(
        arraySize(x).length,
        arraySize(y).length
      );
      x = squeeze(x);
      y = squeeze(y);
      const xSize = arraySize(x);
      const ySize = arraySize(y);
      if (xSize.length !== 1 || ySize.length !== 1 || xSize[0] !== 3 || ySize[0] !== 3) {
        throw new RangeError(
          "Vectors with length 3 expected (Size A = [" + xSize.join(", ") + "], B = [" + ySize.join(", ") + "])"
        );
      }
      const product3 = [
        subtract(multiply(x[1], y[2]), multiply(x[2], y[1])),
        subtract(multiply(x[2], y[0]), multiply(x[0], y[2])),
        subtract(multiply(x[0], y[1]), multiply(x[1], y[0]))
      ];
      if (highestDimension > 1) {
        return [product3];
      } else {
        return product3;
      }
    }
  }
);

// src/function/matrix/diag.ts
var name92 = "diag";
var dependencies93 = ["typed", "matrix", "DenseMatrix", "SparseMatrix"];
var createDiag = /* @__PURE__ */ factory(
  name92,
  dependencies93,
  ({ typed: typed2, matrix, DenseMatrix, SparseMatrix }) => {
    return typed2(name92, {
      // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments
      Array: function(x) {
        return _diag(x, 0, arraySize(x), null);
      },
      "Array, number": function(x, k) {
        return _diag(x, k, arraySize(x), null);
      },
      "Array, BigNumber": function(x, k) {
        return _diag(x, k.toNumber(), arraySize(x), null);
      },
      "Array, string": function(x, format4) {
        return _diag(x, 0, arraySize(x), format4);
      },
      "Array, number, string": function(x, k, format4) {
        return _diag(x, k, arraySize(x), format4);
      },
      "Array, BigNumber, string": function(x, k, format4) {
        return _diag(x, k.toNumber(), arraySize(x), format4);
      },
      Matrix: function(x) {
        return _diag(x, 0, x.size(), x.storage());
      },
      "Matrix, number": function(x, k) {
        return _diag(x, k, x.size(), x.storage());
      },
      "Matrix, BigNumber": function(x, k) {
        return _diag(x, k.toNumber(), x.size(), x.storage());
      },
      "Matrix, string": function(x, format4) {
        return _diag(x, 0, x.size(), format4);
      },
      "Matrix, number, string": function(x, k, format4) {
        return _diag(x, k, x.size(), format4);
      },
      "Matrix, BigNumber, string": function(x, k, format4) {
        return _diag(x, k.toNumber(), x.size(), format4);
      }
    });
    function _diag(x, k, size, format4) {
      if (!isInteger(k)) {
        throw new TypeError(
          "Second parameter in function diag must be an integer"
        );
      }
      const kSuper = k > 0 ? k : 0;
      const kSub = k < 0 ? -k : 0;
      switch (size.length) {
        case 1:
          return _createDiagonalMatrix(x, k, format4, size[0], kSub, kSuper);
        case 2:
          return _getDiagonal(x, k, format4, size, kSub, kSuper);
      }
      throw new RangeError("Matrix for function diag must be 2 dimensional");
    }
    function _createDiagonalMatrix(x, k, format4, l, kSub, kSuper) {
      const ms = [l + kSub, l + kSuper];
      if (format4 && format4 !== "sparse" && format4 !== "dense") {
        throw new TypeError(`Unknown matrix type ${format4}"`);
      }
      const m = format4 === "sparse" ? SparseMatrix.diagonal(ms, x, k) : DenseMatrix.diagonal(ms, x, k);
      return format4 !== null ? m : m.valueOf();
    }
    function _getDiagonal(x, k, format4, s, kSub, kSuper) {
      if (isMatrix(x)) {
        const dm = x.diagonal(k);
        if (format4 !== null) {
          if (format4 !== dm.storage()) {
            return matrix(dm.valueOf(), format4);
          }
          return dm;
        }
        return dm.valueOf();
      }
      const n = Math.min(s[0] - kSub, s[1] - kSuper);
      const vector = [];
      for (let i = 0; i < n; i++) {
        vector[i] = x[i + kSub][i + kSuper];
      }
      return format4 !== null ? matrix(vector) : vector;
    }
  }
);

// src/function/matrix/filter.ts
var name93 = "filter";
var dependencies94 = ["typed"];
var createFilter = /* @__PURE__ */ factory(
  name93,
  dependencies94,
  ({ typed: typed2 }) => {
    return typed2("filter", {
      "Array, function": _filterCallback,
      "Matrix, function": function(x, test) {
        return x.create(_filterCallback(x.valueOf(), test), x.datatype());
      },
      "Array, RegExp": filterRegExp,
      "Matrix, RegExp": function(x, test) {
        return x.create(filterRegExp(x.valueOf(), test), x.datatype());
      }
    });
  }
);
function _filterCallback(x, callback) {
  const fastCallback = optimizeCallback(callback, x, "filter");
  if (fastCallback.isUnary) {
    return filter(x, fastCallback.fn);
  }
  return filter(x, function(value, index, array) {
    return fastCallback.fn(value, [index], array);
  });
}

// src/function/matrix/flatten.ts
var name94 = "flatten";
var dependencies95 = ["typed"];
var createFlatten = /* @__PURE__ */ factory(
  name94,
  dependencies95,
  ({ typed: typed2 }) => {
    return typed2(name94, {
      Array: function(x) {
        return flatten(x);
      },
      DenseMatrix: function(x) {
        return x.create(flatten(x.valueOf(), true), x.datatype());
      },
      SparseMatrix: function(_x) {
        throw new TypeError(
          "SparseMatrix is not supported by function flatten because it does not support 1D vectors. Convert to a DenseMatrix or Array first. Example: flatten(x.toArray())"
        );
      }
    });
  }
);

// src/function/matrix/forEach.ts
var name95 = "forEach";
var dependencies96 = ["typed"];
var createForEach = /* @__PURE__ */ factory(
  name95,
  dependencies96,
  ({ typed: typed2 }) => {
    return typed2(name95, {
      "Array, function": _forEach,
      "Matrix, function": function(x, callback) {
        x.forEach(callback);
      }
    });
  }
);
function _forEach(array, callback) {
  const fastCallback = optimizeCallback(callback, array, name95);
  deepForEach(array, fastCallback.fn, fastCallback.isUnary);
}

// src/function/matrix/getMatrixDataType.ts
var name96 = "getMatrixDataType";
var dependencies97 = ["typed"];
var createGetMatrixDataType = /* @__PURE__ */ factory(
  name96,
  dependencies97,
  ({ typed: typed2 }) => {
    return typed2(name96, {
      Array: function(x) {
        return getArrayDataType(x, typeOf);
      },
      Matrix: function(x) {
        return x.getDataType();
      }
    });
  }
);

// src/function/matrix/identity.ts
var name97 = "identity";
var dependencies98 = [
  "typed",
  "config",
  "matrix",
  "BigNumber",
  "DenseMatrix",
  "SparseMatrix"
];
var createIdentity = /* @__PURE__ */ factory(
  name97,
  dependencies98,
  ({
    typed: typed2,
    config,
    matrix,
    BigNumber,
    DenseMatrix,
    SparseMatrix
  }) => {
    return typed2(name97, {
      "": function() {
        return config.matrix === "Matrix" ? matrix([]) : [];
      },
      string: function(format4) {
        return matrix(format4);
      },
      "number | BigNumber": function(rows) {
        return _identity(
          rows,
          rows,
          config.matrix === "Matrix" ? "dense" : void 0
        );
      },
      "number | BigNumber, string": function(rows, format4) {
        return _identity(rows, rows, format4);
      },
      "number | BigNumber, number | BigNumber": function(rows, cols) {
        return _identity(
          rows,
          cols,
          config.matrix === "Matrix" ? "dense" : void 0
        );
      },
      "number | BigNumber, number | BigNumber, string": function(rows, cols, format4) {
        return _identity(rows, cols, format4);
      },
      Array: function(size) {
        return _identityVector(size);
      },
      "Array, string": function(size, format4) {
        return _identityVector(size, format4);
      },
      Matrix: function(size) {
        return _identityVector(
          size.valueOf(),
          size.storage()
        );
      },
      "Matrix, string": function(size, format4) {
        return _identityVector(size.valueOf(), format4);
      }
    });
    function _identityVector(size, format4) {
      switch (size.length) {
        case 0:
          return format4 ? matrix(format4) : [];
        case 1:
          return _identity(size[0], size[0], format4);
        case 2:
          return _identity(size[0], size[1], format4);
        default:
          throw new Error("Vector containing two values expected");
      }
    }
    function _identity(rows, cols, format4) {
      const Big = isBigNumber(rows) || isBigNumber(cols) ? BigNumber : null;
      if (isBigNumber(rows)) rows = rows.toNumber();
      if (isBigNumber(cols)) cols = cols.toNumber();
      if (!isInteger(rows) || rows < 1) {
        throw new Error(
          "Parameters in function identity must be positive integers"
        );
      }
      if (!isInteger(cols) || cols < 1) {
        throw new Error(
          "Parameters in function identity must be positive integers"
        );
      }
      const one = Big ? new BigNumber(1) : 1;
      const defaultValue = Big ? new Big(0) : 0;
      const size = [rows, cols];
      if (format4) {
        if (format4 === "sparse") {
          return SparseMatrix.diagonal(size, one, 0, defaultValue);
        }
        if (format4 === "dense") {
          return DenseMatrix.diagonal(size, one, 0, defaultValue);
        }
        throw new TypeError(`Unknown matrix type "${format4}"`);
      }
      const res = resize([], size, defaultValue);
      const minimum = rows < cols ? rows : cols;
      for (let d = 0; d < minimum; d++) {
        res[d][d] = one;
      }
      return res;
    }
  }
);

// src/wasm/WasmLoader.ts
var _WasmLoader = class _WasmLoader {
  // 1MB max per pool entry
  constructor() {
    this.wasmModule = null;
    this.compiledModule = null;
    this.loading = null;
    this.lastMetrics = null;
    // Memory pool for reusable allocations
    this.float64Pool = [];
    this.int32Pool = [];
    this.maxPoolSize = 32;
    this.poolSizeThreshold = 1024 * 1024;
    this.isNode = typeof process !== "undefined" && process.versions?.node !== void 0;
  }
  static getInstance() {
    if (!_WasmLoader.instance) {
      _WasmLoader.instance = new _WasmLoader();
    }
    return _WasmLoader.instance;
  }
  /**
   * Load the WASM module
   */
  async load(wasmPath) {
    if (this.wasmModule) {
      return this.wasmModule;
    }
    if (this.loading) {
      return this.loading;
    }
    this.loading = this.loadModule(wasmPath);
    this.wasmModule = await this.loading;
    return this.wasmModule;
  }
  /**
   * Precompile the WASM module without instantiation
   * Useful for build-time or startup optimization
   */
  async precompile(wasmPath) {
    if (this.compiledModule) return;
    const path = wasmPath || this.getDefaultWasmPath();
    const startTime = performance.now();
    if (this.isNode) {
      const fs = await import('fs');
      const { promisify } = await import('util');
      const readFile = promisify(fs.readFile);
      const buffer = await readFile(path);
      this.compiledModule = await WebAssembly.compile(buffer);
    } else {
      const response = await fetch(path);
      if (typeof WebAssembly.compileStreaming === "function") {
        this.compiledModule = await WebAssembly.compileStreaming(fetch(path));
      } else {
        const buffer = await response.arrayBuffer();
        this.compiledModule = await WebAssembly.compile(buffer);
      }
    }
    this.lastMetrics = {
      fileReadMs: 0,
      compileMs: performance.now() - startTime,
      instantiateMs: 0,
      totalMs: performance.now() - startTime,
      fromCache: false
    };
  }
  async loadModule(wasmPath) {
    const path = wasmPath || this.getDefaultWasmPath();
    const totalStart = performance.now();
    if (this.compiledModule) {
      const instStart = performance.now();
      const instance = await WebAssembly.instantiate(
        this.compiledModule,
        this.getImports()
      );
      this.lastMetrics = {
        fileReadMs: 0,
        compileMs: 0,
        instantiateMs: performance.now() - instStart,
        totalMs: performance.now() - totalStart,
        fromCache: true
      };
      return instance.exports;
    }
    if (this.isNode) {
      return this.loadNodeWasm(path, totalStart);
    } else {
      return this.loadBrowserWasm(path, totalStart);
    }
  }
  getDefaultWasmPath() {
    if (this.isNode) {
      return "./lib/wasm/index.wasm";
    } else {
      return new URL("../../lib/wasm/index.wasm", (typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('index.cjs', document.baseURI).href))).href;
    }
  }
  async loadNodeWasm(path, totalStart) {
    const fs = await import('fs');
    const { promisify } = await import('util');
    const readFile = promisify(fs.readFile);
    const readStart = performance.now();
    const buffer = await readFile(path);
    const readEnd = performance.now();
    const compileStart = performance.now();
    this.compiledModule = await WebAssembly.compile(buffer);
    const compileEnd = performance.now();
    const instStart = performance.now();
    const instance = await WebAssembly.instantiate(
      this.compiledModule,
      this.getImports()
    );
    const instEnd = performance.now();
    this.lastMetrics = {
      fileReadMs: readEnd - readStart,
      compileMs: compileEnd - compileStart,
      instantiateMs: instEnd - instStart,
      totalMs: performance.now() - totalStart,
      fromCache: false
    };
    return instance.exports;
  }
  async loadBrowserWasm(path, totalStart) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      const instStart2 = performance.now();
      const result = await WebAssembly.instantiateStreaming(
        fetch(path),
        this.getImports()
      );
      this.compiledModule = result.module;
      this.lastMetrics = {
        fileReadMs: 0,
        // Combined with compile in streaming
        compileMs: 0,
        // Combined in streaming
        instantiateMs: performance.now() - instStart2,
        totalMs: performance.now() - totalStart,
        fromCache: false
      };
      return result.instance.exports;
    }
    const readStart = performance.now();
    const response = await fetch(path);
    const buffer = await response.arrayBuffer();
    const readEnd = performance.now();
    const compileStart = performance.now();
    this.compiledModule = await WebAssembly.compile(buffer);
    const compileEnd = performance.now();
    const instStart = performance.now();
    const instance = await WebAssembly.instantiate(
      this.compiledModule,
      this.getImports()
    );
    const instEnd = performance.now();
    this.lastMetrics = {
      fileReadMs: readEnd - readStart,
      compileMs: compileEnd - compileStart,
      instantiateMs: instEnd - instStart,
      totalMs: performance.now() - totalStart,
      fromCache: false
    };
    return instance.exports;
  }
  getImports() {
    return {
      env: {
        abort: (msg, file, line, column) => {
          console.error("WASM abort", { msg, file, line, column });
          throw new Error("WASM abort");
        },
        seed: () => Date.now()
      },
      Math,
      Date
    };
  }
  /**
   * Get the loaded WASM module
   */
  getModule() {
    return this.wasmModule;
  }
  /**
   * Get the compiled WASM module (for caching/serialization)
   */
  getCompiledModule() {
    return this.compiledModule;
  }
  /**
   * Check if WASM is loaded
   */
  isLoaded() {
    return this.wasmModule !== null;
  }
  /**
   * Check if WASM is precompiled
   */
  isPrecompiled() {
    return this.compiledModule !== null;
  }
  /**
   * Get loading performance metrics
   */
  getLoadingMetrics() {
    return this.lastMetrics;
  }
  /**
   * Allocate Float64Array in WASM memory
   * Uses memory pooling for frequently reused sizes
   */
  allocateFloat64Array(data) {
    const module = this.wasmModule;
    if (!module) throw new Error("WASM module not loaded");
    const length = data.length;
    const byteLength = length * 8;
    let ptr;
    if (byteLength <= this.poolSizeThreshold) {
      const poolEntry = this.getFromPool(this.float64Pool, byteLength);
      if (poolEntry) {
        ptr = poolEntry.ptr;
        poolEntry.inUse = true;
      } else {
        ptr = module.__new(byteLength, 2);
      }
    } else {
      ptr = module.__new(byteLength, 2);
    }
    const array = new Float64Array(module.memory.buffer, ptr, length);
    array.set(data);
    return { ptr, array };
  }
  /**
   * Allocate Float64Array without copying data (for output buffers)
   */
  allocateFloat64ArrayEmpty(length) {
    const module = this.wasmModule;
    if (!module) throw new Error("WASM module not loaded");
    const byteLength = length * 8;
    let ptr;
    if (byteLength <= this.poolSizeThreshold) {
      const poolEntry = this.getFromPool(this.float64Pool, byteLength);
      if (poolEntry) {
        ptr = poolEntry.ptr;
        poolEntry.inUse = true;
      } else {
        ptr = module.__new(byteLength, 2);
      }
    } else {
      ptr = module.__new(byteLength, 2);
    }
    const array = new Float64Array(module.memory.buffer, ptr, length);
    return { ptr, array };
  }
  /**
   * Allocate Int32Array in WASM memory
   * Uses memory pooling for frequently reused sizes
   */
  allocateInt32Array(data) {
    const module = this.wasmModule;
    if (!module) throw new Error("WASM module not loaded");
    const length = data.length;
    const byteLength = length * 4;
    let ptr;
    if (byteLength <= this.poolSizeThreshold) {
      const poolEntry = this.getFromPool(this.int32Pool, byteLength);
      if (poolEntry) {
        ptr = poolEntry.ptr;
        poolEntry.inUse = true;
      } else {
        ptr = module.__new(byteLength, 1);
      }
    } else {
      ptr = module.__new(byteLength, 1);
    }
    const array = new Int32Array(module.memory.buffer, ptr, length);
    array.set(data);
    return { ptr, array };
  }
  /**
   * Allocate Int32Array without copying data (for output buffers)
   */
  allocateInt32ArrayEmpty(length) {
    const module = this.wasmModule;
    if (!module) throw new Error("WASM module not loaded");
    const byteLength = length * 4;
    let ptr;
    if (byteLength <= this.poolSizeThreshold) {
      const poolEntry = this.getFromPool(this.int32Pool, byteLength);
      if (poolEntry) {
        ptr = poolEntry.ptr;
        poolEntry.inUse = true;
      } else {
        ptr = module.__new(byteLength, 1);
      }
    } else {
      ptr = module.__new(byteLength, 1);
    }
    const array = new Int32Array(module.memory.buffer, ptr, length);
    return { ptr, array };
  }
  /**
   * Get a suitable entry from the memory pool
   */
  getFromPool(pool, requestedSize) {
    let bestFit = null;
    let bestFitWaste = Infinity;
    for (const entry of pool) {
      if (!entry.inUse && entry.size >= requestedSize) {
        const waste = entry.size - requestedSize;
        if (waste < bestFitWaste && entry.size <= requestedSize * 2) {
          bestFit = entry;
          bestFitWaste = waste;
        }
      }
    }
    return bestFit;
  }
  /**
   * Return allocation to pool for reuse
   */
  release(ptr, isFloat64 = true) {
    const pool = isFloat64 ? this.float64Pool : this.int32Pool;
    const entry = pool.find((e2) => e2.ptr === ptr);
    if (entry) {
      entry.inUse = false;
      return;
    }
    this.free(ptr);
  }
  /**
   * Free allocated memory (immediate, bypasses pool)
   */
  free(ptr) {
    const module = this.wasmModule;
    if (!module) return;
    this.float64Pool = this.float64Pool.filter((e2) => e2.ptr !== ptr);
    this.int32Pool = this.int32Pool.filter((e2) => e2.ptr !== ptr);
    module.__unpin(ptr);
  }
  /**
   * Clear the memory pool
   */
  clearPool() {
    const module = this.wasmModule;
    if (!module) return;
    for (const entry of this.float64Pool) {
      module.__unpin(entry.ptr);
    }
    for (const entry of this.int32Pool) {
      module.__unpin(entry.ptr);
    }
    this.float64Pool = [];
    this.int32Pool = [];
  }
  /**
   * Get pool statistics
   */
  getPoolStats() {
    const f64InUse = this.float64Pool.filter((e2) => e2.inUse).length;
    const f64Bytes = this.float64Pool.reduce((sum, e2) => sum + e2.size, 0);
    const i32InUse = this.int32Pool.filter((e2) => e2.inUse).length;
    const i32Bytes = this.int32Pool.reduce((sum, e2) => sum + e2.size, 0);
    return {
      float64: {
        total: this.float64Pool.length,
        inUse: f64InUse,
        totalBytes: f64Bytes
      },
      int32: {
        total: this.int32Pool.length,
        inUse: i32InUse,
        totalBytes: i32Bytes
      }
    };
  }
  /**
   * Run garbage collection
   */
  collect() {
    const module = this.wasmModule;
    if (!module) return;
    module.__collect();
  }
  /**
   * Reset the loader (for testing)
   */
  reset() {
    this.clearPool();
    this.wasmModule = null;
    this.compiledModule = null;
    this.loading = null;
    this.lastMetrics = null;
  }
};
_WasmLoader.instance = null;
var WasmLoader = _WasmLoader;
var wasmLoader = WasmLoader.getInstance();

// src/function/matrix/kron.ts
var WASM_KRON_THRESHOLD = 64;
function isPlainNumber2D(arr) {
  for (let i = 0; i < arr.length; i++) {
    const row = arr[i];
    for (let j = 0; j < row.length; j++) {
      if (typeof row[j] !== "number") {
        return false;
      }
    }
  }
  return true;
}
function flatten2D(arr, rows, cols) {
  const result = new Float64Array(rows * cols);
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      result[i * cols + j] = arr[i][j];
    }
  }
  return result;
}
function unflatten2D(flat, rows, cols) {
  const result = [];
  for (let i = 0; i < rows; i++) {
    const row = [];
    for (let j = 0; j < cols; j++) {
      row.push(flat[i * cols + j]);
    }
    result.push(row);
  }
  return result;
}
var name98 = "kron";
var dependencies99 = ["typed", "matrix", "multiplyScalar"];
var createKron = /* @__PURE__ */ factory(
  name98,
  dependencies99,
  ({ typed: typed2, matrix, multiplyScalar }) => {
    return typed2(name98, {
      "Matrix, Matrix": function(x, y) {
        return matrix(_kron(x.toArray(), y.toArray()));
      },
      "Matrix, Array": function(x, y) {
        return matrix(_kron(x.toArray(), y));
      },
      "Array, Matrix": function(x, y) {
        return matrix(_kron(x, y.toArray()));
      },
      "Array, Array": _kron
    });
    function _kron1d(a, b) {
      return a.flatMap((x) => b.map((y) => multiplyScalar(x, y)));
    }
    function _kron(a, b, d = -1) {
      if (d < 0) {
        let adim = arraySize(a).length;
        let bdim = arraySize(b).length;
        d = Math.max(adim, bdim);
        while (adim++ < d) a = [a];
        while (bdim++ < d) b = [b];
      }
      if (d === 1) return _kron1d(a, b);
      if (d === 2) {
        const aSize = arraySize(a);
        const bSize = arraySize(b);
        const aRows = aSize[0];
        const aCols = aSize[1];
        const bRows = bSize[0];
        const bCols = bSize[1];
        const totalElements = aRows * aCols * bRows * bCols;
        const wasm = wasmLoader.getModule();
        if (wasm && totalElements >= WASM_KRON_THRESHOLD && isPlainNumber2D(a) && isPlainNumber2D(b)) {
          try {
            const aFlat = flatten2D(a, aRows, aCols);
            const bFlat = flatten2D(b, bRows, bCols);
            const aAlloc = wasmLoader.allocateFloat64Array(aFlat);
            const bAlloc = wasmLoader.allocateFloat64Array(bFlat);
            const resultRows = aRows * bRows;
            const resultCols = aCols * bCols;
            const resultAlloc = wasmLoader.allocateFloat64ArrayEmpty(
              resultRows * resultCols
            );
            try {
              wasm.laKron(aAlloc.ptr, aRows, aCols, bAlloc.ptr, bRows, bCols);
              const resultFlat = new Float64Array(resultAlloc.array);
              return unflatten2D(resultFlat, resultRows, resultCols);
            } finally {
              wasmLoader.free(aAlloc.ptr);
              wasmLoader.free(bAlloc.ptr);
              wasmLoader.free(resultAlloc.ptr);
            }
          } catch {
          }
        }
      }
      return a.flatMap(
        (aSlice) => b.map((bSlice) => _kron(aSlice, bSlice, d - 1))
      );
    }
  }
);

// src/function/matrix/map.ts
var name99 = "map";
var dependencies100 = ["typed"];
var createMap2 = /* @__PURE__ */ factory(
  name99,
  dependencies100,
  ({ typed: typed2 }) => {
    return typed2(name99, {
      "Array, function": _mapArray,
      "Matrix, function": function(x, callback) {
        return x.map(callback);
      },
      "Array|Matrix, Array|Matrix, ...Array|Matrix|function": (A, B, rest) => _mapMultiple(
        [A, B, ...rest.slice(0, rest.length - 1)],
        rest[rest.length - 1]
      )
    });
    function _mapMultiple(Arrays, multiCallback) {
      if (typeof multiCallback !== "function") {
        throw new Error("Last argument must be a callback function");
      }
      const firstArrayIsMatrix = Arrays[0].isMatrix;
      const sizes = Arrays.map(
        (M) => M.isMatrix ? M.size() : arraySize(M)
      );
      const newSize = broadcastSizes(...sizes);
      const numberOfArrays = Arrays.length;
      const _get = firstArrayIsMatrix ? (matrix, idx) => matrix.get(idx) : get;
      const firstValues = Arrays.map((collection, i) => {
        const firstIndex = sizes[i].map(() => 0);
        return collection.isMatrix ? collection.get(firstIndex) : get(collection, firstIndex);
      });
      const callbackArgCount = typed2.isTypedFunction(multiCallback) ? _getTypedCallbackArgCount(
        multiCallback,
        firstValues,
        newSize.map(() => 0),
        Arrays
      ) : _getCallbackArgCount(multiCallback, numberOfArrays);
      if (callbackArgCount < 2) {
        const callback2 = _getLimitedCallback(
          callbackArgCount,
          multiCallback,
          null
        );
        return mapMultiple(Arrays, callback2);
      }
      const broadcastedArrays = firstArrayIsMatrix ? Arrays.map(
        (M) => M.isMatrix ? M.create(broadcastTo(M.toArray(), newSize), M.datatype()) : Arrays[0].create(broadcastTo(M.valueOf(), newSize))
      ) : Arrays.map(
        (M) => M.isMatrix ? broadcastTo(M.toArray(), newSize) : broadcastTo(M, newSize)
      );
      const callback = _getLimitedCallback(
        callbackArgCount,
        multiCallback,
        broadcastedArrays
      );
      const broadcastedArraysCallback = (x, idx) => callback(
        [
          x,
          ...broadcastedArrays.slice(1).map((array) => _get(array, idx))
        ],
        idx
      );
      if (firstArrayIsMatrix) {
        return broadcastedArrays[0].map(broadcastedArraysCallback);
      } else {
        return _mapArray(broadcastedArrays[0], broadcastedArraysCallback);
      }
    }
    function mapMultiple(collections, callback) {
      const firstCollection = collections[0];
      const arrays = collections.map(
        (collection) => collection.isMatrix ? collection.valueOf() : collection
      );
      const sizes = collections.map(
        (collection) => collection.isMatrix ? collection.size() : arraySize(collection)
      );
      const finalSize = broadcastSizes(...sizes);
      const offsets = sizes.map(
        (size) => finalSize.length - size.length
      );
      const maxDepth = finalSize.length - 1;
      const callbackUsesIndex = callback.length > 1;
      const index = callbackUsesIndex ? [] : null;
      const resultsArray = iterate(arrays, 0);
      if (firstCollection.isMatrix) {
        const resultsMatrix = firstCollection.create();
        resultsMatrix._data = resultsArray;
        resultsMatrix._size = finalSize;
        return resultsMatrix;
      } else {
        return resultsArray;
      }
      function iterate(arrays2, depth = 0) {
        const currentDimensionSize = finalSize[depth];
        const result = Array(currentDimensionSize);
        if (depth < maxDepth) {
          for (let i = 0; i < currentDimensionSize; i++) {
            if (index) index[depth] = i;
            result[i] = iterate(
              arrays2.map(
                (array, arrayIndex) => offsets[arrayIndex] > depth ? array : array.length === 1 ? array[0] : array[i]
              ),
              depth + 1
            );
          }
        } else {
          for (let i = 0; i < currentDimensionSize; i++) {
            if (index) index[depth] = i;
            result[i] = callback(
              arrays2.map((a) => a.length === 1 ? a[0] : a[i]),
              index ? index.slice() : void 0
            );
          }
        }
        return result;
      }
    }
    function _getLimitedCallback(callbackArgCount, multiCallback, broadcastedArrays) {
      switch (callbackArgCount) {
        case 0:
          return (x) => multiCallback(...x);
        case 1:
          return (x, idx) => multiCallback(...x, idx);
        case 2:
          return (x, idx) => multiCallback(...x, idx, ...broadcastedArrays);
      }
      throw new Error("Invalid callbackArgCount");
    }
    function _getCallbackArgCount(callback, numberOfArrays) {
      const callbackStr = callback.toString();
      if (/arguments/.test(callbackStr)) return 2;
      const paramsStr = callbackStr.match(/\(.*?\)/);
      if (/\.\.\./.test(paramsStr)) return 2;
      if (callback.length > numberOfArrays + 1) {
        return 2;
      }
      if (callback.length === numberOfArrays + 1) {
        return 1;
      }
      return 0;
    }
    function _getTypedCallbackArgCount(callback, values, idx, arrays) {
      if (typed2.resolve(callback, [...values, idx, ...arrays]) !== null) {
        return 2;
      }
      if (typed2.resolve(callback, [...values, idx]) !== null) {
        return 1;
      }
      if (typed2.resolve(callback, values) !== null) {
        return 0;
      }
      return 0;
    }
    function _mapArray(array, callback) {
      const fastCallback = optimizeCallback(callback, array, name99);
      return deepMap(array, fastCallback.fn, fastCallback.isUnary);
    }
  }
);

// src/function/matrix/diff.ts
var name100 = "diff";
var dependencies101 = ["typed", "matrix", "subtract", "number"];
var createDiff = /* @__PURE__ */ factory(
  name100,
  dependencies101,
  ({
    typed: typed2,
    matrix,
    subtract,
    number
  }) => {
    return typed2(name100, {
      "Array | Matrix": function(arr) {
        if (isMatrix(arr)) {
          return matrix(_diff(arr.toArray()));
        } else {
          return _diff(arr);
        }
      },
      "Array | Matrix, number": function(arr, dim) {
        if (!isInteger(dim))
          throw new RangeError("Dimension must be a whole number");
        if (isMatrix(arr)) {
          return matrix(_recursive(arr.toArray(), dim));
        } else {
          return _recursive(arr, dim);
        }
      },
      "Array, BigNumber": typed2.referTo(
        "Array,number",
        (selfAn) => (arr, dim) => selfAn(arr, number(dim))
      ),
      "Matrix, BigNumber": typed2.referTo(
        "Matrix,number",
        (selfMn) => (arr, dim) => selfMn(arr, number(dim))
      )
    });
    function _recursive(arr, dim) {
      if (isMatrix(arr)) {
        arr = arr.toArray();
      }
      if (!Array.isArray(arr)) {
        throw RangeError("Array/Matrix does not have that many dimensions");
      }
      if (dim > 0) {
        const result = [];
        arr.forEach((element) => {
          result.push(_recursive(element, dim - 1));
        });
        return result;
      } else if (dim === 0) {
        return _diff(arr);
      } else {
        throw RangeError("Cannot have negative dimension");
      }
    }
    function _diff(arr) {
      const result = [];
      const size = arr.length;
      for (let i = 1; i < size; i++) {
        result.push(_ElementDiff(arr[i - 1], arr[i]));
      }
      return result;
    }
    function _ElementDiff(obj1, obj2) {
      if (isMatrix(obj1)) obj1 = obj1.toArray();
      if (isMatrix(obj2)) obj2 = obj2.toArray();
      const obj1IsArray = Array.isArray(obj1);
      const obj2IsArray = Array.isArray(obj2);
      if (obj1IsArray && obj2IsArray) {
        return _ArrayDiff(obj1, obj2);
      }
      if (!obj1IsArray && !obj2IsArray) {
        return subtract(obj2, obj1);
      }
      throw TypeError(
        "Cannot calculate difference between 1 array and 1 non-array"
      );
    }
    function _ArrayDiff(arr1, arr2) {
      if (arr1.length !== arr2.length) {
        throw RangeError("Not all sub-arrays have the same length");
      }
      const result = [];
      const size = arr1.length;
      for (let i = 0; i < size; i++) {
        result.push(_ElementDiff(arr1[i], arr2[i]));
      }
      return result;
    }
  }
);

// src/function/matrix/ones.ts
var name101 = "ones";
var dependencies102 = ["typed", "config", "matrix", "BigNumber"];
var createOnes = /* @__PURE__ */ factory(
  name101,
  dependencies102,
  ({ typed: typed2, config, matrix, BigNumber }) => {
    return typed2("ones", {
      "": function() {
        return config.matrix === "Array" ? _ones([]) : _ones([], "default");
      },
      // math.ones(m, n, p, ..., format)
      // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
      "...number | BigNumber | string": function(size) {
        const last = size[size.length - 1];
        if (typeof last === "string") {
          const format4 = size.pop();
          return _ones(size, format4);
        } else if (config.matrix === "Array") {
          return _ones(size);
        } else {
          return _ones(size, "default");
        }
      },
      Array: _ones,
      Matrix: function(size) {
        const format4 = size.storage();
        return _ones(size.valueOf(), format4);
      },
      "Array | Matrix, string": function(size, format4) {
        const sizeArray = Array.isArray(size) ? size : size.valueOf();
        return _ones(sizeArray, format4);
      }
    });
    function _ones(size, format4) {
      const hasBigNumbers = _normalize(size);
      const defaultValue = hasBigNumbers ? new BigNumber(1) : 1;
      _validate2(size);
      if (format4) {
        const m = matrix(format4);
        if (size.length > 0) {
          return m.resize(size, defaultValue);
        }
        return m;
      } else {
        const arr = [];
        if (size.length > 0) {
          return resize(arr, size, defaultValue);
        }
        return arr;
      }
    }
    function _normalize(size) {
      let hasBigNumbers = false;
      size.forEach(function(value, index, arr) {
        if (isBigNumber(value)) {
          hasBigNumbers = true;
          arr[index] = value.toNumber();
        }
      });
      return hasBigNumbers;
    }
    function _validate2(size) {
      size.forEach(function(value) {
        if (typeof value !== "number" || !isInteger(value) || value < 0) {
          throw new Error(
            "Parameters in function ones must be positive integers"
          );
        }
      });
    }
  }
);

// src/utils/noop.ts
function noBignumber() {
  throw new Error('No "bignumber" implementation available');
}
function noFraction() {
  throw new Error('No "fraction" implementation available');
}
function noMatrix() {
  throw new Error('No "matrix" implementation available');
}

// src/function/matrix/range.ts
var name102 = "range";
var dependencies103 = [
  "typed",
  "config",
  "?matrix",
  "?bignumber",
  "equal",
  "smaller",
  "smallerEq",
  "larger",
  "largerEq",
  "add",
  "isZero",
  "isPositive"
];
var createRange = /* @__PURE__ */ factory(
  name102,
  dependencies103,
  ({
    typed: typed2,
    config,
    matrix,
    bignumber,
    smaller,
    smallerEq,
    larger,
    largerEq,
    add,
    isZero,
    isPositive
  }) => {
    return typed2(name102, {
      // TODO: simplify signatures when typed-function supports default values and optional arguments
      string: _strRange,
      "string, boolean": _strRange,
      number: function(oops) {
        throw new TypeError(`Too few arguments to function range(): ${oops}`);
      },
      boolean: function(oops) {
        throw new TypeError(
          `Unexpected type of argument 1 to function range(): ${oops}, number|bigint|BigNumber|Fraction`
        );
      },
      "number, number": function(start, end) {
        return _out(_range(start, end, 1, false));
      },
      "number, number, number": function(start, end, step) {
        return _out(_range(start, end, step, false));
      },
      "number, number, boolean": function(start, end, includeEnd) {
        return _out(_range(start, end, 1, includeEnd));
      },
      "number, number, number, boolean": function(start, end, step, includeEnd) {
        return _out(_range(start, end, step, includeEnd));
      },
      // Handle bigints; if either limit is bigint, range should be too
      "bigint, bigint|number": function(start, end) {
        return _out(_range(start, end, 1n, false));
      },
      "number, bigint": function(start, end) {
        return _out(_range(BigInt(start), end, 1n, false));
      },
      "bigint, bigint|number, bigint|number": function(start, end, step) {
        return _out(_range(start, end, BigInt(step), false));
      },
      "number, bigint, bigint|number": function(start, end, step) {
        return _out(_range(BigInt(start), end, BigInt(step), false));
      },
      "bigint, bigint|number, boolean": function(start, end, includeEnd) {
        return _out(_range(start, end, 1n, includeEnd));
      },
      "number, bigint, boolean": function(start, end, includeEnd) {
        return _out(_range(BigInt(start), end, 1n, includeEnd));
      },
      "bigint, bigint|number, bigint|number, boolean": function(start, end, step, includeEnd) {
        return _out(_range(start, end, BigInt(step), includeEnd));
      },
      "number, bigint, bigint|number, boolean": function(start, end, step, includeEnd) {
        return _out(_range(BigInt(start), end, BigInt(step), includeEnd));
      },
      "BigNumber, BigNumber": function(start, end) {
        const BigNumber = start.constructor;
        return _out(_range(start, end, new BigNumber(1), false));
      },
      "BigNumber, BigNumber, BigNumber": function(start, end, step) {
        return _out(_range(start, end, step, false));
      },
      "BigNumber, BigNumber, boolean": function(start, end, includeEnd) {
        const BigNumber = start.constructor;
        return _out(_range(start, end, new BigNumber(1), includeEnd));
      },
      "BigNumber, BigNumber, BigNumber, boolean": function(start, end, step, includeEnd) {
        return _out(_range(start, end, step, includeEnd));
      },
      "Fraction, Fraction": function(start, end) {
        return _out(_range(start, end, 1, false));
      },
      "Fraction, Fraction, Fraction": function(start, end, step) {
        return _out(_range(start, end, step, false));
      },
      "Fraction, Fraction, boolean": function(start, end, includeEnd) {
        return _out(_range(start, end, 1, includeEnd));
      },
      "Fraction, Fraction, Fraction, boolean": function(start, end, step, includeEnd) {
        return _out(_range(start, end, step, includeEnd));
      },
      "Unit, Unit, Unit": function(start, end, step) {
        return _out(_range(start, end, step, false));
      },
      "Unit, Unit, Unit, boolean": function(start, end, step, includeEnd) {
        return _out(_range(start, end, step, includeEnd));
      }
    });
    function _out(arr) {
      if (config.matrix === "Matrix") {
        return matrix ? matrix(arr) : noMatrix();
      }
      return arr;
    }
    function _strRange(str, includeEnd) {
      const r = _parse(str);
      if (!r) {
        throw new SyntaxError('String "' + str + '" is no valid range');
      }
      if (config.number === "BigNumber") {
        if (bignumber === void 0) {
          noBignumber();
        }
        return _out(
          _range(
            bignumber(r.start),
            bignumber(r.end),
            bignumber(r.step),
            includeEnd
          )
        );
      } else {
        return _out(_range(r.start, r.end, r.step, includeEnd));
      }
    }
    function _range(start, end, step, includeEnd) {
      const array = [];
      if (isZero(step)) throw new Error("Step must be non-zero");
      const ongoing = isPositive(step) ? includeEnd ? smallerEq : smaller : includeEnd ? largerEq : larger;
      let x = start;
      while (ongoing(x, end)) {
        array.push(x);
        x = add(x, step);
      }
      return array;
    }
    function _parse(str) {
      const args = str.split(":");
      const nums = args.map(function(arg) {
        return Number(arg);
      });
      const invalid = nums.some(function(num) {
        return isNaN(num);
      });
      if (invalid) {
        return null;
      }
      switch (nums.length) {
        case 2:
          return {
            start: nums[0],
            end: nums[1],
            step: 1
          };
        case 3:
          return {
            start: nums[0],
            end: nums[2],
            step: nums[1]
          };
        default:
          return null;
      }
    }
  }
);

// src/function/matrix/reshape.ts
var name103 = "reshape";
var dependencies104 = ["typed", "isInteger", "matrix"];
var createReshape = /* @__PURE__ */ factory(
  name103,
  dependencies104,
  ({ typed: typed2, isInteger: isInteger2 }) => {
    return typed2(name103, {
      "Matrix, Array": function(x, sizes) {
        return x.reshape(sizes, true);
      },
      "Array, Array": function(x, sizes) {
        sizes.forEach(function(size) {
          if (!isInteger2(size)) {
            throw new TypeError("Invalid size for dimension: " + size);
          }
        });
        return reshape(x, sizes);
      }
    });
  }
);

// src/function/matrix/resize.ts
var name104 = "resize";
var dependencies105 = ["config", "matrix"];
var createResize = /* @__PURE__ */ factory(
  name104,
  dependencies105,
  ({ config, matrix }) => {
    return function resize2(x, size, defaultValue) {
      if (arguments.length !== 2 && arguments.length !== 3) {
        throw new ArgumentsError("resize", arguments.length, 2, 3);
      }
      if (isMatrix(size)) {
        size = size.valueOf();
      }
      if (isBigNumber(size[0])) {
        size = size.map(function(value) {
          return !isBigNumber(value) ? value : value.toNumber();
        });
      }
      if (isMatrix(x)) {
        return x.resize(size, defaultValue, true);
      }
      if (typeof x === "string") {
        return _resizeString(x, size, defaultValue);
      }
      const asMatrix = Array.isArray(x) ? false : config.matrix !== "Array";
      if (size.length === 0) {
        while (Array.isArray(x)) {
          x = x[0];
        }
        return clone(x);
      } else {
        if (!Array.isArray(x)) {
          x = [x];
        }
        x = clone(x);
        const res = resize(x, size, defaultValue);
        return asMatrix ? matrix(res) : res;
      }
    };
    function _resizeString(str, size, defaultChar) {
      if (defaultChar !== void 0) {
        if (typeof defaultChar !== "string" || defaultChar.length !== 1) {
          throw new TypeError("Single character expected as defaultValue");
        }
      } else {
        defaultChar = " ";
      }
      if (size.length !== 1) {
        throw new DimensionError(size.length, 1);
      }
      const len = size[0];
      if (typeof len !== "number" || !isInteger(len)) {
        throw new TypeError(
          "Invalid size, must contain positive integers (size: " + format3(size, {}) + ")"
        );
      }
      if (str.length > len) {
        return str.substring(0, len);
      } else if (str.length < len) {
        let res = str;
        for (let i = 0, ii = len - str.length; i < ii; i++) {
          res += defaultChar;
        }
        return res;
      } else {
        return str;
      }
    }
  }
);

// src/function/matrix/rotate.ts
var name105 = "rotate";
var dependencies106 = ["typed", "multiply", "rotationMatrix"];
var createRotate = /* @__PURE__ */ factory(
  name105,
  dependencies106,
  ({
    typed: typed2,
    multiply,
    rotationMatrix
  }) => {
    return typed2(name105, {
      "Array , number | BigNumber | Complex | Unit": function(w, theta) {
        _validateSize(w, 2);
        const matrixRes = multiply(rotationMatrix(theta), w);
        return matrixRes.toArray();
      },
      "Matrix , number | BigNumber | Complex | Unit": function(w, theta) {
        _validateSize(w, 2);
        return multiply(rotationMatrix(theta), w);
      },
      "Array, number | BigNumber | Complex | Unit, Array | Matrix": function(w, theta, v) {
        _validateSize(w, 3);
        const matrixRes = multiply(rotationMatrix(theta, v), w);
        return matrixRes;
      },
      "Matrix, number | BigNumber | Complex | Unit, Array | Matrix": function(w, theta, v) {
        _validateSize(w, 3);
        return multiply(rotationMatrix(theta, v), w);
      }
    });
    function _validateSize(v, expectedSize) {
      const actualSize = Array.isArray(v) ? arraySize(v) : v.size();
      if (actualSize.length > 2) {
        throw new RangeError(`Vector must be of dimensions 1x${expectedSize}`);
      }
      if (actualSize.length === 2 && actualSize[1] !== 1) {
        throw new RangeError(`Vector must be of dimensions 1x${expectedSize}`);
      }
      if (actualSize[0] !== expectedSize) {
        throw new RangeError(`Vector must be of dimensions 1x${expectedSize}`);
      }
    }
  }
);

// src/function/matrix/rotationMatrix.ts
var name106 = "rotationMatrix";
var dependencies107 = [
  "typed",
  "config",
  "multiplyScalar",
  "addScalar",
  "unaryMinus",
  "norm",
  "matrix",
  "BigNumber",
  "DenseMatrix",
  "SparseMatrix",
  "cos",
  "sin"
];
var createRotationMatrix = /* @__PURE__ */ factory(
  name106,
  dependencies107,
  ({
    typed: typed2,
    config,
    multiplyScalar,
    addScalar,
    unaryMinus,
    norm,
    BigNumber,
    matrix,
    DenseMatrix,
    SparseMatrix,
    cos,
    sin
  }) => {
    return typed2(name106, {
      "": function() {
        return config.matrix === "Matrix" ? matrix([]) : [];
      },
      string: function(format4) {
        return matrix(format4);
      },
      "number | BigNumber | Complex | Unit": function(theta) {
        return _rotationMatrix2x2(
          theta,
          config.matrix === "Matrix" ? "dense" : void 0
        );
      },
      "number | BigNumber | Complex | Unit, string": function(theta, format4) {
        return _rotationMatrix2x2(theta, format4);
      },
      "number | BigNumber | Complex | Unit, Array": function(theta, v) {
        const matrixV = matrix(v);
        _validateVector(matrixV);
        return _rotationMatrix3x3(theta, matrixV, void 0);
      },
      "number | BigNumber | Complex | Unit, Matrix": function(theta, v) {
        _validateVector(v);
        const storageType = v.storage() || (config.matrix === "Matrix" ? "dense" : void 0);
        return _rotationMatrix3x3(theta, v, storageType);
      },
      "number | BigNumber | Complex | Unit, Array, string": function(theta, v, format4) {
        const matrixV = matrix(v);
        _validateVector(matrixV);
        return _rotationMatrix3x3(theta, matrixV, format4);
      },
      "number | BigNumber | Complex | Unit, Matrix, string": function(theta, v, format4) {
        _validateVector(v);
        return _rotationMatrix3x3(theta, v, format4);
      }
    });
    function _rotationMatrix2x2(theta, format4) {
      const Big = isBigNumber(theta);
      const minusOne = Big ? new BigNumber(-1) : -1;
      const cosTheta = cos(theta);
      const sinTheta = sin(theta);
      const data = [
        [cosTheta, multiplyScalar(minusOne, sinTheta)],
        [sinTheta, cosTheta]
      ];
      return _convertToFormat(data, format4);
    }
    function _validateVector(v) {
      const size = v.size();
      if (size.length < 1 || size[0] !== 3) {
        throw new RangeError("Vector must be of dimensions 1x3");
      }
    }
    function _mul(array) {
      return array.reduce((p, curr) => multiplyScalar(p, curr));
    }
    function _convertToFormat(data, format4) {
      if (format4) {
        if (format4 === "sparse") {
          return new SparseMatrix(data);
        }
        if (format4 === "dense") {
          return new DenseMatrix(data);
        }
        throw new TypeError(`Unknown matrix type "${format4}"`);
      }
      return data;
    }
    function _rotationMatrix3x3(theta, v, format4) {
      const normV = norm(v);
      if (normV === 0) {
        throw new RangeError("Rotation around zero vector");
      }
      const Big = isBigNumber(theta) ? BigNumber : null;
      const one = Big ? new Big(1) : 1;
      const minusOne = Big ? new Big(-1) : -1;
      const vx = Big ? new Big(v.get([0]) / normV) : v.get([0]) / normV;
      const vy = Big ? new Big(v.get([1]) / normV) : v.get([1]) / normV;
      const vz = Big ? new Big(v.get([2]) / normV) : v.get([2]) / normV;
      const c = cos(theta);
      const oneMinusC = addScalar(one, unaryMinus(c));
      const s = sin(theta);
      const r11 = addScalar(c, _mul([vx, vx, oneMinusC]));
      const r12 = addScalar(_mul([vx, vy, oneMinusC]), _mul([minusOne, vz, s]));
      const r13 = addScalar(_mul([vx, vz, oneMinusC]), _mul([vy, s]));
      const r21 = addScalar(_mul([vx, vy, oneMinusC]), _mul([vz, s]));
      const r22 = addScalar(c, _mul([vy, vy, oneMinusC]));
      const r23 = addScalar(_mul([vy, vz, oneMinusC]), _mul([minusOne, vx, s]));
      const r31 = addScalar(_mul([vx, vz, oneMinusC]), _mul([minusOne, vy, s]));
      const r32 = addScalar(_mul([vy, vz, oneMinusC]), _mul([vx, s]));
      const r33 = addScalar(c, _mul([vz, vz, oneMinusC]));
      const data = [
        [r11, r12, r13],
        [r21, r22, r23],
        [r31, r32, r33]
      ];
      return _convertToFormat(data, format4);
    }
  }
);

// src/function/matrix/row.ts
var name107 = "row";
var dependencies108 = ["typed", "Index", "matrix", "range"];
var createRow = /* @__PURE__ */ factory(
  name107,
  dependencies108,
  ({ typed: typed2, Index: Index2, matrix, range }) => {
    return typed2(name107, {
      "Matrix, number": _row,
      "Array, number": function(value, row) {
        return _row(matrix(clone(value)), row).valueOf();
      }
    });
    function _row(value, row) {
      if (value.size().length !== 2) {
        throw new Error("Only two dimensional matrix is supported");
      }
      validateIndex(row, value.size()[0]);
      const columnRange = range(0, value.size()[1]);
      const index = new Index2([row], columnRange);
      const result = value.subset(index);
      return isMatrix(result) ? result : matrix([[result]]);
    }
  }
);

// src/function/matrix/size.ts
var name108 = "size";
var dependencies109 = ["typed"];
var createSize = /* @__PURE__ */ factory(
  name108,
  dependencies109,
  ({ typed: typed2 }) => {
    return typed2(name108, {
      Matrix: (x) => x.size(),
      Array: arraySize,
      string: (x) => [x.length],
      // scalar
      "number | Complex | BigNumber | Unit | boolean | null": (_x) => []
    });
  }
);

// src/function/matrix/squeeze.ts
var name109 = "squeeze";
var dependencies110 = ["typed"];
var createSqueeze = /* @__PURE__ */ factory(
  name109,
  dependencies110,
  ({ typed: typed2 }) => {
    return typed2(name109, {
      Array: function(x) {
        return squeeze(clone(x));
      },
      Matrix: function(x) {
        const res = squeeze(x.toArray());
        return Array.isArray(res) ? x.create(res, x.datatype()) : res;
      },
      any: function(x) {
        return clone(x);
      }
    });
  }
);

// src/function/matrix/subset.ts
var name110 = "subset";
var dependencies111 = ["typed", "matrix", "zeros", "add"];
var createSubset = /* @__PURE__ */ factory(
  name110,
  dependencies111,
  ({
    typed: typed2,
    matrix,
    zeros: zeros2,
    add
  }) => {
    return typed2(name110, {
      // get subset
      "Matrix, Index": function(value, index) {
        if (isEmptyIndex(index)) {
          return matrix();
        }
        validateIndexSourceSize(value, index);
        return value.subset(index);
      },
      "Array, Index": typed2.referTo("Matrix, Index", function(subsetRef) {
        return function(value, index) {
          const subsetResult = subsetRef(matrix(value), index);
          return index.isScalar() ? subsetResult : subsetResult.valueOf();
        };
      }),
      "Object, Index": _getObjectProperty,
      "string, Index": _getSubstring,
      // set subset
      "Matrix, Index, any, any": function(value, index, replacement, defaultValue) {
        if (isEmptyIndex(index)) {
          return value;
        }
        validateIndexSourceSize(value, index);
        return value.clone().subset(
          index,
          _broadcastReplacement(replacement, index),
          defaultValue
        );
      },
      "Array, Index, any, any": typed2.referTo(
        "Matrix, Index, any, any",
        function(subsetRef) {
          return function(value, index, replacement, defaultValue) {
            const subsetResult = subsetRef(
              matrix(value),
              index,
              replacement,
              defaultValue
            );
            return subsetResult.isMatrix ? subsetResult.valueOf() : subsetResult;
          };
        }
      ),
      "Array, Index, any": typed2.referTo(
        "Matrix, Index, any, any",
        function(subsetRef) {
          return function(value, index, replacement) {
            return subsetRef(
              matrix(value),
              index,
              replacement,
              void 0
            ).valueOf();
          };
        }
      ),
      "Matrix, Index, any": typed2.referTo(
        "Matrix, Index, any, any",
        function(subsetRef) {
          return function(value, index, replacement) {
            return subsetRef(value, index, replacement, void 0);
          };
        }
      ),
      "string, Index, string": _setSubstring,
      "string, Index, string, string": _setSubstring,
      "Object, Index, any": _setObjectProperty
    });
    function _broadcastReplacement(replacement, index) {
      if (typeof replacement === "string") {
        throw new Error("can't boradcast a string");
      }
      if (index.isScalar()) {
        return replacement;
      }
      const indexSize = index.size();
      if (indexSize.every((d) => d > 0)) {
        try {
          return add(replacement, zeros2(indexSize));
        } catch {
          return replacement;
        }
      } else {
        return replacement;
      }
    }
  }
);
function _getSubstring(str, index) {
  if (!isIndex(index)) {
    throw new TypeError("Index expected");
  }
  if (isEmptyIndex(index)) {
    return "";
  }
  validateIndexSourceSize(Array.from(str), index);
  if (index.size().length !== 1) {
    throw new DimensionError(index.size().length, 1);
  }
  const strLen = str.length;
  validateIndex(index.min()[0], strLen);
  validateIndex(index.max()[0], strLen);
  const range = index.dimension(0);
  let substr = "";
  function callback(v) {
    substr += str.charAt(v);
  }
  if (Number.isInteger(range)) {
    callback(range);
  } else {
    range.forEach(callback);
  }
  return substr;
}
function _setSubstring(str, index, replacement, defaultValue) {
  if (!index || index.isIndex !== true) {
    throw new TypeError("Index expected");
  }
  if (isEmptyIndex(index)) {
    return str;
  }
  validateIndexSourceSize(Array.from(str), index);
  if (index.size().length !== 1) {
    throw new DimensionError(index.size().length, 1);
  }
  if (defaultValue !== void 0) {
    if (typeof defaultValue !== "string" || defaultValue.length !== 1) {
      throw new TypeError("Single character expected as defaultValue");
    }
  } else {
    defaultValue = " ";
  }
  const range = index.dimension(0);
  const len = Number.isInteger(range) ? 1 : range.size()[0];
  if (len !== replacement.length) {
    throw new DimensionError(range.size()[0], replacement.length);
  }
  const strLen = str.length;
  validateIndex(index.min()[0]);
  validateIndex(index.max()[0]);
  const chars = [];
  for (let i = 0; i < strLen; i++) {
    chars[i] = str.charAt(i);
  }
  function callback(v, i) {
    chars[v] = replacement.charAt(i[0]);
  }
  if (Number.isInteger(range)) {
    callback(range, [0]);
  } else {
    range.forEach(callback);
  }
  if (chars.length > strLen) {
    for (let i = strLen - 1, len2 = chars.length; i < len2; i++) {
      if (!chars[i]) {
        chars[i] = defaultValue;
      }
    }
  }
  return chars.join("");
}
function _getObjectProperty(object, index) {
  if (isEmptyIndex(index)) {
    return void 0;
  }
  if (index.size().length !== 1) {
    throw new DimensionError(index.size(), 1);
  }
  const key = index.dimension(0);
  if (typeof key !== "string") {
    throw new TypeError(
      "String expected as index to retrieve an object property"
    );
  }
  return getSafeProperty(object, key);
}
function _setObjectProperty(object, index, replacement) {
  if (isEmptyIndex(index)) {
    return object;
  }
  if (index.size().length !== 1) {
    throw new DimensionError(index.size(), 1);
  }
  const key = index.dimension(0);
  if (typeof key !== "string") {
    throw new TypeError(
      "String expected as index to retrieve an object property"
    );
  }
  const updated = clone(object);
  setSafeProperty(updated, key, replacement);
  return updated;
}

// src/function/matrix/transpose.ts
var WASM_TRANSPOSE_THRESHOLD = 100;
function isPlainNumberMatrix(matrix) {
  for (let i = 0; i < matrix.length; i++) {
    const row = matrix[i];
    for (let j = 0; j < row.length; j++) {
      if (typeof row[j] !== "number") {
        return false;
      }
    }
  }
  return true;
}
function flattenToFloat64(matrix, rows, cols) {
  const result = new Float64Array(rows * cols);
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      result[i * cols + j] = matrix[i][j];
    }
  }
  return result;
}
var name111 = "transpose";
var dependencies112 = ["typed", "matrix"];
var createTranspose = /* @__PURE__ */ factory(
  name111,
  dependencies112,
  ({ typed: typed2, matrix }) => {
    return typed2(name111, {
      Array: (x) => transposeMatrix(matrix(x)).valueOf(),
      Matrix: transposeMatrix,
      any: clone
      // scalars
    });
    function transposeMatrix(x) {
      const size = x.size();
      let c;
      switch (size.length) {
        case 1:
          c = x.clone();
          break;
        case 2:
          {
            const rows = size[0];
            const columns = size[1];
            if (columns === 0) {
              throw new RangeError(
                "Cannot transpose a 2D matrix with no columns (size: " + format3(size, {}) + ")"
              );
            }
            switch (x.storage()) {
              case "dense":
                c = _denseTranspose(x, rows, columns);
                break;
              case "sparse":
                c = _sparseTranspose(x, rows, columns);
                break;
            }
          }
          break;
        default:
          throw new RangeError(
            "Matrix must be a vector or two dimensional (size: " + format3(size, {}) + ")"
          );
      }
      return c;
    }
    function _denseTranspose(m, rows, columns) {
      const data = m._data;
      const wasm = wasmLoader.getModule();
      if (wasm && rows * columns >= WASM_TRANSPOSE_THRESHOLD && isPlainNumberMatrix(data)) {
        try {
          const flat = flattenToFloat64(data, rows, columns);
          const input = wasmLoader.allocateFloat64Array(flat);
          const output = wasmLoader.allocateFloat64ArrayEmpty(rows * columns);
          try {
            wasm.transpose(input.ptr, rows, columns, output.ptr);
            const transposed2 = [];
            for (let j = 0; j < columns; j++) {
              const row = [];
              for (let i = 0; i < rows; i++) {
                row[i] = output.array[j * rows + i];
              }
              transposed2[j] = row;
            }
            return m.createDenseMatrix({
              data: transposed2,
              size: [columns, rows],
              datatype: m._datatype
            });
          } finally {
            wasmLoader.free(input.ptr);
            wasmLoader.free(output.ptr);
          }
        } catch {
        }
      }
      const transposed = [];
      let transposedRow;
      for (let j = 0; j < columns; j++) {
        transposedRow = transposed[j] = [];
        for (let i = 0; i < rows; i++) {
          transposedRow[i] = clone(data[i][j]);
        }
      }
      return m.createDenseMatrix({
        data: transposed,
        size: [columns, rows],
        datatype: m._datatype
      });
    }
    function _sparseTranspose(m, rows, columns) {
      const values = m._values;
      const index = m._index;
      const ptr = m._ptr;
      const cvalues = values ? [] : void 0;
      const cindex = [];
      const cptr = [];
      const w = [];
      for (let x = 0; x < rows; x++) {
        w[x] = 0;
      }
      let p, l, j;
      for (p = 0, l = index.length; p < l; p++) {
        w[index[p]]++;
      }
      let sum = 0;
      for (let i = 0; i < rows; i++) {
        cptr.push(sum);
        sum += w[i];
        w[i] = cptr[i];
      }
      cptr.push(sum);
      for (j = 0; j < columns; j++) {
        for (let k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {
          const q = w[index[k]]++;
          cindex[q] = j;
          if (values) {
            cvalues[q] = clone(values[k]);
          }
        }
      }
      return m.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [columns, rows],
        datatype: m._datatype
      });
    }
  }
);

// src/function/matrix/ctranspose.ts
var name112 = "ctranspose";
var dependencies113 = ["typed", "transpose", "conj"];
var createCtranspose = /* @__PURE__ */ factory(
  name112,
  dependencies113,
  ({ typed: typed2, transpose, conj }) => {
    return typed2(name112, {
      any: function(x) {
        return conj(transpose(x));
      }
    });
  }
);

// src/function/matrix/zeros.ts
var name113 = "zeros";
var dependencies114 = ["typed", "config", "matrix", "BigNumber"];
var createZeros = /* @__PURE__ */ factory(
  name113,
  dependencies114,
  ({ typed: typed2, config, matrix, BigNumber }) => {
    return typed2(name113, {
      "": function() {
        return config.matrix === "Array" ? _zeros([]) : _zeros([], "default");
      },
      // math.zeros(m, n, p, ..., format)
      // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
      "...number | BigNumber | string": function(size) {
        const last = size[size.length - 1];
        if (typeof last === "string") {
          const format4 = size.pop();
          return _zeros(size, format4);
        } else if (config.matrix === "Array") {
          return _zeros(size);
        } else {
          return _zeros(size, "default");
        }
      },
      Array: _zeros,
      Matrix: function(size) {
        const format4 = size.storage();
        return _zeros(size.valueOf(), format4);
      },
      "Array | Matrix, string": function(size, format4) {
        const sizeArray = Array.isArray(size) ? size : size.valueOf();
        return _zeros(sizeArray, format4);
      }
    });
    function _zeros(size, format4) {
      const hasBigNumbers = _normalize(size);
      const defaultValue = hasBigNumbers ? new BigNumber(0) : 0;
      _validate2(size);
      if (format4) {
        const m = matrix(format4);
        if (size.length > 0) {
          return m.resize(size, defaultValue);
        }
        return m;
      } else {
        const arr = [];
        if (size.length > 0) {
          return resize(arr, size, defaultValue);
        }
        return arr;
      }
    }
    function _normalize(size) {
      let hasBigNumbers = false;
      size.forEach(function(value, index, arr) {
        if (isBigNumber(value)) {
          hasBigNumbers = true;
          arr[index] = value.toNumber();
        }
      });
      return hasBigNumbers;
    }
    function _validate2(size) {
      size.forEach(function(value) {
        if (typeof value !== "number" || !isInteger(value) || value < 0) {
          throw new Error(
            "Parameters in function zeros must be positive integers"
          );
        }
      });
    }
  }
);

// src/function/matrix/fft.ts
var WASM_FFT_THRESHOLD = 64;
function isPowerOf2(n) {
  return n > 0 && (n & n - 1) === 0;
}
function complexToInterleaved(arr, complex) {
  const n = arr.length;
  const result = new Float64Array(n * 2);
  for (let i = 0; i < n; i++) {
    const val = arr[i];
    if (typeof val === "number") {
      result[i * 2] = val;
      result[i * 2 + 1] = 0;
    } else if (val && typeof val.re === "number" && typeof val.im === "number") {
      result[i * 2] = val.re;
      result[i * 2 + 1] = val.im;
    } else {
      return null;
    }
  }
  return result;
}
function interleavedToComplex(data, n, complex) {
  const result = [];
  for (let i = 0; i < n; i++) {
    result.push(complex(data[i * 2], data[i * 2 + 1]));
  }
  return result;
}
var name114 = "fft";
var dependencies115 = [
  "typed",
  "matrix",
  "addScalar",
  "multiplyScalar",
  "divideScalar",
  "exp",
  "tau",
  "i",
  "dotDivide",
  "conj",
  "pow",
  "ceil",
  "log2",
  "complex"
];
var createFft = /* @__PURE__ */ factory(
  name114,
  dependencies115,
  ({
    typed: typed2,
    matrix: _matrix,
    addScalar,
    multiplyScalar,
    divideScalar,
    exp,
    tau: tau2,
    i: I,
    dotDivide,
    conj,
    pow,
    ceil,
    log2: log23,
    complex
  }) => {
    return typed2(name114, {
      Array: _ndFft,
      Matrix: function(matrix) {
        return matrix.create(_ndFft(matrix.valueOf()), matrix._datatype);
      }
    });
    function _ndFft(arr) {
      const size = arraySize(arr);
      if (size.length === 1) return _fft(arr, size[0]);
      return _1dFft(
        arr.map((slice) => _ndFft(slice)),
        0
      );
    }
    function _1dFft(arr, dim) {
      const size = arraySize(arr);
      if (dim !== 0) {
        const result = [];
        for (let i = 0; i < size[0]; i++) {
          result.push(_1dFft(arr[i], dim - 1));
        }
        return result;
      }
      if (size.length === 1) return _fft(arr);
      function _transpose(arr2) {
        const size2 = arraySize(arr2);
        const result = [];
        for (let j = 0; j < size2[1]; j++) {
          const row = [];
          for (let i = 0; i < size2[0]; i++) {
            row.push(arr2[i][j]);
          }
          result.push(row);
        }
        return result;
      }
      return _transpose(_1dFft(_transpose(arr), 1));
    }
    function _czt(arr) {
      const n = arr.length;
      const w = exp(divideScalar(multiplyScalar(-1, multiplyScalar(I, tau2)), n));
      const chirp = [];
      for (let i = 1 - n; i < n; i++) {
        chirp.push(pow(w, divideScalar(pow(i, 2), 2)));
      }
      const N2 = pow(2, ceil(log23(n + n - 1)));
      const xp = [];
      for (let i = 0; i < n; i++) {
        xp.push(multiplyScalar(arr[i], chirp[n - 1 + i]));
      }
      for (let i = 0; i < N2 - n; i++) {
        xp.push(0);
      }
      const ichirp = [];
      for (let i = 0; i < n + n - 1; i++) {
        ichirp.push(divideScalar(1, chirp[i]));
      }
      for (let i = 0; i < N2 - (n + n - 1); i++) {
        ichirp.push(0);
      }
      const fftXp = _fft(xp);
      const fftIchirp = _fft(ichirp);
      const fftProduct = [];
      for (let i = 0; i < N2; i++) {
        fftProduct.push(multiplyScalar(fftXp[i], fftIchirp[i]));
      }
      const ifftProduct = dotDivide(conj(_ndFft(conj(fftProduct))), N2);
      const ret = [];
      for (let i = n - 1; i < n + n - 1; i++) {
        ret.push(multiplyScalar(ifftProduct[i], chirp[i]));
      }
      return ret;
    }
    function _fft(arr, len) {
      const length = len ?? arr.length;
      if (length === 1) return [arr[0]];
      const wasm = wasmLoader.getModule();
      if (wasm && length >= WASM_FFT_THRESHOLD && isPowerOf2(length) && len === void 0) {
        const interleaved = complexToInterleaved(arr);
        if (interleaved) {
          try {
            const dataAlloc = wasmLoader.allocateFloat64Array(interleaved);
            try {
              wasm.fft(dataAlloc.ptr, length, 0);
              return interleavedToComplex(dataAlloc.array, length, complex);
            } finally {
              wasmLoader.free(dataAlloc.ptr);
            }
          } catch (e2) {
          }
        }
      }
      if (length % 2 === 0) {
        const ret = [
          ..._fft(
            arr.filter((_, i) => i % 2 === 0),
            length / 2
          ),
          ..._fft(
            arr.filter((_, i) => i % 2 === 1),
            length / 2
          )
        ];
        for (let k = 0; k < length / 2; k++) {
          const p = ret[k];
          const q = multiplyScalar(
            ret[k + length / 2],
            exp(
              multiplyScalar(multiplyScalar(tau2, I), divideScalar(-k, length))
            )
          );
          ret[k] = addScalar(p, q);
          ret[k + length / 2] = addScalar(p, multiplyScalar(-1, q));
        }
        return ret;
      } else {
        return _czt(arr);
      }
    }
  }
);

// src/function/matrix/ifft.ts
var WASM_IFFT_THRESHOLD = 64;
function isPowerOf22(n) {
  return n > 0 && (n & n - 1) === 0;
}
function complexToInterleaved2(arr, complex) {
  const n = arr.length;
  const result = new Float64Array(n * 2);
  for (let i = 0; i < n; i++) {
    const val = arr[i];
    if (typeof val === "number") {
      result[i * 2] = val;
      result[i * 2 + 1] = 0;
    } else if (val && typeof val.re === "number" && typeof val.im === "number") {
      result[i * 2] = val.re;
      result[i * 2 + 1] = val.im;
    } else {
      return null;
    }
  }
  return result;
}
function interleavedToComplex2(data, n, complex) {
  const result = [];
  for (let i = 0; i < n; i++) {
    result.push(complex(data[i * 2], data[i * 2 + 1]));
  }
  return result;
}
var name115 = "ifft";
var dependencies116 = ["typed", "fft", "dotDivide", "conj", "complex"];
var createIfft = /* @__PURE__ */ factory(
  name115,
  dependencies116,
  ({ typed: typed2, fft, dotDivide, conj, complex }) => {
    return typed2(name115, {
      "Array | Matrix": function(arr) {
        const size = isMatrix(arr) ? arr.size() : arraySize(arr);
        const totalSize = size.reduce(
          (acc, curr) => acc * curr,
          1
        );
        if (size.length === 1) {
          const length = size[0];
          const wasm = wasmLoader.getModule();
          if (wasm && length >= WASM_IFFT_THRESHOLD && isPowerOf22(length)) {
            const arrData = isMatrix(arr) ? arr.valueOf() : arr;
            const interleaved = complexToInterleaved2(arrData);
            if (interleaved) {
              try {
                const dataAlloc = wasmLoader.allocateFloat64Array(interleaved);
                try {
                  wasm.fft(dataAlloc.ptr, length, 1);
                  const result = interleavedToComplex2(
                    dataAlloc.array,
                    length,
                    complex
                  );
                  if (isMatrix(arr)) {
                    return arr.create(result);
                  }
                  return result;
                } finally {
                  wasmLoader.free(dataAlloc.ptr);
                }
              } catch (e2) {
              }
            }
          }
        }
        return dotDivide(conj(fft(conj(arr))), totalSize);
      }
    });
  }
);

// src/function/numeric/solveODE.ts
var name116 = "solveODE";
var dependencies117 = [
  "typed",
  "add",
  "subtract",
  "multiply",
  "divide",
  "max",
  "map",
  "abs",
  "isPositive",
  "isNegative",
  "larger",
  "smaller",
  "matrix",
  "bignumber",
  "unaryMinus"
];
var createSolveODE = /* @__PURE__ */ factory(
  name116,
  dependencies117,
  ({
    typed: typed2,
    add,
    subtract,
    multiply,
    divide,
    max,
    map: map2,
    abs,
    isPositive,
    isNegative,
    larger,
    smaller,
    matrix,
    bignumber,
    unaryMinus
  }) => {
    function _rk(butcherTableau) {
      return function(f, tspan, y0, options) {
        const wrongTSpan = !(tspan.length === 2 && (tspan.every(isNumOrBig) || tspan.every(isUnit)));
        if (wrongTSpan) {
          throw new Error(
            '"tspan" must be an Array of two numeric values or two units [tStart, tEnd]'
          );
        }
        const t0 = tspan[0];
        const tf = tspan[1];
        const isForwards = larger(tf, t0);
        const firstStep = options.firstStep;
        if (firstStep !== void 0 && !isPositive(firstStep)) {
          throw new Error('"firstStep" must be positive');
        }
        const maxStep = options.maxStep;
        if (maxStep !== void 0 && !isPositive(maxStep)) {
          throw new Error('"maxStep" must be positive');
        }
        const minStep = options.minStep;
        if (minStep && isNegative(minStep)) {
          throw new Error('"minStep" must be positive or zero');
        }
        const timeVars = [t0, tf, firstStep, minStep, maxStep].filter(
          (x) => x !== void 0
        );
        if (!(timeVars.every(isNumOrBig) || timeVars.every(isUnit))) {
          throw new Error('Inconsistent type of "t" dependant variables');
        }
        const steps = 1;
        const tol = options.tol ? options.tol : 1e-4;
        const minDelta = options.minDelta ? options.minDelta : 0.2;
        const maxDelta = options.maxDelta ? options.maxDelta : 5;
        const maxIter = options.maxIter ? options.maxIter : 1e4;
        const hasBigNumbers = [t0, tf, ...y0, maxStep, minStep].some(
          isBigNumber
        );
        const [a, c, b, bp] = hasBigNumbers ? [
          bignumber(butcherTableau.a),
          bignumber(butcherTableau.c),
          bignumber(butcherTableau.b),
          bignumber(butcherTableau.bp)
        ] : [
          butcherTableau.a,
          butcherTableau.c,
          butcherTableau.b,
          butcherTableau.bp
        ];
        let h = firstStep ? isForwards ? firstStep : unaryMinus(firstStep) : divide(subtract(tf, t0), steps);
        const t = [t0];
        const y = [y0];
        const deltaB = subtract(b, bp);
        let n = 0;
        let iter = 0;
        const ongoing = _createOngoing(isForwards);
        const trimStep = _createTrimStep(isForwards);
        while (ongoing(t[n], tf)) {
          const k = [];
          h = trimStep(t[n], tf, h);
          k.push(f(t[n], y[n]));
          for (let i = 1; i < c.length; ++i) {
            k.push(
              f(add(t[n], multiply(c[i], h)), add(y[n], multiply(h, a[i], k)))
            );
          }
          const TE = max(
            abs(
              map2(
                multiply(deltaB, k),
                (X) => isUnit(X) ? X.value : X
              )
            )
          );
          if (TE < tol && tol / TE > 1 / 4) {
            t.push(add(t[n], h));
            y.push(add(y[n], multiply(h, b, k)));
            n++;
          }
          let delta = 0.84 * (tol / TE) ** (1 / 5);
          if (smaller(delta, minDelta)) {
            delta = minDelta;
          } else if (larger(delta, maxDelta)) {
            delta = maxDelta;
          }
          delta = hasBigNumbers ? bignumber(delta) : delta;
          h = multiply(h, delta);
          if (maxStep && larger(abs(h), maxStep)) {
            h = isForwards ? maxStep : unaryMinus(maxStep);
          } else if (minStep && smaller(abs(h), minStep)) {
            h = isForwards ? minStep : unaryMinus(minStep);
          }
          iter++;
          if (iter > maxIter) {
            throw new Error(
              "Maximum number of iterations reached, try changing options"
            );
          }
        }
        return { t, y };
      };
    }
    function _rk23(f, tspan, y0, options) {
      const a = [[], [1 / 2], [0, 3 / 4], [2 / 9, 1 / 3, 4 / 9]];
      const c = [null, 1 / 2, 3 / 4, 1];
      const b = [2 / 9, 1 / 3, 4 / 9, 0];
      const bp = [7 / 24, 1 / 4, 1 / 3, 1 / 8];
      const butcherTableau = { a, c, b, bp };
      return _rk(butcherTableau)(f, tspan, y0, options);
    }
    function _rk45(f, tspan, y0, options) {
      const a = [
        [],
        [1 / 5],
        [3 / 40, 9 / 40],
        [44 / 45, -56 / 15, 32 / 9],
        [19372 / 6561, -25360 / 2187, 64448 / 6561, -212 / 729],
        [9017 / 3168, -355 / 33, 46732 / 5247, 49 / 176, -5103 / 18656],
        [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84]
      ];
      const c = [null, 1 / 5, 3 / 10, 4 / 5, 8 / 9, 1, 1];
      const b = [
        35 / 384,
        0,
        500 / 1113,
        125 / 192,
        -2187 / 6784,
        11 / 84,
        0
      ];
      const bp = [
        5179 / 57600,
        0,
        7571 / 16695,
        393 / 640,
        -92097 / 339200,
        187 / 2100,
        1 / 40
      ];
      const butcherTableau = { a, c, b, bp };
      return _rk(butcherTableau)(f, tspan, y0, options);
    }
    function _solveODE(f, tspan, y0, opt) {
      const method = opt.method ? opt.method : "RK45";
      const methods = {
        RK23: _rk23,
        RK45: _rk45
      };
      if (method.toUpperCase() in methods) {
        const methodOptions = { ...opt };
        delete methodOptions.method;
        return methods[method.toUpperCase()](
          f,
          tspan,
          y0,
          methodOptions
        );
      } else {
        const methodsWithQuotes = Object.keys(methods).map((x) => `"${x}"`);
        const availableMethodsString = `${methodsWithQuotes.slice(0, -1).join(", ")} and ${methodsWithQuotes.slice(-1)}`;
        throw new Error(
          `Unavailable method "${method}". Available methods are ${availableMethodsString}`
        );
      }
    }
    function _createOngoing(isForwards) {
      return isForwards ? smaller : larger;
    }
    function _createTrimStep(isForwards) {
      const outOfBounds = isForwards ? larger : smaller;
      return function(t, tf, h) {
        const next = add(t, h);
        return outOfBounds(next, tf) ? subtract(tf, t) : h;
      };
    }
    function isNumOrBig(x) {
      return isBigNumber(x) || isNumber(x);
    }
    function _matrixSolveODE(f, T, y0, options) {
      const sol = _solveODE(f, T.toArray(), y0.toArray(), options);
      return { t: matrix(sol.t), y: matrix(sol.y) };
    }
    return typed2("solveODE", {
      "function, Array, Array, Object": _solveODE,
      "function, Matrix, Matrix, Object": _matrixSolveODE,
      "function, Array, Array": (f, T, y0) => _solveODE(f, T, y0, {}),
      "function, Matrix, Matrix": (f, T, y0) => _matrixSolveODE(f, T, y0, {}),
      "function, Array, number | BigNumber | Unit": (f, T, y0) => {
        const sol = _solveODE(f, T, [y0], {});
        return { t: sol.t, y: sol.y.map((Y) => Y[0]) };
      },
      "function, Matrix, number | BigNumber | Unit": (f, T, y0) => {
        const sol = _solveODE(f, T.toArray(), [y0], {});
        return { t: matrix(sol.t), y: matrix(sol.y.map((Y) => Y[0])) };
      },
      "function, Array, number | BigNumber | Unit, Object": (f, T, y0, options) => {
        const sol = _solveODE(f, T, [y0], options);
        return { t: sol.t, y: sol.y.map((Y) => Y[0]) };
      },
      "function, Matrix, number | BigNumber | Unit, Object": (f, T, y0, options) => {
        const sol = _solveODE(f, T.toArray(), [y0], options);
        return { t: matrix(sol.t), y: matrix(sol.y.map((Y) => Y[0])) };
      }
    });
  }
);

// src/function/special/erf.ts
var name117 = "erf";
var dependencies118 = ["typed"];
var createErf = /* @__PURE__ */ factory(
  name117,
  dependencies118,
  ({ typed: typed2 }) => {
    return typed2("name", {
      number: function(x) {
        const y = Math.abs(x);
        if (y >= MAX_NUM) {
          return sign(x);
        }
        if (y <= THRESH) {
          return sign(x) * erf1(y);
        }
        if (y <= 4) {
          return sign(x) * (1 - erfc2(y));
        }
        return sign(x) * (1 - erfc3(y));
      },
      "Array | Matrix": typed2.referToSelf(
        (self) => (n) => deepMap2(n, self)
      )
      // TODO: For complex numbers, use the approximation for the Faddeeva function
      //  from "More Efficient Computation of the Complex Error Function" (AMS)
    });
    function erf1(y) {
      const ysq = y * y;
      let xnum = P[0][4] * ysq;
      let xden = ysq;
      let i;
      for (i = 0; i < 3; i += 1) {
        xnum = (xnum + P[0][i]) * ysq;
        xden = (xden + Q[0][i]) * ysq;
      }
      return y * (xnum + P[0][3]) / (xden + Q[0][3]);
    }
    function erfc2(y) {
      let xnum = P[1][8] * y;
      let xden = y;
      let i;
      for (i = 0; i < 7; i += 1) {
        xnum = (xnum + P[1][i]) * y;
        xden = (xden + Q[1][i]) * y;
      }
      const result = (xnum + P[1][7]) / (xden + Q[1][7]);
      const ysq = parseInt(String(y * 16)) / 16;
      const del = (y - ysq) * (y + ysq);
      return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
    }
    function erfc3(y) {
      let ysq = 1 / (y * y);
      let xnum = P[2][5] * ysq;
      let xden = ysq;
      let i;
      for (i = 0; i < 4; i += 1) {
        xnum = (xnum + P[2][i]) * ysq;
        xden = (xden + Q[2][i]) * ysq;
      }
      let result = ysq * (xnum + P[2][4]) / (xden + Q[2][4]);
      result = (SQRPI - result) / y;
      ysq = parseInt(String(y * 16)) / 16;
      const del = (y - ysq) * (y + ysq);
      return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
    }
  }
);
var THRESH = 0.46875;
var SQRPI = 0.5641895835477563;
var P = [
  [
    3.1611237438705655,
    113.86415415105016,
    377.485237685302,
    3209.3775891384694,
    0.18577770618460315
  ],
  [
    0.5641884969886701,
    8.883149794388377,
    66.11919063714163,
    298.6351381974001,
    881.952221241769,
    1712.0476126340707,
    2051.0783778260716,
    1230.3393547979972,
    21531153547440383e-24
  ],
  [
    0.30532663496123236,
    0.36034489994980445,
    0.12578172611122926,
    0.016083785148742275,
    6587491615298378e-19,
    0.016315387137302097
  ]
];
var Q = [
  [
    23.601290952344122,
    244.02463793444417,
    1282.6165260773723,
    2844.236833439171
  ],
  [
    15.744926110709835,
    117.6939508913125,
    537.1811018620099,
    1621.3895745666903,
    3290.7992357334597,
    4362.619090143247,
    3439.3676741437216,
    1230.3393548037495
  ],
  [
    2.568520192289822,
    1.8729528499234604,
    0.5279051029514285,
    0.06051834131244132,
    0.0023352049762686918
  ]
];
var MAX_NUM = Math.pow(2, 53);

// src/function/special/zeta.ts
var name118 = "zeta";
var dependencies119 = [
  "typed",
  "config",
  "multiply",
  "pow",
  "divide",
  "factorial",
  "equal",
  "smallerEq",
  "isBounded",
  "isNegative",
  "gamma",
  "sin",
  "subtract",
  "add",
  "?Complex",
  "?BigNumber",
  "pi"
];
var createZeta = /* @__PURE__ */ factory(
  name118,
  dependencies119,
  ({
    typed: typed2,
    config,
    multiply,
    pow,
    divide,
    factorial,
    equal,
    smallerEq,
    isBounded,
    isNegative,
    gamma,
    sin,
    subtract,
    add,
    Complex: Complex2,
    BigNumber,
    pi: pi2
  }) => {
    return typed2(name118, {
      number: (s) => zetaNumeric(
        s,
        (value) => value,
        () => 20
      ),
      BigNumber: (s) => zetaNumeric(
        s,
        (value) => new BigNumber(value),
        () => {
          return Math.abs(Math.log10(config.relTol));
        }
      ),
      Complex: zetaComplex
    });
    function zetaNumeric(s, createValue, determineDigits) {
      if (equal(s, 0)) {
        return createValue(-0.5);
      }
      if (equal(s, 1)) {
        return createValue(NaN);
      }
      if (!isBounded(s)) {
        return isNegative(s) ? createValue(NaN) : createValue(1);
      }
      return zeta(s, createValue, determineDigits, (s2) => s2);
    }
    function zetaComplex(s) {
      if (s.re === 0 && s.im === 0) {
        return new Complex2(-0.5);
      }
      if (s.re === 1) {
        return new Complex2(NaN, NaN);
      }
      if (s.re === Infinity && s.im === 0) {
        return new Complex2(1);
      }
      if (s.im === Infinity || s.re === -Infinity) {
        return new Complex2(NaN, NaN);
      }
      return zeta(
        s,
        (value) => value,
        (s2) => Math.round(1.3 * 15 + 0.9 * Math.abs(s2.im)),
        (s2) => s2.re
      );
    }
    function zeta(s, createValue, determineDigits, getRe) {
      const n = determineDigits(s);
      if (getRe(s) > -(n - 1) / 2) {
        return f(s, createValue(n), createValue);
      } else {
        let c = multiply(pow(2, s), pow(createValue(pi2), subtract(s, 1)));
        c = multiply(c, sin(multiply(divide(createValue(pi2), 2), s)));
        c = multiply(c, gamma(subtract(1, s)));
        return multiply(
          c,
          zeta(subtract(1, s), createValue, determineDigits, getRe)
        );
      }
    }
    function d(k, n) {
      let S = k;
      for (let j = k; smallerEq(j, n); j = add(j, 1)) {
        const factor = divide(
          multiply(factorial(add(n, subtract(j, 1))), pow(4, j)),
          multiply(factorial(subtract(n, j)), factorial(multiply(2, j)))
        );
        S = add(S, factor);
      }
      return multiply(n, S);
    }
    function f(s, n, createValue) {
      const c = divide(
        1,
        multiply(d(createValue(0), n), subtract(1, pow(2, subtract(1, s))))
      );
      let S = createValue(0);
      for (let k = createValue(1); smallerEq(k, n); k = add(k, 1)) {
        S = add(S, divide(multiply((-1) ** (k - 1), d(k, n)), pow(k, s)));
      }
      return multiply(c, S);
    }
  }
);

// src/function/statistics/mode.ts
var name119 = "mode";
var dependencies120 = ["typed", "isNaN", "isNumeric"];
var createMode = /* @__PURE__ */ factory(
  name119,
  dependencies120,
  ({ typed: typed2, isNaN: mathIsNaN, isNumeric }) => {
    return typed2(name119, {
      "Array | Matrix": _mode,
      "...": function(args) {
        return _mode(args);
      }
    });
    function _mode(values) {
      const flat = flatten(values.valueOf());
      const num = flat.length;
      if (num === 0) {
        throw new Error("Cannot calculate mode of an empty array");
      }
      const count = {};
      let mode = [];
      let max = 0;
      for (let i = 0; i < flat.length; i++) {
        const value = flat[i];
        if (isNumeric(value) && mathIsNaN(value)) {
          throw new Error(
            "Cannot calculate mode of an array containing NaN values"
          );
        }
        if (!(String(value) in count)) {
          count[String(value)] = 0;
        }
        count[String(value)]++;
        if (count[String(value)] === max) {
          mode.push(value);
        } else if (count[String(value)] > max) {
          max = count[String(value)];
          mode = [value];
        }
      }
      return mode;
    }
  }
);

// src/function/statistics/utils/improveErrorMessage.ts
function improveErrorMessage(err, fnName, value) {
  let details;
  if (String(err).includes("Unexpected type")) {
    details = value !== void 0 ? " (type: " + typeOf(value) + ", value: " + JSON.stringify(value) + ")" : " (type: " + (err.data?.actual ?? "unknown") + ")";
    return new TypeError(
      "Cannot calculate " + fnName + ", unexpected type of argument" + details
    );
  }
  if (String(err).includes("complex numbers")) {
    details = value !== void 0 ? " (type: " + typeOf(value) + ", value: " + JSON.stringify(value) + ")" : "";
    return new TypeError(
      "Cannot calculate " + fnName + ", no ordering relation is defined for complex numbers" + details
    );
  }
  return err;
}

// src/function/statistics/prod.ts
var WASM_PROD_THRESHOLD = 100;
function isFlatNumberArray(arr) {
  for (let i = 0; i < arr.length; i++) {
    if (typeof arr[i] !== "number") {
      return false;
    }
  }
  return true;
}
var name120 = "prod";
var dependencies121 = [
  "typed",
  "config",
  "multiplyScalar",
  "numeric",
  "parseNumberWithConfig"
];
var createProd = /* @__PURE__ */ factory(
  name120,
  dependencies121,
  ({
    typed: typed2,
    config: _config,
    multiplyScalar,
    numeric: _numeric,
    parseNumberWithConfig
  }) => {
    return typed2(name120, {
      // prod(string) - single string input
      string: function(x) {
        return parseNumberWithConfig(x);
      },
      // prod([a, b, c, d, ...])
      "Array | Matrix": _prod,
      // prod([a, b, c, d, ...], dim)
      "Array | Matrix, number | BigNumber": function(_array, _dim) {
        throw new Error("prod(A, dim) is not yet supported");
      },
      // prod(a, b, c, d, ...)
      "...": function(args) {
        return _prod(args);
      }
    });
    function _prod(array) {
      if (Array.isArray(array) && array.length >= WASM_PROD_THRESHOLD) {
        if (isFlatNumberArray(array)) {
          const wasm = wasmLoader.getModule();
          if (wasm) {
            try {
              const alloc = wasmLoader.allocateFloat64Array(array);
              try {
                return wasm.statsProd(alloc.ptr, array.length);
              } finally {
                wasmLoader.free(alloc.ptr);
              }
            } catch {
            }
          }
        }
      }
      let prod;
      deepForEach2(array, function(value) {
        try {
          const converted = typeof value === "string" ? parseNumberWithConfig(value) : value;
          prod = prod === void 0 ? converted : multiplyScalar(prod, converted);
        } catch (err) {
          throw improveErrorMessage(err, "prod", value);
        }
      });
      if (prod === void 0) {
        throw new Error("Cannot calculate prod of an empty array");
      }
      return prod;
    }
  }
);

// src/function/string/format.ts
var name121 = "format";
var dependencies122 = ["typed"];
var createFormat = /* @__PURE__ */ factory(
  name121,
  dependencies122,
  ({ typed: typed2 }) => {
    return typed2(name121, {
      any: format3,
      "any, Object | function | number | BigNumber": format3
    });
  }
);

// src/function/string/bin.ts
var name122 = "bin";
var dependencies123 = ["typed", "format"];
var createBin = /* @__PURE__ */ factory(
  name122,
  dependencies123,
  ({ typed: typed2, format: format4 }) => {
    return typed2(name122, {
      "number | BigNumber": function(n) {
        return format4(n, { notation: "bin" });
      },
      "number | BigNumber, number | BigNumber": function(n, wordSize) {
        return format4(n, { notation: "bin", wordSize });
      }
    });
  }
);

// src/function/string/oct.ts
var name123 = "oct";
var dependencies124 = ["typed", "format"];
var createOct = /* @__PURE__ */ factory(
  name123,
  dependencies124,
  ({ typed: typed2, format: format4 }) => {
    return typed2(name123, {
      "number | BigNumber": function(n) {
        return format4(n, { notation: "oct" });
      },
      "number | BigNumber, number | BigNumber": function(n, wordSize) {
        return format4(n, { notation: "oct", wordSize });
      }
    });
  }
);

// src/function/string/hex.ts
var name124 = "hex";
var dependencies125 = ["typed", "format"];
var createHex = /* @__PURE__ */ factory(
  name124,
  dependencies125,
  ({ typed: typed2, format: format4 }) => {
    return typed2(name124, {
      "number | BigNumber": function(n) {
        return format4(n, { notation: "hex" });
      },
      "number | BigNumber, number | BigNumber": function(n, wordSize) {
        return format4(n, { notation: "hex", wordSize });
      }
    });
  }
);

// src/utils/print.ts
var printTemplate = /\$([\w.]+)/g;

// src/function/string/print.ts
var name125 = "print";
var dependencies126 = ["typed"];
var createPrint = /* @__PURE__ */ factory(
  name125,
  dependencies126,
  ({ typed: typed2 }) => {
    return typed2(name125, {
      // note: Matrix will be converted automatically to an Array
      "string, Object | Array": _print,
      "string, Object | Array, number | Object": _print
    });
  }
);
function _print(template, values, options) {
  return template.replace(
    printTemplate,
    function(original, key) {
      const keys = key.split(".");
      let value = values[keys.shift()];
      if (value !== void 0 && value.isMatrix) {
        value = value.toArray();
      }
      while (keys.length && value !== void 0) {
        const k = keys.shift();
        value = k ? value[k] : value + ".";
      }
      if (value !== void 0) {
        if (!isString(value)) {
          return format3(value, options);
        } else {
          return value;
        }
      }
      return original;
    }
  );
}

// src/function/unit/to.ts
var name126 = "to";
var dependencies127 = ["typed", "matrix", "concat"];
var createTo = /* @__PURE__ */ factory(
  name126,
  dependencies127,
  ({ typed: typed2, matrix, concat: concat2 }) => {
    const matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed2,
      matrix,
      concat: concat2
    });
    return typed2(
      name126,
      { "Unit, Unit | string": (x, unit) => x.to(unit) },
      matrixAlgorithmSuite({})
    );
  }
);

// src/function/unit/toBest.ts
var name127 = "toBest";
var dependencies128 = ["typed"];
var createToBest = /* @__PURE__ */ factory(
  name127,
  dependencies128,
  ({ typed: typed2 }) => {
    return typed2(name127, {
      Unit: (x) => x.toBest(),
      "Unit, string": (x, unitList) => x.toBest(unitList.split(",")),
      "Unit, string, Object": (x, unitList, options) => x.toBest(unitList.split(","), options),
      "Unit, Array": (x, unitList) => x.toBest(unitList),
      "Unit, Array, Object": (x, unitList, options) => x.toBest(unitList, options)
    });
  }
);

// src/function/utils/isPrime.ts
var name128 = "isPrime";
var dependencies129 = ["typed"];
var createIsPrime = /* @__PURE__ */ factory(
  name128,
  dependencies129,
  ({ typed: typed2 }) => {
    return typed2(name128, {
      number: function(x) {
        if (x <= 3) {
          return x > 1;
        }
        if (x % 2 === 0 || x % 3 === 0) {
          return false;
        }
        for (let i = 5; i * i <= x; i += 6) {
          if (x % i === 0 || x % (i + 2) === 0) {
            return false;
          }
        }
        return true;
      },
      bigint: function(x) {
        if (x <= 3n) {
          return x > 1n;
        }
        if (x % 2n === 0n || x % 3n === 0n) {
          return false;
        }
        for (let i = 5n; i * i <= x; i += 6n) {
          if (x % i === 0n || x % (i + 2n) === 0n) {
            return false;
          }
        }
        return true;
      },
      BigNumber: function(n) {
        if (n.lte(3)) return n.gt(1);
        if (n.mod(2).eq(0) || n.mod(3).eq(0)) return false;
        if (n.lt(Math.pow(2, 32))) {
          const x = n.toNumber();
          for (let i = 5; i * i <= x; i += 6) {
            if (x % i === 0 || x % (i + 2) === 0) {
              return false;
            }
          }
          return true;
        }
        function modPow(base, exponent, modulus) {
          let accumulator = 1;
          while (!exponent.eq(0)) {
            if (exponent.mod(2).eq(0)) {
              exponent = exponent.div(2);
              base = base.mul(base).mod(modulus);
            } else {
              exponent = exponent.sub(1);
              accumulator = base.mul(accumulator).mod(modulus);
            }
          }
          return accumulator;
        }
        const Decimal4 = n.constructor.clone({
          precision: n.toFixed(0).length * 2
        });
        n = new Decimal4(n);
        let r = 0;
        let d = n.sub(1);
        while (d.mod(2).eq(0)) {
          d = d.div(2);
          r += 1;
        }
        let bases = null;
        if (n.lt("3317044064679887385961981")) {
          bases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41].filter(
            (x) => x < n.toNumber()
          );
        } else {
          const max = Math.min(
            n.toNumber() - 2,
            Math.floor(2 * Math.pow(n.toFixed(0).length * Math.log(10), 2))
          );
          bases = [];
          for (let i = 2; i <= max; i += 1) {
            bases.push(max);
          }
        }
        for (let i = 0; i < bases.length; i += 1) {
          const a = bases[i];
          const adn = modPow(n.sub(n).add(a), d, n);
          if (!adn.eq(1)) {
            for (let i2 = 0, x = adn; !x.eq(n.sub(1)); i2 += 1, x = x.mul(x).mod(n)) {
              if (i2 === r - 1) {
                return false;
              }
            }
          }
        }
        return true;
      },
      "Array | Matrix": typed2.referToSelf(
        (self) => (x) => deepMap2(x, self)
      )
    });
  }
);

// src/function/utils/numeric.ts
var name129 = "numeric";
var dependencies130 = ["number", "?bignumber", "?fraction"];
var createNumeric = /* @__PURE__ */ factory(
  name129,
  dependencies130,
  ({ number, bignumber, fraction }) => {
    const validInputTypes = {
      string: true,
      number: true,
      BigNumber: true,
      Fraction: true
    };
    const validOutputTypes = {
      number: (x) => number(x),
      BigNumber: bignumber ? (x) => bignumber(x) : noBignumber,
      bigint: (x) => BigInt(x),
      Fraction: fraction ? (x) => fraction(x) : noFraction
    };
    return function numeric(value, outputType = "number", check) {
      if (check !== void 0) {
        throw new SyntaxError("numeric() takes one or two arguments");
      }
      const inputType = typeOf(value);
      if (!(inputType in validInputTypes)) {
        throw new TypeError(
          "Cannot convert " + value + ' of type "' + inputType + '"; valid input types are ' + Object.keys(validInputTypes).join(", ")
        );
      }
      if (!(outputType in validOutputTypes)) {
        throw new TypeError(
          "Cannot convert " + value + ' to type "' + outputType + '"; valid output types are ' + Object.keys(validOutputTypes).join(", ")
        );
      }
      if (outputType === inputType) {
        return value;
      } else {
        return validOutputTypes[outputType](value);
      }
    };
  }
);

// src/utils/parseNumber.ts
var name130 = "parseNumberWithConfig";
var dependencies131 = ["config", "?bignumber"];
var createParseNumberWithConfig = /* @__PURE__ */ factory(
  name130,
  dependencies131,
  ({ config, bignumber }) => {
    function parseNumberWithConfig(str) {
      if (typeof str !== "string") {
        throw new TypeError(
          `parseNumberWithConfig expects string, got ${typeof str}`
        );
      }
      const numberType = config.number || "number";
      switch (numberType) {
        case "BigNumber":
          if (!bignumber) {
            throw new Error(
              "BigNumber not available. Configure mathjs with BigNumber support."
            );
          }
          return bignumber(str);
        case "bigint":
          if (str.includes(".") || str.includes("e") || str.includes("E")) {
            const num = Number(str);
            if (isNaN(num)) {
              throw new SyntaxError(`String "${str}" is not a valid number`);
            }
            return num;
          }
          try {
            return BigInt(str);
          } catch {
            throw new SyntaxError(`String "${str}" is not a valid number`);
          }
        case "Fraction": {
          const fracNum = Number(str);
          if (isNaN(fracNum)) {
            throw new SyntaxError(`String "${str}" is not a valid number`);
          }
          return fracNum;
        }
        case "number":
        default: {
          const num = Number(str);
          if (isNaN(num)) {
            throw new SyntaxError(`String "${str}" is not a valid number`);
          }
          return num;
        }
      }
    }
    return parseNumberWithConfig;
  }
);

// src/function/arithmetic/divideScalar.ts
var name131 = "divideScalar";
var dependencies132 = ["typed", "numeric"];
var createDivideScalar = /* @__PURE__ */ factory(
  name131,
  dependencies132,
  ({ typed: typed2, numeric: _numeric }) => {
    return typed2(name131, {
      "number, number": function(x, y) {
        return x / y;
      },
      "Complex, Complex": function(x, y) {
        return x.div(y);
      },
      "BigNumber, BigNumber": function(x, y) {
        return x.div(y);
      },
      "bigint, bigint": function(x, y) {
        return x / y;
      },
      "Fraction, Fraction": function(x, y) {
        return x.div(y);
      },
      "Unit, number | Complex | Fraction | BigNumber | Unit": (x, y) => x.divide(y),
      "number | Fraction | Complex | BigNumber, Unit": (x, y) => y.divideInto(x)
    });
  }
);

// src/function/arithmetic/pow.ts
var name132 = "pow";
var dependencies133 = [
  "typed",
  "config",
  "identity",
  "multiply",
  "matrix",
  "inv",
  "fraction",
  "number",
  "Complex"
];
var createPow = /* @__PURE__ */ factory(
  name132,
  dependencies133,
  ({
    typed: typed2,
    config,
    identity,
    multiply,
    matrix,
    inv,
    number,
    fraction,
    Complex: Complex2
  }) => {
    return typed2(name132, {
      "number, number": _pow,
      "Complex, Complex": function(x, y) {
        return x.pow(y);
      },
      "BigNumber, BigNumber": function(x, y) {
        if (y.isInteger() || x.gte(0) || config.predictable) {
          return x.pow(y);
        } else {
          return new Complex2(x.toNumber(), 0).pow(
            y.toNumber(),
            0
          );
        }
      },
      "bigint, bigint": (x, y) => x ** y,
      "Fraction, Fraction": function(x, y) {
        const result = x.pow(y);
        if (result != null) {
          return result;
        }
        if (config.predictable) {
          throw new Error(
            "Result of pow is non-rational and cannot be expressed as a fraction"
          );
        } else {
          return _pow(x.valueOf(), y.valueOf());
        }
      },
      "Array, number": _powArray,
      "Array, BigNumber": function(x, y) {
        return _powArray(x, y.toNumber());
      },
      "Matrix, number": _powMatrix,
      "Matrix, BigNumber": function(x, y) {
        return _powMatrix(x, y.toNumber());
      },
      "Unit, number | BigNumber": function(x, y) {
        return x.pow(y);
      }
    });
    function _pow(x, y) {
      if (config.predictable && !isInteger(y) && x < 0) {
        try {
          const yFrac = fraction(y);
          const yNum = number(yFrac);
          if (y === yNum || Math.abs((y - yNum) / y) < 1e-14) {
            if (yFrac.d % 2n === 1n) {
              return (yFrac.n % 2n === 0n ? 1 : -1) * Math.pow(-x, y);
            }
          }
        } catch {
        }
      }
      if (config.predictable && (x < -1 && y === Infinity || x > -1 && x < 0 && y === -Infinity)) {
        return NaN;
      }
      if (isInteger(y) || x >= 0 || config.predictable) {
        return powNumber(x, y);
      } else {
        if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
          return 0;
        }
        return new Complex2(x, 0).pow(y, 0);
      }
    }
    function _powArray(x, y) {
      if (!isInteger(y)) {
        throw new TypeError(
          "For A^b, b must be an integer (value is " + y + ")"
        );
      }
      const s = arraySize(x);
      if (s.length !== 2) {
        throw new Error(
          "For A^b, A must be 2 dimensional (A has " + s.length + " dimensions)"
        );
      }
      if (s[0] !== s[1]) {
        throw new Error(
          "For A^b, A must be square (size is " + s[0] + "x" + s[1] + ")"
        );
      }
      if (y < 0) {
        try {
          return _powArray(inv(x), -y);
        } catch (error) {
          if (error instanceof Error && error.message === "Cannot calculate inverse, determinant is zero") {
            throw new TypeError(
              "For A^b, when A is not invertible, b must be a positive integer (value is " + y + ")"
            );
          }
          throw error;
        }
      }
      let res = identity(s[0]).valueOf();
      let px = x;
      while (y >= 1) {
        if ((y & 1) === 1) {
          res = multiply(px, res);
        }
        y >>= 1;
        px = multiply(px, px);
      }
      return res;
    }
    function _powMatrix(x, y) {
      return matrix(_powArray(x.valueOf(), y));
    }
  }
);

// src/function/arithmetic/round.ts
var NO_INT = "Number of decimals in function round must be an integer";
var name133 = "round";
var dependencies134 = [
  "typed",
  "config",
  "matrix",
  "equalScalar",
  "zeros",
  "BigNumber",
  "DenseMatrix"
];
var createRound = /* @__PURE__ */ factory(
  name133,
  dependencies134,
  ({
    typed: typed2,
    config,
    matrix,
    equalScalar,
    zeros: zeros2,
    BigNumber,
    DenseMatrix
  }) => {
    const matAlgo11xS0s = createMatAlgo11xS0s({ typed: typed2, equalScalar });
    const matAlgo12xSfs = createMatAlgo12xSfs({ typed: typed2, DenseMatrix });
    const matAlgo14xDs = createMatAlgo14xDs({ typed: typed2 });
    function toExponent(epsilon) {
      return Math.abs(splitNumber(epsilon).exponent);
    }
    return typed2(name133, {
      number: function(x) {
        const xEpsilon = roundNumber(x, toExponent(config.relTol));
        const xSelected = nearlyEqual(x, xEpsilon, config.relTol, config.absTol) ? xEpsilon : x;
        return roundNumber(xSelected);
      },
      "number, number": function(x, n) {
        const epsilonExponent = toExponent(config.relTol);
        if (n >= epsilonExponent) {
          return roundNumber(x, n);
        }
        const xEpsilon = roundNumber(x, epsilonExponent);
        const xSelected = nearlyEqual(x, xEpsilon, config.relTol, config.absTol) ? xEpsilon : x;
        return roundNumber(xSelected, n);
      },
      "number, BigNumber": function(x, n) {
        if (!n.isInteger()) {
          throw new TypeError(NO_INT);
        }
        return new BigNumber(x).toDecimalPlaces(n.toNumber());
      },
      Complex: function(x) {
        return x.round();
      },
      "Complex, number": function(x, n) {
        if (n % 1) {
          throw new TypeError(NO_INT);
        }
        return x.round(n);
      },
      "Complex, BigNumber": function(x, n) {
        if (!n.isInteger()) {
          throw new TypeError(NO_INT);
        }
        const _n = n.toNumber();
        return x.round(_n);
      },
      BigNumber: function(x) {
        const xEpsilon = new BigNumber(x).toDecimalPlaces(
          toExponent(config.relTol)
        );
        const xSelected = nearlyEqual2(
          x,
          xEpsilon,
          config.relTol,
          config.absTol
        ) ? xEpsilon : x;
        return xSelected.toDecimalPlaces(0);
      },
      "BigNumber, BigNumber": function(x, n) {
        if (!n.isInteger()) {
          throw new TypeError(NO_INT);
        }
        const epsilonExponent = toExponent(config.relTol);
        if (n >= epsilonExponent) {
          return x.toDecimalPlaces(n.toNumber());
        }
        const xEpsilon = x.toDecimalPlaces(epsilonExponent);
        const xSelected = nearlyEqual2(
          x,
          xEpsilon,
          config.relTol,
          config.absTol
        ) ? xEpsilon : x;
        return xSelected.toDecimalPlaces(n.toNumber());
      },
      // bigints can't be rounded
      bigint: (b) => b,
      "bigint, number": (b, _dummy) => b,
      "bigint, BigNumber": (b, _dummy) => b,
      Fraction: function(x) {
        return x.round();
      },
      "Fraction, number": function(x, n) {
        if (n % 1) {
          throw new TypeError(NO_INT);
        }
        return x.round(n);
      },
      "Fraction, BigNumber": function(x, n) {
        if (!n.isInteger()) {
          throw new TypeError(NO_INT);
        }
        return x.round(n.toNumber());
      },
      "Unit, number, Unit": typed2.referToSelf(
        (self) => function(x, n, unit) {
          const valueless = x.toNumeric(unit);
          return unit.multiply(self(valueless, n));
        }
      ),
      "Unit, BigNumber, Unit": typed2.referToSelf(
        (self) => (x, n, unit) => self(x, n.toNumber(), unit)
      ),
      "Array | Matrix, number | BigNumber, Unit": typed2.referToSelf(
        (self) => (x, n, unit) => {
          return deepMap2(x, (value) => self(value, n, unit), true);
        }
      ),
      "Array | Matrix | Unit, Unit": typed2.referToSelf(
        (self) => (x, unit) => self(x, 0, unit)
      ),
      "Array | Matrix": typed2.referToSelf((self) => (x) => {
        return deepMap2(x, self, true);
      }),
      "SparseMatrix, number | BigNumber": typed2.referToSelf(
        (self) => (x, n) => {
          return matAlgo11xS0s(x, n, self, false);
        }
      ),
      "DenseMatrix, number | BigNumber": typed2.referToSelf(
        (self) => (x, n) => {
          return matAlgo14xDs(x, n, self, false);
        }
      ),
      "Array, number | BigNumber": typed2.referToSelf(
        (self) => (x, n) => {
          return matAlgo14xDs(matrix(x), n, self, false).valueOf();
        }
      ),
      "number | Complex | BigNumber | Fraction, SparseMatrix": typed2.referToSelf((self) => (x, n) => {
        if (equalScalar(x, 0)) {
          return zeros2(n.size(), n.storage());
        }
        return matAlgo12xSfs(n, x, self, true);
      }),
      "number | Complex | BigNumber | Fraction, DenseMatrix": typed2.referToSelf(
        (self) => (x, n) => {
          if (equalScalar(x, 0)) {
            return zeros2(n.size(), n.storage());
          }
          return matAlgo14xDs(n, x, self, true);
        }
      ),
      "number | Complex | BigNumber | Fraction, Array": typed2.referToSelf(
        (self) => (x, n) => {
          return matAlgo14xDs(matrix(n), x, self, true).valueOf();
        }
      )
    });
  }
);

// src/function/arithmetic/log.ts
var name134 = "log";
var dependencies135 = ["config", "typed", "typeOf", "divideScalar", "Complex"];
var nlg16 = Math.log(16);
var createLog = /* @__PURE__ */ factory(
  name134,
  dependencies135,
  ({
    typed: typed2,
    typeOf: typeOf2,
    config,
    divideScalar,
    Complex: Complex2
  }) => {
    function complexLog(c) {
      return c.log();
    }
    function complexLogNumber(x) {
      return complexLog(new Complex2(x, 0));
    }
    return typed2(name134, {
      number: function(x) {
        if (x >= 0 || config.predictable) {
          return logNumber(x);
        } else {
          return complexLogNumber(x);
        }
      },
      bigint: promoteLogarithm(nlg16, logNumber, config, complexLogNumber),
      Complex: complexLog,
      BigNumber: function(x) {
        if (!x.isNegative() || config.predictable) {
          return x.ln();
        } else {
          return complexLogNumber(x.toNumber());
        }
      },
      "any, any": typed2.referToSelf((self) => (x, base) => {
        if (typeOf2(x) === "Fraction" && typeOf2(base) === "Fraction") {
          const result = x.log(base);
          if (result !== null) {
            return result;
          }
        }
        return divideScalar(self(x), self(base));
      })
    });
  }
);

// src/function/arithmetic/log1p.ts
var name135 = "log1p";
var dependencies136 = ["typed", "config", "divideScalar", "log", "Complex"];
var createLog1p = /* @__PURE__ */ factory(
  name135,
  dependencies136,
  ({
    typed: typed2,
    config,
    divideScalar,
    log,
    Complex: Complex2
  }) => {
    return typed2(name135, {
      number: function(x) {
        if (x >= -1 || config.predictable) {
          return log1p(x);
        } else {
          return _log1pComplex(new Complex2(x, 0));
        }
      },
      Complex: _log1pComplex,
      BigNumber: function(x) {
        const y = x.plus(1);
        if (!y.isNegative() || config.predictable) {
          return y.ln();
        } else {
          return _log1pComplex(new Complex2(x.toNumber(), 0));
        }
      },
      "Array | Matrix": typed2.referToSelf(
        (self) => (x) => deepMap2(x, self)
      ),
      "any, any": typed2.referToSelf((self) => (x, base) => {
        return divideScalar(self(x), log(base));
      })
    });
    function _log1pComplex(x) {
      const xRe1p = x.re + 1;
      return new Complex2(
        Math.log(Math.sqrt(xRe1p * xRe1p + x.im * x.im)),
        Math.atan2(x.im, xRe1p)
      );
    }
  }
);

// src/function/arithmetic/nthRoots.ts
var name136 = "nthRoots";
var dependencies137 = ["config", "typed", "divideScalar", "Complex"];
var createNthRoots = /* @__PURE__ */ factory(
  name136,
  dependencies137,
  ({
    typed: typed2,
    config: _config,
    divideScalar: _divideScalar,
    Complex: Complex2
  }) => {
    const _calculateExactResult = [
      function realPos(val) {
        return new Complex2(val, 0);
      },
      function imagPos(val) {
        return new Complex2(0, val);
      },
      function realNeg(val) {
        return new Complex2(-val, 0);
      },
      function imagNeg(val) {
        return new Complex2(0, -val);
      }
    ];
    function _nthComplexRoots(a, root) {
      if (root < 0) throw new Error("Root must be greater than zero");
      if (root === 0) throw new Error("Root must be non-zero");
      if (root % 1 !== 0) throw new Error("Root must be an integer");
      if (a === 0 || a.abs() === 0) return [new Complex2(0, 0)];
      const aIsNumeric = typeof a === "number";
      let offset;
      if (aIsNumeric || a.re === 0 || a.im === 0) {
        if (aIsNumeric) {
          offset = 2 * +(a < 0);
        } else if (a.im === 0) {
          offset = 2 * +(a.re < 0);
        } else {
          offset = 2 * +(a.im < 0) + 1;
        }
      }
      const arg = a.arg();
      const abs = a.abs();
      const roots = [];
      const r = Math.pow(abs, 1 / root);
      for (let k = 0; k < root; k++) {
        const halfPiFactor = (offset + 4 * k) / root;
        if (halfPiFactor === Math.round(halfPiFactor)) {
          roots.push(_calculateExactResult[halfPiFactor % 4](r));
          continue;
        }
        roots.push(new Complex2({ r, phi: (arg + 2 * Math.PI * k) / root }));
      }
      return roots;
    }
    return typed2(name136, {
      Complex: function(x) {
        return _nthComplexRoots(x, 2);
      },
      "Complex, number": _nthComplexRoots
    });
  }
);

// src/function/arithmetic/dotPow.ts
var name137 = "dotPow";
var dependencies138 = [
  "typed",
  "equalScalar",
  "matrix",
  "pow",
  "DenseMatrix",
  "concat",
  "SparseMatrix"
];
var createDotPow = /* @__PURE__ */ factory(
  name137,
  dependencies138,
  ({
    typed: typed2,
    equalScalar,
    matrix,
    pow,
    DenseMatrix,
    concat: concat2,
    SparseMatrix
  }) => {
    const matAlgo03xDSf = createMatAlgo03xDSf({ typed: typed2 });
    const matAlgo07xSSf = createMatAlgo07xSSf({ typed: typed2, SparseMatrix });
    const matAlgo11xS0s = createMatAlgo11xS0s({ typed: typed2, equalScalar });
    const matAlgo12xSfs = createMatAlgo12xSfs({ typed: typed2, DenseMatrix });
    const matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed2,
      matrix,
      concat: concat2
    });
    const powScalarSignatures = {};
    for (const signature in pow.signatures) {
      if (Object.prototype.hasOwnProperty.call(pow.signatures, signature)) {
        if (!signature.includes("Matrix") && !signature.includes("Array")) {
          powScalarSignatures[signature] = pow.signatures[signature];
        }
      }
    }
    const powScalar = typed2(powScalarSignatures);
    return typed2(
      name137,
      matrixAlgorithmSuite({
        elop: powScalar,
        SS: matAlgo07xSSf,
        DS: matAlgo03xDSf,
        Ss: matAlgo11xS0s,
        sS: matAlgo12xSfs
      })
    );
  }
);

// src/function/arithmetic/dotDivide.ts
var name138 = "dotDivide";
var dependencies139 = [
  "typed",
  "matrix",
  "equalScalar",
  "divideScalar",
  "DenseMatrix",
  "concat",
  "SparseMatrix"
];
var createDotDivide = /* @__PURE__ */ factory(
  name138,
  dependencies139,
  ({
    typed: typed2,
    matrix,
    equalScalar,
    divideScalar,
    DenseMatrix,
    concat: concat2,
    SparseMatrix
  }) => {
    const matAlgo02xDS0 = createMatAlgo02xDS0({ typed: typed2, equalScalar });
    const matAlgo03xDSf = createMatAlgo03xDSf({ typed: typed2 });
    const matAlgo07xSSf = createMatAlgo07xSSf({ typed: typed2, SparseMatrix });
    const matAlgo11xS0s = createMatAlgo11xS0s({ typed: typed2, equalScalar });
    const matAlgo12xSfs = createMatAlgo12xSfs({ typed: typed2, DenseMatrix });
    const matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed2,
      matrix,
      concat: concat2
    });
    return typed2(
      name138,
      matrixAlgorithmSuite({
        elop: divideScalar,
        SS: matAlgo07xSSf,
        DS: matAlgo03xDSf,
        SD: matAlgo02xDS0,
        Ss: matAlgo11xS0s,
        sS: matAlgo12xSfs
      })
    );
  }
);

// src/function/algebra/solver/utils/solveValidation.ts
function createSolveValidation({ DenseMatrix }) {
  return function solveValidation(m, b, copy) {
    const mSize = m.size();
    if (mSize.length !== 2) {
      throw new RangeError(
        "Matrix must be two dimensional (size: " + format3(mSize, {}) + ")"
      );
    }
    const rows = mSize[0];
    const columns = mSize[1];
    if (rows !== columns) {
      throw new RangeError(
        "Matrix must be square (size: " + format3(mSize, {}) + ")"
      );
    }
    let data = [];
    if (isMatrix(b)) {
      const bSize = b.size();
      const bdata = b._data;
      if (bSize.length === 1) {
        if (bSize[0] !== rows) {
          throw new RangeError(
            "Dimension mismatch. Matrix columns must match vector length."
          );
        }
        for (let i = 0; i < rows; i++) {
          data[i] = [bdata[i]];
        }
        return new DenseMatrix({
          data,
          size: [rows, 1],
          datatype: b._datatype
        });
      }
      if (bSize.length === 2) {
        if (bSize[0] !== rows || bSize[1] !== 1) {
          throw new RangeError(
            "Dimension mismatch. Matrix columns must match vector length."
          );
        }
        if (isDenseMatrix(b)) {
          if (copy) {
            data = [];
            for (let i = 0; i < rows; i++) {
              data[i] = [bdata[i][0]];
            }
            return new DenseMatrix({
              data,
              size: [rows, 1],
              datatype: b._datatype
            });
          }
          return b;
        }
        if (isSparseMatrix(b)) {
          for (let i = 0; i < rows; i++) {
            data[i] = [0];
          }
          const values = b._values;
          const index = b._index;
          const ptr = b._ptr;
          for (let k1 = ptr[1], k = ptr[0]; k < k1; k++) {
            const i = index[k];
            data[i][0] = values[k];
          }
          return new DenseMatrix({
            data,
            size: [rows, 1],
            datatype: b._datatype
          });
        }
      }
      throw new RangeError(
        "Dimension mismatch. The right side has to be either 1- or 2-dimensional vector."
      );
    }
    if (isArray(b)) {
      const bsize = arraySize(b);
      if (bsize.length === 1) {
        if (bsize[0] !== rows) {
          throw new RangeError(
            "Dimension mismatch. Matrix columns must match vector length."
          );
        }
        for (let i = 0; i < rows; i++) {
          data[i] = [b[i]];
        }
        return new DenseMatrix({
          data,
          size: [rows, 1]
        });
      }
      if (bsize.length === 2) {
        if (bsize[0] !== rows || bsize[1] !== 1) {
          throw new RangeError(
            "Dimension mismatch. Matrix columns must match vector length."
          );
        }
        for (let i = 0; i < rows; i++) {
          data[i] = [b[i][0]];
        }
        return new DenseMatrix({
          data,
          size: [rows, 1]
        });
      }
      throw new RangeError(
        "Dimension mismatch. The right side has to be either 1- or 2-dimensional vector."
      );
    }
  };
}

// src/function/algebra/solver/lsolve.ts
var WASM_LSOLVE_THRESHOLD = 16;
function isPlainNumberMatrix2(matrix) {
  for (let i = 0; i < matrix.length; i++) {
    const row = matrix[i];
    for (let j = 0; j < row.length; j++) {
      if (typeof row[j] !== "number") {
        return false;
      }
    }
  }
  return true;
}
function isPlainNumberVector(vec) {
  for (let i = 0; i < vec.length; i++) {
    if (typeof vec[i][0] !== "number") {
      return false;
    }
  }
  return true;
}
function flattenToFloat642(matrix, rows, cols) {
  const result = new Float64Array(rows * cols);
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      result[i * cols + j] = matrix[i][j];
    }
  }
  return result;
}
function vectorToFloat64(vec) {
  const result = new Float64Array(vec.length);
  for (let i = 0; i < vec.length; i++) {
    result[i] = vec[i][0];
  }
  return result;
}
var name139 = "lsolve";
var dependencies140 = [
  "typed",
  "matrix",
  "divideScalar",
  "multiplyScalar",
  "subtractScalar",
  "equalScalar",
  "DenseMatrix"
];
var createLsolve = /* @__PURE__ */ factory(
  name139,
  dependencies140,
  ({
    typed: typed2,
    matrix,
    divideScalar,
    multiplyScalar,
    subtractScalar,
    equalScalar,
    DenseMatrix
  }) => {
    const solveValidation = createSolveValidation({
      DenseMatrix
    });
    return typed2(name139, {
      "SparseMatrix, Array | Matrix": function(m, b) {
        return _sparseForwardSubstitution(m, b);
      },
      "DenseMatrix, Array | Matrix": function(m, b) {
        return _denseForwardSubstitution(m, b);
      },
      "Array, Array | Matrix": function(a, b) {
        const m = matrix(a);
        const r = _denseForwardSubstitution(m, b);
        return r.valueOf();
      }
    });
    function _denseForwardSubstitution(m, b) {
      const bVector = solveValidation(m, b, true);
      const bdata = bVector._data;
      const rows = m._size[0];
      const columns = m._size[1];
      const mdata = m._data;
      const wasm = wasmLoader.getModule();
      if (wasm && rows === columns && rows * rows >= WASM_LSOLVE_THRESHOLD && isPlainNumberMatrix2(mdata) && isPlainNumberVector(bdata)) {
        try {
          const lFlat = flattenToFloat642(mdata, rows, columns);
          const bFlat = vectorToFloat64(bdata);
          const lAlloc = wasmLoader.allocateFloat64Array(lFlat);
          const bAlloc = wasmLoader.allocateFloat64Array(bFlat);
          const resultAlloc = wasmLoader.allocateFloat64ArrayEmpty(rows);
          try {
            const success = wasm.laLsolve(
              lAlloc.ptr,
              bAlloc.ptr,
              rows,
              resultAlloc.ptr
            );
            if (success === 0) {
              throw new Error(
                "Linear system cannot be solved since matrix is singular"
              );
            }
            const x2 = [];
            for (let i = 0; i < rows; i++) {
              x2[i] = [resultAlloc.array[i]];
            }
            return new DenseMatrix({
              data: x2,
              size: [rows, 1]
            });
          } finally {
            wasmLoader.free(lAlloc.ptr);
            wasmLoader.free(bAlloc.ptr);
            wasmLoader.free(resultAlloc.ptr);
          }
        } catch (e2) {
          if (e2 instanceof Error && e2.message.includes("singular")) {
            throw e2;
          }
        }
      }
      const x = [];
      for (let j = 0; j < columns; j++) {
        const bj = bdata[j][0] || 0;
        let xj;
        if (!equalScalar(bj, 0)) {
          const vjj = mdata[j][j];
          if (equalScalar(vjj, 0)) {
            throw new Error(
              "Linear system cannot be solved since matrix is singular"
            );
          }
          xj = divideScalar(bj, vjj);
          for (let i = j + 1; i < rows; i++) {
            bdata[i] = [
              subtractScalar(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))
            ];
          }
        } else {
          xj = 0;
        }
        x[j] = [xj];
      }
      return new DenseMatrix({
        data: x,
        size: [rows, 1]
      });
    }
    function _sparseForwardSubstitution(m, b) {
      const bVector = solveValidation(m, b, true);
      const bdata = bVector._data;
      const rows = m._size[0];
      const columns = m._size[1];
      const values = m._values;
      const index = m._index;
      const ptr = m._ptr;
      const x = [];
      for (let j = 0; j < columns; j++) {
        const bj = bdata[j][0] || 0;
        if (!equalScalar(bj, 0)) {
          let vjj = 0;
          const jValues = [];
          const jIndices = [];
          const firstIndex = ptr[j];
          const lastIndex = ptr[j + 1];
          for (let k = firstIndex; k < lastIndex; k++) {
            const i = index[k];
            if (i === j) {
              vjj = values[k];
            } else if (i > j) {
              jValues.push(values[k]);
              jIndices.push(i);
            }
          }
          if (equalScalar(vjj, 0)) {
            throw new Error(
              "Linear system cannot be solved since matrix is singular"
            );
          }
          const xj = divideScalar(bj, vjj);
          for (let k = 0, l = jIndices.length; k < l; k++) {
            const i = jIndices[k];
            bdata[i] = [
              subtractScalar(bdata[i][0] || 0, multiplyScalar(xj, jValues[k]))
            ];
          }
          x[j] = [xj];
        } else {
          x[j] = [0];
        }
      }
      return new DenseMatrix({
        data: x,
        size: [rows, 1]
      });
    }
  }
);

// src/function/algebra/solver/usolve.ts
var WASM_USOLVE_THRESHOLD = 16;
function isPlainNumberMatrix3(matrix) {
  for (let i = 0; i < matrix.length; i++) {
    const row = matrix[i];
    for (let j = 0; j < row.length; j++) {
      if (typeof row[j] !== "number") {
        return false;
      }
    }
  }
  return true;
}
function isPlainNumberVector2(vec) {
  for (let i = 0; i < vec.length; i++) {
    if (typeof vec[i][0] !== "number") {
      return false;
    }
  }
  return true;
}
function flattenToFloat643(matrix, rows, cols) {
  const result = new Float64Array(rows * cols);
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      result[i * cols + j] = matrix[i][j];
    }
  }
  return result;
}
function vectorToFloat642(vec) {
  const result = new Float64Array(vec.length);
  for (let i = 0; i < vec.length; i++) {
    result[i] = vec[i][0];
  }
  return result;
}
var name140 = "usolve";
var dependencies141 = [
  "typed",
  "matrix",
  "divideScalar",
  "multiplyScalar",
  "subtractScalar",
  "equalScalar",
  "DenseMatrix"
];
var createUsolve = /* @__PURE__ */ factory(
  name140,
  dependencies141,
  ({
    typed: typed2,
    matrix,
    divideScalar,
    multiplyScalar,
    subtractScalar,
    equalScalar,
    DenseMatrix
  }) => {
    const solveValidation = createSolveValidation({
      DenseMatrix
    });
    return typed2(name140, {
      "SparseMatrix, Array | Matrix": function(m, b) {
        return _sparseBackwardSubstitution(m, b);
      },
      "DenseMatrix, Array | Matrix": function(m, b) {
        return _denseBackwardSubstitution(m, b);
      },
      "Array, Array | Matrix": function(a, b) {
        const m = matrix(a);
        const r = _denseBackwardSubstitution(m, b);
        return r.valueOf();
      }
    });
    function _denseBackwardSubstitution(m, b) {
      const bVector = solveValidation(m, b, true);
      const bdata = bVector._data;
      const rows = m._size[0];
      const columns = m._size[1];
      const mdata = m._data;
      const wasm = wasmLoader.getModule();
      if (wasm && rows === columns && rows * rows >= WASM_USOLVE_THRESHOLD && isPlainNumberMatrix3(mdata) && isPlainNumberVector2(bdata)) {
        try {
          const uFlat = flattenToFloat643(mdata, rows, columns);
          const bFlat = vectorToFloat642(bdata);
          const uAlloc = wasmLoader.allocateFloat64Array(uFlat);
          const bAlloc = wasmLoader.allocateFloat64Array(bFlat);
          const resultAlloc = wasmLoader.allocateFloat64ArrayEmpty(rows);
          try {
            const success = wasm.laUsolve(
              uAlloc.ptr,
              bAlloc.ptr,
              rows,
              resultAlloc.ptr
            );
            if (success === 0) {
              throw new Error(
                "Linear system cannot be solved since matrix is singular"
              );
            }
            const x2 = [];
            for (let i = 0; i < rows; i++) {
              x2[i] = [resultAlloc.array[i]];
            }
            return new DenseMatrix({
              data: x2,
              size: [rows, 1]
            });
          } finally {
            wasmLoader.free(uAlloc.ptr);
            wasmLoader.free(bAlloc.ptr);
            wasmLoader.free(resultAlloc.ptr);
          }
        } catch (e2) {
          if (e2 instanceof Error && e2.message.includes("singular")) {
            throw e2;
          }
        }
      }
      const x = [];
      for (let j = columns - 1; j >= 0; j--) {
        const bj = bdata[j][0] || 0;
        let xj;
        if (!equalScalar(bj, 0)) {
          const vjj = mdata[j][j];
          if (equalScalar(vjj, 0)) {
            throw new Error(
              "Linear system cannot be solved since matrix is singular"
            );
          }
          xj = divideScalar(bj, vjj);
          for (let i = j - 1; i >= 0; i--) {
            bdata[i] = [
              subtractScalar(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))
            ];
          }
        } else {
          xj = 0;
        }
        x[j] = [xj];
      }
      return new DenseMatrix({
        data: x,
        size: [rows, 1]
      });
    }
    function _sparseBackwardSubstitution(m, b) {
      const bVector = solveValidation(m, b, true);
      const bdata = bVector._data;
      const rows = m._size[0];
      const columns = m._size[1];
      const values = m._values;
      const index = m._index;
      const ptr = m._ptr;
      const x = [];
      for (let j = columns - 1; j >= 0; j--) {
        const bj = bdata[j][0] || 0;
        if (!equalScalar(bj, 0)) {
          let vjj = 0;
          const jValues = [];
          const jIndices = [];
          const firstIndex = ptr[j];
          const lastIndex = ptr[j + 1];
          for (let k = lastIndex - 1; k >= firstIndex; k--) {
            const i = index[k];
            if (i === j) {
              vjj = values[k];
            } else if (i < j) {
              jValues.push(values[k]);
              jIndices.push(i);
            }
          }
          if (equalScalar(vjj, 0)) {
            throw new Error(
              "Linear system cannot be solved since matrix is singular"
            );
          }
          const xj = divideScalar(bj, vjj);
          for (let k = 0, lastIndex2 = jIndices.length; k < lastIndex2; k++) {
            const i = jIndices[k];
            bdata[i] = [
              subtractScalar(bdata[i][0], multiplyScalar(xj, jValues[k]))
            ];
          }
          x[j] = [xj];
        } else {
          x[j] = [0];
        }
      }
      return new DenseMatrix({
        data: x,
        size: [rows, 1]
      });
    }
  }
);

// src/function/algebra/solver/lsolveAll.ts
var name141 = "lsolveAll";
var dependencies142 = [
  "typed",
  "matrix",
  "divideScalar",
  "multiplyScalar",
  "subtractScalar",
  "equalScalar",
  "DenseMatrix"
];
var createLsolveAll = /* @__PURE__ */ factory(
  name141,
  dependencies142,
  ({
    typed: typed2,
    matrix,
    divideScalar,
    multiplyScalar,
    subtractScalar,
    equalScalar,
    DenseMatrix
  }) => {
    const solveValidation = createSolveValidation({
      DenseMatrix
    });
    return typed2(name141, {
      "SparseMatrix, Array | Matrix": function(m, b) {
        return _sparseForwardSubstitution(m, b);
      },
      "DenseMatrix, Array | Matrix": function(m, b) {
        return _denseForwardSubstitution(m, b);
      },
      "Array, Array | Matrix": function(a, b) {
        const m = matrix(a);
        const R = _denseForwardSubstitution(m, b);
        return R.map((r) => r.valueOf());
      }
    });
    function _denseForwardSubstitution(m, b_) {
      const B = [
        solveValidation(m, b_, true)._data.map(
          (e2) => e2[0]
        )
      ];
      const M = m._data;
      const rows = m._size[0];
      const columns = m._size[1];
      for (let i = 0; i < columns; i++) {
        let L = B.length;
        for (let k = 0; k < L; k++) {
          const b = B[k];
          if (!equalScalar(M[i][i], 0)) {
            b[i] = divideScalar(b[i], M[i][i]);
            for (let j = i + 1; j < columns; j++) {
              b[j] = subtractScalar(b[j], multiplyScalar(b[i], M[j][i]));
            }
          } else if (!equalScalar(b[i], 0)) {
            if (k === 0) {
              return [];
            } else {
              B.splice(k, 1);
              k -= 1;
              L -= 1;
            }
          } else if (k === 0) {
            const bNew = [...b];
            bNew[i] = 1;
            for (let j = i + 1; j < columns; j++) {
              bNew[j] = subtractScalar(bNew[j], M[j][i]);
            }
            B.push(bNew);
          }
        }
      }
      return B.map(
        (x) => new DenseMatrix({
          data: x.map((e2) => [e2]),
          size: [rows, 1]
        })
      );
    }
    function _sparseForwardSubstitution(m, b_) {
      const B = [
        solveValidation(m, b_, true)._data.map(
          (e2) => e2[0]
        )
      ];
      const rows = m._size[0];
      const columns = m._size[1];
      const values = m._values;
      const index = m._index;
      const ptr = m._ptr;
      for (let i = 0; i < columns; i++) {
        let L = B.length;
        for (let k = 0; k < L; k++) {
          const b = B[k];
          const iValues = [];
          const iIndices = [];
          const firstIndex = ptr[i];
          const lastIndex = ptr[i + 1];
          let Mii = 0;
          for (let j = firstIndex; j < lastIndex; j++) {
            const J = index[j];
            if (J === i) {
              Mii = values[j];
            } else if (J > i) {
              iValues.push(values[j]);
              iIndices.push(J);
            }
          }
          if (!equalScalar(Mii, 0)) {
            b[i] = divideScalar(b[i], Mii);
            for (let j = 0, lastIdx = iIndices.length; j < lastIdx; j++) {
              const J = iIndices[j];
              b[J] = subtractScalar(b[J], multiplyScalar(b[i], iValues[j]));
            }
          } else if (!equalScalar(b[i], 0)) {
            if (k === 0) {
              return [];
            } else {
              B.splice(k, 1);
              k -= 1;
              L -= 1;
            }
          } else if (k === 0) {
            const bNew = [...b];
            bNew[i] = 1;
            for (let j = 0, lastIdx = iIndices.length; j < lastIdx; j++) {
              const J = iIndices[j];
              bNew[J] = subtractScalar(bNew[J], iValues[j]);
            }
            B.push(bNew);
          }
        }
      }
      return B.map(
        (x) => new DenseMatrix({
          data: x.map((e2) => [e2]),
          size: [rows, 1]
        })
      );
    }
  }
);

// src/function/algebra/solver/usolveAll.ts
var name142 = "usolveAll";
var dependencies143 = [
  "typed",
  "matrix",
  "divideScalar",
  "multiplyScalar",
  "subtractScalar",
  "equalScalar",
  "DenseMatrix"
];
var createUsolveAll = /* @__PURE__ */ factory(
  name142,
  dependencies143,
  ({
    typed: typed2,
    matrix,
    divideScalar,
    multiplyScalar,
    subtractScalar,
    equalScalar,
    DenseMatrix
  }) => {
    const solveValidation = createSolveValidation({
      DenseMatrix
    });
    return typed2(name142, {
      "SparseMatrix, Array | Matrix": function(m, b) {
        return _sparseBackwardSubstitution(m, b);
      },
      "DenseMatrix, Array | Matrix": function(m, b) {
        return _denseBackwardSubstitution(m, b);
      },
      "Array, Array | Matrix": function(a, b) {
        const m = matrix(a);
        const R = _denseBackwardSubstitution(m, b);
        return R.map((r) => r.valueOf());
      }
    });
    function _denseBackwardSubstitution(m, b_) {
      const B = [
        solveValidation(m, b_, true)._data.map(
          (e2) => e2[0]
        )
      ];
      const M = m._data;
      const rows = m._size[0];
      const columns = m._size[1];
      for (let i = columns - 1; i >= 0; i--) {
        let L = B.length;
        for (let k = 0; k < L; k++) {
          const b = B[k];
          if (!equalScalar(M[i][i], 0)) {
            b[i] = divideScalar(b[i], M[i][i]);
            for (let j = i - 1; j >= 0; j--) {
              b[j] = subtractScalar(b[j], multiplyScalar(b[i], M[j][i]));
            }
          } else if (!equalScalar(b[i], 0)) {
            if (k === 0) {
              return [];
            } else {
              B.splice(k, 1);
              k -= 1;
              L -= 1;
            }
          } else if (k === 0) {
            const bNew = [...b];
            bNew[i] = 1;
            for (let j = i - 1; j >= 0; j--) {
              bNew[j] = subtractScalar(bNew[j], M[j][i]);
            }
            B.push(bNew);
          }
        }
      }
      return B.map(
        (x) => new DenseMatrix({
          data: x.map((e2) => [e2]),
          size: [rows, 1]
        })
      );
    }
    function _sparseBackwardSubstitution(m, b_) {
      const B = [
        solveValidation(m, b_, true)._data.map(
          (e2) => e2[0]
        )
      ];
      const rows = m._size[0];
      const columns = m._size[1];
      const values = m._values;
      const index = m._index;
      const ptr = m._ptr;
      for (let i = columns - 1; i >= 0; i--) {
        let L = B.length;
        for (let k = 0; k < L; k++) {
          const b = B[k];
          const iValues = [];
          const iIndices = [];
          const firstIndex = ptr[i];
          const lastIndex = ptr[i + 1];
          let Mii = 0;
          for (let j = lastIndex - 1; j >= firstIndex; j--) {
            const J = index[j];
            if (J === i) {
              Mii = values[j];
            } else if (J < i) {
              iValues.push(values[j]);
              iIndices.push(J);
            }
          }
          if (!equalScalar(Mii, 0)) {
            b[i] = divideScalar(b[i], Mii);
            for (let j = 0, lastIdx = iIndices.length; j < lastIdx; j++) {
              const J = iIndices[j];
              b[J] = subtractScalar(b[J], multiplyScalar(b[i], iValues[j]));
            }
          } else if (!equalScalar(b[i], 0)) {
            if (k === 0) {
              return [];
            } else {
              B.splice(k, 1);
              k -= 1;
              L -= 1;
            }
          } else if (k === 0) {
            const bNew = [...b];
            bNew[i] = 1;
            for (let j = 0, lastIdx = iIndices.length; j < lastIdx; j++) {
              const J = iIndices[j];
              bNew[J] = subtractScalar(bNew[J], iValues[j]);
            }
            B.push(bNew);
          }
        }
      }
      return B.map(
        (x) => new DenseMatrix({
          data: x.map((e2) => [e2]),
          size: [rows, 1]
        })
      );
    }
  }
);

// src/type/matrix/utils/matAlgo08xS0Sid.ts
var name143 = "matAlgo08xS0Sid";
var dependencies144 = ["typed", "equalScalar"];
var createMatAlgo08xS0Sid = /* @__PURE__ */ factory(
  name143,
  dependencies144,
  ({
    typed: typed2,
    equalScalar
  }) => {
    return function matAlgo08xS0Sid(a, b, callback) {
      const avalues = a._values;
      const aindex = a._index;
      const aptr = a._ptr;
      const asize = a._size;
      const adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
      const bvalues = b._values;
      const bindex = b._index;
      const bptr = b._ptr;
      const bsize = b._size;
      const bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError(
          "Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")"
        );
      }
      if (!avalues || !bvalues) {
        throw new Error("Cannot perform operation on Pattern Sparse Matrices");
      }
      const rows = asize[0];
      const columns = asize[1];
      let dt;
      let eq = equalScalar;
      let zero = 0;
      let cf = callback;
      if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
        dt = adt;
        eq = typed2.find(equalScalar, [dt, dt]);
        zero = typed2.convert(0, dt);
        cf = typed2.find(callback, [dt, dt]);
      }
      const cvalues = [];
      const cindex = [];
      const cptr = [];
      const x = [];
      const w = [];
      let k, k0, k1, i;
      for (let j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        const mark = j + 1;
        for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          i = aindex[k];
          w[i] = mark;
          x[i] = avalues[k];
          cindex.push(i);
        }
        for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          i = bindex[k];
          if (w[i] === mark) {
            x[i] = cf(x[i], bvalues[k]);
          }
        }
        k = cptr[j];
        while (k < cindex.length) {
          i = cindex[k];
          const v = x[i];
          if (!eq(v, zero)) {
            cvalues.push(v);
            k++;
          } else {
            cindex.splice(k, 1);
          }
        }
      }
      cptr[columns] = cindex.length;
      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
      });
    };
  }
);

// src/function/bitwise/useMatrixForArrayScalar.ts
var createUseMatrixForArrayScalar = /* @__PURE__ */ factory(
  "useMatrixForArrayScalar",
  ["typed", "matrix"],
  ({ typed: typed2, matrix }) => ({
    "Array, number": typed2.referTo(
      "DenseMatrix, number",
      (selfDn) => (x, y) => selfDn(matrix(x), y).valueOf()
    ),
    "Array, BigNumber": typed2.referTo(
      "DenseMatrix, BigNumber",
      (selfDB) => (x, y) => selfDB(matrix(x), y).valueOf()
    ),
    "number, Array": typed2.referTo(
      "number, DenseMatrix",
      (selfnD) => (x, y) => selfnD(x, matrix(y)).valueOf()
    ),
    "BigNumber, Array": typed2.referTo(
      "BigNumber, DenseMatrix",
      (selfBD) => (x, y) => selfBD(x, matrix(y)).valueOf()
    )
  })
);

// src/function/bitwise/leftShift.ts
var name144 = "leftShift";
var dependencies145 = [
  "typed",
  "matrix",
  "equalScalar",
  "zeros",
  "DenseMatrix",
  "concat"
];
var createLeftShift = /* @__PURE__ */ factory(
  name144,
  dependencies145,
  ({ typed: typed2, matrix, equalScalar, zeros: zeros2, DenseMatrix, concat: concat2 }) => {
    const matAlgo01xDSid = createMatAlgo01xDSid({ typed: typed2 });
    const matAlgo02xDS0 = createMatAlgo02xDS0({ typed: typed2, equalScalar });
    const matAlgo08xS0Sid = createMatAlgo08xS0Sid({ typed: typed2, equalScalar });
    const matAlgo10xSids = createMatAlgo10xSids({ typed: typed2, DenseMatrix });
    const matAlgo11xS0s = createMatAlgo11xS0s({ typed: typed2, equalScalar });
    const matAlgo14xDs = createMatAlgo14xDs({ typed: typed2 });
    const matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed2,
      matrix,
      concat: concat2
    });
    const useMatrixForArrayScalar = createUseMatrixForArrayScalar({
      typed: typed2,
      matrix
    });
    return typed2(
      name144,
      {
        "number, number": leftShiftNumber,
        "BigNumber, BigNumber": leftShiftBigNumber,
        "bigint, bigint": (x, y) => x << y,
        "SparseMatrix, number | BigNumber": typed2.referToSelf(
          (self) => (x, y) => {
            if (equalScalar(y, 0)) {
              return x.clone();
            }
            return matAlgo11xS0s(x, y, self, false);
          }
        ),
        "DenseMatrix, number | BigNumber": typed2.referToSelf(
          (self) => (x, y) => {
            if (equalScalar(y, 0)) {
              return x.clone();
            }
            return matAlgo14xDs(x, y, self, false);
          }
        ),
        "number | BigNumber, SparseMatrix": typed2.referToSelf(
          (self) => (x, y) => {
            if (equalScalar(x, 0)) {
              return zeros2(y.size(), y.storage());
            }
            return matAlgo10xSids(y, x, self, true);
          }
        ),
        "number | BigNumber, DenseMatrix": typed2.referToSelf(
          (self) => (x, y) => {
            if (equalScalar(x, 0)) {
              return zeros2(y.size(), y.storage());
            }
            return matAlgo14xDs(y, x, self, true);
          }
        )
      },
      useMatrixForArrayScalar,
      matrixAlgorithmSuite({
        SS: matAlgo08xS0Sid,
        DS: matAlgo01xDSid,
        SD: matAlgo02xDS0
      })
    );
  }
);

// src/function/bitwise/rightArithShift.ts
var name145 = "rightArithShift";
var dependencies146 = [
  "typed",
  "matrix",
  "equalScalar",
  "zeros",
  "DenseMatrix",
  "concat"
];
var createRightArithShift = /* @__PURE__ */ factory(
  name145,
  dependencies146,
  ({ typed: typed2, matrix, equalScalar, zeros: zeros2, DenseMatrix, concat: concat2 }) => {
    const matAlgo01xDSid = createMatAlgo01xDSid({ typed: typed2 });
    const matAlgo02xDS0 = createMatAlgo02xDS0({ typed: typed2, equalScalar });
    const matAlgo08xS0Sid = createMatAlgo08xS0Sid({ typed: typed2, equalScalar });
    const matAlgo10xSids = createMatAlgo10xSids({ typed: typed2, DenseMatrix });
    const matAlgo11xS0s = createMatAlgo11xS0s({ typed: typed2, equalScalar });
    const matAlgo14xDs = createMatAlgo14xDs({ typed: typed2 });
    const matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed2,
      matrix,
      concat: concat2
    });
    const useMatrixForArrayScalar = createUseMatrixForArrayScalar({
      typed: typed2,
      matrix
    });
    return typed2(
      name145,
      {
        "number, number": rightArithShiftNumber,
        "BigNumber, BigNumber": rightArithShiftBigNumber,
        "bigint, bigint": (x, y) => x >> y,
        "SparseMatrix, number | BigNumber": typed2.referToSelf(
          (self) => (x, y) => {
            if (equalScalar(y, 0)) {
              return x.clone();
            }
            return matAlgo11xS0s(x, y, self, false);
          }
        ),
        "DenseMatrix, number | BigNumber": typed2.referToSelf(
          (self) => (x, y) => {
            if (equalScalar(y, 0)) {
              return x.clone();
            }
            return matAlgo14xDs(x, y, self, false);
          }
        ),
        "number | BigNumber, SparseMatrix": typed2.referToSelf(
          (self) => (x, y) => {
            if (equalScalar(x, 0)) {
              return zeros2(y.size(), y.storage());
            }
            return matAlgo10xSids(y, x, self, true);
          }
        ),
        "number | BigNumber, DenseMatrix": typed2.referToSelf(
          (self) => (x, y) => {
            if (equalScalar(x, 0)) {
              return zeros2(y.size(), y.storage());
            }
            return matAlgo14xDs(y, x, self, true);
          }
        )
      },
      useMatrixForArrayScalar,
      matrixAlgorithmSuite({
        SS: matAlgo08xS0Sid,
        DS: matAlgo01xDSid,
        SD: matAlgo02xDS0
      })
    );
  }
);

// src/function/bitwise/rightLogShift.ts
var name146 = "rightLogShift";
var dependencies147 = [
  "typed",
  "matrix",
  "equalScalar",
  "zeros",
  "DenseMatrix",
  "concat"
];
var createRightLogShift = /* @__PURE__ */ factory(
  name146,
  dependencies147,
  ({ typed: typed2, matrix, equalScalar, zeros: zeros2, DenseMatrix, concat: concat2 }) => {
    const matAlgo01xDSid = createMatAlgo01xDSid({ typed: typed2 });
    const matAlgo02xDS0 = createMatAlgo02xDS0({ typed: typed2, equalScalar });
    const matAlgo08xS0Sid = createMatAlgo08xS0Sid({ typed: typed2, equalScalar });
    const matAlgo10xSids = createMatAlgo10xSids({ typed: typed2, DenseMatrix });
    const matAlgo11xS0s = createMatAlgo11xS0s({ typed: typed2, equalScalar });
    const matAlgo14xDs = createMatAlgo14xDs({ typed: typed2 });
    const matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed2,
      matrix,
      concat: concat2
    });
    const useMatrixForArrayScalar = createUseMatrixForArrayScalar({
      typed: typed2,
      matrix
    });
    return typed2(
      name146,
      {
        "number, number": rightLogShiftNumber,
        // 'BigNumber, BigNumber': ..., // TODO: implement BigNumber support for rightLogShift
        "SparseMatrix, number | BigNumber": typed2.referToSelf(
          (self) => (x, y) => {
            if (equalScalar(y, 0)) {
              return x.clone();
            }
            return matAlgo11xS0s(x, y, self, false);
          }
        ),
        "DenseMatrix, number | BigNumber": typed2.referToSelf(
          (self) => (x, y) => {
            if (equalScalar(y, 0)) {
              return x.clone();
            }
            return matAlgo14xDs(x, y, self, false);
          }
        ),
        "number | BigNumber, SparseMatrix": typed2.referToSelf(
          (self) => (x, y) => {
            if (equalScalar(x, 0)) {
              return zeros2(y.size(), y.storage());
            }
            return matAlgo10xSids(y, x, self, true);
          }
        ),
        "number | BigNumber, DenseMatrix": typed2.referToSelf(
          (self) => (x, y) => {
            if (equalScalar(x, 0)) {
              return zeros2(y.size(), y.storage());
            }
            return matAlgo14xDs(y, x, self, true);
          }
        )
      },
      useMatrixForArrayScalar,
      matrixAlgorithmSuite({
        SS: matAlgo08xS0Sid,
        DS: matAlgo01xDSid,
        SD: matAlgo02xDS0
      })
    );
  }
);

// src/function/logical/and.ts
var name147 = "and";
var dependencies148 = [
  "typed",
  "matrix",
  "equalScalar",
  "zeros",
  "not",
  "concat"
];
var createAnd = /* @__PURE__ */ factory(
  name147,
  dependencies148,
  ({ typed: typed2, matrix, equalScalar, zeros: zeros2, not, concat: concat2 }) => {
    const matAlgo02xDS0 = createMatAlgo02xDS0({ typed: typed2, equalScalar });
    const matAlgo06xS0S0 = createMatAlgo06xS0S0({ typed: typed2, equalScalar });
    const matAlgo11xS0s = createMatAlgo11xS0s({ typed: typed2, equalScalar });
    const matAlgo14xDs = createMatAlgo14xDs({ typed: typed2 });
    const matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed2,
      matrix,
      concat: concat2
    });
    return typed2(
      name147,
      {
        "number, number": andNumber,
        "Complex, Complex": function(x, y) {
          return (x.re !== 0 || x.im !== 0) && (y.re !== 0 || y.im !== 0);
        },
        "BigNumber, BigNumber": function(x, y) {
          return !x.isZero() && !y.isZero() && !x.isNaN() && !y.isNaN();
        },
        "bigint, bigint": andNumber,
        "Unit, Unit": typed2.referToSelf(
          (self) => (x, y) => self(x.value || 0, y.value || 0)
        ),
        "SparseMatrix, any": typed2.referToSelf(
          (self) => (x, y) => {
            if (not(y)) {
              return zeros2(x.size(), x.storage());
            }
            return matAlgo11xS0s(x, y, self, false);
          }
        ),
        "DenseMatrix, any": typed2.referToSelf(
          (self) => (x, y) => {
            if (not(y)) {
              return zeros2(x.size(), x.storage());
            }
            return matAlgo14xDs(x, y, self, false);
          }
        ),
        "any, SparseMatrix": typed2.referToSelf(
          (self) => (x, y) => {
            if (not(x)) {
              return zeros2(y.size(), y.storage());
            }
            return matAlgo11xS0s(y, x, self, true);
          }
        ),
        "any, DenseMatrix": typed2.referToSelf(
          (self) => (x, y) => {
            if (not(x)) {
              return zeros2(y.size(), y.storage());
            }
            return matAlgo14xDs(y, x, self, true);
          }
        ),
        "Array, any": typed2.referToSelf(
          (self) => (x, y) => {
            return self(matrix(x), y).valueOf();
          }
        ),
        "any, Array": typed2.referToSelf(
          (self) => (x, y) => {
            return self(x, matrix(y)).valueOf();
          }
        )
      },
      matrixAlgorithmSuite({
        SS: matAlgo06xS0S0,
        DS: matAlgo02xDS0
      })
    );
  }
);

// src/function/relational/compare.ts
var name148 = "compare";
var dependencies149 = [
  "typed",
  "config",
  "matrix",
  "equalScalar",
  "BigNumber",
  "Fraction",
  "DenseMatrix",
  "concat"
];
var createCompare = /* @__PURE__ */ factory(
  name148,
  dependencies149,
  ({
    typed: typed2,
    config,
    equalScalar,
    matrix,
    BigNumber,
    Fraction: Fraction2,
    DenseMatrix,
    concat: concat2
  }) => {
    const matAlgo03xDSf = createMatAlgo03xDSf({ typed: typed2 });
    const matAlgo05xSfSf = createMatAlgo05xSfSf({ typed: typed2, equalScalar });
    const matAlgo12xSfs = createMatAlgo12xSfs({ typed: typed2, DenseMatrix });
    const matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed2,
      matrix,
      concat: concat2
    });
    const compareUnits = createCompareUnits({ typed: typed2 });
    return typed2(
      name148,
      createCompareNumber({ typed: typed2, config }),
      {
        "boolean, boolean": function(x, y) {
          return x === y ? 0 : x > y ? 1 : -1;
        },
        "BigNumber, BigNumber": function(x, y) {
          return nearlyEqual2(x, y, config.relTol, config.absTol) ? new BigNumber(0) : new BigNumber(x.cmp(y));
        },
        "bigint, bigint": function(x, y) {
          return x === y ? 0n : x > y ? 1n : -1n;
        },
        "Fraction, Fraction": function(x, y) {
          return new Fraction2(x.compare(y));
        },
        "Complex, Complex": function() {
          throw new TypeError(
            "No ordering relation is defined for complex numbers"
          );
        }
      },
      compareUnits,
      matrixAlgorithmSuite({
        SS: matAlgo05xSfSf,
        DS: matAlgo03xDSf,
        Ss: matAlgo12xSfs
      })
    );
  }
);
var createCompareNumber = /* @__PURE__ */ factory(
  name148,
  ["typed", "config"],
  ({ typed: typed2, config }) => {
    return typed2(name148, {
      "number, number": function(x, y) {
        return nearlyEqual(x, y, config.relTol, config.absTol) ? 0 : x > y ? 1 : -1;
      }
    });
  }
);
var name149 = "compareNatural";
var dependencies150 = ["typed", "compare"];
var createCompareNatural = /* @__PURE__ */ factory(
  name149,
  dependencies150,
  ({ typed: typed2, compare }) => {
    const compareBooleans = compare.signatures["boolean,boolean"];
    return typed2(name149, { "any, any": _compareNatural });
    function _compareNatural(x, y) {
      const typeX = typeOf(x);
      const typeY = typeOf(y);
      let c;
      if ((typeX === "number" || typeX === "BigNumber" || typeX === "Fraction") && (typeY === "number" || typeY === "BigNumber" || typeY === "Fraction")) {
        c = compare(x, y);
        if (c.toString() !== "0") {
          return c > 0 ? 1 : -1;
        } else {
          return naturalSort__default.default(typeX, typeY);
        }
      }
      const matTypes = ["Array", "DenseMatrix", "SparseMatrix"];
      if (matTypes.includes(typeX) || matTypes.includes(typeY)) {
        c = compareMatricesAndArrays(_compareNatural, x, y);
        if (c !== 0) {
          return c;
        } else {
          return naturalSort__default.default(typeX, typeY);
        }
      }
      if (typeX !== typeY) {
        return naturalSort__default.default(typeX, typeY);
      }
      if (typeX === "Complex") {
        return compareComplexNumbers(x, y);
      }
      if (typeX === "Unit") {
        const unitX = x;
        const unitY = y;
        if (unitX.equalBase(unitY)) {
          return _compareNatural(unitX.value, unitY.value);
        }
        return compareArrays(_compareNatural, unitX.formatUnits(), unitY.formatUnits());
      }
      if (typeX === "boolean") {
        return compareBooleans(x, y);
      }
      if (typeX === "string") {
        return naturalSort__default.default(x, y);
      }
      if (typeX === "Object") {
        return compareObjects(_compareNatural, x, y);
      }
      if (typeX === "null") {
        return 0;
      }
      if (typeX === "undefined") {
        return 0;
      }
      throw new TypeError('Unsupported type of value "' + typeX + '"');
    }
    function compareMatricesAndArrays(compareNatural, x, y) {
      if (isSparseMatrix(x) && isSparseMatrix(y)) {
        return compareArrays(
          compareNatural,
          x.toJSON().values,
          y.toJSON().values
        );
      }
      if (isSparseMatrix(x)) {
        return compareMatricesAndArrays(compareNatural, x.toArray(), y);
      }
      if (isSparseMatrix(y)) {
        return compareMatricesAndArrays(compareNatural, x, y.toArray());
      }
      if (isDenseMatrix(x)) {
        return compareMatricesAndArrays(
          compareNatural,
          x.toJSON().data,
          y
        );
      }
      if (isDenseMatrix(y)) {
        return compareMatricesAndArrays(
          compareNatural,
          x,
          y.toJSON().data
        );
      }
      if (!Array.isArray(x)) {
        return compareMatricesAndArrays(compareNatural, [x], y);
      }
      if (!Array.isArray(y)) {
        return compareMatricesAndArrays(compareNatural, x, [y]);
      }
      return compareArrays(compareNatural, x, y);
    }
    function compareArrays(compareNatural, x, y) {
      for (let i = 0, ii = Math.min(x.length, y.length); i < ii; i++) {
        const v = compareNatural(x[i], y[i]);
        if (v !== 0) {
          return v;
        }
      }
      if (x.length > y.length) {
        return 1;
      }
      if (x.length < y.length) {
        return -1;
      }
      return 0;
    }
    function compareObjects(compareNatural, x, y) {
      const keysX = Object.keys(x);
      const keysY = Object.keys(y);
      keysX.sort(naturalSort__default.default);
      keysY.sort(naturalSort__default.default);
      const c = compareArrays(compareNatural, keysX, keysY);
      if (c !== 0) {
        return c;
      }
      for (let i = 0; i < keysX.length; i++) {
        const v = compareNatural(x[keysX[i]], y[keysY[i]]);
        if (v !== 0) {
          return v;
        }
      }
      return 0;
    }
  }
);
function compareComplexNumbers(x, y) {
  if (x.re > y.re) {
    return 1;
  }
  if (x.re < y.re) {
    return -1;
  }
  if (x.im > y.im) {
    return 1;
  }
  if (x.im < y.im) {
    return -1;
  }
  return 0;
}

// src/function/relational/compareText.ts
var name150 = "compareText";
var dependencies151 = ["typed", "matrix", "concat"];
compareText.signature = "any, any";
var createCompareText = /* @__PURE__ */ factory(
  name150,
  dependencies151,
  ({ typed: typed2, matrix, concat: concat2 }) => {
    const matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed2,
      matrix,
      concat: concat2
    });
    return typed2(
      name150,
      compareText,
      matrixAlgorithmSuite({
        elop: compareText,
        Ds: compareText
      })
    );
  }
);

// src/function/relational/equal.ts
var name151 = "equal";
var dependencies152 = [
  "typed",
  "matrix",
  "equalScalar",
  "DenseMatrix",
  "SparseMatrix"
];
var createEqual = /* @__PURE__ */ factory(
  name151,
  dependencies152,
  ({
    typed: typed2,
    matrix,
    equalScalar,
    DenseMatrix,
    concat: _concat,
    SparseMatrix
  }) => {
    const matAlgo03xDSf = createMatAlgo03xDSf({ typed: typed2 });
    const matAlgo07xSSf = createMatAlgo07xSSf({ typed: typed2, SparseMatrix });
    const matAlgo12xSfs = createMatAlgo12xSfs({ typed: typed2, DenseMatrix });
    const matrixAlgorithmSuite = createMatrixAlgorithmSuite({ typed: typed2, matrix });
    return typed2(
      name151,
      createEqualNumber({ typed: typed2, equalScalar }),
      matrixAlgorithmSuite({
        elop: equalScalar,
        SS: matAlgo07xSSf,
        DS: matAlgo03xDSf,
        Ss: matAlgo12xSfs
      })
    );
  }
);
var createEqualNumber = factory(
  name151,
  ["typed", "equalScalar"],
  ({ typed: typed2, equalScalar }) => {
    return typed2(name151, {
      "any, any": function(x, y) {
        if (x === null) {
          return y === null;
        }
        if (y === null) {
          return x === null;
        }
        if (x === void 0) {
          return y === void 0;
        }
        if (y === void 0) {
          return x === void 0;
        }
        return equalScalar(x, y);
      }
    });
  }
);

// src/function/relational/equalText.ts
var name152 = "equalText";
var dependencies153 = ["typed", "compareText", "isZero"];
var createEqualText = /* @__PURE__ */ factory(
  name152,
  dependencies153,
  ({ typed: typed2, compareText: compareText2, isZero }) => {
    return typed2(name152, {
      "any, any": function(x, y) {
        return isZero(compareText2(x, y));
      }
    });
  }
);

// src/function/relational/smaller.ts
var name153 = "smaller";
var dependencies154 = [
  "typed",
  "config",
  "bignumber",
  "matrix",
  "DenseMatrix",
  "concat",
  "SparseMatrix"
];
var createSmaller = /* @__PURE__ */ factory(
  name153,
  dependencies154,
  ({
    typed: typed2,
    config,
    bignumber,
    matrix,
    DenseMatrix,
    concat: concat2,
    SparseMatrix
  }) => {
    const matAlgo03xDSf = createMatAlgo03xDSf({ typed: typed2 });
    const matAlgo07xSSf = createMatAlgo07xSSf({ typed: typed2, SparseMatrix });
    const matAlgo12xSfs = createMatAlgo12xSfs({ typed: typed2, DenseMatrix });
    const matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed2,
      matrix,
      concat: concat2
    });
    const compareUnits = createCompareUnits({ typed: typed2 });
    function bignumSmaller(x, y) {
      return x.lt(y) && !nearlyEqual2(x, y, config.relTol, config.absTol);
    }
    return typed2(
      name153,
      createSmallerNumber({ typed: typed2, config }),
      {
        "boolean, boolean": (x, y) => x < y,
        "BigNumber, BigNumber": bignumSmaller,
        "bigint, bigint": (x, y) => x < y,
        "Fraction, Fraction": (x, y) => x.compare(y) === -1,
        "Fraction, BigNumber": function(x, y) {
          return bignumSmaller(bignumber(x), y);
        },
        "BigNumber, Fraction": function(x, y) {
          return bignumSmaller(x, bignumber(y));
        },
        "Complex, Complex": function(_x, _y) {
          throw new TypeError(
            "No ordering relation is defined for complex numbers"
          );
        }
      },
      compareUnits,
      matrixAlgorithmSuite({
        SS: matAlgo07xSSf,
        DS: matAlgo03xDSf,
        Ss: matAlgo12xSfs
      })
    );
  }
);
var createSmallerNumber = /* @__PURE__ */ factory(
  name153,
  ["typed", "config"],
  ({ typed: typed2, config }) => {
    return typed2(name153, {
      "number, number": function(x, y) {
        return x < y && !nearlyEqual(x, y, config.relTol, config.absTol);
      }
    });
  }
);

// src/function/relational/smallerEq.ts
var name154 = "smallerEq";
var dependencies155 = [
  "typed",
  "config",
  "matrix",
  "DenseMatrix",
  "concat",
  "SparseMatrix"
];
var createSmallerEq = /* @__PURE__ */ factory(
  name154,
  dependencies155,
  ({
    typed: typed2,
    config,
    matrix,
    DenseMatrix,
    concat: concat2,
    SparseMatrix
  }) => {
    const matAlgo03xDSf = createMatAlgo03xDSf({ typed: typed2 });
    const matAlgo07xSSf = createMatAlgo07xSSf({ typed: typed2, SparseMatrix });
    const matAlgo12xSfs = createMatAlgo12xSfs({ typed: typed2, DenseMatrix });
    const matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed2,
      matrix,
      concat: concat2
    });
    const compareUnits = createCompareUnits({ typed: typed2 });
    return typed2(
      name154,
      createSmallerEqNumber({ typed: typed2, config }),
      {
        "boolean, boolean": (x, y) => x <= y,
        "BigNumber, BigNumber": function(x, y) {
          return x.lte(y) || nearlyEqual2(x, y, config.relTol, config.absTol);
        },
        "bigint, bigint": (x, y) => x <= y,
        "Fraction, Fraction": (x, y) => x.compare(y) !== 1,
        "Complex, Complex": function() {
          throw new TypeError(
            "No ordering relation is defined for complex numbers"
          );
        }
      },
      compareUnits,
      matrixAlgorithmSuite({
        SS: matAlgo07xSSf,
        DS: matAlgo03xDSf,
        Ss: matAlgo12xSfs
      })
    );
  }
);
var createSmallerEqNumber = /* @__PURE__ */ factory(
  name154,
  ["typed", "config"],
  ({ typed: typed2, config }) => {
    return typed2(name154, {
      "number, number": function(x, y) {
        return x <= y || nearlyEqual(x, y, config.relTol, config.absTol);
      }
    });
  }
);

// src/function/relational/larger.ts
var name155 = "larger";
var dependencies156 = [
  "typed",
  "config",
  "bignumber",
  "matrix",
  "DenseMatrix",
  "concat",
  "SparseMatrix"
];
var createLarger = /* @__PURE__ */ factory(
  name155,
  dependencies156,
  ({
    typed: typed2,
    config,
    bignumber,
    matrix,
    DenseMatrix,
    concat: concat2,
    SparseMatrix
  }) => {
    const matAlgo03xDSf = createMatAlgo03xDSf({ typed: typed2 });
    const matAlgo07xSSf = createMatAlgo07xSSf({ typed: typed2, SparseMatrix });
    const matAlgo12xSfs = createMatAlgo12xSfs({ typed: typed2, DenseMatrix });
    const matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed2,
      matrix,
      concat: concat2
    });
    const compareUnits = createCompareUnits({ typed: typed2 });
    function bignumLarger(x, y) {
      return x.gt(y) && !nearlyEqual2(x, y, config.relTol, config.absTol);
    }
    return typed2(
      name155,
      createLargerNumber({ typed: typed2, config }),
      {
        "boolean, boolean": (x, y) => x > y,
        "BigNumber, BigNumber": bignumLarger,
        "bigint, bigint": (x, y) => x > y,
        "Fraction, Fraction": (x, y) => x.compare(y) === 1,
        "Fraction, BigNumber": function(x, y) {
          return bignumLarger(bignumber(x), y);
        },
        "BigNumber, Fraction": function(x, y) {
          return bignumLarger(x, bignumber(y));
        },
        "Complex, Complex": function() {
          throw new TypeError(
            "No ordering relation is defined for complex numbers"
          );
        }
      },
      compareUnits,
      matrixAlgorithmSuite({
        SS: matAlgo07xSSf,
        DS: matAlgo03xDSf,
        Ss: matAlgo12xSfs
      })
    );
  }
);
var createLargerNumber = /* @__PURE__ */ factory(
  name155,
  ["typed", "config"],
  ({ typed: typed2, config }) => {
    return typed2(name155, {
      "number, number": function(x, y) {
        return x > y && !nearlyEqual(x, y, config.relTol, config.absTol);
      }
    });
  }
);

// src/function/relational/largerEq.ts
var name156 = "largerEq";
var dependencies157 = [
  "typed",
  "config",
  "matrix",
  "DenseMatrix",
  "concat",
  "SparseMatrix"
];
var createLargerEq = /* @__PURE__ */ factory(
  name156,
  dependencies157,
  ({
    typed: typed2,
    config,
    matrix,
    DenseMatrix,
    concat: concat2,
    SparseMatrix
  }) => {
    const matAlgo03xDSf = createMatAlgo03xDSf({ typed: typed2 });
    const matAlgo07xSSf = createMatAlgo07xSSf({ typed: typed2, SparseMatrix });
    const matAlgo12xSfs = createMatAlgo12xSfs({ typed: typed2, DenseMatrix });
    const matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed2,
      matrix,
      concat: concat2
    });
    const compareUnits = createCompareUnits({ typed: typed2 });
    return typed2(
      name156,
      createLargerEqNumber({ typed: typed2, config }),
      {
        "boolean, boolean": (x, y) => x >= y,
        "BigNumber, BigNumber": function(x, y) {
          return x.gte(y) || nearlyEqual2(x, y, config.relTol, config.absTol);
        },
        "bigint, bigint": function(x, y) {
          return x >= y;
        },
        "Fraction, Fraction": (x, y) => x.compare(y) !== -1,
        "Complex, Complex": function() {
          throw new TypeError(
            "No ordering relation is defined for complex numbers"
          );
        }
      },
      compareUnits,
      matrixAlgorithmSuite({
        SS: matAlgo07xSSf,
        DS: matAlgo03xDSf,
        Ss: matAlgo12xSfs
      })
    );
  }
);
var createLargerEqNumber = /* @__PURE__ */ factory(
  name156,
  ["typed", "config"],
  ({ typed: typed2, config }) => {
    return typed2(name156, {
      "number, number": function(x, y) {
        return x >= y || nearlyEqual(x, y, config.relTol, config.absTol);
      }
    });
  }
);

// src/function/relational/deepEqual.ts
var name157 = "deepEqual";
var dependencies158 = ["typed", "equal"];
var createDeepEqual = /* @__PURE__ */ factory(
  name157,
  dependencies158,
  ({ typed: typed2, equal }) => {
    return typed2(name157, {
      "any, any": function(x, y) {
        return _deepEqual(x.valueOf(), y.valueOf());
      }
    });
    function _deepEqual(x, y) {
      if (Array.isArray(x)) {
        if (Array.isArray(y)) {
          const len = x.length;
          if (len !== y.length) {
            return false;
          }
          for (let i = 0; i < len; i++) {
            if (!_deepEqual(x[i], y[i])) {
              return false;
            }
          }
          return true;
        } else {
          return false;
        }
      } else {
        if (Array.isArray(y)) {
          return false;
        } else {
          return equal(x, y);
        }
      }
    }
  }
);

// src/function/relational/unequal.ts
var name158 = "unequal";
var dependencies159 = [
  "typed",
  "config",
  "equalScalar",
  "matrix",
  "DenseMatrix",
  "concat",
  "SparseMatrix"
];
var createUnequal = /* @__PURE__ */ factory(
  name158,
  dependencies159,
  ({
    typed: typed2,
    config: _config,
    equalScalar,
    matrix,
    DenseMatrix,
    concat: concat2,
    SparseMatrix
  }) => {
    const matAlgo03xDSf = createMatAlgo03xDSf({ typed: typed2 });
    const matAlgo07xSSf = createMatAlgo07xSSf({ typed: typed2, SparseMatrix });
    const matAlgo12xSfs = createMatAlgo12xSfs({ typed: typed2, DenseMatrix });
    const matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed2,
      matrix,
      concat: concat2
    });
    return typed2(
      name158,
      createUnequalNumber({ typed: typed2, equalScalar }),
      matrixAlgorithmSuite({
        elop: _unequal,
        SS: matAlgo07xSSf,
        DS: matAlgo03xDSf,
        Ss: matAlgo12xSfs
      })
    );
    function _unequal(x, y) {
      return !equalScalar(x, y);
    }
  }
);
var createUnequalNumber = factory(
  name158,
  ["typed", "equalScalar"],
  ({ typed: typed2, equalScalar }) => {
    return typed2(name158, {
      "any, any": function(x, y) {
        if (x === null) {
          return y !== null;
        }
        if (y === null) {
          return x !== null;
        }
        if (x === void 0) {
          return y !== void 0;
        }
        if (y === void 0) {
          return x !== void 0;
        }
        return !equalScalar(x, y);
      }
    });
  }
);

// src/function/matrix/partitionSelect.ts
var WASM_PARTITION_SELECT_THRESHOLD = 100;
function isFlatNumberArray2(arr) {
  for (let i = 0; i < arr.length; i++) {
    if (typeof arr[i] !== "number") {
      return false;
    }
  }
  return true;
}
var name159 = "partitionSelect";
var dependencies160 = ["typed", "isNumeric", "isNaN", "compare"];
var createPartitionSelect = /* @__PURE__ */ factory(
  name159,
  dependencies160,
  ({ typed: typed2, isNumeric, isNaN: mathIsNaN, compare }) => {
    const asc = compare;
    const desc = (a, b) => -compare(a, b);
    return typed2(name159, {
      "Array | Matrix, number": function(x, k) {
        return _partitionSelect(x, k, asc);
      },
      "Array | Matrix, number, string": function(x, k, compare2) {
        if (compare2 === "asc") {
          return _partitionSelect(x, k, asc);
        } else if (compare2 === "desc") {
          return _partitionSelect(x, k, desc);
        } else {
          throw new Error('Compare string must be "asc" or "desc"');
        }
      },
      "Array | Matrix, number, function": _partitionSelect
    });
    function _partitionSelect(x, k, compare2) {
      if (!isInteger(k) || k < 0) {
        throw new Error("k must be a non-negative integer");
      }
      if (isMatrix(x)) {
        const size = x.size();
        if (size.length > 1) {
          throw new Error("Only one dimensional matrices supported");
        }
        return quickSelect(x.valueOf(), k, compare2);
      }
      if (Array.isArray(x)) {
        return quickSelect(x, k, compare2);
      }
    }
    function quickSelect(arr, k, compare2) {
      if (k >= arr.length) {
        throw new Error("k out of bounds");
      }
      for (let i = 0; i < arr.length; i++) {
        if (isNumeric(arr[i]) && mathIsNaN(arr[i])) {
          return arr[i];
        }
      }
      const wasm = wasmLoader.getModule();
      if (wasm && arr.length >= WASM_PARTITION_SELECT_THRESHOLD && isFlatNumberArray2(arr)) {
        const isAsc = compare2 === asc;
        const isDesc = compare2 === desc;
        if (isAsc || isDesc) {
          try {
            const effectiveK = isDesc ? arr.length - 1 - k : k;
            const data = wasmLoader.allocateFloat64Array(arr);
            const work = wasmLoader.allocateFloat64ArrayEmpty(arr.length);
            try {
              const result = wasm.partitionSelect(
                data.ptr,
                arr.length,
                effectiveK,
                work.ptr
              );
              for (let i = 0; i < arr.length; i++) {
                arr[i] = work.array[i];
              }
              return result;
            } finally {
              wasmLoader.free(data.ptr);
              wasmLoader.free(work.ptr);
            }
          } catch {
          }
        }
      }
      let from = 0;
      let to = arr.length - 1;
      while (from < to) {
        let r = from;
        let w = to;
        const pivot = arr[Math.floor(Math.random() * (to - from + 1)) + from];
        while (r < w) {
          if (compare2(arr[r], pivot) >= 0) {
            const tmp = arr[w];
            arr[w] = arr[r];
            arr[r] = tmp;
            --w;
          } else {
            ++r;
          }
        }
        if (compare2(arr[r], pivot) > 0) {
          --r;
        }
        if (k <= r) {
          to = r;
        } else {
          from = r + 1;
        }
      }
      return arr[k];
    }
  }
);

// src/function/matrix/sort.ts
var name160 = "sort";
var dependencies161 = ["typed", "matrix", "compare", "compareNatural"];
var createSort = /* @__PURE__ */ factory(
  name160,
  dependencies161,
  ({
    typed: typed2,
    matrix,
    compare,
    compareNatural
  }) => {
    const compareAsc = compare;
    const compareDesc = (a, b) => -compare(a, b);
    return typed2(name160, {
      Array: function(x) {
        _arrayIsVector(x);
        return x.sort(compareAsc);
      },
      Matrix: function(x) {
        _matrixIsVector(x);
        return matrix(x.toArray().sort(compareAsc), x.storage());
      },
      "Array, function": function(x, _comparator2) {
        _arrayIsVector(x);
        return x.sort(_comparator2);
      },
      "Matrix, function": function(x, _comparator2) {
        _matrixIsVector(x);
        return matrix(x.toArray().sort(_comparator2), x.storage());
      },
      "Array, string": function(x, order) {
        _arrayIsVector(x);
        return x.sort(_comparator(order));
      },
      "Matrix, string": function(x, order) {
        _matrixIsVector(x);
        return matrix(x.toArray().sort(_comparator(order)), x.storage());
      }
    });
    function _comparator(order) {
      if (order === "asc") {
        return compareAsc;
      } else if (order === "desc") {
        return compareDesc;
      } else if (order === "natural") {
        return compareNatural;
      } else {
        throw new Error('String "asc", "desc", or "natural" expected');
      }
    }
    function _arrayIsVector(array) {
      if (arraySize(array).length !== 1) {
        throw new Error("One dimensional array expected");
      }
    }
    function _matrixIsVector(matrix2) {
      if (matrix2.size().length !== 1) {
        throw new Error("One dimensional matrix expected");
      }
    }
  }
);

// src/function/statistics/max.ts
var WASM_MAX_THRESHOLD = 100;
function isFlatNumberArray3(arr) {
  for (let i = 0; i < arr.length; i++) {
    if (typeof arr[i] !== "number") {
      return false;
    }
  }
  return true;
}
var name161 = "max";
var dependencies162 = ["typed", "config", "numeric", "larger", "isNaN"];
var createMax = /* @__PURE__ */ factory(
  name161,
  dependencies162,
  ({ typed: typed2, config, numeric, larger, isNaN: mathIsNaN }) => {
    return typed2(name161, {
      // max([a, b, c, d, ...])
      "Array | Matrix": _max,
      // max([a, b, c, d, ...], dim)
      "Array | Matrix, number | BigNumber": function(array, dim) {
        const dimValue = typeof dim === "number" ? dim : dim.valueOf();
        return reduce(array, dimValue, _largest);
      },
      // max(a, b, c, d, ...)
      "...": function(args) {
        if (containsCollections(args)) {
          throw new TypeError("Scalar values expected in function max");
        }
        return _max(args);
      }
    });
    function _largest(x, y) {
      try {
        return larger(x, y) ? x : y;
      } catch (err) {
        throw improveErrorMessage(err, "max", y);
      }
    }
    function _max(array) {
      if (Array.isArray(array) && array.length >= WASM_MAX_THRESHOLD) {
        if (isFlatNumberArray3(array)) {
          const wasm = wasmLoader.getModule();
          if (wasm) {
            try {
              const alloc = wasmLoader.allocateFloat64Array(array);
              try {
                return wasm.statsMax(alloc.ptr, array.length);
              } finally {
                wasmLoader.free(alloc.ptr);
              }
            } catch {
            }
          }
        }
      }
      let res;
      deepForEach2(array, function(value) {
        try {
          if (mathIsNaN(value)) {
            res = value;
          } else if (res === void 0 || larger(value, res)) {
            res = value;
          }
        } catch (err) {
          throw improveErrorMessage(err, "max", value);
        }
      });
      if (res === void 0) {
        throw new Error("Cannot calculate max of an empty array");
      }
      if (typeof res === "string") {
        res = numeric(res, safeNumberType(res, config));
      }
      return res;
    }
  }
);

// src/function/statistics/min.ts
var WASM_MIN_THRESHOLD = 100;
function isFlatNumberArray4(arr) {
  for (let i = 0; i < arr.length; i++) {
    if (typeof arr[i] !== "number") {
      return false;
    }
  }
  return true;
}
var name162 = "min";
var dependencies163 = ["typed", "config", "numeric", "smaller", "isNaN"];
var createMin = /* @__PURE__ */ factory(
  name162,
  dependencies163,
  ({ typed: typed2, config, numeric, smaller, isNaN: mathIsNaN }) => {
    return typed2(name162, {
      // min([a, b, c, d, ...])
      "Array | Matrix": _min,
      // min([a, b, c, d, ...], dim)
      "Array | Matrix, number | BigNumber": function(array, dim) {
        const dimValue = typeof dim === "number" ? dim : dim.valueOf();
        return reduce(array, dimValue, _smallest);
      },
      // min(a, b, c, d, ...)
      "...": function(args) {
        if (containsCollections(args)) {
          throw new TypeError("Scalar values expected in function min");
        }
        return _min(args);
      }
    });
    function _smallest(x, y) {
      try {
        return smaller(x, y) ? x : y;
      } catch (err) {
        throw improveErrorMessage(err, "min", y);
      }
    }
    function _min(array) {
      if (Array.isArray(array) && array.length >= WASM_MIN_THRESHOLD) {
        if (isFlatNumberArray4(array)) {
          const wasm = wasmLoader.getModule();
          if (wasm) {
            try {
              const alloc = wasmLoader.allocateFloat64Array(array);
              try {
                return wasm.statsMin(alloc.ptr, array.length);
              } finally {
                wasmLoader.free(alloc.ptr);
              }
            } catch {
            }
          }
        }
      }
      let min;
      deepForEach2(array, function(value) {
        try {
          if (mathIsNaN(value)) {
            min = value;
          } else if (min === void 0 || smaller(value, min)) {
            min = value;
          }
        } catch (err) {
          throw improveErrorMessage(err, "min", value);
        }
      });
      if (min === void 0) {
        throw new Error("Cannot calculate min of an empty array");
      }
      if (typeof min === "string") {
        min = numeric(min, safeNumberType(min, config));
      }
      return min;
    }
  }
);

// src/type/matrix/ImmutableDenseMatrix.ts
var name163 = "ImmutableDenseMatrix";
var dependencies164 = ["smaller", "DenseMatrix"];
var createImmutableDenseMatrixClass = /* @__PURE__ */ factory(
  name163,
  dependencies164,
  ({ smaller, DenseMatrix }) => {
    class ImmutableDenseMatrix extends DenseMatrix {
      constructor(data, datatype) {
        super();
        /**
         * Type identifier
         */
        this.type = "ImmutableDenseMatrix";
        /**
         * ImmutableDenseMatrix type flag
         */
        this.isImmutableDenseMatrix = true;
        if (!(this instanceof ImmutableDenseMatrix)) {
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        }
        if (datatype && !isString(datatype)) {
          throw new Error("Invalid datatype: " + datatype);
        }
        if (isMatrix(data) || isArray(data)) {
          const matrix = new DenseMatrix(data, datatype);
          this._data = matrix._data;
          this._size = matrix._size;
          this._datatype = matrix._datatype;
          this._min = null;
          this._max = null;
        } else if (data && isArray(data.data) && isArray(data.size)) {
          const matrixData = data;
          this._data = matrixData.data;
          this._size = matrixData.size;
          this._datatype = matrixData.datatype;
          this._min = typeof matrixData.min !== "undefined" ? matrixData.min : null;
          this._max = typeof matrixData.max !== "undefined" ? matrixData.max : null;
        } else if (data) {
          throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
        } else {
          this._data = [];
          this._size = [0];
          this._datatype = datatype;
          this._min = null;
          this._max = null;
        }
      }
      /**
       * Get a subset of the matrix, or replace a subset of the matrix.
       *
       * Usage:
       *     const subset = matrix.subset(index)               // retrieve subset
       *     const value = matrix.subset(index, replacement)   // replace subset
       *
       * @param {Index} index
       * @param {Array | ImmutableDenseMatrix | MatrixValue} [replacement]
       * @param {MatrixValue} [defaultValue=0] Default value, filled in on new entries when
       *                             the matrix is resized. If not provided,
       *                             new matrix elements will be filled with zeros.
       */
      subset(index, _replacement, _defaultValue) {
        switch (arguments.length) {
          case 1: {
            const m = DenseMatrix.prototype.subset.call(this, index);
            if (isMatrix(m)) {
              return new ImmutableDenseMatrix({
                data: m._data,
                size: m._size,
                datatype: m._datatype
              });
            }
            return m;
          }
          // intentional fall through
          case 2:
          case 3:
            throw new Error(
              "Cannot invoke set subset on an Immutable Matrix instance"
            );
          default:
            throw new SyntaxError("Wrong number of arguments");
        }
      }
      /**
       * Replace a single element in the matrix.
       * @param {Number[]} index Zero-based index
       * @param {MatrixValue} value
       * @param {MatrixValue} [defaultValue] Default value, filled in on new entries when
       *                           the matrix is resized. If not provided,
       *                           new matrix elements will be left undefined.
       * @return {ImmutableDenseMatrix} self
       */
      set(_index, _value, _defaultValue) {
        throw new Error("Cannot invoke set on an Immutable Matrix instance");
      }
      /**
       * Resize the matrix to the given size. Returns a copy of the matrix when
       * `copy=true`, otherwise return the matrix itself (resize in place).
       *
       * @param {Number[]} size The new size the matrix should have.
       * @param {MatrixValue} [defaultValue=0] Default value, filled in on new entries.
       *                             If not provided, the matrix elements will
       *                             be filled with zeros.
       * @param {boolean} [copy] Return a resized copy of the matrix
       *
       * @return {ImmutableDenseMatrix} The resized matrix
       */
      resize(_size, _defaultValue, _copy) {
        throw new Error("Cannot invoke resize on an Immutable Matrix instance");
      }
      /**
       * Disallows reshaping in favor of immutability.
       *
       * @throws {Error} Operation not allowed
       */
      reshape(_size, _copy) {
        throw new Error("Cannot invoke reshape on an Immutable Matrix instance");
      }
      /**
       * Create a clone of the matrix
       * @return {ImmutableDenseMatrix} clone
       */
      clone() {
        return new ImmutableDenseMatrix({
          data: clone(this._data),
          size: clone(this._size),
          datatype: this._datatype
        });
      }
      /**
       * Get a JSON representation of the matrix
       * @returns {Object}
       */
      toJSON() {
        return {
          mathjs: "ImmutableDenseMatrix",
          data: this._data,
          size: this._size,
          datatype: this._datatype
        };
      }
      /**
       * Generate a matrix from a JSON object
       * @param {Object} json An object structured like
       *                      `{"mathjs": "ImmutableDenseMatrix", data: [], size: []}`,
       *                      where mathjs is optional
       * @returns {ImmutableDenseMatrix}
       */
      static fromJSON(json) {
        return new ImmutableDenseMatrix(json);
      }
      /**
       * Swap rows i and j in Matrix.
       *
       * @param {Number} i Matrix row index 1
       * @param {Number} j Matrix row index 2
       *
       * @return {Matrix} The matrix reference
       */
      swapRows(_i, _j) {
        throw new Error(
          "Cannot invoke swapRows on an Immutable Matrix instance"
        );
      }
      /**
       * Calculate the minimum value in the set
       * @return {MatrixValue | undefined} min
       */
      min() {
        if (this._min === null) {
          let m = null;
          const smallerFn = smaller;
          DenseMatrix.prototype.forEach.call(this, function(v) {
            if (m === null || smallerFn(v, m)) {
              m = v;
            }
          });
          this._min = m !== null ? m : void 0;
        }
        return this._min ?? void 0;
      }
      /**
       * Calculate the maximum value in the set
       * @return {MatrixValue | undefined} max
       */
      max() {
        if (this._max === null) {
          let m = null;
          const smallerFn = smaller;
          DenseMatrix.prototype.forEach.call(this, function(v) {
            if (m === null || smallerFn(m, v)) {
              m = v;
            }
          });
          this._max = m !== null ? m : void 0;
        }
        return this._max ?? void 0;
      }
    }
    Object.setPrototypeOf(ImmutableDenseMatrix.prototype, DenseMatrix.prototype);
    ImmutableDenseMatrix.prototype.constructor = ImmutableDenseMatrix;
    ImmutableDenseMatrix.prototype.type = "ImmutableDenseMatrix";
    ImmutableDenseMatrix.prototype.isImmutableDenseMatrix = true;
    return ImmutableDenseMatrix;
  },
  { isClass: true }
);

// src/type/matrix/MatrixIndex.ts
var name164 = "Index";
var dependencies165 = ["ImmutableDenseMatrix", "getMatrixDataType"];
var createIndexClass = /* @__PURE__ */ factory(
  name164,
  dependencies165,
  ({ ImmutableDenseMatrix, getMatrixDataType }) => {
    function _createImmutableMatrix(arg) {
      for (let i = 0, l = arg.length; i < l; i++) {
        if (!isNumber(arg[i]) || !isInteger(arg[i])) {
          throw new TypeError(
            "Index parameters must be positive integer numbers"
          );
        }
      }
      const matrix = new ImmutableDenseMatrix();
      matrix._data = arg;
      matrix._size = [arg.length];
      return matrix;
    }
    class Index2 {
      constructor(...ranges) {
        /**
         * Type identifier
         */
        this.type = "Index";
        /**
         * Index type flag
         */
        this.isIndex = true;
        if (!(this instanceof Index2)) {
          throw new SyntaxError(
            "Constructor must be called with the new operator"
          );
        }
        this._dimensions = [];
        this._sourceSize = [];
        this._isScalar = true;
        for (let i = 0, ii = ranges.length; i < ii; i++) {
          const arg = ranges[i];
          const argIsArray = isArray(arg);
          const argIsMatrix = isMatrix(arg);
          const argType = typeof arg;
          let sourceSize = null;
          if (isRange(arg)) {
            this._dimensions.push(arg);
            this._isScalar = false;
          } else if (argIsArray || argIsMatrix) {
            let m;
            this._isScalar = false;
            if (getMatrixDataType(arg) === "boolean") {
              if (argIsArray)
                m = _createImmutableMatrix(
                  _booleansArrayToNumbersForIndex(arg)
                );
              if (argIsMatrix)
                m = _createImmutableMatrix(
                  _booleansArrayToNumbersForIndex(arg._data)
                );
              sourceSize = arg.valueOf().length;
            } else {
              m = _createImmutableMatrix(arg.valueOf());
            }
            this._dimensions.push(m);
          } else if (argType === "number") {
            this._dimensions.push(arg);
          } else if (argType === "bigint") {
            this._dimensions.push(Number(arg));
          } else if (argType === "string") {
            this._dimensions.push(arg);
          } else {
            throw new TypeError(
              "Dimension must be an Array, Matrix, number, bigint, string, or Range"
            );
          }
          this._sourceSize.push(sourceSize);
        }
      }
      /**
       * Create a clone of the index
       * @memberof Index
       * @return {Index} clone
       */
      clone() {
        const index = new Index2();
        index._dimensions = clone(this._dimensions);
        index._isScalar = this._isScalar;
        index._sourceSize = this._sourceSize;
        return index;
      }
      /**
       * Create an index from an array with ranges/numbers
       * @memberof Index
       * @param {Array.<Array | number>} ranges
       * @return {Index} index
       * @private
       */
      static create(ranges) {
        return new Index2(...ranges);
      }
      /**
       * Retrieve the size of the index, the number of elements for each dimension.
       * @memberof Index
       * @returns {number[]} size
       */
      size() {
        const size = [];
        for (let i = 0, ii = this._dimensions.length; i < ii; i++) {
          const d = this._dimensions[i];
          size[i] = isString(d) || isNumber(d) ? 1 : d.size()[0];
        }
        return size;
      }
      /**
       * Get the maximum value for each of the indexes ranges.
       * @memberof Index
       * @returns {number[]} max
       */
      max() {
        const values = [];
        for (let i = 0, ii = this._dimensions.length; i < ii; i++) {
          const range = this._dimensions[i];
          values[i] = isString(range) || isNumber(range) ? range : range.max();
        }
        return values;
      }
      /**
       * Get the minimum value for each of the indexes ranges.
       * @memberof Index
       * @returns {number[]} min
       */
      min() {
        const values = [];
        for (let i = 0, ii = this._dimensions.length; i < ii; i++) {
          const range = this._dimensions[i];
          values[i] = isString(range) || isNumber(range) ? range : range.min();
        }
        return values;
      }
      /**
       * Loop over each of the ranges of the index
       * @memberof Index
       * @param {Function} callback Called for each range with a Range as first
       *                            argument, the dimension as second, and the
       *                            index object as third.
       */
      forEach(callback) {
        for (let i = 0, ii = this._dimensions.length; i < ii; i++) {
          callback(this._dimensions[i], i, this);
        }
      }
      /**
       * Retrieve the dimension for the given index
       * @memberof Index
       * @param {Number} dim Number of the dimension
       * @returns {Range | null} range
       */
      dimension(dim) {
        if (!isNumber(dim)) {
          return null;
        }
        return this._dimensions[dim] ?? null;
      }
      /**
       * Test whether this index contains an object property
       * @returns {boolean} Returns true if the index is an object property
       */
      isObjectProperty() {
        return this._dimensions.length === 1 && isString(this._dimensions[0]);
      }
      /**
       * Returns the object property name when the Index holds a single object property,
       * else returns null
       * @returns {string | null}
       */
      getObjectProperty() {
        return this.isObjectProperty() ? this._dimensions[0] : null;
      }
      /**
       * Test whether this index contains only a single value.
       *
       * This is the case when the index is created with only scalar values as ranges,
       * not for ranges resolving into a single value.
       * @memberof Index
       * @return {boolean} isScalar
       */
      isScalar() {
        return this._isScalar;
      }
      /**
       * Expand the Index into an array.
       * For example new Index([0,3], [2,7]) returns [[0,1,2], [2,3,4,5,6]]
       * @memberof Index
       * @returns {Array} array
       */
      toArray() {
        const array = [];
        for (let i = 0, ii = this._dimensions.length; i < ii; i++) {
          const dimension = this._dimensions[i];
          array.push(
            isString(dimension) || isNumber(dimension) ? dimension : dimension.toArray()
          );
        }
        return array;
      }
      /**
       * Get the primitive value of the Index, a two dimensional array.
       * Equivalent to Index.toArray().
       * @memberof Index
       * @returns {Array} array
       */
      valueOf() {
        return this.toArray();
      }
      /**
       * Get the string representation of the index, for example '[2:6]' or '[0:2:10, 4:7, [1,2,3]]'
       * @memberof Index
       * @returns {String} str
       */
      toString() {
        const strings = [];
        for (let i = 0, ii = this._dimensions.length; i < ii; i++) {
          const dimension = this._dimensions[i];
          if (isString(dimension)) {
            strings.push(JSON.stringify(dimension));
          } else {
            strings.push(dimension.toString());
          }
        }
        return "[" + strings.join(", ") + "]";
      }
      /**
       * Get a JSON representation of the Index
       * @memberof Index
       * @returns {Object} Returns a JSON object structured as:
       *                   `{"mathjs": "Index", "ranges": [{"mathjs": "Range", start: 0, end: 10, step:1}, ...]}`
       */
      toJSON() {
        return {
          mathjs: "Index",
          dimensions: this._dimensions
        };
      }
      /**
       * Instantiate an Index from a JSON object
       * @memberof Index
       * @param {Object} json A JSON object structured as:
       *                     `{"mathjs": "Index", "dimensions": [{"mathjs": "Range", start: 0, end: 10, step:1}, ...]}`
       * @return {Index}
       */
      static fromJSON(json) {
        return Index2.create(json.dimensions);
      }
    }
    Index2.prototype.type = "Index";
    Index2.prototype.isIndex = true;
    return Index2;
  },
  { isClass: true }
);
function _booleansArrayToNumbersForIndex(booleanArrayIndex) {
  const indexOfNumbers = [];
  booleanArrayIndex.forEach((bool, idx) => {
    if (bool) {
      indexOfNumbers.push(idx);
    }
  });
  return indexOfNumbers;
}

// src/type/matrix/FibonacciHeap.ts
var name165 = "FibonacciHeap";
var dependencies166 = ["smaller", "larger"];
var createFibonacciHeapClass = /* @__PURE__ */ factory(
  name165,
  dependencies166,
  ({ smaller, larger }) => {
    const oneOverLogPhi = 1 / Math.log((1 + Math.sqrt(5)) / 2);
    class FibonacciHeap {
      constructor() {
        this.type = "FibonacciHeap";
        this.isFibonacciHeap = true;
        this._minimum = null;
        this._size = 0;
      }
      /**
       * Inserts a new data element into the heap. No heap consolidation is
       * performed at this time, the new node is simply inserted into the root
       * list of this heap. Running time: O(1) actual.
       * @memberof FibonacciHeap
       */
      insert(key, value) {
        const node = {
          key,
          value,
          degree: 0
        };
        if (this._minimum) {
          const minimum = this._minimum;
          node.left = minimum;
          node.right = minimum.right;
          minimum.right = node;
          node.right.left = node;
          if (smaller(key, minimum.key)) {
            this._minimum = node;
          }
        } else {
          node.left = node;
          node.right = node;
          this._minimum = node;
        }
        this._size++;
        return node;
      }
      /**
       * Returns the number of nodes in heap. Running time: O(1) actual.
       * @memberof FibonacciHeap
       */
      size() {
        return this._size;
      }
      /**
       * Removes all elements from this heap.
       * @memberof FibonacciHeap
       */
      clear() {
        this._minimum = null;
        this._size = 0;
      }
      /**
       * Returns true if the heap is empty, otherwise false.
       * @memberof FibonacciHeap
       */
      isEmpty() {
        return this._size === 0;
      }
      /**
       * Extracts the node with minimum key from heap. Amortized running
       * time: O(log n).
       * @memberof FibonacciHeap
       */
      extractMinimum() {
        const node = this._minimum;
        if (node === null) {
          return node;
        }
        let minimum = this._minimum;
        let numberOfChildren = node.degree;
        let x = node.child;
        while (numberOfChildren > 0) {
          const tempRight = x.right;
          x.left.right = x.right;
          x.right.left = x.left;
          x.left = minimum;
          x.right = minimum.right;
          minimum.right = x;
          x.right.left = x;
          x.parent = void 0;
          x = tempRight;
          numberOfChildren--;
        }
        node.left.right = node.right;
        node.right.left = node.left;
        if (node === node.right) {
          minimum = null;
        } else {
          minimum = node.right;
          minimum = _findMinimumNode(minimum, this._size);
        }
        this._size--;
        this._minimum = minimum;
        return node;
      }
      /**
       * Removes a node from the heap given the reference to the node. The trees
       * in the heap will be consolidated, if necessary. This operation may fail
       * to remove the correct element if there are nodes with key value -Infinity.
       * Running time: O(log n) amortized.
       * @memberof FibonacciHeap
       */
      remove(node) {
        this._minimum = _decreaseKey(this._minimum, node, -1);
        this.extractMinimum();
      }
    }
    function _decreaseKey(minimum, node, key) {
      node.key = key;
      const parent = node.parent;
      if (parent && smaller(node.key, parent.key)) {
        _cut(minimum, node, parent);
        _cascadingCut(minimum, parent);
      }
      if (smaller(node.key, minimum.key)) {
        minimum = node;
      }
      return minimum;
    }
    function _cut(minimum, node, parent) {
      node.left.right = node.right;
      node.right.left = node.left;
      parent.degree--;
      if (parent.child === node) {
        parent.child = node.right;
      }
      if (parent.degree === 0) {
        parent.child = void 0;
      }
      node.left = minimum;
      node.right = minimum.right;
      minimum.right = node;
      node.right.left = node;
      node.parent = void 0;
      node.mark = false;
    }
    function _cascadingCut(minimum, node) {
      const parent = node.parent;
      if (!parent) {
        return;
      }
      if (!node.mark) {
        node.mark = true;
      } else {
        _cut(minimum, node, parent);
        _cascadingCut(minimum, parent);
      }
    }
    function _linkNodes(node, parent) {
      node.left.right = node.right;
      node.right.left = node.left;
      node.parent = parent;
      if (!parent.child) {
        parent.child = node;
        node.right = node;
        node.left = node;
      } else {
        node.left = parent.child;
        node.right = parent.child.right;
        parent.child.right = node;
        node.right.left = node;
      }
      parent.degree++;
      node.mark = false;
    }
    function _findMinimumNode(minimum, size) {
      const arraySize2 = Math.floor(Math.log(size) * oneOverLogPhi) + 1;
      const array = new Array(arraySize2);
      let numRoots = 0;
      let x = minimum;
      if (x) {
        numRoots++;
        x = x.right;
        while (x !== minimum) {
          numRoots++;
          x = x.right;
        }
      }
      let y;
      while (numRoots > 0) {
        let d = x.degree;
        const next = x.right;
        while (true) {
          y = array[d];
          if (!y) {
            break;
          }
          if (larger(x.key, y.key)) {
            const temp = y;
            y = x;
            x = temp;
          }
          _linkNodes(y, x);
          array[d] = void 0;
          d++;
        }
        array[d] = x;
        x = next;
        numRoots--;
      }
      let newMinimum = null;
      for (let i = 0; i < arraySize2; i++) {
        y = array[i];
        if (!y) {
          continue;
        }
        if (newMinimum) {
          y.left.right = y.right;
          y.right.left = y.left;
          y.left = newMinimum;
          y.right = newMinimum.right;
          newMinimum.right = y;
          y.right.left = y;
          if (smaller(y.key, newMinimum.key)) {
            newMinimum = y;
          }
        } else {
          newMinimum = y;
        }
      }
      return newMinimum;
    }
    return FibonacciHeap;
  },
  { isClass: true }
);

// src/type/matrix/Spa.ts
var name166 = "Spa";
var dependencies167 = ["addScalar", "equalScalar", "FibonacciHeap"];
var createSpaClass = /* @__PURE__ */ factory(
  name166,
  dependencies167,
  ({ addScalar, equalScalar, FibonacciHeap }) => {
    class Spa {
      constructor() {
        this.type = "Spa";
        this.isSpa = true;
        this._values = [];
        this._heap = new FibonacciHeap();
      }
      /**
       * Set the value for index i.
       *
       * @param {number} i                       The index
       * @param {number | BigNumber | Complex}   The value at index i
       */
      set(i, v) {
        if (!this._values[i]) {
          const node = this._heap.insert(i, v);
          this._values[i] = node;
        } else {
          this._values[i].value = v;
        }
      }
      get(i) {
        const node = this._values[i];
        if (node) {
          return node.value;
        }
        return 0;
      }
      accumulate(i, v) {
        let node = this._values[i];
        if (!node) {
          node = this._heap.insert(i, v);
          this._values[i] = node;
        } else {
          node.value = addScalar(node.value, v);
        }
      }
      forEach(from, to, callback) {
        const heap = this._heap;
        const values = this._values;
        const nodes = [];
        let node = heap.extractMinimum();
        if (node) {
          nodes.push(node);
        }
        while (node && node.key <= to) {
          if (node.key >= from) {
            if (!equalScalar(node.value, 0)) {
              callback(node.key, node.value, this);
            }
          }
          node = heap.extractMinimum();
          if (node) {
            nodes.push(node);
          }
        }
        for (let i = 0; i < nodes.length; i++) {
          const n = nodes[i];
          node = heap.insert(n.key, n.value);
          values[node.key] = node;
        }
      }
      swap(i, j) {
        let nodei = this._values[i];
        let nodej = this._values[j];
        if (!nodei && nodej) {
          nodei = this._heap.insert(i, nodej.value);
          this._heap.remove(nodej);
          this._values[i] = nodei;
          this._values[j] = void 0;
        } else if (nodei && !nodej) {
          nodej = this._heap.insert(j, nodei.value);
          this._heap.remove(nodei);
          this._values[j] = nodej;
          this._values[i] = void 0;
        } else if (nodei && nodej) {
          const v = nodei.value;
          nodei.value = nodej.value;
          nodej.value = v;
        }
      }
    }
    return Spa;
  },
  { isClass: true }
);

// src/utils/lruQueue.ts
function lruQueue(limit) {
  let size = 0;
  let base = 1;
  let queue = /* @__PURE__ */ Object.create(null);
  let map2 = /* @__PURE__ */ Object.create(null);
  let index = 0;
  const del = function(id) {
    const oldIndex = map2[id];
    if (!oldIndex) return;
    delete queue[oldIndex];
    delete map2[id];
    --size;
    if (base !== oldIndex) return;
    if (!size) {
      index = 0;
      base = 1;
      return;
    }
    while (!Object.prototype.hasOwnProperty.call(queue, ++base)) {
    }
  };
  limit = Math.abs(limit);
  return {
    hit: function(id) {
      const oldIndex = map2[id];
      const nuIndex = ++index;
      queue[nuIndex] = id;
      map2[id] = nuIndex;
      if (!oldIndex) {
        ++size;
        if (size <= limit) return void 0;
        id = queue[base];
        del(id);
        return id;
      }
      delete queue[oldIndex];
      if (base !== oldIndex) return void 0;
      while (!Object.prototype.hasOwnProperty.call(queue, ++base)) {
      }
      return void 0;
    },
    delete: del,
    clear: function() {
      size = index = 0;
      base = 1;
      queue = /* @__PURE__ */ Object.create(null);
      map2 = /* @__PURE__ */ Object.create(null);
    }
  };
}

// src/utils/function.ts
function memoize(fn, { hasher: hasher2, limit } = {}) {
  limit = limit == null ? Number.POSITIVE_INFINITY : limit;
  hasher2 = hasher2 == null ? JSON.stringify : hasher2;
  const memoized = function() {
    if (typeof memoized.cache !== "object") {
      memoized.cache = {
        values: /* @__PURE__ */ new Map(),
        lru: lruQueue(limit || Number.POSITIVE_INFINITY)
      };
    }
    const args = [];
    for (let i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }
    const hash = hasher2(args);
    if (memoized.cache.values.has(hash)) {
      memoized.cache.lru.hit(hash);
      return memoized.cache.values.get(hash);
    }
    const newVal = fn.apply(fn, args);
    memoized.cache.values.set(hash, newVal);
    memoized.cache.values.delete(memoized.cache.lru.hit(hash));
    return newVal;
  };
  return memoized;
}

// src/utils/bignumber/constants.ts
var createBigNumberE = memoize(
  function(BigNumber) {
    return new BigNumber(1).exp();
  },
  { hasher }
);
var createBigNumberPhi = memoize(
  function(BigNumber) {
    return new BigNumber(1).plus(new BigNumber(5).sqrt()).div(2);
  },
  { hasher }
);
var createBigNumberPi = memoize(
  function(BigNumber) {
    return BigNumber.acos(-1);
  },
  { hasher }
);
var createBigNumberTau = memoize(
  function(BigNumber) {
    return createBigNumberPi(BigNumber).times(2);
  },
  { hasher }
);
function hasher(args) {
  return args[0].precision;
}

// src/type/unit/Unit.ts
var name167 = "Unit";
var dependencies168 = [
  "?on",
  "config",
  "addScalar",
  "subtractScalar",
  "multiplyScalar",
  "divideScalar",
  "pow",
  "abs",
  "fix",
  "round",
  "equal",
  "isNumeric",
  "format",
  "number",
  "Complex",
  "BigNumber",
  "Fraction"
];
var createUnitClass = /* @__PURE__ */ factory(
  name167,
  dependencies168,
  ({
    on,
    config,
    addScalar,
    subtractScalar,
    multiplyScalar,
    divideScalar,
    pow,
    abs,
    fix,
    round,
    equal,
    isNumeric,
    format: format4,
    number,
    Complex: Complex2,
    BigNumber,
    Fraction: Fraction2
  }) => {
    const toNumber = number;
    const fixPrefixDefault = false;
    const skipAutomaticSimplificationDefault = true;
    function Unit(value, valuelessUnit) {
      if (!(this instanceof Unit)) {
        throw new Error("Constructor must be called with the new operator");
      }
      if (!(value === null || value === void 0 || isNumeric(value) || isComplex(value))) {
        throw new TypeError(
          "First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined"
        );
      }
      this.fixPrefix = fixPrefixDefault;
      this.skipAutomaticSimplification = skipAutomaticSimplificationDefault;
      if (valuelessUnit === void 0) {
        this.units = [];
        this.dimensions = BASE_DIMENSIONS.map((_x) => 0);
      } else if (typeof valuelessUnit === "string") {
        const u = Unit.parse(valuelessUnit);
        this.units = u.units;
        this.dimensions = u.dimensions;
      } else if (isUnit(valuelessUnit) && valuelessUnit.value === null) {
        this.fixPrefix = valuelessUnit.fixPrefix;
        this.skipAutomaticSimplification = valuelessUnit.skipAutomaticSimplification;
        this.dimensions = valuelessUnit.dimensions.slice(0);
        this.units = valuelessUnit.units.map((u) => Object.assign({}, u));
      } else {
        throw new TypeError(
          "Second parameter in Unit constructor must be a string or valueless Unit"
        );
      }
      this.value = this._normalize(value);
    }
    Object.defineProperty(Unit, "name", { value: "Unit" });
    Unit.prototype.constructor = Unit;
    Unit.prototype.type = "Unit";
    Unit.prototype.isUnit = true;
    let text;
    let index;
    let c;
    function skipWhitespace() {
      while (c === " " || c === "	") {
        next();
      }
    }
    function isDigitDot(c2) {
      return c2 >= "0" && c2 <= "9" || c2 === ".";
    }
    function isDigit(c2) {
      return c2 >= "0" && c2 <= "9";
    }
    function next() {
      index++;
      c = text.charAt(index);
    }
    function revert(oldIndex) {
      index = oldIndex;
      c = text.charAt(index);
    }
    function parseNumber() {
      let number2 = "";
      const oldIndex = index;
      if (c === "+") {
        next();
      } else if (c === "-") {
        number2 += c;
        next();
      }
      if (!isDigitDot(c)) {
        revert(oldIndex);
        return null;
      }
      if (c === ".") {
        number2 += c;
        next();
        if (!isDigit(c)) {
          revert(oldIndex);
          return null;
        }
      } else {
        while (isDigit(c)) {
          number2 += c;
          next();
        }
        if (c === ".") {
          number2 += c;
          next();
        }
      }
      while (isDigit(c)) {
        number2 += c;
        next();
      }
      if (c === "E" || c === "e") {
        let tentativeNumber = "";
        const tentativeIndex = index;
        tentativeNumber += c;
        next();
        if (c === "+" || c === "-") {
          tentativeNumber += c;
          next();
        }
        if (!isDigit(c)) {
          revert(tentativeIndex);
          return number2;
        }
        number2 = number2 + tentativeNumber;
        while (isDigit(c)) {
          number2 += c;
          next();
        }
      }
      return number2;
    }
    function parseUnit() {
      let unitName = "";
      while (isDigit(c) || Unit.isValidAlpha(c)) {
        unitName += c;
        next();
      }
      const firstC = unitName.charAt(0);
      if (Unit.isValidAlpha(firstC)) {
        return unitName;
      } else {
        return null;
      }
    }
    function parseCharacter(toFind) {
      if (c === toFind) {
        next();
        return toFind;
      } else {
        return null;
      }
    }
    Unit.parse = function(str, options) {
      options = options || {};
      text = str;
      index = -1;
      c = "";
      if (typeof text !== "string") {
        throw new TypeError("Invalid argument in Unit.parse, string expected");
      }
      const unit = new Unit();
      unit.units = [];
      let powerMultiplierCurrent = 1;
      let expectingUnit = false;
      next();
      skipWhitespace();
      const valueStr = parseNumber();
      let value = null;
      if (valueStr) {
        if (config.number === "BigNumber") {
          value = new BigNumber(valueStr);
        } else if (config.number === "Fraction") {
          try {
            value = new Fraction2(valueStr);
          } catch {
            value = parseFloat(valueStr);
          }
        } else {
          value = parseFloat(valueStr);
        }
        skipWhitespace();
        if (parseCharacter("*")) {
          powerMultiplierCurrent = 1;
          expectingUnit = true;
        } else if (parseCharacter("/")) {
          powerMultiplierCurrent = -1;
          expectingUnit = true;
        }
      }
      const powerMultiplierStack = [];
      let powerMultiplierStackProduct = 1;
      while (true) {
        skipWhitespace();
        while (c === "(") {
          powerMultiplierStack.push(powerMultiplierCurrent);
          powerMultiplierStackProduct *= powerMultiplierCurrent;
          powerMultiplierCurrent = 1;
          next();
          skipWhitespace();
        }
        let uStr;
        if (c) {
          const oldC = c;
          uStr = parseUnit();
          if (uStr === null) {
            throw new SyntaxError(
              'Unexpected "' + oldC + '" in "' + text + '" at index ' + index.toString()
            );
          }
        } else {
          break;
        }
        const res = _findUnit(uStr);
        if (res === null) {
          throw new SyntaxError('Unit "' + uStr + '" not found.');
        }
        let power = powerMultiplierCurrent * powerMultiplierStackProduct;
        skipWhitespace();
        if (parseCharacter("^")) {
          skipWhitespace();
          const p = parseNumber();
          if (p === null) {
            throw new SyntaxError(
              'In "' + str + '", "^" must be followed by a floating-point number'
            );
          }
          power *= p;
        }
        unit.units.push({
          unit: res.unit,
          prefix: res.prefix,
          power
        });
        for (let i = 0; i < BASE_DIMENSIONS.length; i++) {
          unit.dimensions[i] += (res.unit.dimensions[i] || 0) * power;
        }
        skipWhitespace();
        while (c === ")") {
          if (powerMultiplierStack.length === 0) {
            throw new SyntaxError(
              'Unmatched ")" in "' + text + '" at index ' + index.toString()
            );
          }
          powerMultiplierStackProduct /= powerMultiplierStack.pop();
          next();
          skipWhitespace();
        }
        expectingUnit = false;
        if (parseCharacter("*")) {
          powerMultiplierCurrent = 1;
          expectingUnit = true;
        } else if (parseCharacter("/")) {
          powerMultiplierCurrent = -1;
          expectingUnit = true;
        } else {
          powerMultiplierCurrent = 1;
        }
        if (res.unit.base) {
          const baseDim = res.unit.base.key;
          UNIT_SYSTEMS.auto[baseDim] = {
            unit: res.unit,
            prefix: res.prefix
          };
        }
      }
      skipWhitespace();
      if (c) {
        throw new SyntaxError('Could not parse: "' + str + '"');
      }
      if (expectingUnit) {
        throw new SyntaxError('Trailing characters: "' + str + '"');
      }
      if (powerMultiplierStack.length !== 0) {
        throw new SyntaxError('Unmatched "(" in "' + text + '"');
      }
      if (unit.units.length === 0 && !options.allowNoUnits) {
        throw new SyntaxError('"' + str + '" contains no units');
      }
      unit.value = value !== void 0 ? unit._normalize(value) : null;
      return unit;
    };
    Unit.prototype.clone = function() {
      const unit = new Unit();
      unit.fixPrefix = this.fixPrefix;
      unit.skipAutomaticSimplification = this.skipAutomaticSimplification;
      unit.value = clone(this.value);
      unit.dimensions = this.dimensions.slice(0);
      unit.units = [];
      for (let i = 0; i < this.units.length; i++) {
        unit.units[i] = {};
        for (const p in this.units[i]) {
          if (hasOwnProperty(this.units[i], p)) {
            unit.units[i][p] = this.units[i][p];
          }
        }
      }
      return unit;
    };
    Unit.prototype.valueType = function() {
      return typeOf(this.value);
    };
    Unit.prototype._isDerived = function() {
      if (this.units.length === 0) {
        return false;
      }
      return this.units.length > 1 || Math.abs(this.units[0].power - 1) > 1e-15;
    };
    Unit.prototype._normalize = function(value) {
      if (value === null || value === void 0 || this.units.length === 0) {
        return value;
      }
      let res = value;
      const convert = Unit._getNumberConverter(typeOf(value));
      for (let i = 0; i < this.units.length; i++) {
        const unitValue = convert(this.units[i].unit.value);
        const unitPrefixValue = convert(this.units[i].prefix.value);
        const unitPower = convert(this.units[i].power);
        res = multiplyScalar(
          res,
          pow(multiplyScalar(unitValue, unitPrefixValue), unitPower)
        );
      }
      return res;
    };
    Unit.prototype._denormalize = function(value, _prefixValue) {
      if (value === null || value === void 0 || this.units.length === 0) {
        return value;
      }
      let res = value;
      const convert = Unit._getNumberConverter(typeOf(value));
      for (let i = 0; i < this.units.length; i++) {
        const unitValue = convert(this.units[i].unit.value);
        const unitPrefixValue = convert(this.units[i].prefix.value);
        const unitPower = convert(this.units[i].power);
        res = divideScalar(
          res,
          pow(multiplyScalar(unitValue, unitPrefixValue), unitPower)
        );
      }
      return res;
    };
    const _findUnit = memoize(
      (str) => {
        if (hasOwnProperty(UNITS, str)) {
          const unit = UNITS[str];
          const prefix = unit.prefixes[""];
          return { unit, prefix };
        }
        for (const name323 in UNITS) {
          if (hasOwnProperty(UNITS, name323)) {
            if (endsWith(str, name323)) {
              const unit = UNITS[name323];
              const prefixLen = str.length - name323.length;
              const prefixName = str.substring(0, prefixLen);
              const prefix = hasOwnProperty(unit.prefixes, prefixName) ? unit.prefixes[prefixName] : void 0;
              if (prefix !== void 0) {
                return { unit, prefix };
              }
            }
          }
        }
        return null;
      },
      { hasher: (args) => args[0], limit: 100 }
    );
    Unit.isValuelessUnit = function(name323) {
      return _findUnit(name323) !== null;
    };
    Unit.prototype.hasBase = function(base) {
      if (typeof base === "string") {
        base = BASE_UNITS[base];
      }
      if (!base) {
        return false;
      }
      for (let i = 0; i < BASE_DIMENSIONS.length; i++) {
        if (Math.abs((this.dimensions[i] || 0) - (base.dimensions[i] || 0)) > 1e-12) {
          return false;
        }
      }
      return true;
    };
    Unit.prototype.equalBase = function(other) {
      for (let i = 0; i < BASE_DIMENSIONS.length; i++) {
        if (Math.abs((this.dimensions[i] || 0) - (other.dimensions[i] || 0)) > 1e-12) {
          return false;
        }
      }
      return true;
    };
    Unit.prototype.equals = function(other) {
      return this.equalBase(other) && equal(this.value, other.value);
    };
    Unit.prototype.multiply = function(_other) {
      const res = this.clone();
      const other = isUnit(_other) ? _other : new Unit(_other);
      for (let i = 0; i < BASE_DIMENSIONS.length; i++) {
        res.dimensions[i] = (this.dimensions[i] || 0) + (other.dimensions[i] || 0);
      }
      for (let i = 0; i < other.units.length; i++) {
        const inverted = {
          ...other.units[i]
        };
        res.units.push(inverted);
      }
      if (this.value !== null || other.value !== null) {
        const valThis = this.value === null ? this._normalize(one(other.value)) : this.value;
        const valOther = other.value === null ? other._normalize(one(this.value)) : other.value;
        res.value = multiplyScalar(valThis, valOther);
      } else {
        res.value = null;
      }
      if (isUnit(_other)) {
        res.skipAutomaticSimplification = false;
      }
      if (!res.skipAutomaticSimplification) {
        simplifyUnit(res);
      }
      return getNumericIfUnitless(res);
    };
    Unit.prototype.divideInto = function(numerator) {
      return new Unit(numerator).divide(this);
    };
    Unit.prototype.divide = function(_other) {
      const res = this.clone();
      const other = isUnit(_other) ? _other : new Unit(_other);
      for (let i = 0; i < BASE_DIMENSIONS.length; i++) {
        res.dimensions[i] = (this.dimensions[i] || 0) - (other.dimensions[i] || 0);
      }
      for (let i = 0; i < other.units.length; i++) {
        const inverted = {
          ...other.units[i],
          power: -other.units[i].power
        };
        res.units.push(inverted);
      }
      if (this.value !== null || other.value !== null) {
        const valThis = this.value === null ? this._normalize(one(other.value)) : this.value;
        const valOther = other.value === null ? other._normalize(one(this.value)) : other.value;
        res.value = divideScalar(valThis, valOther);
      } else {
        res.value = null;
      }
      if (isUnit(_other)) {
        res.skipAutomaticSimplification = false;
      }
      if (!res.skipAutomaticSimplification) {
        simplifyUnit(res);
      }
      return getNumericIfUnitless(res);
    };
    Unit.prototype.pow = function(p) {
      const res = this.clone();
      for (let i = 0; i < BASE_DIMENSIONS.length; i++) {
        res.dimensions[i] = (this.dimensions[i] || 0) * p;
      }
      for (let i = 0; i < res.units.length; i++) {
        res.units[i].power *= p;
      }
      if (res.value !== null) {
        res.value = pow(res.value, p);
      } else {
        res.value = null;
      }
      res.skipAutomaticSimplification = false;
      return getNumericIfUnitless(res);
    };
    function getNumericIfUnitless(unit) {
      if (unit.equalBase(BASE_UNITS.NONE) && unit.value !== null && !config.predictable) {
        return unit.value;
      } else {
        return unit;
      }
    }
    function normalizeUnitName(name323) {
      const lower = name323.toLowerCase();
      const aliasMap = {
        // Length
        meter: "m",
        meters: "m",
        metre: "m",
        metres: "m",
        // Mass
        gram: "g",
        grams: "g",
        kilogram: "kg",
        kilograms: "kg",
        // Time
        second: "s",
        seconds: "s",
        // Temperature
        kelvin: "K",
        kelvins: "K",
        celsius: "degC",
        // Frequency
        hertz: "Hz",
        // Force
        newton: "N",
        newtons: "N",
        // Energy
        joule: "J",
        joules: "J",
        // Power
        watt: "W",
        watts: "W"
      };
      return aliasMap[lower] || lower;
    }
    function normalizeUnitKey(unitObj) {
      const normalizedName = normalizeUnitName(unitObj.unit.name);
      const prefixName = unitObj.prefix ? unitObj.prefix.name : "";
      return `${normalizedName}_${prefixName}`;
    }
    function simplifyUnit(unit) {
      let units = unit.units;
      if (!units || units.length <= 1) {
        return unit;
      }
      units = units.map((u) => ({ ...u }));
      for (let i = 0; i < units.length; i++) {
        if (units[i].power > 0) {
          const key1 = normalizeUnitKey(units[i]);
          for (let j = 0; j < units.length; j++) {
            if (j !== i && units[j].power < 0) {
              const key2 = normalizeUnitKey(units[j]);
              if (key1 === key2) {
                const positivePower = units[i].power;
                const negativePower = Math.abs(units[j].power);
                const cancelAmount = Math.min(positivePower, negativePower);
                units[i].power -= cancelAmount;
                units[j].power += cancelAmount;
                break;
              }
            }
          }
        }
      }
      const simplifiedUnits = units.filter(
        (u) => Math.abs(u.power) >= 1e-12
      );
      unit.units = simplifiedUnits;
      return unit;
    }
    function one(typeOfValue) {
      const convert = Unit._getNumberConverter(typeOf(typeOfValue));
      return convert(1);
    }
    Unit.prototype.abs = function() {
      const ret = this.clone();
      if (ret.value !== null) {
        if (ret._isDerived() || ret.units.length === 0 || ret.units[0].unit.offset === 0) {
          ret.value = abs(ret.value);
        } else {
          const convert = ret._numberConverter();
          const unitValue = convert(ret.units[0].unit.value);
          const nominalOffset = convert(ret.units[0].unit.offset);
          const unitOffset = multiplyScalar(unitValue, nominalOffset);
          ret.value = subtractScalar(
            abs(addScalar(ret.value, unitOffset)),
            unitOffset
          );
        }
      }
      for (const i in ret.units) {
        if (ret.units[i].unit.name === "VA" || ret.units[i].unit.name === "VAR") {
          ret.units[i].unit = UNITS.W;
        }
      }
      return ret;
    };
    Unit.prototype.to = function(valuelessUnit) {
      const value = this.value === null ? this._normalize(1) : this.value;
      let other;
      if (typeof valuelessUnit === "string") {
        other = Unit.parse(valuelessUnit);
      } else if (isUnit(valuelessUnit)) {
        other = valuelessUnit.clone();
      } else {
        throw new Error("String or Unit expected as parameter");
      }
      if (!this.equalBase(other)) {
        throw new Error(
          `Units do not match ('${other.toString()}' != '${this.toString()}')`
        );
      }
      if (other.value !== null) {
        throw new Error("Cannot convert to a unit with a value");
      }
      if (this.value === null || this._isDerived() || this.units.length === 0 || other.units.length === 0 || this.units[0].unit.offset === other.units[0].unit.offset) {
        other.value = clone(value);
      } else {
        const convert = Unit._getNumberConverter(typeOf(value));
        const thisUnitValue = this.units[0].unit.value;
        const thisNominalOffset = this.units[0].unit.offset;
        const thisUnitOffset = multiplyScalar(thisUnitValue, thisNominalOffset);
        const otherUnitValue = other.units[0].unit.value;
        const otherNominalOffset = other.units[0].unit.offset;
        const otherUnitOffset = multiplyScalar(
          otherUnitValue,
          otherNominalOffset
        );
        other.value = addScalar(
          value,
          convert(subtractScalar(thisUnitOffset, otherUnitOffset))
        );
      }
      other.fixPrefix = true;
      other.skipAutomaticSimplification = true;
      return other;
    };
    Unit.prototype.toNumber = function(valuelessUnit) {
      return toNumber(this.toNumeric(valuelessUnit));
    };
    Unit.prototype.toNumeric = function(valuelessUnit) {
      let other;
      if (valuelessUnit) {
        other = this.to(valuelessUnit);
      } else {
        other = this.clone();
      }
      if (other._isDerived() || other.units.length === 0) {
        return other._denormalize(other.value);
      } else {
        return other._denormalize(other.value, other.units[0].prefix.value);
      }
    };
    Unit.prototype.toString = function() {
      return this.format();
    };
    Unit.prototype.toJSON = function() {
      return {
        mathjs: "Unit",
        value: this._denormalize(this.value),
        unit: this.units.length > 0 ? this.formatUnits() : null,
        fixPrefix: this.fixPrefix,
        skipSimp: this.skipAutomaticSimplification
      };
    };
    Unit.fromJSON = function(json) {
      const unit = new Unit(json.value, json.unit ?? void 0);
      unit.fixPrefix = json.fixPrefix ?? fixPrefixDefault;
      unit.skipAutomaticSimplification = json.skipSimp ?? skipAutomaticSimplificationDefault;
      return unit;
    };
    Unit.prototype.valueOf = Unit.prototype.toString;
    Unit.prototype.simplify = function() {
      const ret = this.clone();
      const proposedUnitList = [];
      let matchingBase;
      for (const key in currentUnitSystem) {
        if (hasOwnProperty(currentUnitSystem, key)) {
          if (ret.hasBase(BASE_UNITS[key])) {
            matchingBase = key;
            break;
          }
        }
      }
      if (matchingBase === "NONE") {
        ret.units = [];
      } else {
        let matchingUnit;
        if (matchingBase) {
          if (hasOwnProperty(currentUnitSystem, matchingBase)) {
            matchingUnit = currentUnitSystem[matchingBase];
          }
        }
        if (matchingUnit) {
          ret.units = [
            {
              unit: matchingUnit.unit,
              prefix: matchingUnit.prefix,
              power: 1
            }
          ];
        } else {
          let missingBaseDim = false;
          for (let i = 0; i < BASE_DIMENSIONS.length; i++) {
            const baseDim = BASE_DIMENSIONS[i];
            if (Math.abs(ret.dimensions[i] || 0) > 1e-12) {
              if (hasOwnProperty(currentUnitSystem, baseDim)) {
                proposedUnitList.push({
                  unit: currentUnitSystem[baseDim].unit,
                  prefix: currentUnitSystem[baseDim].prefix,
                  power: ret.dimensions[i] || 0
                });
              } else {
                missingBaseDim = true;
              }
            }
          }
          if (proposedUnitList.length < ret.units.length && !missingBaseDim) {
            ret.units = proposedUnitList;
          }
        }
      }
      return ret;
    };
    Unit.prototype.toSI = function() {
      const ret = this.clone();
      const proposedUnitList = [];
      for (let i = 0; i < BASE_DIMENSIONS.length; i++) {
        const baseDim = BASE_DIMENSIONS[i];
        if (Math.abs(ret.dimensions[i] || 0) > 1e-12) {
          if (hasOwnProperty(UNIT_SYSTEMS.si, baseDim)) {
            proposedUnitList.push({
              unit: UNIT_SYSTEMS.si[baseDim].unit,
              prefix: UNIT_SYSTEMS.si[baseDim].prefix,
              power: ret.dimensions[i] || 0
            });
          } else {
            throw new Error(
              "Cannot express custom unit " + baseDim + " in SI units"
            );
          }
        }
      }
      ret.units = proposedUnitList;
      ret.fixPrefix = true;
      ret.skipAutomaticSimplification = true;
      if (this.value !== null) {
        ret.value = null;
        return this.to(ret);
      }
      return ret;
    };
    Unit.prototype.formatUnits = function() {
      let strNum = "";
      let strDen = "";
      let nNum = 0;
      let nDen = 0;
      for (let i = 0; i < this.units.length; i++) {
        if (this.units[i].power > 0) {
          nNum++;
          strNum += " " + this.units[i].prefix.name + this.units[i].unit.name;
          if (Math.abs(this.units[i].power - 1) > 1e-15) {
            strNum += "^" + this.units[i].power;
          }
        } else if (this.units[i].power < 0) {
          nDen++;
        }
      }
      if (nDen > 0) {
        for (let i = 0; i < this.units.length; i++) {
          if (this.units[i].power < 0) {
            if (nNum > 0) {
              strDen += " " + this.units[i].prefix.name + this.units[i].unit.name;
              if (Math.abs(this.units[i].power + 1) > 1e-15) {
                strDen += "^" + -this.units[i].power;
              }
            } else {
              strDen += " " + this.units[i].prefix.name + this.units[i].unit.name;
              strDen += "^" + this.units[i].power;
            }
          }
        }
      }
      strNum = strNum.substr(1);
      strDen = strDen.substr(1);
      if (nNum > 1 && nDen > 0) {
        strNum = "(" + strNum + ")";
      }
      if (nDen > 1 && nNum > 0) {
        strDen = "(" + strDen + ")";
      }
      let str = strNum;
      if (nNum > 0 && nDen > 0) {
        str += " / ";
      }
      str += strDen;
      return str;
    };
    Unit.prototype.toBest = function(unitList = [], options = {}) {
      if (unitList && !Array.isArray(unitList)) {
        throw new Error("Invalid unit type. Expected string or Unit.");
      }
      const startPrefixes = this.units[0].unit.prefixes;
      if (unitList && unitList.length > 0) {
        const unitObjects = unitList.map((u) => {
          let unit = null;
          if (typeof u === "string") {
            unit = Unit.parse(u);
            if (!unit) {
              throw new Error(
                "Invalid unit type. Expected compatible string or Unit."
              );
            }
          } else if (!isUnit(u)) {
            throw new Error(
              "Invalid unit type. Expected compatible string or Unit."
            );
          }
          if (unit === null) {
            unit = u.clone();
          }
          try {
            this.to(unit.formatUnits());
            return unit;
          } catch {
            throw new Error(
              "Invalid unit type. Expected compatible string or Unit."
            );
          }
        });
        const prefixes = unitObjects.map((el) => el.units[0].prefix);
        this.units[0].unit.prefixes = prefixes.reduce((acc, prefix) => {
          acc[prefix.name] = prefix;
          return acc;
        }, {});
        this.units[0].prefix = prefixes[0];
      }
      const result = formatBest(this, options).simp;
      this.units[0].unit.prefixes = startPrefixes;
      result.fixPrefix = true;
      return result;
    };
    Unit.prototype.format = function(options) {
      const { simp, valueStr, unitStr } = formatBest(this, options);
      let str = valueStr;
      if (simp.value && isComplex(simp.value)) {
        str = "(" + str + ")";
      }
      if (unitStr.length > 0 && str.length > 0) {
        str += " ";
      }
      str += unitStr;
      return str;
    };
    function formatBest(unit, options = {}) {
      const simp = unit.skipAutomaticSimplification || unit.value === null ? unit.clone() : unit.simplify();
      handleVAandVARUnits(simp);
      applyBestPrefixIfNeeded(simp, options.offset);
      const value = simp._denormalize(simp.value);
      const valueStr = simp.value !== null ? format4(value, options || {}) : "";
      const unitStr = simp.formatUnits();
      return {
        simp,
        valueStr,
        unitStr
      };
    }
    function handleVAandVARUnits(simp) {
      let isImaginary = false;
      if (typeof simp.value !== "undefined" && simp.value !== null && isComplex(simp.value)) {
        isImaginary = Math.abs(simp.value.re) < 1e-14;
      }
      for (const i in simp.units) {
        if (hasOwnProperty(simp.units, i)) {
          if (simp.units[i].unit) {
            if (simp.units[i].unit.name === "VA" && isImaginary) {
              simp.units[i].unit = UNITS.VAR;
            } else if (simp.units[i].unit.name === "VAR" && !isImaginary) {
              simp.units[i].unit = UNITS.VA;
            }
          }
        }
      }
    }
    function applyBestPrefixIfNeeded(simp, offset) {
      if (simp.units.length === 1 && !simp.fixPrefix) {
        if (Math.abs(simp.units[0].power - Math.round(simp.units[0].power)) < 1e-14) {
          simp.units[0].prefix = simp._bestPrefix(offset);
        }
      }
    }
    Unit.prototype._bestPrefix = function(offset = 1.2) {
      if (this.units.length !== 1) {
        throw new Error(
          "Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!"
        );
      }
      if (Math.abs(this.units[0].power - Math.round(this.units[0].power)) >= 1e-14) {
        throw new Error(
          "Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!"
        );
      }
      const absValue = this.value !== null ? abs(this.value) : 0;
      const absUnitValue = abs(this.units[0].unit.value);
      let bestPrefix = this.units[0].prefix;
      if (absValue === 0) {
        return bestPrefix;
      }
      const power = this.units[0].power;
      let bestDiff = Math.log(absValue / Math.pow(bestPrefix.value * absUnitValue, power)) / Math.LN10 - offset;
      if (bestDiff > -2.200001 && bestDiff < 1.800001) return bestPrefix;
      bestDiff = Math.abs(bestDiff);
      const prefixes = this.units[0].unit.prefixes;
      for (const p in prefixes) {
        if (hasOwnProperty(prefixes, p)) {
          const prefix = prefixes[p];
          if (prefix.scientific) {
            const diff = Math.abs(
              Math.log(
                absValue / Math.pow(prefix.value * absUnitValue, power)
              ) / Math.LN10 - offset
            );
            if (diff < bestDiff || diff === bestDiff && prefix.name.length < bestPrefix.name.length) {
              bestPrefix = prefix;
              bestDiff = diff;
            }
          }
        }
      }
      return bestPrefix;
    };
    Unit.prototype.splitUnit = function(parts) {
      let x = this.clone();
      const ret = [];
      for (let i = 0; i < parts.length; i++) {
        x = x.to(parts[i]);
        if (i === parts.length - 1) break;
        const xNumeric = x.toNumeric();
        const xRounded = round(xNumeric);
        let xFixed;
        const isNearlyEqual = equal(xRounded, xNumeric);
        if (isNearlyEqual) {
          xFixed = xRounded;
        } else {
          xFixed = fix(x.toNumeric());
        }
        const y = new Unit(xFixed, parts[i].toString());
        ret.push(y);
        x = subtractScalar(x, y);
      }
      let testSum = 0;
      for (let i = 0; i < ret.length; i++) {
        testSum = addScalar(testSum, ret[i].value);
      }
      if (equal(testSum, this.value)) {
        x.value = 0;
      }
      ret.push(x);
      return ret;
    };
    const PREFIXES = {
      NONE: {
        "": { name: "", value: 1, scientific: true }
      },
      SHORT: {
        "": { name: "", value: 1, scientific: true },
        da: { name: "da", value: 10, scientific: false },
        h: { name: "h", value: 100, scientific: false },
        k: { name: "k", value: 1e3, scientific: true },
        M: { name: "M", value: 1e6, scientific: true },
        G: { name: "G", value: 1e9, scientific: true },
        T: { name: "T", value: 1e12, scientific: true },
        P: { name: "P", value: 1e15, scientific: true },
        E: { name: "E", value: 1e18, scientific: true },
        Z: { name: "Z", value: 1e21, scientific: true },
        Y: { name: "Y", value: 1e24, scientific: true },
        R: { name: "R", value: 1e27, scientific: true },
        Q: { name: "Q", value: 1e30, scientific: true },
        d: { name: "d", value: 0.1, scientific: false },
        c: { name: "c", value: 0.01, scientific: false },
        m: { name: "m", value: 1e-3, scientific: true },
        u: { name: "u", value: 1e-6, scientific: true },
        n: { name: "n", value: 1e-9, scientific: true },
        p: { name: "p", value: 1e-12, scientific: true },
        f: { name: "f", value: 1e-15, scientific: true },
        a: { name: "a", value: 1e-18, scientific: true },
        z: { name: "z", value: 1e-21, scientific: true },
        y: { name: "y", value: 1e-24, scientific: true },
        r: { name: "r", value: 1e-27, scientific: true },
        q: { name: "q", value: 1e-30, scientific: true }
      },
      LONG: {
        "": { name: "", value: 1, scientific: true },
        deca: { name: "deca", value: 10, scientific: false },
        hecto: { name: "hecto", value: 100, scientific: false },
        kilo: { name: "kilo", value: 1e3, scientific: true },
        mega: { name: "mega", value: 1e6, scientific: true },
        giga: { name: "giga", value: 1e9, scientific: true },
        tera: { name: "tera", value: 1e12, scientific: true },
        peta: { name: "peta", value: 1e15, scientific: true },
        exa: { name: "exa", value: 1e18, scientific: true },
        zetta: { name: "zetta", value: 1e21, scientific: true },
        yotta: { name: "yotta", value: 1e24, scientific: true },
        ronna: { name: "ronna", value: 1e27, scientific: true },
        quetta: { name: "quetta", value: 1e30, scientific: true },
        deci: { name: "deci", value: 0.1, scientific: false },
        centi: { name: "centi", value: 0.01, scientific: false },
        milli: { name: "milli", value: 1e-3, scientific: true },
        micro: { name: "micro", value: 1e-6, scientific: true },
        nano: { name: "nano", value: 1e-9, scientific: true },
        pico: { name: "pico", value: 1e-12, scientific: true },
        femto: { name: "femto", value: 1e-15, scientific: true },
        atto: { name: "atto", value: 1e-18, scientific: true },
        zepto: { name: "zepto", value: 1e-21, scientific: true },
        yocto: { name: "yocto", value: 1e-24, scientific: true },
        ronto: { name: "ronto", value: 1e-27, scientific: true },
        quecto: { name: "quecto", value: 1e-30, scientific: true }
      },
      SQUARED: {
        "": { name: "", value: 1, scientific: true },
        da: { name: "da", value: 100, scientific: false },
        h: { name: "h", value: 1e4, scientific: false },
        k: { name: "k", value: 1e6, scientific: true },
        M: { name: "M", value: 1e12, scientific: true },
        G: { name: "G", value: 1e18, scientific: true },
        T: { name: "T", value: 1e24, scientific: true },
        P: { name: "P", value: 1e30, scientific: true },
        E: { name: "E", value: 1e36, scientific: true },
        Z: { name: "Z", value: 1e42, scientific: true },
        Y: { name: "Y", value: 1e48, scientific: true },
        R: { name: "R", value: 1e54, scientific: true },
        Q: { name: "Q", value: 1e60, scientific: true },
        d: { name: "d", value: 0.01, scientific: false },
        c: { name: "c", value: 1e-4, scientific: false },
        m: { name: "m", value: 1e-6, scientific: true },
        u: { name: "u", value: 1e-12, scientific: true },
        n: { name: "n", value: 1e-18, scientific: true },
        p: { name: "p", value: 1e-24, scientific: true },
        f: { name: "f", value: 1e-30, scientific: true },
        a: { name: "a", value: 1e-36, scientific: true },
        z: { name: "z", value: 1e-42, scientific: true },
        y: { name: "y", value: 1e-48, scientific: true },
        r: { name: "r", value: 1e-54, scientific: true },
        q: { name: "q", value: 1e-60, scientific: true }
      },
      CUBIC: {
        "": { name: "", value: 1, scientific: true },
        da: { name: "da", value: 1e3, scientific: false },
        h: { name: "h", value: 1e6, scientific: false },
        k: { name: "k", value: 1e9, scientific: true },
        M: { name: "M", value: 1e18, scientific: true },
        G: { name: "G", value: 1e27, scientific: true },
        T: { name: "T", value: 1e36, scientific: true },
        P: { name: "P", value: 1e45, scientific: true },
        E: { name: "E", value: 1e54, scientific: true },
        Z: { name: "Z", value: 1e63, scientific: true },
        Y: { name: "Y", value: 1e72, scientific: true },
        R: { name: "R", value: 1e81, scientific: true },
        Q: { name: "Q", value: 1e90, scientific: true },
        d: { name: "d", value: 1e-3, scientific: false },
        c: { name: "c", value: 1e-6, scientific: false },
        m: { name: "m", value: 1e-9, scientific: true },
        u: { name: "u", value: 1e-18, scientific: true },
        n: { name: "n", value: 1e-27, scientific: true },
        p: { name: "p", value: 1e-36, scientific: true },
        f: { name: "f", value: 1e-45, scientific: true },
        a: { name: "a", value: 1e-54, scientific: true },
        z: { name: "z", value: 1e-63, scientific: true },
        y: { name: "y", value: 1e-72, scientific: true },
        r: { name: "r", value: 1e-81, scientific: true },
        q: { name: "q", value: 1e-90, scientific: true }
      },
      BINARY_SHORT_SI: {
        "": { name: "", value: 1, scientific: true },
        k: { name: "k", value: 1e3, scientific: true },
        M: { name: "M", value: 1e6, scientific: true },
        G: { name: "G", value: 1e9, scientific: true },
        T: { name: "T", value: 1e12, scientific: true },
        P: { name: "P", value: 1e15, scientific: true },
        E: { name: "E", value: 1e18, scientific: true },
        Z: { name: "Z", value: 1e21, scientific: true },
        Y: { name: "Y", value: 1e24, scientific: true }
      },
      BINARY_SHORT_IEC: {
        "": { name: "", value: 1, scientific: true },
        Ki: { name: "Ki", value: 1024, scientific: true },
        Mi: { name: "Mi", value: Math.pow(1024, 2), scientific: true },
        Gi: { name: "Gi", value: Math.pow(1024, 3), scientific: true },
        Ti: { name: "Ti", value: Math.pow(1024, 4), scientific: true },
        Pi: { name: "Pi", value: Math.pow(1024, 5), scientific: true },
        Ei: { name: "Ei", value: Math.pow(1024, 6), scientific: true },
        Zi: { name: "Zi", value: Math.pow(1024, 7), scientific: true },
        Yi: { name: "Yi", value: Math.pow(1024, 8), scientific: true }
      },
      BINARY_LONG_SI: {
        "": { name: "", value: 1, scientific: true },
        kilo: { name: "kilo", value: 1e3, scientific: true },
        mega: { name: "mega", value: 1e6, scientific: true },
        giga: { name: "giga", value: 1e9, scientific: true },
        tera: { name: "tera", value: 1e12, scientific: true },
        peta: { name: "peta", value: 1e15, scientific: true },
        exa: { name: "exa", value: 1e18, scientific: true },
        zetta: { name: "zetta", value: 1e21, scientific: true },
        yotta: { name: "yotta", value: 1e24, scientific: true }
      },
      BINARY_LONG_IEC: {
        "": { name: "", value: 1, scientific: true },
        kibi: { name: "kibi", value: 1024, scientific: true },
        mebi: { name: "mebi", value: Math.pow(1024, 2), scientific: true },
        gibi: { name: "gibi", value: Math.pow(1024, 3), scientific: true },
        tebi: { name: "tebi", value: Math.pow(1024, 4), scientific: true },
        pebi: { name: "pebi", value: Math.pow(1024, 5), scientific: true },
        exi: { name: "exi", value: Math.pow(1024, 6), scientific: true },
        zebi: { name: "zebi", value: Math.pow(1024, 7), scientific: true },
        yobi: { name: "yobi", value: Math.pow(1024, 8), scientific: true }
      },
      BTU: {
        "": { name: "", value: 1, scientific: true },
        MM: { name: "MM", value: 1e6, scientific: true }
      }
    };
    PREFIXES.SHORTLONG = Object.assign({}, PREFIXES.SHORT, PREFIXES.LONG);
    PREFIXES.BINARY_SHORT = Object.assign(
      {},
      PREFIXES.BINARY_SHORT_SI,
      PREFIXES.BINARY_SHORT_IEC
    );
    PREFIXES.BINARY_LONG = Object.assign(
      {},
      PREFIXES.BINARY_LONG_SI,
      PREFIXES.BINARY_LONG_IEC
    );
    const BASE_DIMENSIONS = [
      "MASS",
      "LENGTH",
      "TIME",
      "CURRENT",
      "TEMPERATURE",
      "LUMINOUS_INTENSITY",
      "AMOUNT_OF_SUBSTANCE",
      "ANGLE",
      "BIT"
    ];
    const BASE_UNITS = {
      NONE: {
        dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 0]
      },
      MASS: {
        dimensions: [1, 0, 0, 0, 0, 0, 0, 0, 0]
      },
      LENGTH: {
        dimensions: [0, 1, 0, 0, 0, 0, 0, 0, 0]
      },
      TIME: {
        dimensions: [0, 0, 1, 0, 0, 0, 0, 0, 0]
      },
      CURRENT: {
        dimensions: [0, 0, 0, 1, 0, 0, 0, 0, 0]
      },
      TEMPERATURE: {
        dimensions: [0, 0, 0, 0, 1, 0, 0, 0, 0]
      },
      LUMINOUS_INTENSITY: {
        dimensions: [0, 0, 0, 0, 0, 1, 0, 0, 0]
      },
      AMOUNT_OF_SUBSTANCE: {
        dimensions: [0, 0, 0, 0, 0, 0, 1, 0, 0]
      },
      FORCE: {
        dimensions: [1, 1, -2, 0, 0, 0, 0, 0, 0]
      },
      SURFACE: {
        dimensions: [0, 2, 0, 0, 0, 0, 0, 0, 0]
      },
      VOLUME: {
        dimensions: [0, 3, 0, 0, 0, 0, 0, 0, 0]
      },
      ENERGY: {
        dimensions: [1, 2, -2, 0, 0, 0, 0, 0, 0]
      },
      POWER: {
        dimensions: [1, 2, -3, 0, 0, 0, 0, 0, 0]
      },
      PRESSURE: {
        dimensions: [1, -1, -2, 0, 0, 0, 0, 0, 0]
      },
      ELECTRIC_CHARGE: {
        dimensions: [0, 0, 1, 1, 0, 0, 0, 0, 0]
      },
      ELECTRIC_CAPACITANCE: {
        dimensions: [-1, -2, 4, 2, 0, 0, 0, 0, 0]
      },
      ELECTRIC_POTENTIAL: {
        dimensions: [1, 2, -3, -1, 0, 0, 0, 0, 0]
      },
      ELECTRIC_RESISTANCE: {
        dimensions: [1, 2, -3, -2, 0, 0, 0, 0, 0]
      },
      ELECTRIC_INDUCTANCE: {
        dimensions: [1, 2, -2, -2, 0, 0, 0, 0, 0]
      },
      ELECTRIC_CONDUCTANCE: {
        dimensions: [-1, -2, 3, 2, 0, 0, 0, 0, 0]
      },
      MAGNETIC_FLUX: {
        dimensions: [1, 2, -2, -1, 0, 0, 0, 0, 0]
      },
      MAGNETIC_FLUX_DENSITY: {
        dimensions: [1, 0, -2, -1, 0, 0, 0, 0, 0]
      },
      FREQUENCY: {
        dimensions: [0, 0, -1, 0, 0, 0, 0, 0, 0]
      },
      ANGLE: {
        dimensions: [0, 0, 0, 0, 0, 0, 0, 1, 0]
      },
      BIT: {
        dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 1]
      }
    };
    for (const key in BASE_UNITS) {
      if (hasOwnProperty(BASE_UNITS, key)) {
        BASE_UNITS[key].key = key;
      }
    }
    const BASE_UNIT_NONE = {};
    const UNIT_NONE = {
      name: "",
      base: BASE_UNIT_NONE,
      value: 1,
      offset: 0,
      dimensions: BASE_DIMENSIONS.map((_x) => 0)
    };
    const UNITS = {
      // length
      meter: {
        name: "meter",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      inch: {
        name: "inch",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.0254,
        offset: 0
      },
      foot: {
        name: "foot",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.3048,
        offset: 0
      },
      yard: {
        name: "yard",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.9144,
        offset: 0
      },
      mile: {
        name: "mile",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 1609.344,
        offset: 0
      },
      link: {
        name: "link",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.201168,
        offset: 0
      },
      rod: {
        name: "rod",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 5.0292,
        offset: 0
      },
      chain: {
        name: "chain",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 20.1168,
        offset: 0
      },
      angstrom: {
        name: "angstrom",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 1e-10,
        offset: 0
      },
      m: {
        name: "m",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      in: {
        name: "in",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.0254,
        offset: 0
      },
      ft: {
        name: "ft",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.3048,
        offset: 0
      },
      yd: {
        name: "yd",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.9144,
        offset: 0
      },
      mi: {
        name: "mi",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 1609.344,
        offset: 0
      },
      li: {
        name: "li",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.201168,
        offset: 0
      },
      rd: {
        name: "rd",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 5.02921,
        offset: 0
      },
      ch: {
        name: "ch",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 20.1168,
        offset: 0
      },
      mil: {
        name: "mil",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 254e-7,
        offset: 0
      },
      // 1/1000 inch
      // Surface
      m2: {
        name: "m2",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.SQUARED,
        value: 1,
        offset: 0
      },
      sqin: {
        name: "sqin",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 64516e-8,
        offset: 0
      },
      // 645.16 mm2
      sqft: {
        name: "sqft",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 0.09290304,
        offset: 0
      },
      // 0.09290304 m2
      sqyd: {
        name: "sqyd",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 0.83612736,
        offset: 0
      },
      // 0.83612736 m2
      sqmi: {
        name: "sqmi",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 2589988110336e-6,
        offset: 0
      },
      // 2.589988110336 km2
      sqrd: {
        name: "sqrd",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 25.29295,
        offset: 0
      },
      // 25.29295 m2
      sqch: {
        name: "sqch",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 404.6873,
        offset: 0
      },
      // 404.6873 m2
      sqmil: {
        name: "sqmil",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 64516e-14,
        offset: 0
      },
      // 6.4516 * 10^-10 m2
      acre: {
        name: "acre",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 4046.86,
        offset: 0
      },
      // 4046.86 m2
      hectare: {
        name: "hectare",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 1e4,
        offset: 0
      },
      // 10000 m2
      // Volume
      m3: {
        name: "m3",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.CUBIC,
        value: 1,
        offset: 0
      },
      L: {
        name: "L",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.SHORT,
        value: 1e-3,
        offset: 0
      },
      // litre
      l: {
        name: "l",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.SHORT,
        value: 1e-3,
        offset: 0
      },
      // litre
      litre: {
        name: "litre",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.LONG,
        value: 1e-3,
        offset: 0
      },
      cuin: {
        name: "cuin",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 16387064e-12,
        offset: 0
      },
      // 1.6387064e-5 m3
      cuft: {
        name: "cuft",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.028316846592,
        offset: 0
      },
      // 28.316 846 592 L
      cuyd: {
        name: "cuyd",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.764554857984,
        offset: 0
      },
      // 764.554 857 984 L
      teaspoon: {
        name: "teaspoon",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 5e-6,
        offset: 0
      },
      // 5 mL
      tablespoon: {
        name: "tablespoon",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 15e-6,
        offset: 0
      },
      // 15 mL
      // {name: 'cup', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.000240, offset: 0}, // 240 mL  // not possible, we have already another cup
      drop: {
        name: "drop",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 5e-8,
        offset: 0
      },
      // 0.05 mL = 5e-8 m3
      gtt: {
        name: "gtt",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 5e-8,
        offset: 0
      },
      // 0.05 mL = 5e-8 m3
      // Liquid volume
      minim: {
        name: "minim",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 61611519921875e-21,
        offset: 0
      },
      // 1/61440 gallons
      fluiddram: {
        name: "fluiddram",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 36966911953125e-19,
        offset: 0
      },
      // 1/1024 gallons
      fluidounce: {
        name: "fluidounce",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 295735295625e-16,
        offset: 0
      },
      // 1/128 gallons
      gill: {
        name: "gill",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 11829411825e-14,
        offset: 0
      },
      // 1/32 gallons
      cc: {
        name: "cc",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 1e-6,
        offset: 0
      },
      // 1e-6 L
      cup: {
        name: "cup",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 2365882365e-13,
        offset: 0
      },
      // 1/16 gallons
      pint: {
        name: "pint",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 473176473e-12,
        offset: 0
      },
      // 1/8 gallons
      quart: {
        name: "quart",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 946352946e-12,
        offset: 0
      },
      // 1/4 gallons
      gallon: {
        name: "gallon",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.003785411784,
        offset: 0
      },
      // 3.785411784 L
      beerbarrel: {
        name: "beerbarrel",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.117347765304,
        offset: 0
      },
      // 31 gallons
      oilbarrel: {
        name: "oilbarrel",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.158987294928,
        offset: 0
      },
      // 42 gallons
      hogshead: {
        name: "hogshead",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.238480942392,
        offset: 0
      },
      // 63 gallons
      // Mass
      g: {
        name: "g",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.SHORT,
        value: 1e-3,
        offset: 0
      },
      gram: {
        name: "gram",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.LONG,
        value: 1e-3,
        offset: 0
      },
      ton: {
        name: "ton",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.SHORT,
        value: 907.18474,
        offset: 0
      },
      t: {
        name: "t",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.SHORT,
        value: 1e3,
        offset: 0
      },
      tonne: {
        name: "tonne",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.LONG,
        value: 1e3,
        offset: 0
      },
      grain: {
        name: "grain",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 6479891e-11,
        offset: 0
      },
      dram: {
        name: "dram",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 0.0017718451953125,
        offset: 0
      },
      ounce: {
        name: "ounce",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 0.028349523125,
        offset: 0
      },
      poundmass: {
        name: "poundmass",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 0.45359237,
        offset: 0
      },
      hundredweight: {
        name: "hundredweight",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 45.359237,
        offset: 0
      },
      stick: {
        name: "stick",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 0.115,
        offset: 0
      },
      stone: {
        name: "stone",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 6.35029318,
        offset: 0
      },
      gr: {
        name: "gr",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 6479891e-11,
        offset: 0
      },
      dr: {
        name: "dr",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 0.0017718451953125,
        offset: 0
      },
      oz: {
        name: "oz",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 0.028349523125,
        offset: 0
      },
      lbm: {
        name: "lbm",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 0.45359237,
        offset: 0
      },
      cwt: {
        name: "cwt",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 45.359237,
        offset: 0
      },
      // Time
      s: {
        name: "s",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      min: {
        name: "min",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 60,
        offset: 0
      },
      h: {
        name: "h",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 3600,
        offset: 0
      },
      second: {
        name: "second",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      sec: {
        name: "sec",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      minute: {
        name: "minute",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 60,
        offset: 0
      },
      hour: {
        name: "hour",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 3600,
        offset: 0
      },
      day: {
        name: "day",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 86400,
        offset: 0
      },
      week: {
        name: "week",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 7 * 86400,
        offset: 0
      },
      month: {
        name: "month",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 2629800,
        // 1/12th of Julian year
        offset: 0
      },
      year: {
        name: "year",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 31557600,
        // Julian year
        offset: 0
      },
      decade: {
        name: "decade",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 315576e3,
        // Julian decade
        offset: 0
      },
      century: {
        name: "century",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 315576e4,
        // Julian century
        offset: 0
      },
      millennium: {
        name: "millennium",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 315576e5,
        // Julian millennium
        offset: 0
      },
      // Frequency
      hertz: {
        name: "Hertz",
        base: BASE_UNITS.FREQUENCY,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0,
        reciprocal: true
      },
      Hz: {
        name: "Hz",
        base: BASE_UNITS.FREQUENCY,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0,
        reciprocal: true
      },
      // Angle
      rad: {
        name: "rad",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      radian: {
        name: "radian",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      // deg = rad / (2*pi) * 360 = rad / 0.017453292519943295769236907684888
      deg: {
        name: "deg",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.SHORT,
        value: null,
        // will be filled in by calculateAngleValues()
        offset: 0
      },
      degree: {
        name: "degree",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.LONG,
        value: null,
        // will be filled in by calculateAngleValues()
        offset: 0
      },
      // grad = rad / (2*pi) * 400  = rad / 0.015707963267948966192313216916399
      grad: {
        name: "grad",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.SHORT,
        value: null,
        // will be filled in by calculateAngleValues()
        offset: 0
      },
      gradian: {
        name: "gradian",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.LONG,
        value: null,
        // will be filled in by calculateAngleValues()
        offset: 0
      },
      // cycle = rad / (2*pi) = rad / 6.2831853071795864769252867665793
      cycle: {
        name: "cycle",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.NONE,
        value: null,
        // will be filled in by calculateAngleValues()
        offset: 0
      },
      // arcsec = rad / (3600 * (360 / 2 * pi)) = rad / 0.0000048481368110953599358991410235795
      arcsec: {
        name: "arcsec",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.NONE,
        value: null,
        // will be filled in by calculateAngleValues()
        offset: 0
      },
      // arcmin = rad / (60 * (360 / 2 * pi)) = rad / 0.00029088820866572159615394846141477
      arcmin: {
        name: "arcmin",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.NONE,
        value: null,
        // will be filled in by calculateAngleValues()
        offset: 0
      },
      // Electric current
      A: {
        name: "A",
        base: BASE_UNITS.CURRENT,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      ampere: {
        name: "ampere",
        base: BASE_UNITS.CURRENT,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      // Temperature
      // K(C) = C + 273.15
      // K(F) = (F + 459.67) * (5 / 9)
      // K(R) = R * (5 / 9)
      K: {
        name: "K",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      degC: {
        name: "degC",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 273.15
      },
      degF: {
        name: "degF",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.SHORT,
        value: new Fraction2(5, 9),
        offset: 459.67
      },
      degR: {
        name: "degR",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.SHORT,
        value: new Fraction2(5, 9),
        offset: 0
      },
      kelvin: {
        name: "kelvin",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      celsius: {
        name: "celsius",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 273.15
      },
      fahrenheit: {
        name: "fahrenheit",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.LONG,
        value: new Fraction2(5, 9),
        offset: 459.67
      },
      rankine: {
        name: "rankine",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.LONG,
        value: new Fraction2(5, 9),
        offset: 0
      },
      // amount of substance
      mol: {
        name: "mol",
        base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      mole: {
        name: "mole",
        base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      // luminous intensity
      cd: {
        name: "cd",
        base: BASE_UNITS.LUMINOUS_INTENSITY,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      candela: {
        name: "candela",
        base: BASE_UNITS.LUMINOUS_INTENSITY,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      // TODO: units STERADIAN
      // {name: 'sr', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
      // {name: 'steradian', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
      // Force
      N: {
        name: "N",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      newton: {
        name: "newton",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      dyn: {
        name: "dyn",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.SHORT,
        value: 1e-5,
        offset: 0
      },
      dyne: {
        name: "dyne",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.LONG,
        value: 1e-5,
        offset: 0
      },
      lbf: {
        name: "lbf",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.NONE,
        value: 4.4482216152605,
        offset: 0
      },
      poundforce: {
        name: "poundforce",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.NONE,
        value: 4.4482216152605,
        offset: 0
      },
      kip: {
        name: "kip",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.LONG,
        value: 4448.2216,
        offset: 0
      },
      kilogramforce: {
        name: "kilogramforce",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.NONE,
        value: 9.80665,
        offset: 0
      },
      // Energy
      J: {
        name: "J",
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      joule: {
        name: "joule",
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      erg: {
        name: "erg",
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.SHORTLONG,
        // Both kiloerg and kerg are acceptable
        value: 1e-7,
        offset: 0
      },
      Wh: {
        name: "Wh",
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.SHORT,
        value: 3600,
        offset: 0
      },
      BTU: {
        name: "BTU",
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.BTU,
        value: 1055.05585262,
        offset: 0
      },
      eV: {
        name: "eV",
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.SHORT,
        value: 1602176565e-28,
        offset: 0
      },
      electronvolt: {
        name: "electronvolt",
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.LONG,
        value: 1602176565e-28,
        offset: 0
      },
      // Power
      W: {
        name: "W",
        base: BASE_UNITS.POWER,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      watt: {
        name: "watt",
        base: BASE_UNITS.POWER,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      hp: {
        name: "hp",
        base: BASE_UNITS.POWER,
        prefixes: PREFIXES.NONE,
        value: 745.6998715386,
        offset: 0
      },
      // Electrical power units
      VAR: {
        name: "VAR",
        base: BASE_UNITS.POWER,
        prefixes: PREFIXES.SHORT,
        value: Complex2.I,
        offset: 0
      },
      VA: {
        name: "VA",
        base: BASE_UNITS.POWER,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      // Pressure
      Pa: {
        name: "Pa",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      psi: {
        name: "psi",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 6894.75729276459,
        offset: 0
      },
      atm: {
        name: "atm",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 101325,
        offset: 0
      },
      bar: {
        name: "bar",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.SHORTLONG,
        value: 1e5,
        offset: 0
      },
      torr: {
        name: "torr",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 133.322,
        offset: 0
      },
      mmHg: {
        name: "mmHg",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 133.322,
        offset: 0
      },
      mmH2O: {
        name: "mmH2O",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 9.80665,
        offset: 0
      },
      cmH2O: {
        name: "cmH2O",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 98.0665,
        offset: 0
      },
      // Electric charge
      coulomb: {
        name: "coulomb",
        base: BASE_UNITS.ELECTRIC_CHARGE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      C: {
        name: "C",
        base: BASE_UNITS.ELECTRIC_CHARGE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      // Electric capacitance
      farad: {
        name: "farad",
        base: BASE_UNITS.ELECTRIC_CAPACITANCE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      F: {
        name: "F",
        base: BASE_UNITS.ELECTRIC_CAPACITANCE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      // Electric potential
      volt: {
        name: "volt",
        base: BASE_UNITS.ELECTRIC_POTENTIAL,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      V: {
        name: "V",
        base: BASE_UNITS.ELECTRIC_POTENTIAL,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      // Electric resistance
      ohm: {
        name: "ohm",
        base: BASE_UNITS.ELECTRIC_RESISTANCE,
        prefixes: PREFIXES.SHORTLONG,
        // Both Mohm and megaohm are acceptable
        value: 1,
        offset: 0
      },
      /*
       * Unicode breaks in browsers if charset is not specified
      : {
        name: '',
        base: BASE_UNITS.ELECTRIC_RESISTANCE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      */
      // Electric inductance
      henry: {
        name: "henry",
        base: BASE_UNITS.ELECTRIC_INDUCTANCE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      H: {
        name: "H",
        base: BASE_UNITS.ELECTRIC_INDUCTANCE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      // Electric conductance
      siemens: {
        name: "siemens",
        base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      S: {
        name: "S",
        base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      // Magnetic flux
      weber: {
        name: "weber",
        base: BASE_UNITS.MAGNETIC_FLUX,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      Wb: {
        name: "Wb",
        base: BASE_UNITS.MAGNETIC_FLUX,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      // Magnetic flux density
      tesla: {
        name: "tesla",
        base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      T: {
        name: "T",
        base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      // Binary
      b: {
        name: "b",
        base: BASE_UNITS.BIT,
        prefixes: PREFIXES.BINARY_SHORT,
        value: 1,
        offset: 0
      },
      bits: {
        name: "bits",
        base: BASE_UNITS.BIT,
        prefixes: PREFIXES.BINARY_LONG,
        value: 1,
        offset: 0
      },
      B: {
        name: "B",
        base: BASE_UNITS.BIT,
        prefixes: PREFIXES.BINARY_SHORT,
        value: 8,
        offset: 0
      },
      bytes: {
        name: "bytes",
        base: BASE_UNITS.BIT,
        prefixes: PREFIXES.BINARY_LONG,
        value: 8,
        offset: 0
      }
    };
    const ALIASES = {
      meters: "meter",
      inches: "inch",
      feet: "foot",
      yards: "yard",
      miles: "mile",
      links: "link",
      rods: "rod",
      chains: "chain",
      angstroms: "angstrom",
      lt: "l",
      litres: "litre",
      liter: "litre",
      liters: "litre",
      teaspoons: "teaspoon",
      tablespoons: "tablespoon",
      minims: "minim",
      fldr: "fluiddram",
      fluiddrams: "fluiddram",
      floz: "fluidounce",
      fluidounces: "fluidounce",
      gi: "gill",
      gills: "gill",
      cp: "cup",
      cups: "cup",
      pt: "pint",
      pints: "pint",
      qt: "quart",
      quarts: "quart",
      gal: "gallon",
      gallons: "gallon",
      bbl: "beerbarrel",
      beerbarrels: "beerbarrel",
      obl: "oilbarrel",
      oilbarrels: "oilbarrel",
      hogsheads: "hogshead",
      gtts: "gtt",
      grams: "gram",
      tons: "ton",
      tonnes: "tonne",
      grains: "grain",
      drams: "dram",
      ounces: "ounce",
      poundmasses: "poundmass",
      hundredweights: "hundredweight",
      sticks: "stick",
      lb: "lbm",
      lbs: "lbm",
      kips: "kip",
      kgf: "kilogramforce",
      acres: "acre",
      hectares: "hectare",
      sqfeet: "sqft",
      sqyard: "sqyd",
      sqmile: "sqmi",
      sqmiles: "sqmi",
      mmhg: "mmHg",
      mmh2o: "mmH2O",
      cmh2o: "cmH2O",
      seconds: "second",
      secs: "second",
      minutes: "minute",
      mins: "minute",
      hours: "hour",
      hr: "hour",
      hrs: "hour",
      days: "day",
      weeks: "week",
      months: "month",
      years: "year",
      decades: "decade",
      centuries: "century",
      millennia: "millennium",
      hertz: "hertz",
      radians: "radian",
      degrees: "degree",
      gradians: "gradian",
      cycles: "cycle",
      arcsecond: "arcsec",
      arcseconds: "arcsec",
      arcminute: "arcmin",
      arcminutes: "arcmin",
      BTUs: "BTU",
      watts: "watt",
      joules: "joule",
      amperes: "ampere",
      amps: "ampere",
      amp: "ampere",
      coulombs: "coulomb",
      volts: "volt",
      ohms: "ohm",
      farads: "farad",
      webers: "weber",
      teslas: "tesla",
      electronvolts: "electronvolt",
      moles: "mole",
      bit: "bits",
      byte: "bytes"
    };
    function calculateAngleValues(config2) {
      if (config2.number === "BigNumber") {
        const pi2 = createBigNumberPi(BigNumber);
        UNITS.rad.value = new BigNumber(1);
        UNITS.deg.value = pi2.div(180);
        UNITS.grad.value = pi2.div(200);
        UNITS.cycle.value = pi2.times(2);
        UNITS.arcsec.value = pi2.div(648e3);
        UNITS.arcmin.value = pi2.div(10800);
      } else {
        UNITS.rad.value = 1;
        UNITS.deg.value = Math.PI / 180;
        UNITS.grad.value = Math.PI / 200;
        UNITS.cycle.value = Math.PI * 2;
        UNITS.arcsec.value = Math.PI / 648e3;
        UNITS.arcmin.value = Math.PI / 10800;
      }
      UNITS.radian.value = UNITS.rad.value;
      UNITS.degree.value = UNITS.deg.value;
      UNITS.gradian.value = UNITS.grad.value;
    }
    calculateAngleValues(config);
    if (on) {
      on("config", function(curr, prev) {
        if (curr.number !== prev.number) {
          calculateAngleValues(curr);
        }
      });
    }
    const UNIT_SYSTEMS = {
      si: {
        // Base units
        NONE: { unit: UNIT_NONE, prefix: PREFIXES.NONE[""] },
        LENGTH: { unit: UNITS.m, prefix: PREFIXES.SHORT[""] },
        MASS: { unit: UNITS.g, prefix: PREFIXES.SHORT.k },
        TIME: { unit: UNITS.s, prefix: PREFIXES.SHORT[""] },
        CURRENT: { unit: UNITS.A, prefix: PREFIXES.SHORT[""] },
        TEMPERATURE: { unit: UNITS.K, prefix: PREFIXES.SHORT[""] },
        LUMINOUS_INTENSITY: { unit: UNITS.cd, prefix: PREFIXES.SHORT[""] },
        AMOUNT_OF_SUBSTANCE: { unit: UNITS.mol, prefix: PREFIXES.SHORT[""] },
        ANGLE: { unit: UNITS.rad, prefix: PREFIXES.SHORT[""] },
        BIT: { unit: UNITS.bits, prefix: PREFIXES.SHORT[""] },
        // Derived units
        FORCE: { unit: UNITS.N, prefix: PREFIXES.SHORT[""] },
        ENERGY: { unit: UNITS.J, prefix: PREFIXES.SHORT[""] },
        POWER: { unit: UNITS.W, prefix: PREFIXES.SHORT[""] },
        PRESSURE: { unit: UNITS.Pa, prefix: PREFIXES.SHORT[""] },
        ELECTRIC_CHARGE: { unit: UNITS.C, prefix: PREFIXES.SHORT[""] },
        ELECTRIC_CAPACITANCE: { unit: UNITS.F, prefix: PREFIXES.SHORT[""] },
        ELECTRIC_POTENTIAL: { unit: UNITS.V, prefix: PREFIXES.SHORT[""] },
        ELECTRIC_RESISTANCE: { unit: UNITS.ohm, prefix: PREFIXES.SHORT[""] },
        ELECTRIC_INDUCTANCE: { unit: UNITS.H, prefix: PREFIXES.SHORT[""] },
        ELECTRIC_CONDUCTANCE: { unit: UNITS.S, prefix: PREFIXES.SHORT[""] },
        MAGNETIC_FLUX: { unit: UNITS.Wb, prefix: PREFIXES.SHORT[""] },
        MAGNETIC_FLUX_DENSITY: { unit: UNITS.T, prefix: PREFIXES.SHORT[""] },
        FREQUENCY: { unit: UNITS.Hz, prefix: PREFIXES.SHORT[""] }
      }
    };
    UNIT_SYSTEMS.cgs = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
    UNIT_SYSTEMS.cgs.LENGTH = { unit: UNITS.m, prefix: PREFIXES.SHORT.c };
    UNIT_SYSTEMS.cgs.MASS = { unit: UNITS.g, prefix: PREFIXES.SHORT[""] };
    UNIT_SYSTEMS.cgs.FORCE = { unit: UNITS.dyn, prefix: PREFIXES.SHORT[""] };
    UNIT_SYSTEMS.cgs.ENERGY = { unit: UNITS.erg, prefix: PREFIXES.NONE[""] };
    UNIT_SYSTEMS.us = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
    UNIT_SYSTEMS.us.LENGTH = { unit: UNITS.ft, prefix: PREFIXES.NONE[""] };
    UNIT_SYSTEMS.us.MASS = { unit: UNITS.lbm, prefix: PREFIXES.NONE[""] };
    UNIT_SYSTEMS.us.TEMPERATURE = {
      unit: UNITS.degF,
      prefix: PREFIXES.NONE[""]
    };
    UNIT_SYSTEMS.us.FORCE = { unit: UNITS.lbf, prefix: PREFIXES.NONE[""] };
    UNIT_SYSTEMS.us.ENERGY = { unit: UNITS.BTU, prefix: PREFIXES.BTU[""] };
    UNIT_SYSTEMS.us.POWER = { unit: UNITS.hp, prefix: PREFIXES.NONE[""] };
    UNIT_SYSTEMS.us.PRESSURE = { unit: UNITS.psi, prefix: PREFIXES.NONE[""] };
    UNIT_SYSTEMS.auto = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
    let currentUnitSystem = UNIT_SYSTEMS.auto;
    Unit.setUnitSystem = function(name323) {
      if (hasOwnProperty(UNIT_SYSTEMS, name323)) {
        currentUnitSystem = UNIT_SYSTEMS[name323];
      } else {
        throw new Error(
          "Unit system " + name323 + " does not exist. Choices are: " + Object.keys(UNIT_SYSTEMS).join(", ")
        );
      }
    };
    Unit.getUnitSystem = function() {
      for (const key in UNIT_SYSTEMS) {
        if (hasOwnProperty(UNIT_SYSTEMS, key)) {
          if (UNIT_SYSTEMS[key] === currentUnitSystem) {
            return key;
          }
        }
      }
    };
    Unit.typeConverters = {
      BigNumber: function(x) {
        if (x?.isFraction)
          return new BigNumber(String(x.n)).div(String(x.d)).times(String(x.s));
        return new BigNumber(x + "");
      },
      Fraction: function(x) {
        return new Fraction2(x);
      },
      Complex: function(x) {
        return x;
      },
      number: function(x) {
        if (x?.isFraction) return number(x);
        return x;
      }
    };
    Unit.prototype._numberConverter = function() {
      const convert = Unit.typeConverters[this.valueType()];
      if (convert) {
        return convert;
      }
      throw new TypeError(
        'Unsupported Unit value type "' + this.valueType() + '"'
      );
    };
    Unit._getNumberConverter = function(type) {
      if (!Unit.typeConverters[type]) {
        throw new TypeError('Unsupported type "' + type + '"');
      }
      return Unit.typeConverters[type];
    };
    for (const key in UNITS) {
      if (hasOwnProperty(UNITS, key)) {
        const unit = UNITS[key];
        unit.dimensions = unit.base.dimensions;
      }
    }
    for (const name323 in ALIASES) {
      if (hasOwnProperty(ALIASES, name323)) {
        const unit = UNITS[ALIASES[name323]];
        const alias = {};
        for (const key in unit) {
          if (hasOwnProperty(unit, key)) {
            alias[key] = unit[key];
          }
        }
        alias.name = name323;
        UNITS[name323] = alias;
      }
    }
    Unit.isValidAlpha = function isValidAlpha(c2) {
      return /^[a-zA-Z]$/.test(c2);
    };
    function assertUnitNameIsValid(name323) {
      for (let i = 0; i < name323.length; i++) {
        c = name323.charAt(i);
        if (i === 0 && !Unit.isValidAlpha(c)) {
          throw new Error(
            'Invalid unit name (must begin with alpha character): "' + name323 + '"'
          );
        }
        if (i > 0 && !(Unit.isValidAlpha(c) || isDigit(c))) {
          throw new Error(
            'Invalid unit name (only alphanumeric characters are allowed): "' + name323 + '"'
          );
        }
      }
    }
    Unit.createUnit = function(obj, options) {
      if (typeof obj !== "object") {
        throw new TypeError(
          "createUnit expects first parameter to be of type 'Object'"
        );
      }
      if (options && options.override) {
        for (const key in obj) {
          if (hasOwnProperty(obj, key)) {
            Unit.deleteUnit(key);
          }
          if (obj[key].aliases) {
            for (let i = 0; i < obj[key].aliases.length; i++) {
              Unit.deleteUnit(obj[key].aliases[i]);
            }
          }
        }
      }
      let lastUnit;
      for (const key in obj) {
        if (hasOwnProperty(obj, key)) {
          lastUnit = Unit.createUnitSingle(key, obj[key]);
        }
      }
      return lastUnit;
    };
    Unit.createUnitSingle = function(name323, obj) {
      if (typeof obj === "undefined" || obj === null) {
        obj = {};
      }
      if (typeof name323 !== "string") {
        throw new TypeError(
          "createUnitSingle expects first parameter to be of type 'string'"
        );
      }
      if (hasOwnProperty(UNITS, name323)) {
        throw new Error(
          'Cannot create unit "' + name323 + '": a unit with that name already exists'
        );
      }
      assertUnitNameIsValid(name323);
      let defUnit = null;
      let aliases = [];
      let offset = 0;
      let definition;
      let prefixes;
      let baseName;
      if (obj && obj.type === "Unit") {
        defUnit = obj.clone();
      } else if (typeof obj === "string") {
        if (obj !== "") {
          definition = obj;
        }
      } else if (typeof obj === "object") {
        definition = obj.definition;
        prefixes = obj.prefixes;
        offset = obj.offset;
        baseName = obj.baseName;
        if (obj.aliases) {
          aliases = obj.aliases.valueOf();
        }
      } else {
        throw new TypeError(
          'Cannot create unit "' + name323 + '" from "' + obj.toString() + '": expecting "string" or "Unit" or "Object"'
        );
      }
      if (aliases) {
        for (let i = 0; i < aliases.length; i++) {
          if (hasOwnProperty(UNITS, aliases[i])) {
            throw new Error(
              'Cannot create alias "' + aliases[i] + '": a unit with that name already exists'
            );
          }
        }
      }
      if (definition && typeof definition === "string" && !defUnit) {
        try {
          defUnit = Unit.parse(definition, { allowNoUnits: true });
        } catch (ex) {
          ex.message = 'Could not create unit "' + name323 + '" from "' + definition + '": ' + ex.message;
          throw ex;
        }
      } else if (definition && definition.type === "Unit") {
        defUnit = definition.clone();
      }
      aliases = aliases || [];
      offset = offset || 0;
      if (prefixes && prefixes.toUpperCase) {
        prefixes = PREFIXES[prefixes.toUpperCase()] || PREFIXES.NONE;
      } else {
        prefixes = PREFIXES.NONE;
      }
      let newUnit = {};
      if (!defUnit) {
        baseName = baseName || name323 + "_STUFF";
        if (BASE_DIMENSIONS.indexOf(baseName) >= 0) {
          throw new Error(
            'Cannot create new base unit "' + name323 + '": a base unit with that name already exists (and cannot be overridden)'
          );
        }
        BASE_DIMENSIONS.push(baseName);
        for (const b in BASE_UNITS) {
          if (hasOwnProperty(BASE_UNITS, b)) {
            BASE_UNITS[b].dimensions[BASE_DIMENSIONS.length - 1] = 0;
          }
        }
        const newBaseUnit = { dimensions: [] };
        for (let i = 0; i < BASE_DIMENSIONS.length; i++) {
          newBaseUnit.dimensions[i] = 0;
        }
        newBaseUnit.dimensions[BASE_DIMENSIONS.length - 1] = 1;
        newBaseUnit.key = baseName;
        BASE_UNITS[baseName] = newBaseUnit;
        newUnit = {
          name: name323,
          value: 1,
          dimensions: BASE_UNITS[baseName].dimensions.slice(0),
          prefixes,
          offset,
          base: BASE_UNITS[baseName]
        };
        currentUnitSystem[baseName] = {
          unit: newUnit,
          prefix: PREFIXES.NONE[""]
        };
      } else {
        newUnit = {
          name: name323,
          value: defUnit.value,
          dimensions: defUnit.dimensions.slice(0),
          prefixes,
          offset
        };
        let anyMatch = false;
        for (const i in BASE_UNITS) {
          if (hasOwnProperty(BASE_UNITS, i)) {
            let match = true;
            for (let j = 0; j < BASE_DIMENSIONS.length; j++) {
              if (Math.abs(
                (newUnit.dimensions[j] || 0) - (BASE_UNITS[i].dimensions[j] || 0)
              ) > 1e-12) {
                match = false;
                break;
              }
            }
            if (match) {
              anyMatch = true;
              newUnit.base = BASE_UNITS[i];
              break;
            }
          }
        }
        if (!anyMatch) {
          baseName = baseName || name323 + "_STUFF";
          const newBaseUnit = { dimensions: defUnit.dimensions.slice(0) };
          newBaseUnit.key = baseName;
          BASE_UNITS[baseName] = newBaseUnit;
          currentUnitSystem[baseName] = {
            unit: newUnit,
            prefix: PREFIXES.NONE[""]
          };
          newUnit.base = BASE_UNITS[baseName];
        }
      }
      Unit.UNITS[name323] = newUnit;
      for (let i = 0; i < aliases.length; i++) {
        const aliasName = aliases[i];
        const alias = {};
        for (const key in newUnit) {
          if (hasOwnProperty(newUnit, key)) {
            alias[key] = newUnit[key];
          }
        }
        alias.name = aliasName;
        Unit.UNITS[aliasName] = alias;
      }
      delete _findUnit.cache;
      return new Unit(null, name323);
    };
    Unit.deleteUnit = function(name323) {
      delete Unit.UNITS[name323];
      delete _findUnit.cache;
    };
    Unit.PREFIXES = PREFIXES;
    Unit.BASE_DIMENSIONS = BASE_DIMENSIONS;
    Unit.BASE_UNITS = BASE_UNITS;
    Unit.UNIT_SYSTEMS = UNIT_SYSTEMS;
    Unit.UNITS = UNITS;
    return Unit;
  },
  { isClass: true }
);

// src/type/unit/function/unit.ts
var name168 = "unit";
var dependencies169 = ["typed", "Unit"];
var createUnitFunction = /* @__PURE__ */ factory(
  name168,
  dependencies169,
  ({ typed: typed2, Unit }) => {
    return typed2(name168, {
      Unit: function(x) {
        return x.clone();
      },
      string: function(x) {
        if (Unit.isValuelessUnit(x)) {
          return new Unit(null, x);
        }
        return Unit.parse(x, { allowNoUnits: true });
      },
      "number | BigNumber | Fraction | Complex, string | Unit": function(value, unit) {
        return new Unit(value, unit);
      },
      "number | BigNumber | Fraction": function(value) {
        return new Unit(value);
      },
      "Array | Matrix": typed2.referToSelf(
        (self) => (x) => deepMap2(x, self)
      )
    });
  }
);

// src/type/matrix/function/sparse.ts
var name169 = "sparse";
var dependencies170 = ["typed", "SparseMatrix"];
var createSparse = /* @__PURE__ */ factory(
  name169,
  dependencies170,
  ({ typed: typed2, SparseMatrix }) => {
    return typed2(name169, {
      "": function() {
        return new SparseMatrix([]);
      },
      string: function(datatype) {
        return new SparseMatrix([], datatype);
      },
      "Array | Matrix": function(data) {
        return new SparseMatrix(data);
      },
      "Array | Matrix, string": function(data, datatype) {
        return new SparseMatrix(data, datatype);
      }
    });
  }
);

// src/type/unit/function/createUnit.ts
var name170 = "createUnit";
var dependencies171 = ["typed", "Unit"];
var createCreateUnit = /* @__PURE__ */ factory(
  name170,
  dependencies171,
  ({ typed: typed2, Unit }) => {
    return typed2(name170, {
      // General function signature. First parameter is an object where each property is the definition of a new unit. The object keys are the unit names and the values are the definitions. The values can be objects, strings, or Units. If a property is an empty object or an empty string, a new base unit is created. The second parameter is the options.
      "Object, Object": function(obj, options) {
        return Unit.createUnit(obj, options);
      },
      // Same as above but without the options.
      Object: function(obj) {
        return Unit.createUnit(obj, {});
      },
      // Shortcut method for creating one unit.
      "string, Unit | string | Object, Object": function(name323, def, options) {
        const obj = {};
        obj[name323] = def;
        return Unit.createUnit(obj, options);
      },
      // Same as above but without the options.
      "string, Unit | string | Object": function(name323, def) {
        const obj = {};
        obj[name323] = def;
        return Unit.createUnit(obj, {});
      },
      // Without a definition, creates a base unit.
      string: function(name323) {
        const obj = {};
        obj[name323] = {};
        return Unit.createUnit(obj, {});
      }
    });
  }
);

// src/function/trigonometry/acos.ts
var name171 = "acos";
var dependencies172 = ["typed", "config", "Complex"];
var createAcos = /* @__PURE__ */ factory(
  name171,
  dependencies172,
  ({ typed: typed2, config, Complex: Complex2 }) => {
    return typed2(name171, {
      number: function(x) {
        if (x >= -1 && x <= 1 || config.predictable) {
          return Math.acos(x);
        } else {
          return new Complex2(x, 0).acos();
        }
      },
      Complex: function(x) {
        return x.acos();
      },
      BigNumber: function(x) {
        return x.acos();
      }
    });
  }
);

// src/function/trigonometry/acosh.ts
var name172 = "acosh";
var dependencies173 = ["typed", "config", "Complex"];
var createAcosh = /* @__PURE__ */ factory(
  name172,
  dependencies173,
  ({
    typed: typed2,
    config,
    Complex: Complex2
  }) => {
    return typed2(name172, {
      number: function(x) {
        if (x >= 1 || config.predictable) {
          return acoshNumber(x);
        }
        if (x <= -1) {
          return new Complex2(Math.log(Math.sqrt(x * x - 1) - x), Math.PI);
        }
        return new Complex2(x, 0).acosh();
      },
      Complex: function(x) {
        return x.acosh();
      },
      BigNumber: function(x) {
        return x.acosh();
      }
    });
  }
);

// src/function/trigonometry/acot.ts
var name173 = "acot";
var dependencies174 = ["typed", "BigNumber"];
var createAcot = /* @__PURE__ */ factory(
  name173,
  dependencies174,
  ({ typed: typed2, BigNumber }) => {
    return typed2(name173, {
      number: acotNumber,
      Complex: function(x) {
        return x.acot();
      },
      BigNumber: function(x) {
        return new BigNumber(1).div(x).atan();
      }
    });
  }
);

// src/function/trigonometry/acoth.ts
var name174 = "acoth";
var dependencies175 = ["typed", "config", "Complex", "BigNumber"];
var createAcoth = /* @__PURE__ */ factory(
  name174,
  dependencies175,
  ({
    typed: typed2,
    config,
    Complex: Complex2,
    BigNumber
  }) => {
    return typed2(name174, {
      number: function(x) {
        if (x >= 1 || x <= -1 || config.predictable) {
          return acothNumber(x);
        }
        return new Complex2(x, 0).acoth();
      },
      Complex: function(x) {
        return x.acoth();
      },
      BigNumber: function(x) {
        return new BigNumber(1).div(x).atanh();
      }
    });
  }
);

// src/function/trigonometry/acsc.ts
var name175 = "acsc";
var dependencies176 = ["typed", "config", "Complex", "BigNumber"];
var createAcsc = /* @__PURE__ */ factory(
  name175,
  dependencies176,
  ({
    typed: typed2,
    config,
    Complex: Complex2,
    BigNumber
  }) => {
    return typed2(name175, {
      number: function(x) {
        if (x <= -1 || x >= 1 || config.predictable) {
          return acscNumber(x);
        }
        return new Complex2(x, 0).acsc();
      },
      Complex: function(x) {
        return x.acsc();
      },
      BigNumber: function(x) {
        return new BigNumber(1).div(x).asin();
      }
    });
  }
);

// src/function/trigonometry/acsch.ts
var name176 = "acsch";
var dependencies177 = ["typed", "BigNumber"];
var createAcsch = /* @__PURE__ */ factory(
  name176,
  dependencies177,
  ({ typed: typed2, BigNumber }) => {
    return typed2(name176, {
      number: acschNumber,
      Complex: function(x) {
        return x.acsch();
      },
      BigNumber: function(x) {
        return new BigNumber(1).div(x).asinh();
      }
    });
  }
);

// src/function/trigonometry/asec.ts
var name177 = "asec";
var dependencies178 = ["typed", "config", "Complex", "BigNumber"];
var createAsec = /* @__PURE__ */ factory(
  name177,
  dependencies178,
  ({
    typed: typed2,
    config,
    Complex: Complex2,
    BigNumber
  }) => {
    return typed2(name177, {
      number: function(x) {
        if (x <= -1 || x >= 1 || config.predictable) {
          return asecNumber(x);
        }
        return new Complex2(x, 0).asec();
      },
      Complex: function(x) {
        return x.asec();
      },
      BigNumber: function(x) {
        return new BigNumber(1).div(x).acos();
      }
    });
  }
);

// src/function/trigonometry/asech.ts
var name178 = "asech";
var dependencies179 = ["typed", "config", "Complex", "BigNumber"];
var createAsech = /* @__PURE__ */ factory(
  name178,
  dependencies179,
  ({
    typed: typed2,
    config,
    Complex: Complex2,
    BigNumber
  }) => {
    return typed2(name178, {
      number: function(x) {
        if (x <= 1 && x >= -1 || config.predictable) {
          const xInv = 1 / x;
          if (xInv > 0 || config.predictable) {
            return asechNumber(x);
          }
          const ret = Math.sqrt(xInv * xInv - 1);
          return new Complex2(Math.log(ret - xInv), Math.PI);
        }
        return new Complex2(x, 0).asech();
      },
      Complex: function(x) {
        return x.asech();
      },
      BigNumber: function(x) {
        return new BigNumber(1).div(x).acosh();
      }
    });
  }
);

// src/function/trigonometry/asin.ts
var name179 = "asin";
var dependencies180 = ["typed", "config", "Complex"];
var createAsin = /* @__PURE__ */ factory(
  name179,
  dependencies180,
  ({ typed: typed2, config, Complex: Complex2 }) => {
    return typed2(name179, {
      number: function(x) {
        if (x >= -1 && x <= 1 || config.predictable) {
          return Math.asin(x);
        } else {
          return new Complex2(x, 0).asin();
        }
      },
      Complex: function(x) {
        return x.asin();
      },
      BigNumber: function(x) {
        return x.asin();
      }
    });
  }
);

// src/function/trigonometry/asinh.ts
var name180 = "asinh";
var dependencies181 = ["typed"];
var createAsinh = /* @__PURE__ */ factory(
  name180,
  dependencies181,
  ({ typed: typed2 }) => {
    return typed2("asinh", {
      number: asinhNumber,
      Complex: function(x) {
        return x.asinh();
      },
      BigNumber: function(x) {
        return x.asinh();
      }
    });
  }
);

// src/function/trigonometry/atan.ts
var name181 = "atan";
var dependencies182 = ["typed"];
var createAtan = /* @__PURE__ */ factory(
  name181,
  dependencies182,
  ({ typed: typed2 }) => {
    return typed2("atan", {
      number: function(x) {
        return Math.atan(x);
      },
      Complex: function(x) {
        return x.atan();
      },
      BigNumber: function(x) {
        return x.atan();
      }
    });
  }
);

// src/function/trigonometry/atan2.ts
var name182 = "atan2";
var dependencies183 = [
  "typed",
  "matrix",
  "equalScalar",
  "BigNumber",
  "DenseMatrix",
  "concat"
];
var createAtan2 = /* @__PURE__ */ factory(
  name182,
  dependencies183,
  ({
    typed: typed2,
    matrix,
    equalScalar,
    BigNumber,
    DenseMatrix,
    concat: concat2
  }) => {
    const matAlgo02xDS0 = createMatAlgo02xDS0({ typed: typed2, equalScalar });
    const matAlgo03xDSf = createMatAlgo03xDSf({ typed: typed2 });
    const matAlgo09xS0Sf = createMatAlgo09xS0Sf({ typed: typed2, equalScalar });
    const matAlgo11xS0s = createMatAlgo11xS0s({ typed: typed2, equalScalar });
    const matAlgo12xSfs = createMatAlgo12xSfs({ typed: typed2, DenseMatrix });
    const matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed2,
      matrix,
      concat: concat2
    });
    return typed2(
      name182,
      {
        "number, number": Math.atan2,
        // Complex numbers doesn't seem to have a reasonable implementation of
        // atan2(). Even Matlab removed the support, after they only calculated
        // the atan only on base of the real part of the numbers and ignored
        // the imaginary.
        "BigNumber, BigNumber": (y, x) => BigNumber.atan2(y, x)
      },
      matrixAlgorithmSuite({
        scalar: "number | BigNumber",
        SS: matAlgo09xS0Sf,
        DS: matAlgo03xDSf,
        SD: matAlgo02xDS0,
        Ss: matAlgo11xS0s,
        sS: matAlgo12xSfs
      })
    );
  }
);

// src/function/trigonometry/atanh.ts
var name183 = "atanh";
var dependencies184 = ["typed", "config", "Complex"];
var createAtanh = /* @__PURE__ */ factory(
  name183,
  dependencies184,
  ({
    typed: typed2,
    config,
    Complex: Complex2
  }) => {
    return typed2(name183, {
      number: function(x) {
        if (x <= 1 && x >= -1 || config.predictable) {
          return atanhNumber(x);
        }
        return new Complex2(x, 0).atanh();
      },
      Complex: function(x) {
        return x.atanh();
      },
      BigNumber: function(x) {
        return x.atanh();
      }
    });
  }
);

// src/function/trigonometry/trigUnit.ts
var createTrigUnit = /* @__PURE__ */ factory(
  "trigUnit",
  ["typed"],
  ({ typed: typed2 }) => ({
    Unit: typed2.referToSelf((self) => (...args) => {
      const x = args[0];
      if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
        throw new TypeError("Unit in function cot is no angle");
      }
      return typed2.find(self, x.valueType())(x.value);
    })
  })
);

// src/function/trigonometry/cos.ts
var name184 = "cos";
var dependencies185 = ["typed"];
var createCos = /* @__PURE__ */ factory(
  name184,
  dependencies185,
  ({ typed: typed2 }) => {
    const trigUnit = createTrigUnit({ typed: typed2 });
    return typed2(
      name184,
      {
        number: Math.cos,
        "Complex | BigNumber": (x) => x.cos()
      },
      trigUnit
    );
  }
);

// src/function/trigonometry/cosh.ts
var name185 = "cosh";
var dependencies186 = ["typed"];
var createCosh = /* @__PURE__ */ factory(
  name185,
  dependencies186,
  ({ typed: typed2 }) => {
    return typed2(name185, {
      number: cosh,
      "Complex | BigNumber": (x) => x.cosh()
    });
  }
);

// src/function/trigonometry/cot.ts
var name186 = "cot";
var dependencies187 = ["typed", "BigNumber"];
var createCot = /* @__PURE__ */ factory(
  name186,
  dependencies187,
  ({ typed: typed2, BigNumber }) => {
    const trigUnit = createTrigUnit({ typed: typed2 });
    return typed2(
      name186,
      {
        number: cotNumber,
        Complex: (x) => x.cot(),
        BigNumber: (x) => new BigNumber(1).div(x.tan())
      },
      trigUnit
    );
  }
);

// src/function/trigonometry/coth.ts
var name187 = "coth";
var dependencies188 = ["typed", "BigNumber"];
var createCoth = /* @__PURE__ */ factory(
  name187,
  dependencies188,
  ({ typed: typed2, BigNumber }) => {
    return typed2(name187, {
      number: cothNumber,
      Complex: (x) => x.coth(),
      BigNumber: (x) => new BigNumber(1).div(x.tanh())
    });
  }
);

// src/function/trigonometry/csc.ts
var name188 = "csc";
var dependencies189 = ["typed", "BigNumber"];
var createCsc = /* @__PURE__ */ factory(
  name188,
  dependencies189,
  ({ typed: typed2, BigNumber }) => {
    const trigUnit = createTrigUnit({ typed: typed2 });
    return typed2(
      name188,
      {
        number: cscNumber,
        Complex: (x) => x.csc(),
        BigNumber: (x) => new BigNumber(1).div(x.sin())
      },
      trigUnit
    );
  }
);

// src/function/trigonometry/csch.ts
var name189 = "csch";
var dependencies190 = ["typed", "BigNumber"];
var createCsch = /* @__PURE__ */ factory(
  name189,
  dependencies190,
  ({ typed: typed2, BigNumber }) => {
    return typed2(name189, {
      number: cschNumber,
      Complex: (x) => x.csch(),
      BigNumber: (x) => new BigNumber(1).div(x.sinh())
    });
  }
);

// src/function/trigonometry/sec.ts
var name190 = "sec";
var dependencies191 = ["typed", "BigNumber"];
var createSec = /* @__PURE__ */ factory(
  name190,
  dependencies191,
  ({ typed: typed2, BigNumber }) => {
    const trigUnit = createTrigUnit({ typed: typed2 });
    return typed2(
      name190,
      {
        number: secNumber,
        Complex: (x) => x.sec(),
        BigNumber: (x) => new BigNumber(1).div(x.cos())
      },
      trigUnit
    );
  }
);

// src/function/trigonometry/sech.ts
var name191 = "sech";
var dependencies192 = ["typed", "BigNumber"];
var createSech = /* @__PURE__ */ factory(
  name191,
  dependencies192,
  ({ typed: typed2, BigNumber }) => {
    return typed2(name191, {
      number: sechNumber,
      Complex: (x) => x.sech(),
      BigNumber: (x) => new BigNumber(1).div(x.cosh())
    });
  }
);

// src/function/trigonometry/sin.ts
var name192 = "sin";
var dependencies193 = ["typed"];
var createSin = /* @__PURE__ */ factory(
  name192,
  dependencies193,
  ({ typed: typed2 }) => {
    const trigUnit = createTrigUnit({ typed: typed2 });
    return typed2(
      name192,
      {
        number: Math.sin,
        "Complex | BigNumber": (x) => x.sin()
      },
      trigUnit
    );
  }
);

// src/function/trigonometry/sinh.ts
var name193 = "sinh";
var dependencies194 = ["typed"];
var createSinh = /* @__PURE__ */ factory(
  name193,
  dependencies194,
  ({ typed: typed2 }) => {
    return typed2(name193, {
      number: sinhNumber,
      "Complex | BigNumber": (x) => x.sinh()
    });
  }
);

// src/function/trigonometry/tan.ts
var name194 = "tan";
var dependencies195 = ["typed"];
var createTan = /* @__PURE__ */ factory(
  name194,
  dependencies195,
  ({ typed: typed2 }) => {
    const trigUnit = createTrigUnit({ typed: typed2 });
    return typed2(
      name194,
      {
        number: Math.tan,
        "Complex | BigNumber": (x) => x.tan()
      },
      trigUnit
    );
  }
);

// src/function/trigonometry/tanh.ts
var name195 = "tanh";
var dependencies196 = ["typed"];
var createTanh = /* @__PURE__ */ factory(
  name195,
  dependencies196,
  ({ typed: typed2 }) => {
    return typed2("tanh", {
      number: tanh,
      "Complex | BigNumber": (x) => x.tanh()
    });
  }
);

// src/function/set/setCartesian.ts
var name196 = "setCartesian";
var dependencies197 = [
  "typed",
  "size",
  "subset",
  "compareNatural",
  "Index",
  "DenseMatrix"
];
var createSetCartesian = /* @__PURE__ */ factory(
  name196,
  dependencies197,
  ({
    typed: typed2,
    size,
    subset,
    compareNatural,
    Index: Index2,
    DenseMatrix
  }) => {
    return typed2(name196, {
      "Array | Matrix, Array | Matrix": function(a1, a2) {
        let result = [];
        if (subset(size(a1), new Index2(0)) !== 0 && subset(size(a2), new Index2(0)) !== 0) {
          const b1 = flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(
            compareNatural
          );
          const b2 = flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(
            compareNatural
          );
          result = [];
          for (let i = 0; i < b1.length; i++) {
            for (let j = 0; j < b2.length; j++) {
              result.push([b1[i], b2[j]]);
            }
          }
        }
        if (Array.isArray(a1) && Array.isArray(a2)) {
          return result;
        }
        return new DenseMatrix(result);
      }
    });
  }
);

// src/function/set/setDifference.ts
var name197 = "setDifference";
var dependencies198 = [
  "typed",
  "size",
  "subset",
  "compareNatural",
  "Index",
  "DenseMatrix"
];
var createSetDifference = /* @__PURE__ */ factory(
  name197,
  dependencies198,
  ({ typed: typed2, size, subset, compareNatural, Index: Index2, DenseMatrix }) => {
    return typed2(name197, {
      "Array | Matrix, Array | Matrix": function(a1, a2) {
        let result;
        if (subset(size(a1), new Index2(0)) === 0) {
          result = [];
        } else if (subset(size(a2), new Index2(0)) === 0) {
          return flatten(a1.toArray());
        } else {
          const b1 = identify(
            flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural)
          );
          const b2 = identify(
            flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural)
          );
          result = [];
          let inb2;
          for (let i = 0; i < b1.length; i++) {
            inb2 = false;
            for (let j = 0; j < b2.length; j++) {
              if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
                inb2 = true;
                break;
              }
            }
            if (!inb2) {
              result.push(b1[i]);
            }
          }
        }
        if (Array.isArray(a1) && Array.isArray(a2)) {
          return generalize(result);
        }
        return new DenseMatrix(generalize(result));
      }
    });
  }
);

// src/function/set/setDistinct.ts
var name198 = "setDistinct";
var dependencies199 = [
  "typed",
  "size",
  "subset",
  "compareNatural",
  "Index",
  "DenseMatrix"
];
var createSetDistinct = /* @__PURE__ */ factory(
  name198,
  dependencies199,
  ({ typed: typed2, size, subset, compareNatural, Index: Index2, DenseMatrix }) => {
    return typed2(name198, {
      "Array | Matrix": function(a) {
        let result;
        if (subset(size(a), new Index2(0)) === 0) {
          result = [];
        } else {
          const b = flatten(Array.isArray(a) ? a : a.toArray()).sort(
            compareNatural
          );
          result = [];
          result.push(b[0]);
          for (let i = 1; i < b.length; i++) {
            if (compareNatural(b[i], b[i - 1]) !== 0) {
              result.push(b[i]);
            }
          }
        }
        if (Array.isArray(a)) {
          return result;
        }
        return new DenseMatrix(result);
      }
    });
  }
);

// src/function/set/setIntersect.ts
var name199 = "setIntersect";
var dependencies200 = [
  "typed",
  "size",
  "subset",
  "compareNatural",
  "Index",
  "DenseMatrix"
];
var createSetIntersect = /* @__PURE__ */ factory(
  name199,
  dependencies200,
  ({ typed: typed2, size, subset, compareNatural, Index: Index2, DenseMatrix }) => {
    return typed2(name199, {
      "Array | Matrix, Array | Matrix": function(a1, a2) {
        let result;
        if (subset(size(a1), new Index2(0)) === 0 || subset(size(a2), new Index2(0)) === 0) {
          result = [];
        } else {
          const b1 = identify(
            flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural)
          );
          const b2 = identify(
            flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural)
          );
          result = [];
          for (let i = 0; i < b1.length; i++) {
            for (let j = 0; j < b2.length; j++) {
              if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
                result.push(b1[i]);
                break;
              }
            }
          }
        }
        if (Array.isArray(a1) && Array.isArray(a2)) {
          return generalize(result);
        }
        return new DenseMatrix(generalize(result));
      }
    });
  }
);

// src/function/set/setIsSubset.ts
var name200 = "setIsSubset";
var dependencies201 = ["typed", "size", "subset", "compareNatural", "Index"];
var createSetIsSubset = /* @__PURE__ */ factory(
  name200,
  dependencies201,
  ({ typed: typed2, size, subset, compareNatural, Index: Index2 }) => {
    return typed2(name200, {
      "Array | Matrix, Array | Matrix": function(a1, a2) {
        if (subset(size(a1), new Index2(0)) === 0) {
          return true;
        } else if (subset(size(a2), new Index2(0)) === 0) {
          return false;
        }
        const b1 = identify(
          flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural)
        );
        const b2 = identify(
          flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural)
        );
        let inb2;
        for (let i = 0; i < b1.length; i++) {
          inb2 = false;
          for (let j = 0; j < b2.length; j++) {
            if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
              inb2 = true;
              break;
            }
          }
          if (inb2 === false) {
            return false;
          }
        }
        return true;
      }
    });
  }
);

// src/function/set/setMultiplicity.ts
var name201 = "setMultiplicity";
var dependencies202 = ["typed", "size", "subset", "compareNatural", "Index"];
var createSetMultiplicity = /* @__PURE__ */ factory(
  name201,
  dependencies202,
  ({ typed: typed2, size, subset, compareNatural, Index: Index2 }) => {
    return typed2(name201, {
      "number | BigNumber | Fraction | Complex, Array | Matrix": function(e2, a) {
        if (subset(size(a), new Index2(0)) === 0) {
          return 0;
        }
        const b = flatten(Array.isArray(a) ? a : a.toArray());
        let count = 0;
        for (let i = 0; i < b.length; i++) {
          if (compareNatural(b[i], e2) === 0) {
            count++;
          }
        }
        return count;
      }
    });
  }
);

// src/function/set/setPowerset.ts
var name202 = "setPowerset";
var dependencies203 = ["typed", "size", "subset", "compareNatural", "Index"];
var createSetPowerset = /* @__PURE__ */ factory(
  name202,
  dependencies203,
  ({ typed: typed2, size, subset, compareNatural, Index: Index2 }) => {
    return typed2(name202, {
      "Array | Matrix": function(a) {
        if (subset(size(a), new Index2(0)) === 0) {
          return [];
        }
        const b = flatten(Array.isArray(a) ? a : a.toArray()).sort(
          compareNatural
        );
        const result = [];
        let number = 0;
        while (number.toString(2).length <= b.length) {
          result.push(_subset(b, number.toString(2).split("").reverse()));
          number++;
        }
        return _sort(result);
      }
    });
    function _subset(array, bitarray) {
      const result = [];
      for (let i = 0; i < bitarray.length; i++) {
        if (bitarray[i] === "1") {
          result.push(array[i]);
        }
      }
      return result;
    }
    function _sort(array) {
      let temp = [];
      for (let i = array.length - 1; i > 0; i--) {
        for (let j = 0; j < i; j++) {
          if (array[j].length > array[j + 1].length) {
            temp = array[j];
            array[j] = array[j + 1];
            array[j + 1] = temp;
          }
        }
      }
      return array;
    }
  }
);

// src/function/set/setSize.ts
var name203 = "setSize";
var dependencies204 = ["typed", "compareNatural"];
var createSetSize = /* @__PURE__ */ factory(
  name203,
  dependencies204,
  ({ typed: typed2, compareNatural }) => {
    return typed2(name203, {
      "Array | Matrix": function(a) {
        return Array.isArray(a) ? flatten(a).length : flatten(a.toArray()).length;
      },
      "Array | Matrix, boolean": function(a, unique) {
        if (unique === false || a.length === 0) {
          return Array.isArray(a) ? flatten(a).length : flatten(a.toArray()).length;
        } else {
          const b = flatten(Array.isArray(a) ? a : a.toArray()).sort(
            compareNatural
          );
          let count = 1;
          for (let i = 1; i < b.length; i++) {
            if (compareNatural(b[i], b[i - 1]) !== 0) {
              count++;
            }
          }
          return count;
        }
      }
    });
  }
);

// src/function/set/setSymDifference.ts
var name204 = "setSymDifference";
var dependencies205 = [
  "typed",
  "size",
  "concat",
  "subset",
  "setDifference",
  "Index"
];
var createSetSymDifference = /* @__PURE__ */ factory(
  name204,
  dependencies205,
  ({
    typed: typed2,
    size,
    concat: concat2,
    subset,
    setDifference,
    Index: Index2
  }) => {
    return typed2(name204, {
      "Array | Matrix, Array | Matrix": function(a1, a2) {
        if (subset(size(a1), new Index2(0)) === 0) {
          return flatten(a2);
        } else if (subset(size(a2), new Index2(0)) === 0) {
          return flatten(a1);
        }
        const b1 = flatten(a1);
        const b2 = flatten(a2);
        return concat2(setDifference(b1, b2), setDifference(b2, b1));
      }
    });
  }
);

// src/function/set/setUnion.ts
var name205 = "setUnion";
var dependencies206 = [
  "typed",
  "size",
  "concat",
  "subset",
  "setIntersect",
  "setSymDifference",
  "Index"
];
var createSetUnion = /* @__PURE__ */ factory(
  name205,
  dependencies206,
  ({
    typed: typed2,
    size,
    concat: concat2,
    subset,
    setIntersect,
    setSymDifference,
    Index: Index2
  }) => {
    return typed2(name205, {
      "Array | Matrix, Array | Matrix": function(a1, a2) {
        if (subset(size(a1), new Index2(0)) === 0) {
          return flatten(a2);
        } else if (subset(size(a2), new Index2(0)) === 0) {
          return flatten(a1);
        }
        const b1 = flatten(a1);
        const b2 = flatten(a2);
        return concat2(setSymDifference(b1, b2), setIntersect(b1, b2));
      }
    });
  }
);

// src/function/arithmetic/add.ts
var name206 = "add";
var dependencies207 = [
  "typed",
  "matrix",
  "addScalar",
  "equalScalar",
  "DenseMatrix",
  "SparseMatrix",
  "concat",
  "nodeOperations"
];
var createAdd = /* @__PURE__ */ factory(
  name206,
  dependencies207,
  ({
    typed: typed2,
    matrix,
    addScalar,
    equalScalar,
    DenseMatrix,
    SparseMatrix: _SparseMatrix,
    concat: concat2,
    nodeOperations
  }) => {
    const matAlgo01xDSid = createMatAlgo01xDSid({ typed: typed2 });
    const matAlgo04xSidSid = createMatAlgo04xSidSid({ typed: typed2, equalScalar });
    const matAlgo10xSids = createMatAlgo10xSids({ typed: typed2, DenseMatrix });
    const matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed2,
      matrix,
      concat: concat2
    });
    return typed2(
      name206,
      {
        // =========================================================================
        // NODE SIGNATURES - Must be FIRST (before 'any, any')
        // When any operand is a Node, return an OperatorNode for symbolic computation
        // =========================================================================
        "Node, Node": (x, y) => nodeOperations.createBinaryNode("+", "add", x, y),
        "number, Node": (x, y) => nodeOperations.createBinaryNode("+", "add", x, y),
        "Node, number": (x, y) => nodeOperations.createBinaryNode("+", "add", x, y),
        "BigNumber, Node": (x, y) => nodeOperations.createBinaryNode("+", "add", x, y),
        "Node, BigNumber": (x, y) => nodeOperations.createBinaryNode("+", "add", x, y),
        "Complex, Node": (x, y) => nodeOperations.createBinaryNode("+", "add", x, y),
        "Node, Complex": (x, y) => nodeOperations.createBinaryNode("+", "add", x, y),
        "Fraction, Node": (x, y) => nodeOperations.createBinaryNode("+", "add", x, y),
        "Node, Fraction": (x, y) => nodeOperations.createBinaryNode("+", "add", x, y),
        "Unit, Node": (x, y) => nodeOperations.createBinaryNode("+", "add", x, y),
        "Node, Unit": (x, y) => nodeOperations.createBinaryNode("+", "add", x, y),
        "string, Node": (x, y) => nodeOperations.createBinaryNode("+", "add", x, y),
        "Node, string": (x, y) => nodeOperations.createBinaryNode("+", "add", x, y),
        // =========================================================================
        // EXISTING SIGNATURES - Keep after Node signatures
        // =========================================================================
        "any, any": addScalar,
        "any, any, ...any": typed2.referToSelf(
          (self) => (x, y, rest) => {
            let result = self(x, y);
            for (let i = 0; i < rest.length; i++) {
              result = self(result, rest[i]);
            }
            return result;
          }
        )
      },
      matrixAlgorithmSuite({
        elop: addScalar,
        DS: matAlgo01xDSid,
        SS: matAlgo04xSidSid,
        Ss: matAlgo10xSids
      })
    );
  }
);

// src/function/arithmetic/hypot.ts
var name207 = "hypot";
var dependencies208 = [
  "typed",
  "abs",
  "addScalar",
  "divideScalar",
  "multiplyScalar",
  "sqrt",
  "smaller",
  "isPositive"
];
var createHypot = /* @__PURE__ */ factory(
  name207,
  dependencies208,
  ({
    typed: typed2,
    abs,
    addScalar,
    divideScalar,
    multiplyScalar,
    sqrt,
    smaller,
    isPositive
  }) => {
    return typed2(name207, {
      "... number | BigNumber": _hypot,
      Array: _hypot,
      Matrix: (M) => _hypot(flatten(M.toArray(), true))
    });
    function _hypot(args) {
      let result = 0;
      let largest = 0;
      for (let i = 0; i < args.length; i++) {
        if (isComplex(args[i])) {
          throw new TypeError("Unexpected type of argument to hypot");
        }
        const value = abs(args[i]);
        if (smaller(largest, value)) {
          result = multiplyScalar(
            result,
            multiplyScalar(
              divideScalar(largest, value),
              divideScalar(largest, value)
            )
          );
          result = addScalar(result, 1);
          largest = value;
        } else {
          result = addScalar(
            result,
            isPositive(value) ? multiplyScalar(
              divideScalar(value, largest),
              divideScalar(value, largest)
            ) : value
          );
        }
      }
      return multiplyScalar(largest, sqrt(result));
    }
  }
);

// src/function/arithmetic/norm.ts
var name208 = "norm";
var dependencies209 = [
  "typed",
  "abs",
  "add",
  "pow",
  "conj",
  "sqrt",
  "multiply",
  "equalScalar",
  "larger",
  "smaller",
  "matrix",
  "ctranspose",
  "eigs"
];
var createNorm = /* @__PURE__ */ factory(
  name208,
  dependencies209,
  ({
    typed: typed2,
    abs,
    add,
    pow,
    conj,
    sqrt,
    multiply,
    equalScalar,
    larger,
    smaller,
    matrix,
    ctranspose,
    eigs
  }) => {
    return typed2(name208, {
      number: Math.abs,
      Complex: function(x) {
        return x.abs();
      },
      BigNumber: function(x) {
        return x.abs();
      },
      boolean: function(x) {
        return Math.abs(x ? 1 : 0);
      },
      Array: function(x) {
        return _norm(matrix(x), 2);
      },
      Matrix: function(x) {
        return _norm(x, 2);
      },
      "Array, number | BigNumber | string": function(x, p) {
        return _norm(matrix(x), p);
      },
      "Matrix, number | BigNumber | string": function(x, p) {
        return _norm(x, p);
      }
    });
    function _vectorNormPlusInfinity(x) {
      let pinf = 0;
      x.forEach(function(value) {
        const v = abs(value);
        if (larger(v, pinf)) {
          pinf = v;
        }
      }, true);
      return pinf;
    }
    function _vectorNormMinusInfinity(x) {
      let ninf;
      x.forEach(function(value) {
        const v = abs(value);
        if (!ninf || smaller(v, ninf)) {
          ninf = v;
        }
      }, true);
      return ninf || 0;
    }
    function _vectorNorm(x, p) {
      if (p === Number.POSITIVE_INFINITY || p === "inf") {
        return _vectorNormPlusInfinity(x);
      }
      if (p === Number.NEGATIVE_INFINITY || p === "-inf") {
        return _vectorNormMinusInfinity(x);
      }
      if (p === "fro") {
        return _norm(x, 2);
      }
      if (typeof p === "number" && !isNaN(p)) {
        if (!equalScalar(p, 0)) {
          let n = 0;
          x.forEach(function(value) {
            n = add(pow(abs(value), p), n);
          }, true);
          return pow(n, 1 / p);
        }
        return Number.POSITIVE_INFINITY;
      }
      throw new Error("Unsupported parameter value");
    }
    function _matrixNormFrobenius(x) {
      let fro = 0;
      x.forEach(function(value) {
        fro = add(fro, multiply(value, conj(value)));
      });
      return abs(sqrt(fro));
    }
    function _matrixNormOne(x) {
      const c = [];
      let maxc = 0;
      x.forEach(function(value, index) {
        const j = index[1];
        const cj = add(c[j] || 0, abs(value));
        if (larger(cj, maxc)) {
          maxc = cj;
        }
        c[j] = cj;
      }, true);
      return maxc;
    }
    function _matrixNormTwo(x) {
      const sizeX = x.size();
      if (sizeX[0] !== sizeX[1]) {
        throw new RangeError("Invalid matrix dimensions");
      }
      const tx = ctranspose(x);
      const squaredX = multiply(tx, x);
      const eigenVals = eigs(squaredX).values.toArray();
      const rho = eigenVals[eigenVals.length - 1];
      return abs(sqrt(rho));
    }
    function _matrixNormInfinity(x) {
      const r = [];
      let maxr = 0;
      x.forEach(function(value, index) {
        const i = index[0];
        const ri = add(r[i] || 0, abs(value));
        if (larger(ri, maxr)) {
          maxr = ri;
        }
        r[i] = ri;
      }, true);
      return maxr;
    }
    function _matrixNorm(x, p) {
      if (p === 1) {
        return _matrixNormOne(x);
      }
      if (p === Number.POSITIVE_INFINITY || p === "inf") {
        return _matrixNormInfinity(x);
      }
      if (p === "fro") {
        return _matrixNormFrobenius(x);
      }
      if (p === 2) {
        return _matrixNormTwo(x);
      }
      throw new Error("Unsupported parameter value " + p);
    }
    function _norm(x, p) {
      const sizeX = x.size();
      if (sizeX.length === 1) {
        return _vectorNorm(x, p);
      }
      if (sizeX.length === 2) {
        if (sizeX[0] && sizeX[1]) {
          return _matrixNorm(x, p);
        } else {
          throw new RangeError("Invalid matrix dimensions");
        }
      }
      throw new Error("Unsupported matrix dimensions");
    }
  }
);

// src/function/matrix/dot.ts
var name209 = "dot";
var dependencies210 = ["typed", "addScalar", "multiplyScalar", "conj", "size"];
var createDot = /* @__PURE__ */ factory(
  name209,
  dependencies210,
  ({ typed: typed2, addScalar, multiplyScalar, conj, size }) => {
    return typed2(name209, {
      "Array | DenseMatrix, Array | DenseMatrix": _denseDot,
      "SparseMatrix, SparseMatrix": _sparseDot
    });
    function _validateDim(x, y) {
      const xSize = _size(x);
      const ySize = _size(y);
      let xLen, yLen;
      if (xSize.length === 1) {
        xLen = xSize[0];
      } else if (xSize.length === 2 && xSize[1] === 1) {
        xLen = xSize[0];
      } else {
        throw new RangeError(
          "Expected a column vector, instead got a matrix of size (" + xSize.join(", ") + ")"
        );
      }
      if (ySize.length === 1) {
        yLen = ySize[0];
      } else if (ySize.length === 2 && ySize[1] === 1) {
        yLen = ySize[0];
      } else {
        throw new RangeError(
          "Expected a column vector, instead got a matrix of size (" + ySize.join(", ") + ")"
        );
      }
      if (xLen !== yLen)
        throw new RangeError(
          "Vectors must have equal length (" + xLen + " != " + yLen + ")"
        );
      if (xLen === 0)
        throw new RangeError(
          "Cannot calculate the dot product of empty vectors"
        );
      return xLen;
    }
    function _denseDot(a, b) {
      const N = _validateDim(a, b);
      const adata = isMatrix(a) ? a._data : a;
      const adt = isMatrix(a) ? a._datatype || a.getDataType() : void 0;
      const bdata = isMatrix(b) ? b._data : b;
      const bdt = isMatrix(b) ? b._datatype || b.getDataType() : void 0;
      const aIsColumn = _size(a).length === 2;
      const bIsColumn = _size(b).length === 2;
      let add = addScalar;
      let mul = multiplyScalar;
      if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
        const dt = adt;
        add = typed2.find(addScalar, [dt, dt]);
        mul = typed2.find(multiplyScalar, [dt, dt]);
      }
      if (!aIsColumn && !bIsColumn) {
        let c = mul(conj(adata[0]), bdata[0]);
        for (let i = 1; i < N; i++) {
          c = add(c, mul(conj(adata[i]), bdata[i]));
        }
        return c;
      }
      if (!aIsColumn && bIsColumn) {
        let c = mul(conj(adata[0]), bdata[0][0]);
        for (let i = 1; i < N; i++) {
          c = add(c, mul(conj(adata[i]), bdata[i][0]));
        }
        return c;
      }
      if (aIsColumn && !bIsColumn) {
        let c = mul(conj(adata[0][0]), bdata[0]);
        for (let i = 1; i < N; i++) {
          c = add(c, mul(conj(adata[i][0]), bdata[i]));
        }
        return c;
      }
      if (aIsColumn && bIsColumn) {
        let c = mul(conj(adata[0][0]), bdata[0][0]);
        for (let i = 1; i < N; i++) {
          c = add(
            c,
            mul(conj(adata[i][0]), bdata[i][0])
          );
        }
        return c;
      }
    }
    function _sparseDot(x, y) {
      _validateDim(x, y);
      const xindex = x._index;
      const xvalues = x._values;
      const yindex = y._index;
      const yvalues = y._values;
      let c = 0;
      const add = addScalar;
      const mul = multiplyScalar;
      let i = 0;
      let j = 0;
      while (i < xindex.length && j < yindex.length) {
        const I = xindex[i];
        const J = yindex[j];
        if (I < J) {
          i++;
          continue;
        }
        if (I > J) {
          j++;
          continue;
        }
        if (I === J) {
          c = add(c, mul(xvalues[i], yvalues[j]));
          i++;
          j++;
        }
      }
      return c;
    }
    function _size(x) {
      return isMatrix(x) ? x.size() : size(x);
    }
  }
);

// src/function/matrix/trace.ts
var name210 = "trace";
var dependencies211 = ["typed", "matrix", "add"];
var createTrace = /* @__PURE__ */ factory(
  name210,
  dependencies211,
  ({ typed: typed2, matrix, add }) => {
    return typed2("trace", {
      Array: function _arrayTrace(x) {
        return _denseTrace(matrix(x));
      },
      SparseMatrix: _sparseTrace,
      DenseMatrix: _denseTrace,
      any: clone
    });
    function _denseTrace(m) {
      const size = m._size;
      const data = m._data;
      switch (size.length) {
        case 1:
          if (size[0] === 1) {
            return clone(data[0]);
          }
          throw new RangeError(
            "Matrix must be square (size: " + format3(size, {}) + ")"
          );
        case 2: {
          const rows = size[0];
          const cols = size[1];
          if (rows === cols) {
            let sum = 0;
            for (let i = 0; i < rows; i++) {
              sum = add(sum, data[i][i]);
            }
            return sum;
          } else {
            throw new RangeError(
              "Matrix must be square (size: " + format3(size, {}) + ")"
            );
          }
        }
        default:
          throw new RangeError(
            "Matrix must be two dimensional (size: " + format3(size, {}) + ")"
          );
      }
    }
    function _sparseTrace(m) {
      const values = m._values;
      const index = m._index;
      const ptr = m._ptr;
      const size = m._size;
      const rows = size[0];
      const columns = size[1];
      if (rows === columns) {
        let sum = 0;
        if (values && values.length > 0 && index && ptr) {
          for (let j = 0; j < columns; j++) {
            const k0 = ptr[j];
            const k1 = ptr[j + 1];
            for (let k = k0; k < k1; k++) {
              const i = index[k];
              if (i === j) {
                sum = add(sum, values[k]);
                break;
              }
              if (i > j) {
                break;
              }
            }
          }
        }
        return sum;
      }
      throw new RangeError(
        "Matrix must be square (size: " + format3(size, {}) + ")"
      );
    }
  }
);

// src/type/matrix/function/index.ts
var name211 = "index";
var dependencies212 = ["typed", "Index"];
var createIndex = /* @__PURE__ */ factory(
  name211,
  dependencies212,
  ({ typed: typed2, Index: Index2 }) => {
    return typed2(name211, {
      "...number | string | BigNumber | Range | Array | Matrix": function(args) {
        const ranges = args.map(function(arg) {
          if (isBigNumber(arg)) {
            return arg.toNumber();
          } else if (isArray(arg) || isMatrix(arg)) {
            return arg.map(function(elem) {
              return isBigNumber(elem) ? elem.toNumber() : elem;
            });
          } else {
            return arg;
          }
        });
        return new Index2(...ranges);
      }
    });
  }
);

// src/expression/keywords.ts
var keywords = /* @__PURE__ */ new Set(["end"]);

// src/expression/node/Node.ts
var name212 = "Node";
var dependencies213 = ["mathWithTransform"];
var createNode = /* @__PURE__ */ factory(
  name212,
  dependencies213,
  ({ mathWithTransform }) => {
    function _validateScope(scope) {
      for (const symbol of [...keywords]) {
        if (scope.has(symbol)) {
          throw new Error(
            'Scope contains an illegal symbol, "' + symbol + '" is a reserved keyword'
          );
        }
      }
    }
    class Node {
      get type() {
        return "Node";
      }
      get isNode() {
        return true;
      }
      /**
       * Evaluate the node
       * @param {Object} [scope]  Scope to read/write variables
       * @return {*}              Returns the result
       */
      evaluate(scope) {
        return this.compile().evaluate(scope);
      }
      /**
       * Compile the node into an optimized, evauatable JavaScript function
       * @return {{evaluate: function([Object])}} object
       *                Returns an object with a function 'evaluate',
       *                which can be invoked as expr.evaluate([scope: Object]),
       *                where scope is an optional object with
       *                variables.
       */
      compile() {
        const expr = this._compile(mathWithTransform, {});
        const args = {};
        const context = null;
        function evaluate(scope) {
          const s = createMap(scope);
          _validateScope(s);
          return expr(s, args, context);
        }
        return {
          evaluate
        };
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      _compile(_math, _argNames) {
        throw new Error(
          "Method _compile must be implemented by type " + this.type
        );
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(_callback) {
        throw new Error("Cannot run forEach on a Node interface");
      }
      /**
       * Create a new Node whose children are the results of calling the
       * provided callback function for each child of the original node.
       * @param {function(child: Node, path: string, parent: Node): Node} callback
       * @returns {OperatorNode} Returns a transformed copy of the node
       */
      map(_callback) {
        throw new Error("Cannot run map on a Node interface");
      }
      /**
       * Validate whether an object is a Node, for use with map
       * @param {Node} node
       * @returns {Node} Returns the input if it's a node, else throws an Error
       * @protected
       */
      _ifNode(node) {
        if (!isNode(node)) {
          throw new TypeError("Callback function must return a Node");
        }
        return node;
      }
      /**
       * Recursively traverse all nodes in a node tree. Executes given callback for
       * this node and each of its child nodes.
       * @param {function(node: Node, path: string, parent: Node)} callback
       *          A callback called for every node in the node tree.
       */
      traverse(callback) {
        callback(this, null, null);
        function _traverse(node, callback2) {
          node.forEach(function(child, path, parent) {
            callback2(child, path, parent);
            _traverse(child, callback2);
          });
        }
        _traverse(this, callback);
      }
      /**
       * Recursively transform a node tree via a transform function.
       *
       * For example, to replace all nodes of type SymbolNode having name 'x' with
       * a ConstantNode with value 2:
       *
       *     const res = Node.transform(function (node, path, parent) {
       *       if (node && node.isSymbolNode) && (node.name === 'x')) {
       *         return new ConstantNode(2)
       *       }
       *       else {
       *         return node
       *       }
       *     })
       *
       * @param {function(node: Node, path: string, parent: Node) : Node} callback
       *          A mapping function accepting a node, and returning
       *          a replacement for the node or the original node. The "signature"
       *          of the callback must be:
       *          callback(node: Node, index: string, parent: Node) : Node
       * @return {Node} Returns the original node or its replacement
       */
      transform(callback) {
        function _transform(child, path, parent) {
          const replacement = callback(child, path, parent);
          if (replacement !== child) {
            return replacement;
          }
          return child.map(_transform);
        }
        return _transform(this, null, null);
      }
      /**
       * Find any node in the node tree matching given filter function. For
       * example, to find all nodes of type SymbolNode having name 'x':
       *
       *     const results = Node.filter(function (node) {
       *       return (node && node.isSymbolNode) && (node.name === 'x')
       *     })
       *
       * @param {function(node: Node, path: string, parent: Node) : Node} callback
       *            A test function returning true when a node matches, and false
       *            otherwise. Function signature:
       *            callback(node: Node, index: string, parent: Node) : boolean
       * @return {Node[]} nodes
       *            An array with nodes matching given filter criteria
       */
      filter(callback) {
        const nodes = [];
        this.traverse(function(node, path, parent) {
          if (callback(node, path, parent)) {
            nodes.push(node);
          }
        });
        return nodes;
      }
      /**
       * Create a shallow clone of this node
       * @return {Node}
       */
      clone() {
        throw new Error("Cannot clone a Node interface");
      }
      /**
       * Create a deep clone of this node
       * @return {Node}
       */
      cloneDeep() {
        return this.map(function(node) {
          return node.cloneDeep();
        });
      }
      /**
       * Deep compare this node with another node.
       * @param {Node} other
       * @return {boolean} Returns true when both nodes are of the same type and
       *                   contain the same values (as do their childs)
       */
      equals(other) {
        return other ? this.type === other.type && deepStrictEqual(this, other) : false;
      }
      /**
       * Get string representation. (wrapper function)
       *
       * This function can get an object of the following form:
       * {
       *    handler: //This can be a callback function of the form
       *             // "function callback(node, options)"or
       *             // a map that maps function names (used in FunctionNodes)
       *             // to callbacks
       *    parenthesis: "keep" //the parenthesis option (This is optional)
       * }
       *
       * @param {Object} [options]
       * @return {string}
       */
      toString(options) {
        const customString = this._getCustomString(options);
        if (typeof customString !== "undefined") {
          return customString;
        }
        return this._toString(options);
      }
      /**
       * Internal function to generate the string output.
       * This has to be implemented by every Node
       *
       * @throws {Error}
       */
      _toString(_options) {
        throw new Error("_toString not implemented for " + this.type);
      }
      /**
       * Get a JSON representation of the node
       * Both .toJSON() and the static .fromJSON(json) should be implemented by all
       * implementations of Node
       * @returns {Object}
       */
      toJSON() {
        throw new Error(
          "Cannot serialize object: toJSON not implemented by " + this.type
        );
      }
      /**
       * Get HTML representation. (wrapper function)
       *
       * This function can get an object of the following form:
       * {
       *    handler: //This can be a callback function of the form
       *             // "function callback(node, options)" or
       *             // a map that maps function names (used in FunctionNodes)
       *             // to callbacks
       *    parenthesis: "keep" //the parenthesis option (This is optional)
       * }
       *
       * @param {Object} [options]
       * @return {string}
       */
      toHTML(options) {
        const customString = this._getCustomString(options);
        if (typeof customString !== "undefined") {
          return customString;
        }
        return this._toHTML(options);
      }
      /**
       * Internal function to generate the HTML output.
       * This has to be implemented by every Node
       *
       * @throws {Error}
       */
      _toHTML(_options) {
        throw new Error("_toHTML not implemented for " + this.type);
      }
      /**
       * Get LaTeX representation. (wrapper function)
       *
       * This function can get an object of the following form:
       * {
       *    handler: //This can be a callback function of the form
       *             // "function callback(node, options)"or
       *             // a map that maps function names (used in FunctionNodes)
       *             // to callbacks
       *    parenthesis: "keep" //the parenthesis option (This is optional)
       * }
       *
       * @param {Object} [options]
       * @return {string}
       */
      toTex(options) {
        const customString = this._getCustomString(options);
        if (typeof customString !== "undefined") {
          return customString;
        }
        return this._toTex(options);
      }
      /**
       * Internal function to generate the LaTeX output.
       * This has to be implemented by every Node
       *
       * @param {Object} [options]
       * @throws {Error}
       */
      _toTex(_options) {
        throw new Error("_toTex not implemented for " + this.type);
      }
      /**
       * Helper used by `to...` functions.
       */
      _getCustomString(options) {
        if (options && typeof options === "object") {
          switch (typeof options.handler) {
            case "object":
            case "undefined":
              return;
            case "function":
              return options.handler(this, options);
            default:
              throw new TypeError("Object or function expected as callback");
          }
        }
      }
      /**
       * Get identifier.
       * @return {string}
       */
      getIdentifier() {
        return this.type;
      }
      /**
       * Get the content of the current Node.
       * @return {Node} node
       **/
      getContent() {
        return this;
      }
    }
    return Node;
  },
  { isClass: true, isNode: true }
);

// src/expression/transform/utils/errorTransform.ts
function errorTransform(err) {
  if (err && err.isIndexError) {
    const indexErr = err;
    return new IndexError(
      indexErr.index + 1,
      indexErr.min + 1,
      indexErr.max !== void 0 ? indexErr.max + 1 : void 0
    );
  }
  return err;
}

// src/expression/node/utils/access.ts
function accessFactory({ subset }) {
  return function access(object, index) {
    try {
      if (Array.isArray(object)) {
        return subset(object, index);
      } else if (object && typeof object.subset === "function") {
        return object.subset(index);
      } else if (typeof object === "string") {
        return subset(object, index);
      } else if (typeof object === "object") {
        if (!index.isObjectProperty()) {
          throw new TypeError("Cannot apply a numeric index as object property");
        }
        return getSafeProperty(object, index.getObjectProperty());
      } else {
        throw new TypeError("Cannot apply index: unsupported type of object");
      }
    } catch (err) {
      throw errorTransform(err);
    }
  };
}

// src/expression/node/AccessorNode.ts
var name213 = "AccessorNode";
var dependencies214 = ["subset", "Node"];
var createAccessorNode = /* @__PURE__ */ factory(
  name213,
  dependencies214,
  ({
    subset,
    Node
  }) => {
    const access = accessFactory({ subset });
    function needParenthesis(node) {
      return !(isAccessorNode(node) || isArrayNode(node) || isConstantNode(node) || isFunctionNode(node) || isObjectNode(node) || isParenthesisNode(node) || isSymbolNode(node));
    }
    class AccessorNode extends Node {
      /**
       * @constructor AccessorNode
       * @extends {Node}
       * Access an object property or get a matrix subset
       *
       * @param {Node} object                 The object from which to retrieve
       *                                      a property or subset.
       * @param {IndexNode} index             IndexNode containing ranges
       * @param {boolean} [optionalChaining=false]
       *     Optional property, if the accessor was written as optional-chaining
       *     using `a?.b`, or `a?.["b"] with bracket notation.
       *     Forces evaluate to undefined if the given object is undefined or null.
       */
      constructor(object, index, optionalChaining = false) {
        super();
        if (!isNode(object)) {
          throw new TypeError('Node expected for parameter "object"');
        }
        if (!isIndexNode(index)) {
          throw new TypeError('IndexNode expected for parameter "index"');
        }
        this.object = object;
        this.index = index;
        this.optionalChaining = optionalChaining;
      }
      // readonly property name
      get name() {
        if (this.index) {
          return this.index.isObjectProperty() ? this.index.getObjectProperty() : "";
        } else {
          return this.object.name || "";
        }
      }
      get type() {
        return name213;
      }
      get isAccessorNode() {
        return true;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      _compile(math, argNames) {
        const evalObject = this.object._compile(math, argNames);
        const evalIndex = this.index._compile(math, argNames);
        const optionalChaining = this.optionalChaining;
        const prevOptionalChaining = isAccessorNode(this.object) && this.object.optionalChaining;
        if (this.index.isObjectProperty()) {
          const prop = this.index.getObjectProperty();
          return function evalAccessorNode(scope, args, context) {
            const ctx = context || {};
            const object = evalObject(scope, args, ctx);
            if (optionalChaining && object == null) {
              ctx.optionalShortCircuit = true;
              return void 0;
            }
            if (prevOptionalChaining && ctx?.optionalShortCircuit) {
              return void 0;
            }
            return getSafeProperty(object, prop);
          };
        } else {
          return function evalAccessorNode(scope, args, context) {
            const ctx = context || {};
            const object = evalObject(scope, args, ctx);
            if (optionalChaining && object == null) {
              ctx.optionalShortCircuit = true;
              return void 0;
            }
            if (prevOptionalChaining && ctx?.optionalShortCircuit) {
              return void 0;
            }
            const index = evalIndex(scope, args, object);
            return access(object, index);
          };
        }
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(callback) {
        callback(this.object, "object", this);
        callback(this.index, "index", this);
      }
      /**
       * Create a new AccessorNode whose children are the results of calling
       * the provided callback function for each child of the original node.
       * @param {function(child: Node, path: string, parent: Node): Node} callback
       * @returns {AccessorNode} Returns a transformed copy of the node
       */
      map(callback) {
        return new AccessorNode(
          this._ifNode(callback(this.object, "object", this)),
          this._ifNode(callback(this.index, "index", this)),
          this.optionalChaining
        );
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {AccessorNode}
       */
      clone() {
        return new AccessorNode(this.object, this.index, this.optionalChaining);
      }
      /**
       * Get string representation
       * @param {Object} options
       * @return {string}
       */
      _toString(options) {
        let object = this.object.toString(options);
        if (needParenthesis(this.object)) {
          object = "(" + object + ")";
        }
        const optionalChaining = this.optionalChaining ? this.index.dotNotation ? "?" : "?." : "";
        return object + optionalChaining + this.index.toString(options);
      }
      /**
       * Get HTML representation
       * @param {Object} options
       * @return {string}
       */
      _toHTML(options) {
        let object = this.object.toHTML(options);
        if (needParenthesis(this.object)) {
          object = '<span class="math-parenthesis math-round-parenthesis">(</span>' + object + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        return object + this.index.toHTML(options);
      }
      /**
       * Get LaTeX representation
       * @param {Object} options
       * @return {string}
       */
      _toTex(options) {
        let object = this.object.toTex(options);
        if (needParenthesis(this.object)) {
          object = "\\left(' + object + '\\right)";
        }
        return object + this.index.toTex(options);
      }
      /**
       * Get a JSON representation of the node
       * @returns {Object}
       */
      toJSON() {
        return {
          mathjs: name213,
          object: this.object,
          index: this.index,
          optionalChaining: this.optionalChaining
        };
      }
      /**
       * Instantiate an AccessorNode from its JSON representation
       * @param {Object} json
       *     An object structured like
       *     `{"mathjs": "AccessorNode", object: ..., index: ...}`,
       *     where mathjs is optional
       * @returns {AccessorNode}
       */
      static fromJSON(json) {
        return new AccessorNode(json.object, json.index, json.optionalChaining);
      }
    }
    Object.defineProperty(AccessorNode, "name", {
      value: name213,
      configurable: true
    });
    return AccessorNode;
  },
  { isClass: true, isNode: true }
);

// src/expression/node/ArrayNode.ts
var name214 = "ArrayNode";
var dependencies215 = ["Node"];
var createArrayNode = /* @__PURE__ */ factory(
  name214,
  dependencies215,
  ({ Node }) => {
    class ArrayNode extends Node {
      /**
       * @constructor ArrayNode
       * @extends {Node}
       * Holds an 1-dimensional array with items
       * @param {Node[]} [items]   1 dimensional array with items
       */
      constructor(items) {
        super();
        this.items = items || [];
        if (!Array.isArray(this.items) || !this.items.every(isNode)) {
          throw new TypeError("Array containing Nodes expected");
        }
      }
      get type() {
        return name214;
      }
      get isArrayNode() {
        return true;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      _compile(math, argNames) {
        const evalItems = map(this.items, function(item) {
          return item._compile(math, argNames);
        });
        const asMatrix = math.config.matrix !== "Array";
        if (asMatrix) {
          const matrix = math.matrix;
          return function evalArrayNode(scope, args, context) {
            return matrix(
              map(evalItems, function(evalItem) {
                return evalItem(scope, args, context);
              })
            );
          };
        } else {
          return function evalArrayNode(scope, args, context) {
            return map(evalItems, function(evalItem) {
              return evalItem(scope, args, context);
            });
          };
        }
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(callback) {
        for (let i = 0; i < this.items.length; i++) {
          const node = this.items[i];
          callback(node, "items[" + i + "]", this);
        }
      }
      /**
       * Create a new ArrayNode whose children are the results of calling
       * the provided callback function for each child of the original node.
       * @param {function(child: Node, path: string, parent: Node): Node} callback
       * @returns {ArrayNode} Returns a transformed copy of the node
       */
      map(callback) {
        const items = [];
        for (let i = 0; i < this.items.length; i++) {
          items[i] = this._ifNode(
            callback(this.items[i], "items[" + i + "]", this)
          );
        }
        return new ArrayNode(items);
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {ArrayNode}
       */
      clone() {
        return new ArrayNode(this.items.slice(0));
      }
      /**
       * Get string representation
       * @param {Object} options
       * @return {string} str
       * @override
       */
      _toString(options) {
        const items = this.items.map(function(node) {
          return node.toString(options);
        });
        return "[" + items.join(", ") + "]";
      }
      /**
       * Get a JSON representation of the node
       * @returns {Object}
       */
      toJSON() {
        return {
          mathjs: name214,
          items: this.items
        };
      }
      /**
       * Instantiate an ArrayNode from its JSON representation
       * @param {Object} json  An object structured like
       *                       `{"mathjs": "ArrayNode", items: [...]}`,
       *                       where mathjs is optional
       * @returns {ArrayNode}
       */
      static fromJSON(json) {
        return new ArrayNode(json.items);
      }
      /**
       * Get HTML representation
       * @param {Object} options
       * @return {string} str
       * @override
       */
      _toHTML(options) {
        const items = this.items.map(function(node) {
          return node.toHTML(options);
        });
        return '<span class="math-parenthesis math-square-parenthesis">[</span>' + items.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
      }
      /**
       * Get LaTeX representation
       * @param {Object} options
       * @return {string} str
       */
      _toTex(options) {
        function itemsToTex(items, nested) {
          const mixedItems = items.some(isArrayNode) && !items.every(isArrayNode);
          const itemsFormRow = nested || mixedItems;
          const itemSep = itemsFormRow ? "&" : "\\\\";
          const itemsTex = items.map(function(node) {
            if (node.items) {
              return itemsToTex(node.items, !nested);
            } else {
              return node.toTex(options);
            }
          }).join(itemSep);
          return mixedItems || !itemsFormRow || itemsFormRow && !nested ? "\\begin{bmatrix}" + itemsTex + "\\end{bmatrix}" : itemsTex;
        }
        return itemsToTex(this.items, false);
      }
    }
    Object.defineProperty(ArrayNode, "name", {
      value: name214,
      configurable: true
    });
    return ArrayNode;
  },
  { isClass: true, isNode: true }
);

// src/expression/node/utils/assign.ts
function assignFactory({
  subset,
  matrix
}) {
  return function assign(object, index, value) {
    try {
      if (Array.isArray(object)) {
        const result = matrix(object).subset(index, value).valueOf();
        result.forEach((item, index2) => {
          object[index2] = item;
        });
        return object;
      } else if (object && typeof object.subset === "function") {
        return object.subset(index, value);
      } else if (typeof object === "string") {
        return subset(object, index, value);
      } else if (typeof object === "object") {
        if (!index.isObjectProperty()) {
          throw TypeError("Cannot apply a numeric index as object property");
        }
        setSafeProperty(object, index.getObjectProperty(), value);
        return object;
      } else {
        throw new TypeError("Cannot apply index: unsupported type of object");
      }
    } catch (err) {
      throw errorTransform(err);
    }
  };
}

// src/expression/operators.ts
var properties = [
  {
    // assignment
    AssignmentNode: {},
    FunctionAssignmentNode: {}
  },
  {
    // conditional expression
    ConditionalNode: {
      latexLeftParens: false,
      latexRightParens: false,
      latexParens: false
      // conditionals don't need parentheses in LaTeX because
      // they are 2 dimensional
    }
  },
  {
    // logical or
    "OperatorNode:or": {
      op: "or",
      associativity: "left",
      associativeWith: []
    }
  },
  {
    // logical xor
    "OperatorNode:xor": {
      op: "xor",
      associativity: "left",
      associativeWith: []
    }
  },
  {
    // logical and
    "OperatorNode:and": {
      op: "and",
      associativity: "left",
      associativeWith: []
    }
  },
  {
    // bitwise or
    "OperatorNode:bitOr": {
      op: "|",
      associativity: "left",
      associativeWith: []
    }
  },
  {
    // bitwise xor
    "OperatorNode:bitXor": {
      op: "^|",
      associativity: "left",
      associativeWith: []
    }
  },
  {
    // bitwise and
    "OperatorNode:bitAnd": {
      op: "&",
      associativity: "left",
      associativeWith: []
    }
  },
  {
    // relational operators
    "OperatorNode:equal": {
      op: "==",
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:unequal": {
      op: "!=",
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:smaller": {
      op: "<",
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:larger": {
      op: ">",
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:smallerEq": {
      op: "<=",
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:largerEq": {
      op: ">=",
      associativity: "left",
      associativeWith: []
    },
    RelationalNode: {
      associativity: "left",
      associativeWith: []
    }
  },
  {
    // bitshift operators
    "OperatorNode:leftShift": {
      op: "<<",
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:rightArithShift": {
      op: ">>",
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:rightLogShift": {
      op: ">>>",
      associativity: "left",
      associativeWith: []
    }
  },
  {
    // unit conversion
    "OperatorNode:to": {
      op: "to",
      associativity: "left",
      associativeWith: []
    }
  },
  {
    // range
    RangeNode: {}
  },
  {
    // addition, subtraction
    "OperatorNode:add": {
      op: "+",
      associativity: "left",
      associativeWith: ["OperatorNode:add", "OperatorNode:subtract"]
    },
    "OperatorNode:subtract": {
      op: "-",
      associativity: "left",
      associativeWith: []
    }
  },
  {
    // multiply, divide, modulus
    "OperatorNode:multiply": {
      op: "*",
      associativity: "left",
      associativeWith: [
        "OperatorNode:multiply",
        "OperatorNode:divide",
        "Operator:dotMultiply",
        "Operator:dotDivide"
      ]
    },
    "OperatorNode:divide": {
      op: "/",
      associativity: "left",
      associativeWith: [],
      latexLeftParens: false,
      latexRightParens: false,
      latexParens: false
      // fractions don't require parentheses because
      // they're 2 dimensional, so parens aren't needed
      // in LaTeX
    },
    "OperatorNode:dotMultiply": {
      op: ".*",
      associativity: "left",
      associativeWith: [
        "OperatorNode:multiply",
        "OperatorNode:divide",
        "OperatorNode:dotMultiply",
        "OperatorNode:doDivide"
      ]
    },
    "OperatorNode:dotDivide": {
      op: "./",
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:mod": {
      op: "mod",
      associativity: "left",
      associativeWith: []
    }
  },
  {
    // Repeat multiplication for implicit multiplication
    "OperatorNode:multiply": {
      associativity: "left",
      associativeWith: [
        "OperatorNode:multiply",
        "OperatorNode:divide",
        "Operator:dotMultiply",
        "Operator:dotDivide"
      ]
    }
  },
  {
    // unary prefix operators
    "OperatorNode:unaryPlus": {
      op: "+",
      associativity: "right"
    },
    "OperatorNode:unaryMinus": {
      op: "-",
      associativity: "right"
    },
    "OperatorNode:bitNot": {
      op: "~",
      associativity: "right"
    },
    "OperatorNode:not": {
      op: "not",
      associativity: "right"
    }
  },
  {
    // exponentiation
    "OperatorNode:pow": {
      op: "^",
      associativity: "right",
      associativeWith: [],
      latexRightParens: false
      // the exponent doesn't need parentheses in
      // LaTeX because it's 2 dimensional
      // (it's on top)
    },
    "OperatorNode:dotPow": {
      op: ".^",
      associativity: "right",
      associativeWith: []
    }
  },
  {
    // nullish coalescing
    "OperatorNode:nullish": {
      op: "??",
      associativity: "left",
      associativeWith: []
    }
  },
  {
    // factorial
    "OperatorNode:factorial": {
      op: "!",
      associativity: "left"
    }
  },
  {
    // matrix transpose
    "OperatorNode:ctranspose": {
      op: "'",
      associativity: "left"
    }
  }
];
function unwrapParen(_node, parenthesis) {
  if (!parenthesis || parenthesis !== "auto") return _node;
  let node = _node;
  while (isParenthesisNode(node)) node = node.content;
  return node;
}
function getPrecedence(_node, parenthesis, implicit, parent) {
  let node = _node;
  if (parenthesis !== "keep") {
    node = _node.getContent();
  }
  const identifier = node.getIdentifier();
  let precedence = null;
  for (let i = 0; i < properties.length; i++) {
    if (identifier in properties[i]) {
      precedence = i;
      break;
    }
  }
  if (identifier === "OperatorNode:multiply" && node.implicit && implicit !== "show") {
    const leftArg = unwrapParen(node.args[0], parenthesis);
    if (!(isConstantNode(leftArg) && parent && parent.getIdentifier() === "OperatorNode:divide" && rule2Node(unwrapParen(parent.args[0], parenthesis))) && !(leftArg.getIdentifier() === "OperatorNode:divide" && rule2Node(unwrapParen(leftArg.args[0], parenthesis)) && isConstantNode(unwrapParen(leftArg.args[1], parenthesis)))) {
      precedence += 1;
    }
  }
  return precedence;
}
function getAssociativity(_node, parenthesis) {
  let node = _node;
  if (parenthesis !== "keep") {
    node = _node.getContent();
  }
  const identifier = node.getIdentifier();
  const index = getPrecedence(node, parenthesis, void 0, void 0);
  if (index === null) {
    return null;
  }
  const property = properties[index][identifier];
  if (hasOwnProperty(property, "associativity")) {
    if (property.associativity === "left") {
      return "left";
    }
    if (property.associativity === "right") {
      return "right";
    }
    throw Error(
      "'" + identifier + "' has the invalid associativity '" + property.associativity + "'."
    );
  }
  return null;
}
function isAssociativeWith(nodeA, nodeB, parenthesis) {
  const a = parenthesis !== "keep" ? nodeA.getContent() : nodeA;
  const b = parenthesis !== "keep" ? nodeA.getContent() : nodeB;
  const identifierA = a.getIdentifier();
  const identifierB = b.getIdentifier();
  const index = getPrecedence(a, parenthesis, void 0, void 0);
  if (index === null) {
    return null;
  }
  const property = properties[index][identifierA];
  if (hasOwnProperty(property, "associativeWith") && property.associativeWith instanceof Array) {
    for (let i = 0; i < property.associativeWith.length; i++) {
      if (property.associativeWith[i] === identifierB) {
        return true;
      }
    }
    return false;
  }
  return null;
}
function getOperator(fn) {
  const identifier = "OperatorNode:" + fn;
  for (const group of properties) {
    if (identifier in group) {
      return group[identifier].op;
    }
  }
  return null;
}

// src/expression/node/AssignmentNode.ts
var name215 = "AssignmentNode";
var dependencies216 = [
  "subset",
  "?matrix",
  // FIXME: should not be needed at all, should be handled by subset
  "Node"
];
var createAssignmentNode = /* @__PURE__ */ factory(
  name215,
  dependencies216,
  ({ subset, matrix, Node }) => {
    const access = accessFactory({ subset });
    const assign = assignFactory({ subset, matrix });
    function needParenthesis(node, parenthesis, implicit) {
      if (!parenthesis) {
        parenthesis = "keep";
      }
      const precedence = getPrecedence(node, parenthesis, implicit, void 0);
      const exprPrecedence = getPrecedence(
        node.value,
        parenthesis,
        implicit,
        void 0
      );
      return parenthesis === "all" || exprPrecedence !== null && exprPrecedence <= precedence;
    }
    class AssignmentNode extends Node {
      /**
       * @constructor AssignmentNode
       * @extends {Node}
       *
       * Define a symbol, like `a=3.2`, update a property like `a.b=3.2`, or
       * replace a subset of a matrix like `A[2,2]=42`.
       *
       * Syntax:
       *
       *     new AssignmentNode(symbol, value)
       *     new AssignmentNode(object, index, value)
       *
       * Usage:
       *
       *    new AssignmentNode(new SymbolNode('a'), new ConstantNode(2))  // a=2
       *    new AssignmentNode(new SymbolNode('a'),
       *                       new IndexNode('b'),
       *                       new ConstantNode(2))   // a.b=2
       *    new AssignmentNode(new SymbolNode('a'),
       *                       new IndexNode(1, 2),
       *                       new ConstantNode(3))  // a[1,2]=3
       *
       * @param {SymbolNode | AccessorNode} object
       *     Object on which to assign a value
       * @param {IndexNode} [index=null]
       *     Index, property name or matrix index. Optional. If not provided
       *     and `object` is a SymbolNode, the property is assigned to the
       *     global scope.
       * @param {Node} value
       *     The value to be assigned
       */
      constructor(object, index, value) {
        super();
        this.object = object;
        this.index = value ? index : null;
        this.value = value || index;
        if (!isSymbolNode(object) && !isAccessorNode(object)) {
          throw new TypeError('SymbolNode or AccessorNode expected as "object"');
        }
        if (isSymbolNode(object) && object.name === "end") {
          throw new Error('Cannot assign to symbol "end"');
        }
        if (this.index && !isIndexNode(this.index)) {
          throw new TypeError('IndexNode expected as "index"');
        }
        if (!isNode(this.value)) {
          throw new TypeError('Node expected as "value"');
        }
      }
      // readonly property name
      get name() {
        if (this.index) {
          return this.index.isObjectProperty() ? this.index.getObjectProperty() : "";
        } else {
          return this.object.name || "";
        }
      }
      get type() {
        return name215;
      }
      get isAssignmentNode() {
        return true;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param math - Math.js namespace with functions and constants.
       * @param argNames - An object with argument names as key and `true`
       *                   as value. Used in the SymbolNode to optimize
       *                   for arguments from user assigned functions
       *                   (see FunctionAssignmentNode) or special symbols
       *                   like `end` (see IndexNode).
       * @returns A function which can be called like:
       *          evalNode(scope: Scope, args: Record<string, unknown>, context: unknown)
       */
      _compile(math, argNames) {
        const evalObject = this.object._compile(math, argNames);
        const evalIndex = this.index ? this.index._compile(math, argNames) : null;
        const evalValue = this.value._compile(math, argNames);
        const symbolName = this.object.name;
        if (!this.index) {
          if (!isSymbolNode(this.object)) {
            throw new TypeError("SymbolNode expected as object");
          }
          return function evalAssignmentNode(scope, args, context) {
            const value = evalValue(scope, args, context);
            scope.set(symbolName, value);
            return value;
          };
        } else if (this.index.isObjectProperty()) {
          const prop = this.index.getObjectProperty();
          return function evalAssignmentNode(scope, args, context) {
            const object = evalObject(scope, args, context);
            const value = evalValue(scope, args, context);
            setSafeProperty(object, prop, value);
            return value;
          };
        } else if (isSymbolNode(this.object)) {
          return function evalAssignmentNode(scope, args, context) {
            const childObject = evalObject(scope, args, context);
            const value = evalValue(scope, args, context);
            const index = evalIndex(scope, args, childObject);
            scope.set(symbolName, assign(childObject, index, value));
            return value;
          };
        } else {
          const accessorObject = this.object;
          const evalParentObject = accessorObject.object._compile(math, argNames);
          if (accessorObject.index.isObjectProperty()) {
            const parentProp = accessorObject.index.getObjectProperty();
            return function evalAssignmentNode(scope, args, context) {
              const parent = evalParentObject(scope, args, context);
              const childObject = getSafeProperty(
                parent,
                parentProp
              );
              const index = evalIndex(scope, args, childObject);
              const value = evalValue(scope, args, context);
              setSafeProperty(
                parent,
                parentProp,
                assign(childObject, index, value)
              );
              return value;
            };
          } else {
            const evalParentIndex = accessorObject.index._compile(math, argNames);
            return function evalAssignmentNode(scope, args, context) {
              const parent = evalParentObject(scope, args, context);
              const parentIndex = evalParentIndex(scope, args, parent);
              const childObject = access(parent, parentIndex);
              const index = evalIndex(scope, args, childObject);
              const value = evalValue(scope, args, context);
              assign(parent, parentIndex, assign(childObject, index, value));
              return value;
            };
          }
        }
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(callback) {
        callback(this.object, "object", this);
        if (this.index) {
          callback(this.index, "index", this);
        }
        callback(this.value, "value", this);
      }
      /**
       * Create a new AssignmentNode whose children are the results of calling
       * the provided callback function for each child of the original node.
       * @param {function(child: Node, path: string, parent: Node): Node} callback
       * @returns {AssignmentNode} Returns a transformed copy of the node
       */
      map(callback) {
        const object = this._ifNode(
          callback(this.object, "object", this)
        );
        const index = this.index ? this._ifNode(callback(this.index, "index", this)) : null;
        const value = this._ifNode(callback(this.value, "value", this));
        return new AssignmentNode(object, index, value);
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {AssignmentNode}
       */
      clone() {
        return new AssignmentNode(this.object, this.index, this.value);
      }
      /**
       * Get string representation
       * @param options - Formatting options
       * @returns The string representation
       */
      _toString(options) {
        const object = this.object.toString(options);
        const index = this.index ? this.index.toString(options) : "";
        let value = this.value.toString(options);
        if (needParenthesis(
          this,
          options && options.parenthesis,
          options && options.implicit
        )) {
          value = "(" + value + ")";
        }
        return object + index + " = " + value;
      }
      /**
       * Get a JSON representation of the node
       * @returns The JSON representation
       */
      toJSON() {
        return {
          mathjs: name215,
          object: this.object,
          index: this.index,
          value: this.value
        };
      }
      /**
       * Instantiate an AssignmentNode from its JSON representation
       * @param json - An object structured like
       *     `{"mathjs": "AssignmentNode", object: ..., index: ..., value: ...}`,
       *     where mathjs is optional
       * @returns The AssignmentNode instance
       */
      static fromJSON(json) {
        return new AssignmentNode(json.object, json.index, json.value);
      }
      /**
       * Get HTML representation
       * @param options - Formatting options
       * @returns The HTML representation
       */
      _toHTML(options) {
        const object = this.object.toHTML(options);
        const index = this.index ? this.index.toHTML(options) : "";
        let value = this.value.toHTML(options);
        if (needParenthesis(
          this,
          options && options.parenthesis,
          options && options.implicit
        )) {
          value = '<span class="math-paranthesis math-round-parenthesis">(</span>' + value + '<span class="math-paranthesis math-round-parenthesis">)</span>';
        }
        return object + index + '<span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + value;
      }
      /**
       * Get LaTeX representation
       * @param options - Formatting options
       * @returns The LaTeX representation
       */
      _toTex(options) {
        const object = this.object.toTex(options);
        const index = this.index ? this.index.toTex(options) : "";
        let value = this.value.toTex(options);
        if (needParenthesis(
          this,
          options && options.parenthesis,
          options && options.implicit
        )) {
          value = `\\left(${value}\\right)`;
        }
        return object + index + "=" + value;
      }
    }
    Object.defineProperty(AssignmentNode, "name", {
      value: name215,
      configurable: true
    });
    return AssignmentNode;
  },
  { isClass: true, isNode: true }
);

// src/expression/node/BlockNode.ts
var name216 = "BlockNode";
var dependencies217 = ["ResultSet", "Node"];
var createBlockNode = /* @__PURE__ */ factory(
  name216,
  dependencies217,
  ({
    ResultSet,
    Node
  }) => {
    class BlockNode extends Node {
      /**
       * @constructor BlockNode
       * @extends {Node}
       * Holds a set with blocks
       * @param {Array.<{node: Node} | {node: Node, visible: boolean}>} blocks
       *            An array with blocks, where a block is constructed as an
       *            Object with properties block, which is a Node, and visible,
       *            which is a boolean. The property visible is optional and
       *            is true by default
       */
      constructor(blocks) {
        super();
        if (!Array.isArray(blocks)) throw new Error("Array expected");
        this.blocks = blocks.map(function(block) {
          const node = block && block.node;
          const visible = block && block.visible !== void 0 ? block.visible : true;
          if (!isNode(node))
            throw new TypeError('Property "node" must be a Node');
          if (typeof visible !== "boolean") {
            throw new TypeError('Property "visible" must be a boolean');
          }
          return { node, visible };
        });
      }
      get type() {
        return name216;
      }
      get isBlockNode() {
        return true;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      _compile(math, argNames) {
        const evalBlocks = map(this.blocks, function(block) {
          return {
            evaluate: block.node._compile(math, argNames),
            visible: block.visible
          };
        });
        return function evalBlockNodes(scope, args, context) {
          const results = [];
          forEach(evalBlocks, function evalBlockNode(block) {
            const result = block.evaluate(scope, args, context);
            if (block.visible) {
              results.push(result);
            }
          });
          return new ResultSet(results);
        };
      }
      /**
       * Execute a callback for each of the child blocks of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(callback) {
        for (let i = 0; i < this.blocks.length; i++) {
          callback(this.blocks[i].node, "blocks[" + i + "].node", this);
        }
      }
      /**
       * Create a new BlockNode whose children are the results of calling
       * the provided callback function for each child of the original node.
       * @param {function(child: Node, path: string, parent: Node): Node} callback
       * @returns {BlockNode} Returns a transformed copy of the node
       */
      map(callback) {
        const blocks = [];
        for (let i = 0; i < this.blocks.length; i++) {
          const block = this.blocks[i];
          const node = this._ifNode(
            callback(block.node, "blocks[" + i + "].node", this)
          );
          blocks[i] = {
            node,
            visible: block.visible
          };
        }
        return new BlockNode(blocks);
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {BlockNode}
       */
      clone() {
        const blocks = this.blocks.map(function(block) {
          return {
            node: block.node,
            visible: block.visible
          };
        });
        return new BlockNode(blocks);
      }
      /**
       * Get string representation
       * @param {Object} options
       * @return {string} str
       * @override
       */
      _toString(options) {
        return this.blocks.map(function(param) {
          return param.node.toString(options) + (param.visible ? "" : ";");
        }).join("\n");
      }
      /**
       * Get a JSON representation of the node
       * @returns {Object}
       */
      toJSON() {
        return {
          mathjs: name216,
          blocks: this.blocks
        };
      }
      /**
       * Instantiate an BlockNode from its JSON representation
       * @param {Object} json
       *     An object structured like
       *     `{"mathjs": "BlockNode", blocks: [{node: ..., visible: false}, ...]}`,
       *     where mathjs is optional
       * @returns {BlockNode}
       */
      static fromJSON(json) {
        return new BlockNode(json.blocks);
      }
      /**
       * Get HTML representation
       * @param {Object} options
       * @return {string} str
       * @override
       */
      _toHTML(options) {
        return this.blocks.map(function(param) {
          return param.node.toHTML(options) + (param.visible ? "" : '<span class="math-separator">;</span>');
        }).join('<span class="math-separator"><br /></span>');
      }
      /**
       * Get LaTeX representation
       * @param {Object} options
       * @return {string} str
       */
      _toTex(options) {
        return this.blocks.map(function(param) {
          return param.node.toTex(options) + (param.visible ? "" : ";");
        }).join("\\;\\;\n");
      }
    }
    Object.defineProperty(BlockNode, "name", {
      value: name216,
      configurable: true
    });
    return BlockNode;
  },
  { isClass: true, isNode: true }
);

// src/expression/node/ConditionalNode.ts
var name217 = "ConditionalNode";
var dependencies218 = ["Node"];
var createConditionalNode = /* @__PURE__ */ factory(
  name217,
  dependencies218,
  ({ Node }) => {
    function testCondition(condition) {
      if (typeof condition === "number" || typeof condition === "boolean" || typeof condition === "string") {
        return !!condition;
      }
      if (condition) {
        if (isBigNumber(condition)) {
          return !condition.isZero();
        }
        if (isComplex(condition)) {
          return !!(condition.re || condition.im);
        }
        if (isUnit(condition)) {
          return !!condition.value;
        }
      }
      if (condition === null || condition === void 0) {
        return false;
      }
      throw new TypeError(
        'Unsupported type of condition "' + typeOf(condition) + '"'
      );
    }
    class ConditionalNode extends Node {
      /**
       * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'
       *
       * @param {Node} condition   Condition, must result in a boolean
       * @param {Node} trueExpr    Expression evaluated when condition is true
       * @param {Node} falseExpr   Expression evaluated when condition is true
       *
       * @constructor ConditionalNode
       * @extends {Node}
       */
      constructor(condition, trueExpr, falseExpr) {
        super();
        if (!isNode(condition)) {
          throw new TypeError("Parameter condition must be a Node");
        }
        if (!isNode(trueExpr)) {
          throw new TypeError("Parameter trueExpr must be a Node");
        }
        if (!isNode(falseExpr)) {
          throw new TypeError("Parameter falseExpr must be a Node");
        }
        this.condition = condition;
        this.trueExpr = trueExpr;
        this.falseExpr = falseExpr;
      }
      get type() {
        return name217;
      }
      get isConditionalNode() {
        return true;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      _compile(math, argNames) {
        const evalCondition = this.condition._compile(math, argNames);
        const evalTrueExpr = this.trueExpr._compile(math, argNames);
        const evalFalseExpr = this.falseExpr._compile(math, argNames);
        return function evalConditionalNode(scope, args, context) {
          return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);
        };
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(callback) {
        callback(this.condition, "condition", this);
        callback(this.trueExpr, "trueExpr", this);
        callback(this.falseExpr, "falseExpr", this);
      }
      /**
       * Create a new ConditionalNode whose children are the results of calling
       * the provided callback function for each child of the original node.
       * @param {function(child: Node, path: string, parent: Node): Node} callback
       * @returns {ConditionalNode} Returns a transformed copy of the node
       */
      map(callback) {
        return new ConditionalNode(
          this._ifNode(callback(this.condition, "condition", this)),
          this._ifNode(callback(this.trueExpr, "trueExpr", this)),
          this._ifNode(callback(this.falseExpr, "falseExpr", this))
        );
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {ConditionalNode}
       */
      clone() {
        return new ConditionalNode(
          this.condition,
          this.trueExpr,
          this.falseExpr
        );
      }
      /**
       * Get string representation
       * @param {Object} options
       * @return {string} str
       */
      _toString(options) {
        const parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        const precedence = getPrecedence(
          this,
          parenthesis,
          options && options.implicit,
          void 0
        );
        let condition = this.condition.toString(options);
        const conditionPrecedence = getPrecedence(
          this.condition,
          parenthesis,
          options && options.implicit,
          void 0
        );
        if (parenthesis === "all" || this.condition.type === "OperatorNode" || conditionPrecedence !== null && conditionPrecedence <= precedence) {
          condition = "(" + condition + ")";
        }
        let trueExpr = this.trueExpr.toString(options);
        const truePrecedence = getPrecedence(
          this.trueExpr,
          parenthesis,
          options && options.implicit,
          void 0
        );
        if (parenthesis === "all" || this.trueExpr.type === "OperatorNode" || truePrecedence !== null && truePrecedence <= precedence) {
          trueExpr = "(" + trueExpr + ")";
        }
        let falseExpr = this.falseExpr.toString(options);
        const falsePrecedence = getPrecedence(
          this.falseExpr,
          parenthesis,
          options && options.implicit,
          void 0
        );
        if (parenthesis === "all" || this.falseExpr.type === "OperatorNode" || falsePrecedence !== null && falsePrecedence <= precedence) {
          falseExpr = "(" + falseExpr + ")";
        }
        return condition + " ? " + trueExpr + " : " + falseExpr;
      }
      /**
       * Get a JSON representation of the node
       * @returns {Object}
       */
      toJSON() {
        return {
          mathjs: name217,
          condition: this.condition,
          trueExpr: this.trueExpr,
          falseExpr: this.falseExpr
        };
      }
      /**
       * Instantiate an ConditionalNode from its JSON representation
       * @param {Object} json
       *     An object structured like
       *     ```
       *     {"mathjs": "ConditionalNode",
       *      "condition": ...,
       *      "trueExpr": ...,
       *      "falseExpr": ...}
       *     ```
       *     where mathjs is optional
       * @returns {ConditionalNode}
       */
      static fromJSON(json) {
        return new ConditionalNode(
          json.condition,
          json.trueExpr,
          json.falseExpr
        );
      }
      /**
       * Get HTML representation
       * @param {Object} options
       * @return {string} str
       */
      _toHTML(options) {
        const parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        const precedence = getPrecedence(
          this,
          parenthesis,
          options && options.implicit,
          void 0
        );
        let condition = this.condition.toHTML(options);
        const conditionPrecedence = getPrecedence(
          this.condition,
          parenthesis,
          options && options.implicit,
          void 0
        );
        if (parenthesis === "all" || this.condition.type === "OperatorNode" || conditionPrecedence !== null && conditionPrecedence <= precedence) {
          condition = '<span class="math-parenthesis math-round-parenthesis">(</span>' + condition + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        let trueExpr = this.trueExpr.toHTML(options);
        const truePrecedence = getPrecedence(
          this.trueExpr,
          parenthesis,
          options && options.implicit,
          void 0
        );
        if (parenthesis === "all" || this.trueExpr.type === "OperatorNode" || truePrecedence !== null && truePrecedence <= precedence) {
          trueExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + trueExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        let falseExpr = this.falseExpr.toHTML(options);
        const falsePrecedence = getPrecedence(
          this.falseExpr,
          parenthesis,
          options && options.implicit,
          void 0
        );
        if (parenthesis === "all" || this.falseExpr.type === "OperatorNode" || falsePrecedence !== null && falsePrecedence <= precedence) {
          falseExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + falseExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        return condition + '<span class="math-operator math-conditional-operator">?</span>' + trueExpr + '<span class="math-operator math-conditional-operator">:</span>' + falseExpr;
      }
      /**
       * Get LaTeX representation
       * @param {Object} options
       * @return {string} str
       */
      _toTex(options) {
        return "\\begin{cases} {" + this.trueExpr.toTex(options) + "}, &\\quad{\\text{if }\\;" + this.condition.toTex(options) + "}\\\\{" + this.falseExpr.toTex(options) + "}, &\\quad{\\text{otherwise}}\\end{cases}";
      }
    }
    Object.defineProperty(ConditionalNode, "name", {
      value: name217,
      configurable: true
    });
    return ConditionalNode;
  },
  { isClass: true, isNode: true }
);
var latexSymbols = {
  // GREEK LETTERS
  Alpha: "A",
  alpha: "\\alpha",
  Beta: "B",
  beta: "\\beta",
  Gamma: "\\Gamma",
  gamma: "\\gamma",
  Delta: "\\Delta",
  delta: "\\delta",
  Epsilon: "E",
  epsilon: "\\epsilon",
  varepsilon: "\\varepsilon",
  Zeta: "Z",
  zeta: "\\zeta",
  Eta: "H",
  eta: "\\eta",
  Theta: "\\Theta",
  theta: "\\theta",
  vartheta: "\\vartheta",
  Iota: "I",
  iota: "\\iota",
  Kappa: "K",
  kappa: "\\kappa",
  varkappa: "\\varkappa",
  Lambda: "\\Lambda",
  lambda: "\\lambda",
  Mu: "M",
  mu: "\\mu",
  Nu: "N",
  nu: "\\nu",
  Xi: "\\Xi",
  xi: "\\xi",
  Omicron: "O",
  omicron: "o",
  Pi: "\\Pi",
  pi: "\\pi",
  varpi: "\\varpi",
  Rho: "P",
  rho: "\\rho",
  varrho: "\\varrho",
  Sigma: "\\Sigma",
  sigma: "\\sigma",
  varsigma: "\\varsigma",
  Tau: "T",
  tau: "\\tau",
  Upsilon: "\\Upsilon",
  upsilon: "\\upsilon",
  Phi: "\\Phi",
  phi: "\\phi",
  varphi: "\\varphi",
  Chi: "X",
  chi: "\\chi",
  Psi: "\\Psi",
  psi: "\\psi",
  Omega: "\\Omega",
  omega: "\\omega",
  // logic
  true: "\\mathrm{True}",
  false: "\\mathrm{False}",
  // other
  i: "i",
  // TODO use \i ??
  inf: "\\infty",
  Inf: "\\infty",
  infinity: "\\infty",
  Infinity: "\\infty",
  oo: "\\infty",
  lim: "\\lim",
  undefined: "\\mathbf{?}"
};
var latexOperators = {
  transpose: "^\\top",
  ctranspose: "^H",
  factorial: "!",
  pow: "^",
  dotPow: ".^\\wedge",
  // TODO find ideal solution
  unaryPlus: "+",
  unaryMinus: "-",
  bitNot: "\\~",
  // TODO find ideal solution
  not: "\\neg",
  multiply: "\\cdot",
  divide: "\\frac",
  // TODO how to handle that properly?
  dotMultiply: ".\\cdot",
  // TODO find ideal solution
  dotDivide: ".:",
  // TODO find ideal solution
  mod: "\\mod",
  add: "+",
  subtract: "-",
  to: "\\rightarrow",
  leftShift: "<<",
  rightArithShift: ">>",
  rightLogShift: ">>>",
  equal: "=",
  unequal: "\\neq",
  smaller: "<",
  larger: ">",
  smallerEq: "\\leq",
  largerEq: "\\geq",
  bitAnd: "\\&",
  bitXor: "\\underline{|}",
  bitOr: "|",
  and: "\\wedge",
  xor: "\\veebar",
  or: "\\vee"
};
var latexFunctions = {
  // arithmetic
  abs: { 1: "\\left|${args[0]}\\right|" },
  add: { 2: `\\left(\${args[0]}${latexOperators.add}\${args[1]}\\right)` },
  cbrt: { 1: "\\sqrt[3]{${args[0]}}" },
  ceil: { 1: "\\left\\lceil${args[0]}\\right\\rceil" },
  cube: { 1: "\\left(${args[0]}\\right)^3" },
  divide: { 2: "\\frac{${args[0]}}{${args[1]}}" },
  dotDivide: {
    2: `\\left(\${args[0]}${latexOperators.dotDivide}\${args[1]}\\right)`
  },
  dotMultiply: {
    2: `\\left(\${args[0]}${latexOperators.dotMultiply}\${args[1]}\\right)`
  },
  dotPow: {
    2: `\\left(\${args[0]}${latexOperators.dotPow}\${args[1]}\\right)`
  },
  exp: { 1: "\\exp\\left(${args[0]}\\right)" },
  expm1: `\\left(e${latexOperators.pow}{\${args[0]}}-1\\right)`,
  fix: { 1: "\\mathrm{${name}}\\left(${args[0]}\\right)" },
  floor: { 1: "\\left\\lfloor${args[0]}\\right\\rfloor" },
  fraction: { 2: "\\frac{${args[0]}}{${args[1]}}" },
  gcd: "\\gcd\\left(${args}\\right)",
  hypot: "\\hypot\\left(${args}\\right)",
  log: {
    1: "\\ln\\left(${args[0]}\\right)",
    2: "\\log_{${args[1]}}\\left(${args[0]}\\right)"
  },
  log10: { 1: "\\log_{10}\\left(${args[0]}\\right)" },
  log1p: {
    1: "\\ln\\left(${args[0]}+1\\right)",
    2: "\\log_{${args[1]}}\\left(${args[0]}+1\\right)"
  },
  log2: "\\log_{2}\\left(${args[0]}\\right)",
  mod: { 2: `\\left(\${args[0]}${latexOperators.mod}\${args[1]}\\right)` },
  multiply: {
    2: `\\left(\${args[0]}${latexOperators.multiply}\${args[1]}\\right)`
  },
  norm: {
    1: "\\left\\|${args[0]}\\right\\|",
    2: void 0
    // use default template
  },
  nthRoot: { 2: "\\sqrt[${args[1]}]{${args[0]}}" },
  nthRoots: { 2: "\\{y : y^${args[1]} = {${args[0]}}\\}" },
  pow: { 2: `\\left(\${args[0]}\\right)${latexOperators.pow}{\${args[1]}}` },
  round: {
    1: "\\left\\lfloor${args[0]}\\right\\rceil",
    2: void 0
    // use default template
  },
  sign: { 1: "\\mathrm{${name}}\\left(${args[0]}\\right)" },
  sqrt: { 1: "\\sqrt{${args[0]}}" },
  square: { 1: "\\left(${args[0]}\\right)^2" },
  subtract: {
    2: `\\left(\${args[0]}${latexOperators.subtract}\${args[1]}\\right)`
  },
  unaryMinus: { 1: `${latexOperators.unaryMinus}\\left(\${args[0]}\\right)` },
  unaryPlus: { 1: `${latexOperators.unaryPlus}\\left(\${args[0]}\\right)` },
  // bitwise
  bitAnd: {
    2: `\\left(\${args[0]}${latexOperators.bitAnd}\${args[1]}\\right)`
  },
  bitNot: { 1: latexOperators.bitNot + "\\left(${args[0]}\\right)" },
  bitOr: { 2: `\\left(\${args[0]}${latexOperators.bitOr}\${args[1]}\\right)` },
  bitXor: {
    2: `\\left(\${args[0]}${latexOperators.bitXor}\${args[1]}\\right)`
  },
  leftShift: {
    2: `\\left(\${args[0]}${latexOperators.leftShift}\${args[1]}\\right)`
  },
  rightArithShift: {
    2: `\\left(\${args[0]}${latexOperators.rightArithShift}\${args[1]}\\right)`
  },
  rightLogShift: {
    2: `\\left(\${args[0]}${latexOperators.rightLogShift}\${args[1]}\\right)`
  },
  // combinatorics
  bellNumbers: { 1: "\\mathrm{B}_{${args[0]}}" },
  catalan: { 1: "\\mathrm{C}_{${args[0]}}" },
  stirlingS2: { 2: "\\mathrm{S}\\left(${args}\\right)" },
  // complex
  arg: { 1: "\\arg\\left(${args[0]}\\right)" },
  conj: { 1: "\\left(${args[0]}\\right)^*" },
  im: { 1: "\\Im\\left\\lbrace${args[0]}\\right\\rbrace" },
  re: { 1: "\\Re\\left\\lbrace${args[0]}\\right\\rbrace" },
  // logical
  and: { 2: `\\left(\${args[0]}${latexOperators.and}\${args[1]}\\right)` },
  not: { 1: latexOperators.not + "\\left(${args[0]}\\right)" },
  or: { 2: `\\left(\${args[0]}${latexOperators.or}\${args[1]}\\right)` },
  xor: { 2: `\\left(\${args[0]}${latexOperators.xor}\${args[1]}\\right)` },
  // matrix
  cross: { 2: "\\left(${args[0]}\\right)\\times\\left(${args[1]}\\right)" },
  ctranspose: { 1: `\\left(\${args[0]}\\right)${latexOperators.ctranspose}` },
  det: { 1: "\\det\\left(${args[0]}\\right)" },
  dot: { 2: "\\left(${args[0]}\\cdot${args[1]}\\right)" },
  expm: { 1: "\\exp\\left(${args[0]}\\right)" },
  inv: { 1: "\\left(${args[0]}\\right)^{-1}" },
  pinv: { 1: "\\left(${args[0]}\\right)^{+}" },
  sqrtm: { 1: `{\${args[0]}}${latexOperators.pow}{\\frac{1}{2}}` },
  trace: { 1: "\\mathrm{tr}\\left(${args[0]}\\right)" },
  transpose: { 1: `\\left(\${args[0]}\\right)${latexOperators.transpose}` },
  // probability
  combinations: { 2: "\\binom{${args[0]}}{${args[1]}}" },
  combinationsWithRep: {
    2: "\\left(\\!\\!{\\binom{${args[0]}}{${args[1]}}}\\!\\!\\right)"
  },
  factorial: { 1: `\\left(\${args[0]}\\right)${latexOperators.factorial}` },
  gamma: { 1: "\\Gamma\\left(${args[0]}\\right)" },
  lgamma: { 1: "\\ln\\Gamma\\left(${args[0]}\\right)" },
  // relational
  equal: { 2: `\\left(\${args[0]}${latexOperators.equal}\${args[1]}\\right)` },
  larger: {
    2: `\\left(\${args[0]}${latexOperators.larger}\${args[1]}\\right)`
  },
  largerEq: {
    2: `\\left(\${args[0]}${latexOperators.largerEq}\${args[1]}\\right)`
  },
  smaller: {
    2: `\\left(\${args[0]}${latexOperators.smaller}\${args[1]}\\right)`
  },
  smallerEq: {
    2: `\\left(\${args[0]}${latexOperators.smallerEq}\${args[1]}\\right)`
  },
  unequal: {
    2: `\\left(\${args[0]}${latexOperators.unequal}\${args[1]}\\right)`
  },
  // special
  erf: { 1: "erf\\left(${args[0]}\\right)" },
  // statistics
  max: "\\max\\left(${args}\\right)",
  min: "\\min\\left(${args}\\right)",
  variance: "\\mathrm{Var}\\left(${args}\\right)",
  // trigonometry
  acos: { 1: "\\cos^{-1}\\left(${args[0]}\\right)" },
  acosh: { 1: "\\cosh^{-1}\\left(${args[0]}\\right)" },
  acot: { 1: "\\cot^{-1}\\left(${args[0]}\\right)" },
  acoth: { 1: "\\coth^{-1}\\left(${args[0]}\\right)" },
  acsc: { 1: "\\csc^{-1}\\left(${args[0]}\\right)" },
  acsch: { 1: "\\mathrm{csch}^{-1}\\left(${args[0]}\\right)" },
  asec: { 1: "\\sec^{-1}\\left(${args[0]}\\right)" },
  asech: { 1: "\\mathrm{sech}^{-1}\\left(${args[0]}\\right)" },
  asin: { 1: "\\sin^{-1}\\left(${args[0]}\\right)" },
  asinh: { 1: "\\sinh^{-1}\\left(${args[0]}\\right)" },
  atan: { 1: "\\tan^{-1}\\left(${args[0]}\\right)" },
  atan2: { 2: "\\mathrm{atan2}\\left(${args}\\right)" },
  atanh: { 1: "\\tanh^{-1}\\left(${args[0]}\\right)" },
  cos: { 1: "\\cos\\left(${args[0]}\\right)" },
  cosh: { 1: "\\cosh\\left(${args[0]}\\right)" },
  cot: { 1: "\\cot\\left(${args[0]}\\right)" },
  coth: { 1: "\\coth\\left(${args[0]}\\right)" },
  csc: { 1: "\\csc\\left(${args[0]}\\right)" },
  csch: { 1: "\\mathrm{csch}\\left(${args[0]}\\right)" },
  sec: { 1: "\\sec\\left(${args[0]}\\right)" },
  sech: { 1: "\\mathrm{sech}\\left(${args[0]}\\right)" },
  sin: { 1: "\\sin\\left(${args[0]}\\right)" },
  sinh: { 1: "\\sinh\\left(${args[0]}\\right)" },
  tan: { 1: "\\tan\\left(${args[0]}\\right)" },
  tanh: { 1: "\\tanh\\left(${args[0]}\\right)" },
  // unit
  to: { 2: `\\left(\${args[0]}${latexOperators.to}\${args[1]}\\right)` },
  // utils
  numeric: function(node, _options) {
    return node.args[0].toTex();
  },
  // type
  number: {
    0: "0",
    1: "\\left(${args[0]}\\right)",
    2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
  },
  string: {
    0: '\\mathtt{""}',
    1: "\\mathrm{string}\\left(${args[0]}\\right)"
  },
  bignumber: {
    0: "0",
    1: "\\left(${args[0]}\\right)"
  },
  bigint: {
    0: "0",
    1: "\\left(${args[0]}\\right)"
  },
  complex: {
    0: "0",
    1: "\\left(${args[0]}\\right)",
    2: `\\left(\\left(\${args[0]}\\right)+${latexSymbols.i}\\cdot\\left(\${args[1]}\\right)\\right)`
  },
  matrix: {
    0: "\\begin{bmatrix}\\end{bmatrix}",
    1: "\\left(${args[0]}\\right)",
    2: "\\left(${args[0]}\\right)"
  },
  sparse: {
    0: "\\begin{bsparse}\\end{bsparse}",
    1: "\\left(${args[0]}\\right)"
  },
  unit: {
    1: "\\left(${args[0]}\\right)",
    2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
  }
};
var defaultTemplate = "\\mathrm{${name}}\\left(${args}\\right)";
var latexUnits = {
  deg: "^\\circ"
};
function escapeLatex(string) {
  return escapeLatexLib__default.default(string, { preserveFormatting: true });
}
function toSymbol(name323, isUnit2) {
  isUnit2 = typeof isUnit2 === "undefined" ? false : isUnit2;
  if (isUnit2) {
    if (hasOwnProperty(latexUnits, name323)) {
      return latexUnits[name323];
    }
    return "\\mathrm{" + escapeLatex(name323) + "}";
  }
  if (hasOwnProperty(latexSymbols, name323)) {
    return latexSymbols[name323];
  }
  return escapeLatex(name323);
}

// src/expression/node/ConstantNode.ts
var name218 = "ConstantNode";
var dependencies219 = ["Node", "isBounded"];
var createConstantNode = /* @__PURE__ */ factory(
  name218,
  dependencies219,
  ({
    Node,
    isBounded
  }) => {
    class ConstantNode extends Node {
      /**
       * A ConstantNode holds a constant value like a number or string.
       *
       * Usage:
       *
       *     new ConstantNode(2.3)
       *     new ConstantNode('hello')
       *
       * @param {*} value    Value can be any type (number, BigNumber, bigint, string, ...)
       * @constructor ConstantNode
       * @extends {Node}
       */
      constructor(value) {
        super();
        this.value = value;
      }
      get type() {
        return name218;
      }
      get isConstantNode() {
        return true;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      _compile(_math, _argNames) {
        const value = this.value;
        return function evalConstantNode() {
          return value;
        };
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(_callback) {
      }
      /**
       * Create a new ConstantNode with children produced by the given callback.
       * Trivial because there are no children.
       * @param {function(child: Node, path: string, parent: Node) : Node} callback
       * @returns {ConstantNode} Returns a clone of the node
       */
      map(_callback) {
        return this.clone();
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {ConstantNode}
       */
      clone() {
        return new ConstantNode(this.value);
      }
      /**
       * Get string representation
       * @param {Object} options
       * @return {string} str
       */
      _toString(options) {
        return format3(this.value, options);
      }
      /**
       * Get HTML representation
       * @param {Object} options
       * @return {string} str
       */
      _toHTML(options) {
        const value = this._toString(options);
        switch (typeOf(this.value)) {
          case "number":
          case "bigint":
          case "BigNumber":
          case "Fraction":
            return '<span class="math-number">' + value + "</span>";
          case "string":
            return '<span class="math-string">' + value + "</span>";
          case "boolean":
            return '<span class="math-boolean">' + value + "</span>";
          case "null":
            return '<span class="math-null-symbol">' + value + "</span>";
          case "undefined":
            return '<span class="math-undefined">' + value + "</span>";
          default:
            return '<span class="math-symbol">' + value + "</span>";
        }
      }
      /**
       * Get a JSON representation of the node
       * @returns {Object}
       */
      toJSON() {
        return { mathjs: name218, value: this.value };
      }
      /**
       * Instantiate a ConstantNode from its JSON representation
       * @param {Object} json  An object structured like
       *                       `{"mathjs": "SymbolNode", value: 2.3}`,
       *                       where mathjs is optional
       * @returns {ConstantNode}
       */
      static fromJSON(json) {
        return new ConstantNode(json.value);
      }
      /**
       * Get LaTeX representation
       * @param {Object} options
       * @return {string} str
       */
      _toTex(options) {
        const value = this._toString(options);
        const type = typeOf(this.value);
        switch (type) {
          case "string":
            return "\\mathtt{" + escapeLatex(value) + "}";
          case "number":
          case "BigNumber": {
            if (!isBounded(this.value)) {
              return this.value.valueOf() < 0 ? "-\\infty" : "\\infty";
            }
            const index = value.toLowerCase().indexOf("e");
            if (index !== -1) {
              return value.substring(0, index) + "\\cdot10^{" + value.substring(index + 1) + "}";
            }
            return value;
          }
          case "bigint": {
            return value.toString();
          }
          case "Fraction":
            return this.value.toLatex();
          default:
            return value;
        }
      }
    }
    Object.defineProperty(ConstantNode, "name", {
      value: name218,
      configurable: true
    });
    return ConstantNode;
  },
  { isClass: true, isNode: true }
);

// src/expression/node/FunctionAssignmentNode.ts
var name219 = "FunctionAssignmentNode";
var dependencies220 = ["typed", "Node"];
var createFunctionAssignmentNode = /* @__PURE__ */ factory(
  name219,
  dependencies220,
  ({ typed: typed2, Node }) => {
    function needParenthesis(node, parenthesis, implicit) {
      const precedence = getPrecedence(node, parenthesis, implicit, void 0);
      const exprPrecedence = getPrecedence(
        node.expr,
        parenthesis,
        implicit,
        void 0
      );
      return parenthesis === "all" || exprPrecedence !== null && exprPrecedence <= precedence;
    }
    class FunctionAssignmentNode extends Node {
      /**
       * @constructor FunctionAssignmentNode
       * @extends {Node}
       * Function assignment
       *
       * @param {string} name           Function name
       * @param {string[] | Array.<{name: string, type: string}>} params
       *                                Array with function parameter names, or an
       *                                array with objects containing the name
       *                                and type of the parameter
       * @param {Node} expr             The function expression
       */
      constructor(name323, params, expr) {
        super();
        if (typeof name323 !== "string") {
          throw new TypeError('String expected for parameter "name"');
        }
        if (!Array.isArray(params)) {
          throw new TypeError(
            'Array containing strings or objects expected for parameter "params"'
          );
        }
        if (!isNode(expr)) {
          throw new TypeError('Node expected for parameter "expr"');
        }
        if (keywords.has(name323)) {
          throw new Error(
            'Illegal function name, "' + name323 + '" is a reserved keyword'
          );
        }
        const paramNames = /* @__PURE__ */ new Set();
        for (const param of params) {
          const paramName = typeof param === "string" ? param : param.name;
          if (paramNames.has(paramName)) {
            throw new Error(`Duplicate parameter name "${paramName}"`);
          } else {
            paramNames.add(paramName);
          }
        }
        this.name = name323;
        this.params = params.map(function(param) {
          return param && param.name || param;
        });
        this.types = params.map(function(param) {
          return param && param.type || "any";
        });
        this.expr = expr;
      }
      get type() {
        return name219;
      }
      get isFunctionAssignmentNode() {
        return true;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      _compile(math, argNames) {
        const childArgNames = Object.create(argNames);
        forEach(this.params, function(param) {
          childArgNames[param] = true;
        });
        const expr = this.expr;
        const evalExpr = expr._compile(math, childArgNames);
        const name323 = this.name;
        const params = this.params;
        const signature = join(this.types, ",");
        const syntax = name323 + "(" + join(this.params, ", ") + ")";
        return function evalFunctionAssignmentNode(scope, args, context) {
          const signatures = {};
          signatures[signature] = function(...fnArgs) {
            const childArgs = Object.create(args);
            for (let i = 0; i < params.length; i++) {
              childArgs[params[i]] = fnArgs[i];
            }
            return evalExpr(scope, childArgs, context);
          };
          const fn = typed2(name323, signatures);
          fn.syntax = syntax;
          fn.expr = expr.toString();
          scope.set(name323, fn);
          return fn;
        };
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(callback) {
        callback(this.expr, "expr", this);
      }
      /**
       * Create a new FunctionAssignmentNode whose children are the results of
       * calling the provided callback function for each child of the original
       * node.
       * @param {function(child: Node, path: string, parent: Node): Node} callback
       * @returns {FunctionAssignmentNode} Returns a transformed copy of the node
       */
      map(callback) {
        const expr = this._ifNode(callback(this.expr, "expr", this));
        return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {FunctionAssignmentNode}
       */
      clone() {
        return new FunctionAssignmentNode(
          this.name,
          this.params.slice(0),
          this.expr
        );
      }
      /**
       * get string representation
       * @param {Object} options
       * @return {string} str
       */
      _toString(options) {
        const parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        let expr = this.expr.toString(options);
        if (needParenthesis(this, parenthesis, options && options.implicit)) {
          expr = "(" + expr + ")";
        }
        return this.name + "(" + this.params.join(", ") + ") = " + expr;
      }
      /**
       * Get a JSON representation of the node
       * @returns {Object}
       */
      toJSON() {
        const types = this.types;
        return {
          mathjs: name219,
          name: this.name,
          params: this.params.map(function(param, index) {
            return {
              name: param,
              type: types[index]
            };
          }),
          expr: this.expr
        };
      }
      /**
       * Instantiate an FunctionAssignmentNode from its JSON representation
       * @param {Object} json
       *     An object structured like
       *     ```
       *     {"mathjs": "FunctionAssignmentNode",
       *      name: ..., params: ..., expr: ...}
       *     ```
       *     where mathjs is optional
       * @returns {FunctionAssignmentNode}
       */
      static fromJSON(json) {
        return new FunctionAssignmentNode(json.name, json.params, json.expr);
      }
      /**
       * get HTML representation
       * @param {Object} options
       * @return {string} str
       */
      _toHTML(options) {
        const parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        const params = [];
        for (let i = 0; i < this.params.length; i++) {
          params.push(
            '<span class="math-symbol math-parameter">' + escape(this.params[i]) + "</span>"
          );
        }
        let expr = this.expr.toHTML(options);
        if (needParenthesis(this, parenthesis, options && options.implicit)) {
          expr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + expr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        return '<span class="math-function">' + escape(this.name) + '</span><span class="math-parenthesis math-round-parenthesis">(</span>' + params.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-round-parenthesis">)</span><span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + expr;
      }
      /**
       * get LaTeX representation
       * @param {Object} options
       * @return {string} str
       */
      _toTex(options) {
        const parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        let expr = this.expr.toTex(options);
        if (needParenthesis(this, parenthesis, options && options.implicit)) {
          expr = `\\left(${expr}\\right)`;
        }
        return "\\mathrm{" + this.name + "}\\left(" + this.params.map(toSymbol).join(",") + "\\right)=" + expr;
      }
    }
    Object.defineProperty(FunctionAssignmentNode, "name", {
      value: name219,
      configurable: true
    });
    return FunctionAssignmentNode;
  },
  { isClass: true, isNode: true }
);

// src/expression/node/IndexNode.ts
var name220 = "IndexNode";
var dependencies221 = ["Node", "size"];
var createIndexNode = /* @__PURE__ */ factory(
  name220,
  dependencies221,
  ({ Node, size }) => {
    class IndexNode extends Node {
      /**
       * @constructor IndexNode
       * @extends Node
       *
       * Describes a subset of a matrix or an object property.
       * Cannot be used on its own, needs to be used within an AccessorNode or
       * AssignmentNode.
       *
       * @param {Node[]} dimensions
       * @param {boolean} [dotNotation=false]
       *     Optional property describing whether this index was written using dot
       *     notation like `a.b`, or using bracket notation like `a["b"]`
       *     (which is the default). This property is used for string conversion.
       */
      constructor(dimensions, dotNotation) {
        super();
        this.dimensions = dimensions;
        this.dotNotation = dotNotation || false;
        if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {
          throw new TypeError(
            'Array containing Nodes expected for parameter "dimensions"'
          );
        }
        if (this.dotNotation && !this.isObjectProperty()) {
          throw new Error("dotNotation only applicable for object properties");
        }
      }
      get type() {
        return name220;
      }
      get isIndexNode() {
        return true;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      // @ts-expect-error: method signature matches MathNode interface
      _compile(math, argNames) {
        const evalDimensions = map(
          this.dimensions,
          function(dimension, i) {
            const needsEnd = dimension.filter(
              (node) => node.isSymbolNode && node.name === "end"
            ).length > 0;
            if (needsEnd) {
              const childArgNames = Object.create(argNames);
              childArgNames.end = true;
              const _evalDimension = dimension._compile(math, childArgNames);
              return function evalDimension(scope, args, context) {
                if (!isMatrix(context) && !isArray(context) && !isString(context)) {
                  throw new TypeError(
                    'Cannot resolve "end": context must be a Matrix, Array, or string but is ' + typeOf(context)
                  );
                }
                const s = size(context);
                const childArgs = Object.create(args);
                childArgs.end = s[i];
                return _evalDimension(scope, childArgs, context);
              };
            } else {
              return dimension._compile(math, argNames);
            }
          }
        );
        const index = getSafeProperty(math, "index");
        return function evalIndexNode(scope, args, context) {
          const dimensions = map(
            evalDimensions,
            function(evalDimension) {
              return evalDimension(scope, args, context);
            }
          );
          return index(...dimensions);
        };
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(callback) {
        for (let i = 0; i < this.dimensions.length; i++) {
          callback(this.dimensions[i], "dimensions[" + i + "]", this);
        }
      }
      /**
       * Create a new IndexNode whose children are the results of calling
       * the provided callback function for each child of the original node.
       * @param {function(child: Node, path: string, parent: Node): Node} callback
       * @returns {IndexNode} Returns a transformed copy of the node
       */
      map(callback) {
        const dimensions = [];
        for (let i = 0; i < this.dimensions.length; i++) {
          dimensions[i] = this._ifNode(
            callback(this.dimensions[i], "dimensions[" + i + "]", this)
          );
        }
        return new IndexNode(dimensions, this.dotNotation);
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {IndexNode}
       */
      clone() {
        return new IndexNode(this.dimensions.slice(0), this.dotNotation);
      }
      /**
       * Test whether this IndexNode contains a single property name
       * @return {boolean}
       */
      isObjectProperty() {
        return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === "string";
      }
      /**
       * Returns the property name if IndexNode contains a property.
       * If not, returns null.
       * @return {string | null}
       */
      getObjectProperty() {
        return this.isObjectProperty() ? this.dimensions[0].value : null;
      }
      /**
       * Get string representation
       * @param {Object} options
       * @return {string} str
       */
      _toString(_options) {
        return this.dotNotation ? "." + this.getObjectProperty() : "[" + this.dimensions.join(", ") + "]";
      }
      /**
       * Get a JSON representation of the node
       * @returns {Object}
       */
      toJSON() {
        return {
          mathjs: name220,
          dimensions: this.dimensions,
          dotNotation: this.dotNotation
        };
      }
      /**
       * Instantiate an IndexNode from its JSON representation
       * @param {Object} json
       *     An object structured like
       *     `{"mathjs": "IndexNode", dimensions: [...], dotNotation: false}`,
       *     where mathjs is optional
       * @returns {IndexNode}
       */
      static fromJSON(json) {
        return new IndexNode(json.dimensions, json.dotNotation);
      }
      /**
       * Get HTML representation
       * @param {Object} options
       * @return {string} str
       */
      _toHTML(_options) {
        const dimensions = [];
        for (let i = 0; i < this.dimensions.length; i++) {
          dimensions[i] = this.dimensions[i].toHTML();
        }
        if (this.dotNotation) {
          return '<span class="math-operator math-accessor-operator">.</span><span class="math-symbol math-property">' + escape(this.getObjectProperty()) + "</span>";
        } else {
          return '<span class="math-parenthesis math-square-parenthesis">[</span>' + dimensions.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
        }
      }
      /**
       * Get LaTeX representation
       * @param {Object} options
       * @return {string} str
       */
      _toTex(options) {
        const dimensions = this.dimensions.map(function(range) {
          return range.toTex(options);
        });
        return this.dotNotation ? "." + this.getObjectProperty() : "_{" + dimensions.join(",") + "}";
      }
    }
    Object.defineProperty(IndexNode, "name", {
      value: name220,
      configurable: true
    });
    return IndexNode;
  },
  { isClass: true, isNode: true }
);

// src/expression/node/ObjectNode.ts
var name221 = "ObjectNode";
var dependencies222 = ["Node"];
var createObjectNode = /* @__PURE__ */ factory(
  name221,
  dependencies222,
  ({ Node }) => {
    class ObjectNode extends Node {
      /**
       * @constructor ObjectNode
       * @extends {Node}
       * Holds an object with keys/values
       * @param {Object.<string, Node>} [properties]   object with key/value pairs
       */
      constructor(properties2) {
        super();
        this.properties = properties2 || {};
        if (properties2) {
          if (!(typeof properties2 === "object") || !Object.keys(properties2).every(function(key) {
            return isNode(properties2[key]);
          })) {
            throw new TypeError("Object containing Nodes expected");
          }
        }
      }
      get type() {
        return name221;
      }
      get isObjectNode() {
        return true;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      // @ts-expect-error: method signature matches MathNode interface
      _compile(math, argNames) {
        const evalEntries = {};
        for (const key in this.properties) {
          if (hasOwnProperty(this.properties, key)) {
            const stringifiedKey = stringify(key);
            const parsedKey = JSON.parse(stringifiedKey);
            const prop = getSafeProperty(this.properties, key);
            evalEntries[parsedKey] = prop._compile(math, argNames);
          }
        }
        return function evalObjectNode(scope, args, context) {
          const obj = {};
          for (const key in evalEntries) {
            if (hasOwnProperty(evalEntries, key)) {
              obj[key] = evalEntries[key](scope, args, context);
            }
          }
          return obj;
        };
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(callback) {
        for (const key in this.properties) {
          if (hasOwnProperty(this.properties, key)) {
            callback(
              this.properties[key],
              "properties[" + stringify(key) + "]",
              this
            );
          }
        }
      }
      /**
       * Create a new ObjectNode whose children are the results of calling
       * the provided callback function for each child of the original node.
       * @param {function(child: Node, path: string, parent: Node): Node} callback
       * @returns {ObjectNode} Returns a transformed copy of the node
       */
      map(callback) {
        const properties2 = {};
        for (const key in this.properties) {
          if (hasOwnProperty(this.properties, key)) {
            properties2[key] = this._ifNode(
              callback(
                this.properties[key],
                "properties[" + stringify(key) + "]",
                this
              )
            );
          }
        }
        return new ObjectNode(properties2);
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {ObjectNode}
       */
      clone() {
        const properties2 = {};
        for (const key in this.properties) {
          if (hasOwnProperty(this.properties, key)) {
            properties2[key] = this.properties[key];
          }
        }
        return new ObjectNode(properties2);
      }
      /**
       * Get string representation
       * @param {Object} options
       * @return {string} str
       * @override
       */
      _toString(options) {
        const entries = [];
        for (const key in this.properties) {
          if (hasOwnProperty(this.properties, key)) {
            entries.push(
              stringify(key) + ": " + this.properties[key].toString(options)
            );
          }
        }
        return "{" + entries.join(", ") + "}";
      }
      /**
       * Get a JSON representation of the node
       * @returns {Object}
       */
      toJSON() {
        return {
          mathjs: name221,
          properties: this.properties
        };
      }
      /**
       * Instantiate an OperatorNode from its JSON representation
       * @param {Object} json  An object structured like
       *                       `{"mathjs": "ObjectNode", "properties": {...}}`,
       *                       where mathjs is optional
       * @returns {ObjectNode}
       */
      static fromJSON(json) {
        return new ObjectNode(json.properties);
      }
      /**
       * Get HTML representation
       * @param {Object} options
       * @return {string} str
       * @override
       */
      _toHTML(options) {
        const entries = [];
        for (const key in this.properties) {
          if (hasOwnProperty(this.properties, key)) {
            entries.push(
              '<span class="math-symbol math-property">' + escape(key) + '</span><span class="math-operator math-assignment-operator math-property-assignment-operator math-binary-operator">:</span>' + this.properties[key].toHTML(options)
            );
          }
        }
        return '<span class="math-parenthesis math-curly-parenthesis">{</span>' + entries.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-curly-parenthesis">}</span>';
      }
      /**
       * Get LaTeX representation
       * @param {Object} options
       * @return {string} str
       */
      _toTex(options) {
        const entries = [];
        for (const key in this.properties) {
          if (hasOwnProperty(this.properties, key)) {
            entries.push(
              "\\mathbf{" + key + ":} & " + this.properties[key].toTex(options) + "\\\\"
            );
          }
        }
        const tex = "\\left\\{\\begin{array}{ll}" + entries.join("\n") + "\\end{array}\\right\\}";
        return tex;
      }
    }
    Object.defineProperty(ObjectNode, "name", {
      value: name221,
      configurable: true
    });
    return ObjectNode;
  },
  { isClass: true, isNode: true }
);

// src/utils/scope.ts
function createSubScope(parentScope, args) {
  return new PartitionedMap(
    parentScope,
    new ObjectWrappingMap(args),
    new Set(Object.keys(args))
  );
}

// src/expression/node/OperatorNode.ts
var name222 = "OperatorNode";
var dependencies223 = ["Node"];
var createOperatorNode = /* @__PURE__ */ factory(
  name222,
  dependencies223,
  ({ Node }) => {
    function startsWithConstant(expr, parenthesis) {
      let curNode = expr;
      if (parenthesis === "auto") {
        while (isParenthesisNode(curNode)) curNode = curNode.content;
      }
      if (isConstantNode(curNode)) return true;
      if (isOperatorNode(curNode)) {
        return startsWithConstant(curNode.args[0], parenthesis);
      }
      return false;
    }
    function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {
      const precedence = getPrecedence(
        root,
        parenthesis,
        implicit,
        void 0
      );
      const associativity = getAssociativity(root, parenthesis);
      if (parenthesis === "all" || args.length > 2 && root.getIdentifier() !== "OperatorNode:add" && root.getIdentifier() !== "OperatorNode:multiply") {
        return args.map(function(arg) {
          switch (arg.getContent().type) {
            case "ArrayNode":
            case "ConstantNode":
            case "SymbolNode":
            case "ParenthesisNode":
              return false;
            default:
              return true;
          }
        });
      }
      let result;
      switch (args.length) {
        case 0:
          result = [];
          break;
        case 1:
          {
            const operandPrecedence = getPrecedence(
              args[0],
              parenthesis,
              implicit,
              root
            );
            if (latex && operandPrecedence !== null) {
              let operandIdentifier;
              let rootIdentifier;
              if (parenthesis === "keep") {
                operandIdentifier = args[0].getIdentifier();
                rootIdentifier = root.getIdentifier();
              } else {
                operandIdentifier = args[0].getContent().getIdentifier();
                rootIdentifier = root.getContent().getIdentifier();
              }
              if (properties[precedence][rootIdentifier].latexLeftParens === false) {
                result = [false];
                break;
              }
              if (properties[operandPrecedence][operandIdentifier].latexParens === false) {
                result = [false];
                break;
              }
            }
            if (operandPrecedence === null) {
              result = [false];
              break;
            }
            if (operandPrecedence <= precedence) {
              result = [true];
              break;
            }
            result = [false];
          }
          break;
        case 2:
          {
            let lhsParens;
            const lhsPrecedence = getPrecedence(
              args[0],
              parenthesis,
              implicit,
              root
            );
            const assocWithLhs = isAssociativeWith(
              root,
              args[0],
              parenthesis
            );
            if (lhsPrecedence === null) {
              lhsParens = false;
            } else if (lhsPrecedence === precedence && associativity === "right" && !assocWithLhs) {
              lhsParens = true;
            } else if (lhsPrecedence < precedence) {
              lhsParens = true;
            } else {
              lhsParens = false;
            }
            let rhsParens;
            const rhsPrecedence = getPrecedence(
              args[1],
              parenthesis,
              implicit,
              root
            );
            const assocWithRhs = isAssociativeWith(
              root,
              args[1],
              parenthesis
            );
            if (rhsPrecedence === null) {
              rhsParens = false;
            } else if (rhsPrecedence === precedence && associativity === "left" && !assocWithRhs) {
              rhsParens = true;
            } else if (rhsPrecedence < precedence) {
              rhsParens = true;
            } else {
              rhsParens = false;
            }
            if (latex) {
              let rootIdentifier;
              let lhsIdentifier;
              let rhsIdentifier;
              if (parenthesis === "keep") {
                rootIdentifier = root.getIdentifier();
                lhsIdentifier = root.args[0].getIdentifier();
                rhsIdentifier = root.args[1].getIdentifier();
              } else {
                rootIdentifier = root.getContent().getIdentifier();
                lhsIdentifier = root.args[0].getContent().getIdentifier();
                rhsIdentifier = root.args[1].getContent().getIdentifier();
              }
              if (lhsPrecedence !== null) {
                if (properties[precedence][rootIdentifier].latexLeftParens === false) {
                  lhsParens = false;
                }
                if (properties[lhsPrecedence][lhsIdentifier].latexParens === false) {
                  lhsParens = false;
                }
              }
              if (rhsPrecedence !== null) {
                if (properties[precedence][rootIdentifier].latexRightParens === false) {
                  rhsParens = false;
                }
                if (properties[rhsPrecedence][rhsIdentifier].latexParens === false) {
                  rhsParens = false;
                }
              }
            }
            result = [lhsParens, rhsParens];
          }
          break;
        default:
          if (root.getIdentifier() === "OperatorNode:add" || root.getIdentifier() === "OperatorNode:multiply") {
            result = args.map(function(arg) {
              const argPrecedence = getPrecedence(
                arg,
                parenthesis,
                implicit,
                root
              );
              const assocWithArg = isAssociativeWith(
                root,
                arg,
                parenthesis
              );
              const argAssociativity = getAssociativity(arg, parenthesis);
              if (argPrecedence === null) {
                return false;
              } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {
                return true;
              } else if (argPrecedence < precedence) {
                return true;
              }
              return false;
            });
          }
          break;
      }
      if (args.length >= 2 && root.getIdentifier() === "OperatorNode:multiply" && root.implicit && parenthesis !== "all" && implicit === "hide") {
        for (let i = 1; i < result.length; ++i) {
          if (startsWithConstant(args[i], parenthesis) && !result[i - 1] && (parenthesis !== "keep" || !isParenthesisNode(args[i - 1]))) {
            result[i] = true;
          }
        }
      }
      return result;
    }
    class OperatorNode extends Node {
      /**
       * @constructor OperatorNode
       * @extends {Node}
       * An operator with two arguments, like 2+3
       *
       * @param {string} op           Operator name, for example '+'
       * @param {string} fn           Function name, for example 'add'
       * @param {Node[]} args         Operator arguments
       * @param {boolean} [implicit]  Is this an implicit multiplication?
       * @param {boolean} [isPercentage] Is this an percentage Operation?
       */
      constructor(op, fn, args, implicit, isPercentage) {
        super();
        if (typeof op !== "string") {
          throw new TypeError('string expected for parameter "op"');
        }
        if (typeof fn !== "string") {
          throw new TypeError('string expected for parameter "fn"');
        }
        if (!Array.isArray(args) || !args.every(isNode)) {
          throw new TypeError(
            'Array containing Nodes expected for parameter "args"'
          );
        }
        this.implicit = implicit === true;
        this.isPercentage = isPercentage === true;
        this.op = op;
        this.fn = fn;
        this.args = args || [];
      }
      get type() {
        return name222;
      }
      get isOperatorNode() {
        return true;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      // @ts-expect-error: method signature matches MathNode interface
      _compile(math, argNames) {
        if (typeof this.fn !== "string" || !isSafeMethod(math, this.fn)) {
          if (!math[this.fn]) {
            throw new Error(
              "Function " + this.fn + ' missing in provided namespace "math"'
            );
          } else {
            throw new Error('No access to function "' + this.fn + '"');
          }
        }
        const fn = getSafeProperty(math, this.fn);
        const evalArgs = map(this.args, function(arg) {
          return arg._compile(math, argNames);
        });
        if (typeof fn === "function" && fn.rawArgs === true) {
          const rawArgs = this.args;
          return function evalOperatorNode(scope, args, _context) {
            return fn(rawArgs, math, createSubScope(scope, args));
          };
        } else if (evalArgs.length === 1) {
          const evalArg0 = evalArgs[0];
          return function evalOperatorNode(scope, args, context) {
            return fn(evalArg0(scope, args, context));
          };
        } else if (evalArgs.length === 2) {
          const evalArg0 = evalArgs[0];
          const evalArg1 = evalArgs[1];
          return function evalOperatorNode(scope, args, context) {
            return fn(
              evalArg0(scope, args, context),
              evalArg1(scope, args, context)
            );
          };
        } else {
          return function evalOperatorNode(scope, args, context) {
            return fn.apply(
              null,
              map(evalArgs, function(evalArg) {
                return evalArg(scope, args, context);
              })
            );
          };
        }
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(callback) {
        for (let i = 0; i < this.args.length; i++) {
          callback(this.args[i], "args[" + i + "]", this);
        }
      }
      /**
       * Create a new OperatorNode whose children are the results of calling
       * the provided callback function for each child of the original node.
       * @param {function(child: Node, path: string, parent: Node): Node} callback
       * @returns {OperatorNode} Returns a transformed copy of the node
       */
      map(callback) {
        const args = [];
        for (let i = 0; i < this.args.length; i++) {
          args[i] = this._ifNode(
            callback(this.args[i], "args[" + i + "]", this)
          );
        }
        return new OperatorNode(
          this.op,
          this.fn,
          args,
          this.implicit,
          this.isPercentage
        );
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {OperatorNode}
       */
      clone() {
        return new OperatorNode(
          this.op,
          this.fn,
          this.args.slice(0),
          this.implicit,
          this.isPercentage
        );
      }
      /**
       * Check whether this is an unary OperatorNode:
       * has exactly one argument, like `-a`.
       * @return {boolean}
       *     Returns true when an unary operator node, false otherwise.
       */
      isUnary() {
        return this.args.length === 1;
      }
      /**
       * Check whether this is a binary OperatorNode:
       * has exactly two arguments, like `a + b`.
       * @return {boolean}
       *     Returns true when a binary operator node, false otherwise.
       */
      isBinary() {
        return this.args.length === 2;
      }
      /**
       * Get string representation.
       * @param {Object} options
       * @return {string} str
       */
      _toString(options) {
        const parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        const implicit = options && options.implicit ? options.implicit : "hide";
        const args = this.args;
        const parens = calculateNecessaryParentheses(
          this,
          parenthesis,
          implicit,
          args,
          false
        );
        if (args.length === 1) {
          const assoc = getAssociativity(this, parenthesis);
          let operand = args[0].toString(options);
          if (parens[0]) {
            operand = "(" + operand + ")";
          }
          const opIsNamed = /[a-zA-Z]+/.test(this.op);
          if (assoc === "right") {
            return this.op + (opIsNamed ? " " : "") + operand;
          } else if (assoc === "left") {
            return operand + (opIsNamed ? " " : "") + this.op;
          }
          return operand + this.op;
        } else if (args.length === 2) {
          let lhs = args[0].toString(options);
          let rhs = args[1].toString(options);
          if (parens[0]) {
            lhs = "(" + lhs + ")";
          }
          if (parens[1]) {
            rhs = "(" + rhs + ")";
          }
          if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
            return lhs + " " + rhs;
          }
          return lhs + " " + this.op + " " + rhs;
        } else if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
          const stringifiedArgs = args.map(function(arg, index) {
            let argStr = arg.toString(options);
            if (parens[index]) {
              argStr = "(" + argStr + ")";
            }
            return argStr;
          });
          if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
            return stringifiedArgs.join(" ");
          }
          return stringifiedArgs.join(" " + this.op + " ");
        } else {
          return this.fn + "(" + this.args.join(", ") + ")";
        }
      }
      /**
       * Get a JSON representation of the node
       * @returns {Object}
       */
      toJSON() {
        return {
          mathjs: name222,
          op: this.op,
          fn: this.fn,
          args: this.args,
          implicit: this.implicit,
          isPercentage: this.isPercentage
        };
      }
      /**
       * Instantiate an OperatorNode from its JSON representation
       * @param {Object} json
       *     An object structured like
       *     ```
       *     {"mathjs": "OperatorNode",
       *      "op": "+", "fn": "add", "args": [...],
       *      "implicit": false,
       *      "isPercentage":false}
       *     ```
       *     where mathjs is optional
       * @returns {OperatorNode}
       */
      static fromJSON(json) {
        return new OperatorNode(
          json.op,
          json.fn,
          json.args,
          json.implicit,
          json.isPercentage
        );
      }
      /**
       * Get HTML representation.
       * @param {Object} options
       * @return {string} str
       */
      _toHTML(options) {
        const parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        const implicit = options && options.implicit ? options.implicit : "hide";
        const args = this.args;
        const parens = calculateNecessaryParentheses(
          this,
          parenthesis,
          implicit,
          args,
          false
        );
        if (args.length === 1) {
          const assoc = getAssociativity(this, parenthesis);
          let operand = args[0].toHTML(options);
          if (parens[0]) {
            operand = '<span class="math-parenthesis math-round-parenthesis">(</span>' + operand + '<span class="math-parenthesis math-round-parenthesis">)</span>';
          }
          if (assoc === "right") {
            return '<span class="math-operator math-unary-operator math-lefthand-unary-operator">' + escape(this.op) + "</span>" + operand;
          } else {
            return operand + '<span class="math-operator math-unary-operator math-righthand-unary-operator">' + escape(this.op) + "</span>";
          }
        } else if (args.length === 2) {
          let lhs = args[0].toHTML(options);
          let rhs = args[1].toHTML(options);
          if (parens[0]) {
            lhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + lhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
          }
          if (parens[1]) {
            rhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + rhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
          }
          if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
            return lhs + '<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>' + rhs;
          }
          return lhs + '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(this.op) + "</span>" + rhs;
        } else {
          const stringifiedArgs = args.map(function(arg, index) {
            let argStr = arg.toHTML(options);
            if (parens[index]) {
              argStr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + argStr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
            }
            return argStr;
          });
          if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
            if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
              return stringifiedArgs.join(
                '<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>'
              );
            }
            return stringifiedArgs.join(
              '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(this.op) + "</span>"
            );
          } else {
            return '<span class="math-function">' + escape(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + stringifiedArgs.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
          }
        }
      }
      /**
       * Get LaTeX representation
       * @param {Object} options
       * @return {string} str
       */
      _toTex(options) {
        const parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        const implicit = options && options.implicit ? options.implicit : "hide";
        const args = this.args;
        const parens = calculateNecessaryParentheses(
          this,
          parenthesis,
          implicit,
          args,
          true
        );
        let op = latexOperators[this.fn];
        op = typeof op === "undefined" ? this.op : op;
        if (args.length === 1) {
          const assoc = getAssociativity(this, parenthesis);
          let operand = args[0].toTex(options);
          if (parens[0]) {
            operand = `\\left(${operand}\\right)`;
          }
          if (assoc === "right") {
            return op + operand;
          } else if (assoc === "left") {
            return operand + op;
          }
          return operand + op;
        } else if (args.length === 2) {
          const lhs = args[0];
          let lhsTex = lhs.toTex(options);
          if (parens[0]) {
            lhsTex = `\\left(${lhsTex}\\right)`;
          }
          const rhs = args[1];
          let rhsTex = rhs.toTex(options);
          if (parens[1]) {
            rhsTex = `\\left(${rhsTex}\\right)`;
          }
          let lhsIdentifier;
          if (parenthesis === "keep") {
            lhsIdentifier = lhs.getIdentifier();
          } else {
            lhsIdentifier = lhs.getContent().getIdentifier();
          }
          switch (this.getIdentifier()) {
            case "OperatorNode:divide":
              return op + "{" + lhsTex + "}{" + rhsTex + "}";
            case "OperatorNode:pow":
              lhsTex = "{" + lhsTex + "}";
              rhsTex = "{" + rhsTex + "}";
              switch (lhsIdentifier) {
                case "ConditionalNode":
                //
                case "OperatorNode:divide":
                  lhsTex = `\\left(${lhsTex}\\right)`;
              }
              break;
            case "OperatorNode:multiply":
              if (this.implicit && implicit === "hide") {
                return lhsTex + "~" + rhsTex;
              }
          }
          return lhsTex + op + rhsTex;
        } else if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
          const texifiedArgs = args.map(function(arg, index) {
            let argStr = arg.toTex(options);
            if (parens[index]) {
              argStr = `\\left(${argStr}\\right)`;
            }
            return argStr;
          });
          if (this.getIdentifier() === "OperatorNode:multiply" && this.implicit && implicit === "hide") {
            return texifiedArgs.join("~");
          }
          return texifiedArgs.join(op);
        } else {
          return "\\mathrm{" + this.fn + "}\\left(" + args.map(function(arg) {
            return arg.toTex(options);
          }).join(",") + "\\right)";
        }
      }
      /**
       * Get identifier.
       * @return {string}
       */
      // @ts-expect-error: method signature matches MathNode interface
      getIdentifier() {
        return this.type + ":" + this.fn;
      }
    }
    Object.defineProperty(OperatorNode, "name", {
      value: name222,
      configurable: true
    });
    return OperatorNode;
  },
  { isClass: true, isNode: true }
);

// src/expression/node/ParenthesisNode.ts
var name223 = "ParenthesisNode";
var dependencies224 = ["Node"];
var createParenthesisNode = /* @__PURE__ */ factory(
  name223,
  dependencies224,
  ({ Node }) => {
    class ParenthesisNode extends Node {
      /**
       * @constructor ParenthesisNode
       * @extends {Node}
       * A parenthesis node describes manual parenthesis from the user input
       * @param {Node} content
       * @extends {Node}
       */
      constructor(content) {
        super();
        if (!isNode(content)) {
          throw new TypeError('Node expected for parameter "content"');
        }
        this.content = content;
      }
      get type() {
        return name223;
      }
      get isParenthesisNode() {
        return true;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      // @ts-expect-error: method signature matches MathNode interface
      _compile(math, argNames) {
        return this.content._compile(math, argNames);
      }
      /**
       * Get the content of the current Node.
       * @return {Node} content
       * @override
       **/
      // @ts-expect-error: method signature matches MathNode interface
      getContent() {
        return this.content.getContent();
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(callback) {
        callback(this.content, "content", this);
      }
      /**
       * Create a new ParenthesisNode whose child is the result of calling
       * the provided callback function on the child of this node.
       * @param {function(child: Node, path: string, parent: Node) : Node} callback
       * @returns {ParenthesisNode} Returns a clone of the node
       */
      map(callback) {
        const content = callback(this.content, "content", this);
        return new ParenthesisNode(content);
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {ParenthesisNode}
       */
      clone() {
        return new ParenthesisNode(this.content);
      }
      /**
       * Get string representation
       * @param {Object} options
       * @return {string} str
       * @override
       */
      _toString(options) {
        if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
          return "(" + this.content.toString(options) + ")";
        }
        return this.content.toString(options);
      }
      /**
       * Get a JSON representation of the node
       * @returns {Object}
       */
      toJSON() {
        return { mathjs: name223, content: this.content };
      }
      /**
       * Instantiate an ParenthesisNode from its JSON representation
       * @param {Object} json  An object structured like
       *                       `{"mathjs": "ParenthesisNode", "content": ...}`,
       *                       where mathjs is optional
       * @returns {ParenthesisNode}
       */
      static fromJSON(json) {
        return new ParenthesisNode(json.content);
      }
      /**
       * Get HTML representation
       * @param {Object} options
       * @return {string} str
       * @override
       */
      _toHTML(options) {
        if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
          return '<span class="math-parenthesis math-round-parenthesis">(</span>' + this.content.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        return this.content.toHTML(options);
      }
      /**
       * Get LaTeX representation
       * @param {Object} options
       * @return {string} str
       * @override
       */
      _toTex(options) {
        if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
          return `\\left(${this.content.toTex(options)}\\right)`;
        }
        return this.content.toTex(options);
      }
    }
    Object.defineProperty(ParenthesisNode, "name", {
      value: name223,
      configurable: true
    });
    return ParenthesisNode;
  },
  { isClass: true, isNode: true }
);

// src/expression/node/RangeNode.ts
var name224 = "RangeNode";
var dependencies225 = ["Node"];
var createRangeNode = /* @__PURE__ */ factory(
  name224,
  dependencies225,
  ({ Node }) => {
    function calculateNecessaryParentheses(node, parenthesis, implicit) {
      const precedence = getPrecedence(
        node,
        parenthesis,
        implicit,
        void 0
      );
      const parens = { start: false, end: false };
      const startPrecedence = getPrecedence(
        node.start,
        parenthesis,
        implicit,
        void 0
      );
      parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === "all";
      if (node.step) {
        const stepPrecedence = getPrecedence(
          node.step,
          parenthesis,
          implicit,
          void 0
        );
        parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === "all";
      }
      const endPrecedence = getPrecedence(
        node.end,
        parenthesis,
        implicit,
        void 0
      );
      parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === "all";
      return parens;
    }
    class RangeNode extends Node {
      /**
       * @constructor RangeNode
       * @extends {Node}
       * create a range
       * @param {Node} start  included lower-bound
       * @param {Node} end    included upper-bound
       * @param {Node} [step] optional step
       */
      constructor(start, end, step) {
        super();
        if (!isNode(start)) throw new TypeError("Node expected");
        if (!isNode(end)) throw new TypeError("Node expected");
        if (step && !isNode(step)) throw new TypeError("Node expected");
        if (arguments.length > 3) throw new Error("Too many arguments");
        this.start = start;
        this.end = end;
        this.step = step || null;
      }
      get type() {
        return name224;
      }
      get isRangeNode() {
        return true;
      }
      /**
       * Check whether the RangeNode needs the `end` symbol to be defined.
       * This end is the size of the Matrix in current dimension.
       * @return {boolean}
       */
      needsEnd() {
        const endSymbols = this.filter(function(node) {
          return isSymbolNode(node) && node.name === "end";
        });
        return endSymbols.length > 0;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      // @ts-expect-error: method signature matches MathNode interface
      _compile(math, argNames) {
        const range = math.range;
        const evalStart = this.start._compile(math, argNames);
        const evalEnd = this.end._compile(math, argNames);
        if (this.step) {
          const evalStep = this.step._compile(math, argNames);
          return function evalRangeNode(scope, args, context) {
            return range(
              evalStart(scope, args, context),
              evalEnd(scope, args, context),
              evalStep(scope, args, context)
            );
          };
        } else {
          return function evalRangeNode(scope, args, context) {
            return range(
              evalStart(scope, args, context),
              evalEnd(scope, args, context)
            );
          };
        }
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(callback) {
        callback(this.start, "start", this);
        callback(this.end, "end", this);
        if (this.step) {
          callback(this.step, "step", this);
        }
      }
      /**
       * Create a new RangeNode whose children are the results of calling
       * the provided callback function for each child of the original node.
       * @param {function(child: Node, path: string, parent: Node): Node} callback
       * @returns {RangeNode} Returns a transformed copy of the node
       */
      map(callback) {
        return new RangeNode(
          this._ifNode(callback(this.start, "start", this)),
          this._ifNode(callback(this.end, "end", this)),
          this.step ? this._ifNode(callback(this.step, "step", this)) : void 0
        );
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {RangeNode}
       */
      clone() {
        return new RangeNode(this.start, this.end, this.step || void 0);
      }
      /**
       * Get string representation
       * @param {Object} options
       * @return {string} str
       */
      _toString(options) {
        const parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        const parens = calculateNecessaryParentheses(
          this,
          parenthesis,
          options && options.implicit || "hide"
        );
        let str;
        let start = this.start.toString(options);
        if (parens.start) {
          start = "(" + start + ")";
        }
        str = start;
        if (this.step) {
          let step = this.step.toString(options);
          if (parens.step) {
            step = "(" + step + ")";
          }
          str += ":" + step;
        }
        let end = this.end.toString(options);
        if (parens.end) {
          end = "(" + end + ")";
        }
        str += ":" + end;
        return str;
      }
      /**
       * Get a JSON representation of the node
       * @returns {Object}
       */
      toJSON() {
        return {
          mathjs: name224,
          start: this.start,
          end: this.end,
          step: this.step
        };
      }
      /**
       * Instantiate an RangeNode from its JSON representation
       * @param {Object} json
       *     An object structured like
       *     `{"mathjs": "RangeNode", "start": ..., "end": ..., "step": ...}`,
       *     where mathjs is optional
       * @returns {RangeNode}
       */
      static fromJSON(json) {
        return new RangeNode(json.start, json.end, json.step);
      }
      /**
       * Get HTML representation
       * @param {Object} options
       * @return {string} str
       */
      _toHTML(options) {
        const parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        const parens = calculateNecessaryParentheses(
          this,
          parenthesis,
          options && options.implicit || "hide"
        );
        let str;
        let start = this.start.toHTML(options);
        if (parens.start) {
          start = '<span class="math-parenthesis math-round-parenthesis">(</span>' + start + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        str = start;
        if (this.step) {
          let step = this.step.toHTML(options);
          if (parens.step) {
            step = '<span class="math-parenthesis math-round-parenthesis">(</span>' + step + '<span class="math-parenthesis math-round-parenthesis">)</span>';
          }
          str += '<span class="math-operator math-range-operator">:</span>' + step;
        }
        let end = this.end.toHTML(options);
        if (parens.end) {
          end = '<span class="math-parenthesis math-round-parenthesis">(</span>' + end + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        str += '<span class="math-operator math-range-operator">:</span>' + end;
        return str;
      }
      /**
       * Get LaTeX representation
       * @params {Object} options
       * @return {string} str
       */
      _toTex(options) {
        const parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        const parens = calculateNecessaryParentheses(
          this,
          parenthesis,
          options && options.implicit || "hide"
        );
        let str = this.start.toTex(options);
        if (parens.start) {
          str = `\\left(${str}\\right)`;
        }
        if (this.step) {
          let step = this.step.toTex(options);
          if (parens.step) {
            step = `\\left(${step}\\right)`;
          }
          str += ":" + step;
        }
        let end = this.end.toTex(options);
        if (parens.end) {
          end = `\\left(${end}\\right)`;
        }
        str += ":" + end;
        return str;
      }
    }
    Object.defineProperty(RangeNode, "name", {
      value: name224,
      configurable: true
    });
    return RangeNode;
  },
  { isClass: true, isNode: true }
);

// src/expression/node/RelationalNode.ts
var name225 = "RelationalNode";
var dependencies226 = ["Node"];
var createRelationalNode = /* @__PURE__ */ factory(
  name225,
  dependencies226,
  ({ Node }) => {
    const operatorMap = {
      equal: "==",
      unequal: "!=",
      smaller: "<",
      larger: ">",
      smallerEq: "<=",
      largerEq: ">="
    };
    class RelationalNode extends Node {
      /**
       * A node representing a chained conditional expression, such as 'x > y > z'
       *
       * @param {String[]} conditionals
       *     An array of conditional operators used to compare the parameters
       * @param {Node[]} params
       *     The parameters that will be compared
       *
       * @constructor RelationalNode
       * @extends {Node}
       */
      constructor(conditionals, params) {
        super();
        if (!Array.isArray(conditionals)) {
          throw new TypeError("Parameter conditionals must be an array");
        }
        if (!Array.isArray(params)) {
          throw new TypeError("Parameter params must be an array");
        }
        if (conditionals.length !== params.length - 1) {
          throw new TypeError(
            "Parameter params must contain exactly one more element than parameter conditionals"
          );
        }
        this.conditionals = conditionals;
        this.params = params;
      }
      get type() {
        return name225;
      }
      get isRelationalNode() {
        return true;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      // @ts-expect-error: method signature matches MathNode interface
      _compile(math, argNames) {
        const self = this;
        const compiled = this.params.map(
          (p) => p._compile(math, argNames)
        );
        return function evalRelationalNode(scope, args, context) {
          let evalLhs;
          let evalRhs = compiled[0](scope, args, context);
          for (let i = 0; i < self.conditionals.length; i++) {
            evalLhs = evalRhs;
            evalRhs = compiled[i + 1](scope, args, context);
            const condFn = getSafeProperty(math, self.conditionals[i]);
            if (!condFn(evalLhs, evalRhs)) {
              return false;
            }
          }
          return true;
        };
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(callback) {
        this.params.forEach(
          (n, i) => callback(n, "params[" + i + "]", this),
          this
        );
      }
      /**
       * Create a new RelationalNode whose children are the results of calling
       * the provided callback function for each child of the original node.
       * @param {function(child: Node, path: string, parent: Node): Node} callback
       * @returns {RelationalNode} Returns a transformed copy of the node
       */
      map(callback) {
        return new RelationalNode(
          this.conditionals.slice(),
          this.params.map(
            (n, i) => this._ifNode(callback(n, "params[" + i + "]", this)),
            this
          )
        );
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {RelationalNode}
       */
      clone() {
        return new RelationalNode(this.conditionals, this.params);
      }
      /**
       * Get string representation.
       * @param {Object} options
       * @return {string} str
       */
      _toString(options) {
        const parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        const precedence = getPrecedence(
          this,
          parenthesis,
          options && options.implicit || "hide",
          void 0
        );
        const paramStrings = this.params.map(function(p, _index) {
          const paramPrecedence = getPrecedence(
            p,
            parenthesis,
            options && options.implicit || "hide",
            void 0
          );
          return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? "(" + p.toString(options) + ")" : p.toString(options);
        });
        let ret = paramStrings[0];
        for (let i = 0; i < this.conditionals.length; i++) {
          ret += " " + operatorMap[this.conditionals[i]];
          ret += " " + paramStrings[i + 1];
        }
        return ret;
      }
      /**
       * Get a JSON representation of the node
       * @returns {Object}
       */
      toJSON() {
        return {
          mathjs: name225,
          conditionals: this.conditionals,
          params: this.params
        };
      }
      /**
       * Instantiate a RelationalNode from its JSON representation
       * @param {Object} json
       *     An object structured like
       *     `{"mathjs": "RelationalNode", "conditionals": ..., "params": ...}`,
       *     where mathjs is optional
       * @returns {RelationalNode}
       */
      static fromJSON(json) {
        return new RelationalNode(json.conditionals, json.params);
      }
      /**
       * Get HTML representation
       * @param {Object} options
       * @return {string} str
       */
      _toHTML(options) {
        const parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        const precedence = getPrecedence(
          this,
          parenthesis,
          options && options.implicit || "hide",
          void 0
        );
        const paramStrings = this.params.map(function(p, _index) {
          const paramPrecedence = getPrecedence(
            p,
            parenthesis,
            options && options.implicit || "hide",
            void 0
          );
          return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class="math-parenthesis math-round-parenthesis">(</span>' + p.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>' : p.toHTML(options);
        });
        let ret = paramStrings[0];
        for (let i = 0; i < this.conditionals.length; i++) {
          ret += '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(operatorMap[this.conditionals[i]]) + "</span>" + paramStrings[i + 1];
        }
        return ret;
      }
      /**
       * Get LaTeX representation
       * @param {Object} options
       * @return {string} str
       */
      _toTex(options) {
        const parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        const precedence = getPrecedence(
          this,
          parenthesis,
          options && options.implicit || "hide",
          void 0
        );
        const paramStrings = this.params.map(function(p, _index) {
          const paramPrecedence = getPrecedence(
            p,
            parenthesis,
            options && options.implicit || "hide",
            void 0
          );
          return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? "\\left(" + p.toTex(options) + "\\right)" : p.toTex(options);
        });
        let ret = paramStrings[0];
        for (let i = 0; i < this.conditionals.length; i++) {
          ret += latexOperators[this.conditionals[i]] + paramStrings[i + 1];
        }
        return ret;
      }
    }
    Object.defineProperty(RelationalNode, "name", {
      value: name225,
      configurable: true
    });
    return RelationalNode;
  },
  { isClass: true, isNode: true }
);

// src/expression/node/SymbolNode.ts
var name226 = "SymbolNode";
var dependencies227 = ["math", "?Unit", "Node"];
var createSymbolNode = /* @__PURE__ */ factory(
  name226,
  dependencies227,
  ({ math, Unit, Node }) => {
    function isValuelessUnit(name323) {
      return Unit ? Unit.isValuelessUnit(name323) : false;
    }
    class SymbolNode extends Node {
      /**
       * @constructor SymbolNode
       * @extends {Node}
       * A symbol node can hold and resolve a symbol
       * @param {string} name
       * @extends {Node}
       */
      constructor(name323) {
        super();
        if (typeof name323 !== "string") {
          throw new TypeError('String expected for parameter "name"');
        }
        this.name = name323;
      }
      get type() {
        return "SymbolNode";
      }
      get isSymbolNode() {
        return true;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      _compile(math2, argNames) {
        const name323 = this.name;
        if (argNames[name323] === true) {
          return function(scope, args, _context) {
            return getSafeProperty(args, name323);
          };
        } else if (name323 in math2) {
          return function(scope, _args, _context) {
            return scope.has(name323) ? scope.get(name323) : getSafeProperty(math2, name323);
          };
        } else {
          const isUnit2 = isValuelessUnit(name323);
          return function(scope, _args, _context) {
            return scope.has(name323) ? scope.get(name323) : isUnit2 ? new Unit(null, name323) : SymbolNode.onUndefinedSymbol(name323);
          };
        }
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(_callback) {
      }
      /**
       * Create a new SymbolNode with children produced by the given callback.
       * Trivial since a SymbolNode has no children
       * @param {function(child: Node, path: string, parent: Node) : Node} callback
       * @returns {SymbolNode} Returns a clone of the node
       */
      map(_callback) {
        return this.clone();
      }
      /**
       * Throws an error 'Undefined symbol {name}'
       * @param {string} name
       */
      static onUndefinedSymbol(name323) {
        throw new Error("Undefined symbol " + name323);
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {SymbolNode}
       */
      // @ts-expect-error: clone returns SymbolNode which is compatible with MathNode
      clone() {
        return new SymbolNode(this.name);
      }
      /**
       * Get string representation
       * @param {Object} options
       * @return {string} str
       * @override
       */
      _toString(_options) {
        return this.name;
      }
      /**
       * Get HTML representation
       * @param {Object} options
       * @return {string} str
       * @override
       */
      _toHTML(_options) {
        const name323 = escape(this.name);
        if (name323 === "true" || name323 === "false") {
          return '<span class="math-symbol math-boolean">' + name323 + "</span>";
        } else if (name323 === "i") {
          return '<span class="math-symbol math-imaginary-symbol">' + name323 + "</span>";
        } else if (name323 === "Infinity") {
          return '<span class="math-symbol math-infinity-symbol">' + name323 + "</span>";
        } else if (name323 === "NaN") {
          return '<span class="math-symbol math-nan-symbol">' + name323 + "</span>";
        } else if (name323 === "null") {
          return '<span class="math-symbol math-null-symbol">' + name323 + "</span>";
        } else if (name323 === "undefined") {
          return '<span class="math-symbol math-undefined-symbol">' + name323 + "</span>";
        }
        return '<span class="math-symbol">' + name323 + "</span>";
      }
      /**
       * Get a JSON representation of the node
       * @returns {Object}
       */
      toJSON() {
        return {
          mathjs: "SymbolNode",
          name: this.name
        };
      }
      /**
       * Instantiate a SymbolNode from its JSON representation
       * @param {Object} json  An object structured like
       *                       `{"mathjs": "SymbolNode", name: "x"}`,
       *                       where mathjs is optional
       * @returns {SymbolNode}
       */
      static fromJSON(json) {
        return new SymbolNode(json.name);
      }
      /**
       * Get LaTeX representation
       * @param {Object} options
       * @return {string} str
       * @override
       */
      _toTex(_options) {
        let isUnit2 = false;
        if (typeof math[this.name] === "undefined" && isValuelessUnit(this.name)) {
          isUnit2 = true;
        }
        const symbol = toSymbol(this.name, isUnit2);
        if (symbol[0] === "\\") {
          return symbol;
        }
        return " " + symbol;
      }
    }
    return SymbolNode;
  },
  { isClass: true, isNode: true }
);

// src/expression/node/FunctionNode.ts
var name227 = "FunctionNode";
var dependencies228 = ["math", "Node", "SymbolNode"];
var createFunctionNode = /* @__PURE__ */ factory(
  name227,
  dependencies228,
  ({ math, Node, SymbolNode }) => {
    const strin = (entity) => format3(entity, { truncate: 78 });
    function expandTemplate(template, node, options) {
      let latex = "";
      const regex = /\$(?:\{([a-z_][a-z_0-9]*)(?:\[([0-9]+)\])?\}|\$)/gi;
      let inputPos = 0;
      let match;
      while ((match = regex.exec(template)) !== null) {
        latex += template.substring(inputPos, match.index);
        inputPos = match.index;
        if (match[0] === "$$") {
          latex += "$";
          inputPos++;
        } else {
          inputPos += match[0].length;
          const propertyName = match[1];
          const property = node[propertyName];
          if (!property) {
            throw new ReferenceError(
              "Template: Property " + match[1] + " does not exist."
            );
          }
          if (match[2] === void 0) {
            switch (typeof property) {
              case "string":
                latex += property;
                break;
              case "object":
                if (isNode(property)) {
                  latex += property.toTex(options);
                } else if (Array.isArray(property)) {
                  latex += property.map(function(arg, index) {
                    if (isNode(arg)) {
                      return arg.toTex(options);
                    }
                    throw new TypeError(
                      "Template: " + match[1] + "[" + index + "] is not a Node."
                    );
                  }).join(",");
                } else {
                  throw new TypeError(
                    "Template: " + match[1] + " has to be a Node, String or array of Nodes"
                  );
                }
                break;
              default:
                throw new TypeError(
                  "Template: " + match[1] + " has to be a Node, String or array of Nodes"
                );
            }
          } else {
            const arrayProperty = property;
            const indexedNode = arrayProperty[parseInt(match[2], 10)];
            if (isNode(indexedNode)) {
              latex += indexedNode.toTex(options);
            } else {
              throw new TypeError(
                "Template: " + match[1] + "[" + match[2] + "] is not a Node."
              );
            }
          }
        }
      }
      latex += template.slice(inputPos);
      return latex;
    }
    const _FunctionNode = class _FunctionNode extends Node {
      /**
       * @constructor FunctionNode
       * @extends {./Node}
       * invoke a list with arguments on a node
       * @param {./Node | string} fn
       *     Item resolving to a function on which to invoke
       *     the arguments, typically a SymbolNode or AccessorNode
       * @param {./Node[]} args
       */
      constructor(fn, args, optional) {
        super();
        if (typeof fn === "string") {
          fn = new SymbolNode(fn);
        }
        if (!isNode(fn)) throw new TypeError('Node expected as parameter "fn"');
        if (!Array.isArray(args) || !args.every(isNode)) {
          throw new TypeError(
            'Array containing Nodes expected for parameter "args"'
          );
        }
        const optionalType = typeof optional;
        if (!(optionalType === "undefined" || optionalType === "boolean")) {
          throw new TypeError("optional flag, if specified, must be boolean");
        }
        this.fn = fn;
        this.args = args || [];
        this.optional = !!optional;
      }
      // readonly property name
      get name() {
        return this.fn.name || "";
      }
      get type() {
        return name227;
      }
      get isFunctionNode() {
        return true;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param math - Math.js namespace with functions and constants.
       * @param argNames - An object with argument names as key and `true`
       *                   as value. Used in the SymbolNode to optimize
       *                   for arguments from user assigned functions
       *                   (see FunctionAssignmentNode) or special symbols
       *                   like `end` (see IndexNode).
       * @returns A function which can be called like:
       *          evalNode(scope: Scope, args: Record<string, unknown>, context: unknown)
       */
      _compile(math2, argNames) {
        const evalArgs = this.args.map((arg) => arg._compile(math2, argNames));
        const fromOptionalChaining = this.optional || isAccessorNode(this.fn) && this.fn.optionalChaining;
        if (isSymbolNode(this.fn)) {
          const fnName = this.fn.name;
          if (!argNames[fnName]) {
            const fn = fnName in math2 ? getSafeProperty(math2, fnName) : void 0;
            const isRaw = typeof fn === "function" && fn.rawArgs === true;
            const resolveFn = (scope) => {
              let value;
              if (scope.has(fnName)) {
                value = scope.get(fnName);
              } else if (fnName in math2) {
                value = getSafeProperty(math2, fnName);
              } else if (fromOptionalChaining) value = void 0;
              else return _FunctionNode.onUndefinedFunction(fnName);
              if (typeof value === "function" || fromOptionalChaining && value === void 0) {
                return value;
              }
              throw new TypeError(
                `'${fnName}' is not a function; its value is:
  ${strin(value)}`
              );
            };
            if (isRaw) {
              const rawArgs = this.args;
              return function evalFunctionNode(scope, args, context) {
                const fn2 = resolveFn(scope);
                if (fn2 && fn2.rawArgs === true) {
                  return fn2(rawArgs, math2, createSubScope(scope, args));
                } else if (fn2) {
                  const values = evalArgs.map(
                    (evalArg) => evalArg(scope, args, context)
                  );
                  return fn2(...values);
                }
                return void 0;
              };
            } else {
              switch (evalArgs.length) {
                case 0:
                  return function evalFunctionNode(scope, _args, _context) {
                    const fn2 = resolveFn(scope);
                    if (fromOptionalChaining && fn2 === void 0)
                      return void 0;
                    return fn2();
                  };
                case 1:
                  return function evalFunctionNode(scope, args, context) {
                    const fn2 = resolveFn(scope);
                    if (fromOptionalChaining && fn2 === void 0)
                      return void 0;
                    const evalArg0 = evalArgs[0];
                    return fn2(evalArg0(scope, args, context));
                  };
                case 2:
                  return function evalFunctionNode(scope, args, context) {
                    const fn2 = resolveFn(scope);
                    if (fromOptionalChaining && fn2 === void 0)
                      return void 0;
                    const evalArg0 = evalArgs[0];
                    const evalArg1 = evalArgs[1];
                    return fn2(
                      evalArg0(scope, args, context),
                      evalArg1(scope, args, context)
                    );
                  };
                default:
                  return function evalFunctionNode(scope, args, context) {
                    const fn2 = resolveFn(scope);
                    if (fromOptionalChaining && fn2 === void 0)
                      return void 0;
                    const values = evalArgs.map(
                      (evalArg) => evalArg(scope, args, context)
                    );
                    return fn2(...values);
                  };
              }
            }
          } else {
            const rawArgs = this.args;
            return function evalFunctionNode(scope, args, context) {
              const fn = getSafeProperty(args, fnName);
              if (fromOptionalChaining && fn === void 0) return void 0;
              if (typeof fn !== "function") {
                throw new TypeError(
                  `Argument '${fnName}' was not a function; received: ${strin(fn)}`
                );
              }
              if (fn.rawArgs) {
                return fn(rawArgs, math2, createSubScope(scope, args));
              } else {
                const values = evalArgs.map(
                  (evalArg) => evalArg(scope, args, context)
                );
                return fn.apply(fn, values);
              }
            };
          }
        } else if (isAccessorNode(this.fn) && isIndexNode(this.fn.index) && this.fn.index.isObjectProperty()) {
          const accessorFn = this.fn;
          const evalObject = accessorFn.object._compile(math2, argNames);
          const prop = accessorFn.index.getObjectProperty();
          const rawArgs = this.args;
          return function evalFunctionNode(scope, args, context) {
            const object = evalObject(scope, args, context);
            if (fromOptionalChaining && (object == null || object[prop] === void 0)) {
              return void 0;
            }
            const fn = getSafeMethod(object, prop);
            if (fn?.rawArgs) {
              return fn(rawArgs, math2, createSubScope(scope, args));
            } else {
              const values = evalArgs.map(
                (evalArg) => evalArg(scope, args, context)
              );
              return fn.apply(object, values);
            }
          };
        } else {
          const fnExpr = this.fn.toString();
          const evalFn = this.fn._compile(math2, argNames);
          const rawArgs = this.args;
          return function evalFunctionNode(scope, args, context) {
            const fn = evalFn(scope, args, context);
            if (fromOptionalChaining && fn === void 0) return void 0;
            if (typeof fn !== "function") {
              throw new TypeError(
                `Expression '${fnExpr}' did not evaluate to a function; value is:
  ${strin(fn)}`
              );
            }
            if (fn.rawArgs) {
              return fn(rawArgs, math2, createSubScope(scope, args));
            } else {
              const values = evalArgs.map(
                (evalArg) => evalArg(scope, args, context)
              );
              return fn.apply(fn, values);
            }
          };
        }
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(callback) {
        callback(this.fn, "fn", this);
        for (let i = 0; i < this.args.length; i++) {
          callback(this.args[i], "args[" + i + "]", this);
        }
      }
      /**
       * Create a new FunctionNode whose children are the results of calling
       * the provided callback function for each child of the original node.
       * @param {function(child: Node, path: string, parent: Node): Node} callback
       * @returns {FunctionNode} Returns a transformed copy of the node
       */
      map(callback) {
        const fn = this._ifNode(callback(this.fn, "fn", this));
        const args = [];
        for (let i = 0; i < this.args.length; i++) {
          args[i] = this._ifNode(
            callback(this.args[i], "args[" + i + "]", this)
          );
        }
        return new _FunctionNode(fn, args);
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {FunctionNode}
       */
      clone() {
        return new _FunctionNode(this.fn, this.args.slice(0));
      }
      /**
       * Get string representation. (wrapper function)
       * This overrides parts of Node's toString function.
       * If callback is an object containing callbacks, it
       * calls the correct callback for the current node,
       * otherwise it falls back to calling Node's toString
       * function.
       *
       * @param options - Formatting options
       * @returns The string representation
       * @override
       */
      toString(options) {
        let customString;
        const fnName = this.fn.toString(options);
        if (options && typeof options.handler === "object" && hasOwnProperty(options.handler, fnName)) {
          const handler = options.handler;
          customString = handler[fnName](this, options);
        }
        if (typeof customString !== "undefined") {
          return customString;
        }
        return super.toString(options);
      }
      /**
       * Get string representation
       * @param options - Formatting options
       * @returns The string representation
       */
      _toString(options) {
        const args = this.args.map(function(arg) {
          return arg.toString(options);
        });
        const fn = isFunctionAssignmentNode(this.fn) ? "(" + this.fn.toString(options) + ")" : this.fn.toString(options);
        return fn + "(" + args.join(", ") + ")";
      }
      /**
       * Get a JSON representation of the node
       * @returns {Object}
       */
      toJSON() {
        return {
          mathjs: name227,
          fn: this.fn,
          args: this.args
        };
      }
      /**
       * Get HTML representation
       * @param options - Formatting options
       * @returns The HTML representation
       */
      _toHTML(options) {
        const args = this.args.map(function(arg) {
          return arg.toHTML(options);
        });
        return '<span class="math-function">' + escape(this.fn.toString()) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + args.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
      }
      /**
       * Get LaTeX representation. (wrapper function)
       * This overrides parts of Node's toTex function.
       * If callback is an object containing callbacks, it
       * calls the correct callback for the current node,
       * otherwise it falls back to calling Node's toTex
       * function.
       *
       * @param options - Formatting options
       * @returns The LaTeX representation
       */
      toTex(options) {
        let customTex;
        if (options && typeof options.handler === "object" && hasOwnProperty(options.handler, this.name)) {
          const handler = options.handler;
          customTex = handler[this.name](this, options);
        }
        if (typeof customTex !== "undefined") {
          return customTex;
        }
        return super.toTex(options);
      }
      /**
       * Get LaTeX representation
       * @param options - Formatting options
       * @returns The LaTeX representation
       */
      _toTex(options) {
        const args = this.args.map(function(arg) {
          return arg.toTex(options);
        });
        let latexConverter;
        const latexFunctionsMap = latexFunctions;
        if (latexFunctionsMap[this.name]) {
          latexConverter = latexFunctionsMap[this.name];
        }
        const mathFn = math[this.name];
        if (mathFn && (typeof mathFn.toTex === "function" || typeof mathFn.toTex === "object" || typeof mathFn.toTex === "string")) {
          latexConverter = mathFn.toTex;
        }
        let customToTex;
        switch (typeof latexConverter) {
          case "function":
            customToTex = latexConverter(this, options);
            break;
          case "string":
            customToTex = expandTemplate(latexConverter, this, options);
            break;
          case "object": {
            const converterMap = latexConverter;
            const converter = converterMap[args.length];
            switch (typeof converter) {
              case "function":
                customToTex = converter(this, options);
                break;
              case "string":
                customToTex = expandTemplate(converter, this, options);
                break;
            }
          }
        }
        if (typeof customToTex !== "undefined") {
          return customToTex;
        }
        return expandTemplate(defaultTemplate, this, options);
      }
      /**
       * Get identifier.
       * @return {string}
       */
      getIdentifier() {
        return this.type + ":" + this.name;
      }
    };
    /**
     * Throws an error 'Undefined function {name}'
     * @param {string} name
     */
    _FunctionNode.onUndefinedFunction = function(name323) {
      throw new Error("Undefined function " + name323);
    };
    /**
     * Instantiate an AssignmentNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "FunctionNode", fn: ..., args: ...}`,
     *                       where mathjs is optional
     * @returns {FunctionNode}
     */
    _FunctionNode.fromJSON = function(json) {
      return new _FunctionNode(json.fn, json.args);
    };
    let FunctionNode = _FunctionNode;
    Object.defineProperty(FunctionNode, "name", {
      value: name227,
      configurable: true
    });
    return FunctionNode;
  },
  { isClass: true, isNode: true }
);

// src/expression/parse.ts
var name228 = "parse";
var dependencies229 = [
  "typed",
  "numeric",
  "config",
  "AccessorNode",
  "ArrayNode",
  "AssignmentNode",
  "BlockNode",
  "ConditionalNode",
  "ConstantNode",
  "FunctionAssignmentNode",
  "FunctionNode",
  "IndexNode",
  "ObjectNode",
  "OperatorNode",
  "ParenthesisNode",
  "RangeNode",
  "RelationalNode",
  "SymbolNode"
];
var createParse = /* @__PURE__ */ factory(
  name228,
  dependencies229,
  ({
    typed: typed2,
    numeric,
    config,
    AccessorNode,
    ArrayNode,
    AssignmentNode,
    BlockNode,
    ConditionalNode,
    ConstantNode,
    FunctionAssignmentNode,
    FunctionNode,
    IndexNode,
    ObjectNode,
    OperatorNode,
    ParenthesisNode,
    RangeNode,
    RelationalNode,
    SymbolNode
  }) => {
    const parse = typed2(name228, {
      string: function(expression) {
        return parseStart(expression, {});
      },
      "Array | Matrix": function(expressions) {
        return parseMultiple(expressions, {});
      },
      "string, Object": function(expression, options) {
        const extraNodes = options.nodes !== void 0 ? options.nodes : {};
        return parseStart(expression, extraNodes);
      },
      "Array | Matrix, Object": parseMultiple
    });
    function parseMultiple(expressions, options = {}) {
      const extraNodes = options.nodes !== void 0 ? options.nodes : {};
      return deepMap2(expressions, function(elem) {
        if (typeof elem !== "string") throw new TypeError("String expected");
        return parseStart(elem, extraNodes);
      });
    }
    const DELIMITERS = {
      ",": true,
      "(": true,
      ")": true,
      "[": true,
      "]": true,
      "{": true,
      "}": true,
      '"': true,
      "'": true,
      ";": true,
      "+": true,
      "-": true,
      "*": true,
      ".*": true,
      "/": true,
      "./": true,
      "%": true,
      "^": true,
      ".^": true,
      "~": true,
      "!": true,
      "&": true,
      "|": true,
      "^|": true,
      "=": true,
      ":": true,
      "?": true,
      "?.": true,
      "??": true,
      "==": true,
      "!=": true,
      "<": true,
      ">": true,
      "<=": true,
      ">=": true,
      "<<": true,
      ">>": true,
      ">>>": true
    };
    const NAMED_DELIMITERS = {
      mod: true,
      to: true,
      in: true,
      and: true,
      xor: true,
      or: true,
      not: true
    };
    const CONSTANTS = {
      true: true,
      false: false,
      null: null,
      undefined: void 0
    };
    const NUMERIC_CONSTANTS = ["NaN", "Infinity"];
    const ESCAPE_CHARACTERS = {
      '"': '"',
      "'": "'",
      "\\": "\\",
      "/": "/",
      b: "\b",
      f: "\f",
      n: "\n",
      r: "\r",
      t: "	"
      // note that \u is handled separately in parseStringToken()
    };
    function initialState() {
      return {
        extraNodes: {},
        // current extra nodes, must be careful not to mutate
        expression: "",
        // current expression
        comment: "",
        // last parsed comment
        index: 0,
        // current index in expr
        token: "",
        // current token
        tokenType: 0 /* NULL */,
        // type of the token
        nestingLevel: 0,
        // level of nesting inside parameters, used to ignore newline characters
        conditionalLevel: null
        // when a conditional is being parsed, the level of the conditional is stored here
      };
    }
    function currentString(state, length) {
      return state.expression.substr(state.index, length);
    }
    function currentCharacter(state) {
      return currentString(state, 1);
    }
    function next(state) {
      state.index++;
    }
    function prevCharacter(state) {
      return state.expression.charAt(state.index - 1);
    }
    function nextCharacter(state) {
      return state.expression.charAt(state.index + 1);
    }
    function getToken(state) {
      state.tokenType = 0 /* NULL */;
      state.token = "";
      state.comment = "";
      while (true) {
        if (currentCharacter(state) === "#") {
          while (currentCharacter(state) !== "\n" && currentCharacter(state) !== "") {
            state.comment += currentCharacter(state);
            next(state);
          }
        }
        if (parse.isWhitespace(currentCharacter(state), state.nestingLevel)) {
          next(state);
        } else {
          break;
        }
      }
      if (currentCharacter(state) === "") {
        state.tokenType = 1 /* DELIMITER */;
        return;
      }
      if (currentCharacter(state) === "\n" && !state.nestingLevel) {
        state.tokenType = 1 /* DELIMITER */;
        state.token = currentCharacter(state);
        next(state);
        return;
      }
      const c1 = currentCharacter(state);
      const c2 = currentString(state, 2);
      const c3 = currentString(state, 3);
      if (c3.length === 3 && DELIMITERS[c3]) {
        state.tokenType = 1 /* DELIMITER */;
        state.token = c3;
        next(state);
        next(state);
        next(state);
        return;
      }
      if (c2.length === 2 && DELIMITERS[c2] && (c2 !== "?." || !parse.isDigit(state.expression.charAt(state.index + 2)))) {
        state.tokenType = 1 /* DELIMITER */;
        state.token = c2;
        next(state);
        next(state);
        return;
      }
      if (DELIMITERS[c1]) {
        state.tokenType = 1 /* DELIMITER */;
        state.token = c1;
        next(state);
        return;
      }
      if (parse.isDigitDot(c1)) {
        state.tokenType = 2 /* NUMBER */;
        const c22 = currentString(state, 2);
        if (c22 === "0b" || c22 === "0o" || c22 === "0x") {
          state.token += currentCharacter(state);
          next(state);
          state.token += currentCharacter(state);
          next(state);
          while (parse.isAlpha(
            currentCharacter(state),
            prevCharacter(state),
            nextCharacter(state)
          ) || parse.isDigit(currentCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
          if (currentCharacter(state) === ".") {
            state.token += ".";
            next(state);
            while (parse.isAlpha(
              currentCharacter(state),
              prevCharacter(state),
              nextCharacter(state)
            ) || parse.isDigit(currentCharacter(state))) {
              state.token += currentCharacter(state);
              next(state);
            }
          } else if (currentCharacter(state) === "i") {
            state.token += "i";
            next(state);
            while (parse.isDigit(currentCharacter(state))) {
              state.token += currentCharacter(state);
              next(state);
            }
          }
          return;
        }
        if (currentCharacter(state) === ".") {
          state.token += currentCharacter(state);
          next(state);
          if (!parse.isDigit(currentCharacter(state))) {
            state.tokenType = 1 /* DELIMITER */;
            return;
          }
        } else {
          while (parse.isDigit(currentCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
          if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
        }
        while (parse.isDigit(currentCharacter(state))) {
          state.token += currentCharacter(state);
          next(state);
        }
        if (currentCharacter(state) === "E" || currentCharacter(state) === "e") {
          if (parse.isDigit(nextCharacter(state)) || nextCharacter(state) === "-" || nextCharacter(state) === "+") {
            state.token += currentCharacter(state);
            next(state);
            if (currentCharacter(state) === "+" || currentCharacter(state) === "-") {
              state.token += currentCharacter(state);
              next(state);
            }
            if (!parse.isDigit(currentCharacter(state))) {
              throw createSyntaxError(
                state,
                'Digit expected, got "' + currentCharacter(state) + '"'
              );
            }
            while (parse.isDigit(currentCharacter(state))) {
              state.token += currentCharacter(state);
              next(state);
            }
            if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
              throw createSyntaxError(
                state,
                'Digit expected, got "' + currentCharacter(state) + '"'
              );
            }
          } else if (parse.isDecimalMark(
            nextCharacter(state),
            state.expression.charAt(state.index + 2)
          )) {
            next(state);
            throw createSyntaxError(
              state,
              'Digit expected, got "' + currentCharacter(state) + '"'
            );
          }
        }
        return;
      }
      if (parse.isAlpha(
        currentCharacter(state),
        prevCharacter(state),
        nextCharacter(state)
      )) {
        while (parse.isAlpha(
          currentCharacter(state),
          prevCharacter(state),
          nextCharacter(state)
        ) || parse.isDigit(currentCharacter(state))) {
          state.token += currentCharacter(state);
          next(state);
        }
        if (hasOwnProperty(NAMED_DELIMITERS, state.token)) {
          state.tokenType = 1 /* DELIMITER */;
        } else {
          state.tokenType = 3 /* SYMBOL */;
        }
        return;
      }
      state.tokenType = 4 /* UNKNOWN */;
      while (currentCharacter(state) !== "") {
        state.token += currentCharacter(state);
        next(state);
      }
      throw createSyntaxError(
        state,
        'Syntax error in part "' + state.token + '"'
      );
    }
    function getTokenSkipNewline(state) {
      do {
        getToken(state);
      } while (state.token === "\n");
    }
    function openParams(state) {
      state.nestingLevel++;
    }
    function closeParams(state) {
      state.nestingLevel--;
    }
    parse.isAlpha = function isAlpha(c, cPrev, cNext) {
      return parse.isValidLatinOrGreek(c) || parse.isValidMathSymbol(c, cNext) || parse.isValidMathSymbol(cPrev, c);
    };
    parse.isValidLatinOrGreek = function isValidLatinOrGreek(c) {
      return /^[a-zA-Z_$\u00C0-\u02AF\u0370-\u03FF\u2100-\u214F]$/.test(c);
    };
    parse.isValidMathSymbol = function isValidMathSymbol(high, low) {
      return /^[\uD835]$/.test(high) && /^[\uDC00-\uDFFF]$/.test(low) && /^[^\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]$/.test(
        low
      );
    };
    parse.isWhitespace = function isWhitespace(c, nestingLevel) {
      return c === " " || c === "	" || c === "\xA0" || c === "\n" && nestingLevel > 0;
    };
    parse.isDecimalMark = function isDecimalMark(c, cNext) {
      return c === "." && cNext !== "/" && cNext !== "*" && cNext !== "^";
    };
    parse.isDigitDot = function isDigitDot(c) {
      return c >= "0" && c <= "9" || c === ".";
    };
    parse.isDigit = function isDigit(c) {
      return c >= "0" && c <= "9";
    };
    function parseStart(expression, extraNodes) {
      const state = initialState();
      Object.assign(state, { expression, extraNodes });
      getToken(state);
      const node = parseBlock(state);
      if (state.token !== "") {
        if (state.tokenType === 1 /* DELIMITER */) {
          throw createError(state, "Unexpected operator " + state.token);
        } else {
          throw createSyntaxError(
            state,
            'Unexpected part "' + state.token + '"'
          );
        }
      }
      return node;
    }
    function parseBlock(state) {
      let node;
      const blocks = [];
      let visible;
      if (state.token !== "" && state.token !== "\n" && state.token !== ";") {
        node = parseAssignment(state);
        if (state.comment) {
          node.comment = state.comment;
        }
      }
      while (state.token === "\n" || state.token === ";") {
        if (blocks.length === 0 && node) {
          visible = state.token !== ";";
          blocks.push({ node, visible });
        }
        getToken(state);
        if (state.token !== "\n" && state.token !== ";" && state.token !== "") {
          node = parseAssignment(state);
          if (state.comment) {
            node.comment = state.comment;
          }
          visible = state.token !== ";";
          blocks.push({ node, visible });
        }
      }
      if (blocks.length > 0) {
        return new BlockNode(blocks);
      } else {
        if (!node) {
          node = new ConstantNode(void 0);
          if (state.comment) {
            node.comment = state.comment;
          }
        }
        return node;
      }
    }
    function parseAssignment(state) {
      let name323;
      let args;
      let value;
      let valid;
      const node = parseConditional(state);
      if (state.token === "=") {
        if (isSymbolNode(node)) {
          name323 = node.name;
          getTokenSkipNewline(state);
          value = parseAssignment(state);
          return new AssignmentNode(new SymbolNode(name323), value);
        } else if (isAccessorNode(node)) {
          if (node.optionalChaining) {
            throw createSyntaxError(state, "Cannot assign to optional chain");
          }
          getTokenSkipNewline(state);
          value = parseAssignment(state);
          return new AssignmentNode(
            node.object,
            node.index,
            value
          );
        } else if (isFunctionNode(node) && isSymbolNode(node.fn)) {
          valid = true;
          args = [];
          name323 = node.name;
          node.args.forEach(function(arg, index) {
            if (isSymbolNode(arg)) {
              args[index] = arg.name;
            } else {
              valid = false;
            }
          });
          if (valid) {
            getTokenSkipNewline(state);
            value = parseAssignment(state);
            return new FunctionAssignmentNode(name323, args, value);
          }
        }
        throw createSyntaxError(
          state,
          "Invalid left hand side of assignment operator ="
        );
      }
      return node;
    }
    function parseConditional(state) {
      let node = parseLogicalOr(state);
      while (state.token === "?") {
        const prev = state.conditionalLevel;
        state.conditionalLevel = state.nestingLevel;
        getTokenSkipNewline(state);
        const condition = node;
        const trueExpr = parseAssignment(state);
        if (state.token !== ":")
          throw createSyntaxError(
            state,
            "False part of conditional expression expected"
          );
        state.conditionalLevel = null;
        getTokenSkipNewline(state);
        const falseExpr = parseAssignment(state);
        node = new ConditionalNode(condition, trueExpr, falseExpr);
        state.conditionalLevel = prev;
      }
      return node;
    }
    function parseLogicalOr(state) {
      let node = parseLogicalXor(state);
      while (state.token === "or") {
        getTokenSkipNewline(state);
        node = new OperatorNode("or", "or", [node, parseLogicalXor(state)]);
      }
      return node;
    }
    function parseLogicalXor(state) {
      let node = parseLogicalAnd(state);
      while (state.token === "xor") {
        getTokenSkipNewline(state);
        node = new OperatorNode("xor", "xor", [node, parseLogicalAnd(state)]);
      }
      return node;
    }
    function parseLogicalAnd(state) {
      let node = parseBitwiseOr(state);
      while (state.token === "and") {
        getTokenSkipNewline(state);
        node = new OperatorNode("and", "and", [node, parseBitwiseOr(state)]);
      }
      return node;
    }
    function parseBitwiseOr(state) {
      let node = parseBitwiseXor(state);
      while (state.token === "|") {
        getTokenSkipNewline(state);
        node = new OperatorNode("|", "bitOr", [node, parseBitwiseXor(state)]);
      }
      return node;
    }
    function parseBitwiseXor(state) {
      let node = parseBitwiseAnd(state);
      while (state.token === "^|") {
        getTokenSkipNewline(state);
        node = new OperatorNode("^|", "bitXor", [node, parseBitwiseAnd(state)]);
      }
      return node;
    }
    function parseBitwiseAnd(state) {
      let node = parseRelational(state);
      while (state.token === "&") {
        getTokenSkipNewline(state);
        node = new OperatorNode("&", "bitAnd", [node, parseRelational(state)]);
      }
      return node;
    }
    function parseRelational(state) {
      const params = [parseShift(state)];
      const conditionals = [];
      const operators = {
        "==": "equal",
        "!=": "unequal",
        "<": "smaller",
        ">": "larger",
        "<=": "smallerEq",
        ">=": "largerEq"
      };
      while (hasOwnProperty(operators, state.token)) {
        const cond = { name: state.token, fn: operators[state.token] };
        conditionals.push(cond);
        getTokenSkipNewline(state);
        params.push(parseShift(state));
      }
      if (params.length === 1) {
        return params[0];
      } else if (params.length === 2) {
        return new OperatorNode(
          conditionals[0].name,
          conditionals[0].fn,
          params
        );
      } else {
        return new RelationalNode(
          conditionals.map((c) => c.fn),
          params
        );
      }
    }
    function parseShift(state) {
      let node;
      let name323;
      let fn;
      let params;
      node = parseConversion(state);
      const operators = {
        "<<": "leftShift",
        ">>": "rightArithShift",
        ">>>": "rightLogShift"
      };
      while (hasOwnProperty(operators, state.token)) {
        name323 = state.token;
        fn = operators[name323];
        getTokenSkipNewline(state);
        params = [node, parseConversion(state)];
        node = new OperatorNode(name323, fn, params);
      }
      return node;
    }
    function parseConversion(state) {
      let node;
      let name323;
      let fn;
      let params;
      node = parseRange(state);
      const operators = {
        to: "to",
        in: "to"
        // alias of 'to'
      };
      while (hasOwnProperty(operators, state.token)) {
        name323 = state.token;
        fn = operators[name323];
        getTokenSkipNewline(state);
        if (name323 === "in" && "])},;".includes(state.token)) {
          node = new OperatorNode(
            "*",
            "multiply",
            [node, new SymbolNode("in")],
            true
          );
        } else {
          params = [node, parseRange(state)];
          node = new OperatorNode(name323, fn, params);
        }
      }
      return node;
    }
    function parseRange(state) {
      let node;
      const params = [];
      if (state.token === ":") {
        if (state.conditionalLevel === state.nestingLevel) {
          throw createSyntaxError(
            state,
            "The true-expression of a conditional operator may not be empty"
          );
        } else {
          node = new ConstantNode(1);
        }
      } else {
        node = parseAddSubtract(state);
      }
      if (state.token === ":" && state.conditionalLevel !== state.nestingLevel) {
        params.push(node);
        while (state.token === ":" && params.length < 3) {
          getTokenSkipNewline(state);
          if (state.token === ")" || state.token === "]" || state.token === "," || state.token === "") {
            params.push(new SymbolNode("end"));
          } else {
            params.push(parseAddSubtract(state));
          }
        }
        if (params.length === 3) {
          node = new RangeNode(params[0], params[2], params[1]);
        } else {
          node = new RangeNode(params[0], params[1]);
        }
      }
      return node;
    }
    function parseAddSubtract(state) {
      let node;
      let name323;
      let fn;
      let params;
      node = parseMultiplyDivideModulus(state);
      const operators = {
        "+": "add",
        "-": "subtract"
      };
      while (hasOwnProperty(operators, state.token)) {
        name323 = state.token;
        fn = operators[name323];
        getTokenSkipNewline(state);
        const rightNode = parseMultiplyDivideModulus(state);
        if (rightNode.isPercentage) {
          params = [node, new OperatorNode("*", "multiply", [node, rightNode])];
        } else {
          params = [node, rightNode];
        }
        node = new OperatorNode(name323, fn, params);
      }
      return node;
    }
    function parseMultiplyDivideModulus(state) {
      let node;
      let last;
      let name323;
      let fn;
      node = parseImplicitMultiplication(state);
      last = node;
      const operators = {
        "*": "multiply",
        ".*": "dotMultiply",
        "/": "divide",
        "./": "dotDivide",
        "%": "mod",
        mod: "mod"
      };
      while (true) {
        if (hasOwnProperty(operators, state.token)) {
          name323 = state.token;
          fn = operators[name323];
          getTokenSkipNewline(state);
          last = parseImplicitMultiplication(state);
          node = new OperatorNode(name323, fn, [node, last]);
        } else {
          break;
        }
      }
      return node;
    }
    function parseImplicitMultiplication(state) {
      let node;
      let last;
      node = parseRule2(state);
      last = node;
      while (true) {
        if (state.tokenType === 3 /* SYMBOL */ || state.token === "in" && isConstantNode(node) || state.token === "in" && isOperatorNode(node) && node.fn === "unaryMinus" && isConstantNode(node.args[0]) || state.tokenType === 2 /* NUMBER */ && !isConstantNode(last) && (!isOperatorNode(last) || last.op === "!") || state.token === "(") {
          last = parseRule2(state);
          node = new OperatorNode(
            "*",
            "multiply",
            [node, last],
            true
            /* implicit */
          );
        } else {
          break;
        }
      }
      return node;
    }
    function parseRule2(state) {
      let node = parseUnaryPercentage(state);
      let last = node;
      const tokenStates = [];
      while (true) {
        if (state.token === "/" && rule2Node(last)) {
          tokenStates.push(Object.assign({}, state));
          getTokenSkipNewline(state);
          if (state.tokenType === 2 /* NUMBER */) {
            tokenStates.push(Object.assign({}, state));
            getTokenSkipNewline(state);
            if (state.tokenType === 3 /* SYMBOL */ || state.token === "(" || state.token === "in") {
              Object.assign(state, tokenStates.pop());
              tokenStates.pop();
              last = parseUnaryPercentage(state);
              node = new OperatorNode("/", "divide", [node, last]);
            } else {
              tokenStates.pop();
              Object.assign(state, tokenStates.pop());
              break;
            }
          } else {
            Object.assign(state, tokenStates.pop());
            break;
          }
        } else {
          break;
        }
      }
      return node;
    }
    function parseUnaryPercentage(state) {
      let node = parseUnary(state);
      if (state.token === "%") {
        const previousState = Object.assign({}, state);
        getTokenSkipNewline(state);
        try {
          parseUnary(state);
          Object.assign(state, previousState);
        } catch {
          node = new OperatorNode(
            "/",
            "divide",
            [node, new ConstantNode(100)],
            false,
            true
          );
        }
      }
      return node;
    }
    function parseUnary(state) {
      let name323;
      let params;
      let fn;
      const operators = {
        "-": "unaryMinus",
        "+": "unaryPlus",
        "~": "bitNot",
        not: "not"
      };
      if (hasOwnProperty(operators, state.token)) {
        fn = operators[state.token];
        name323 = state.token;
        getTokenSkipNewline(state);
        params = [parseUnary(state)];
        return new OperatorNode(name323, fn, params);
      }
      return parsePow(state);
    }
    function parsePow(state) {
      let node;
      let name323;
      let fn;
      let params;
      node = parseNullishCoalescing(state);
      if (state.token === "^" || state.token === ".^") {
        name323 = state.token;
        fn = name323 === "^" ? "pow" : "dotPow";
        getTokenSkipNewline(state);
        params = [node, parseUnary(state)];
        node = new OperatorNode(name323, fn, params);
      }
      return node;
    }
    function parseNullishCoalescing(state) {
      let node = parseLeftHandOperators(state);
      while (state.token === "??") {
        getTokenSkipNewline(state);
        node = new OperatorNode("??", "nullish", [
          node,
          parseLeftHandOperators(state)
        ]);
      }
      return node;
    }
    function parseLeftHandOperators(state) {
      let node;
      let name323;
      let fn;
      let params;
      node = parseCustomNodes(state);
      const operators = {
        "!": "factorial",
        "'": "ctranspose"
      };
      while (hasOwnProperty(operators, state.token)) {
        name323 = state.token;
        fn = operators[name323];
        getToken(state);
        params = [node];
        node = new OperatorNode(name323, fn, params);
        node = parseAccessors(state, node);
      }
      return node;
    }
    function parseCustomNodes(state) {
      let params = [];
      if (state.tokenType === 3 /* SYMBOL */ && hasOwnProperty(state.extraNodes, state.token)) {
        const CustomNode = state.extraNodes[state.token];
        getToken(state);
        if (state.token === "(") {
          params = [];
          openParams(state);
          getToken(state);
          if (state.token !== ")") {
            params.push(parseAssignment(state));
            while (state.token === ",") {
              getToken(state);
              params.push(parseAssignment(state));
            }
          }
          if (state.token !== ")") {
            throw createSyntaxError(state, "Parenthesis ) expected");
          }
          closeParams(state);
          getToken(state);
        }
        return new CustomNode(params);
      }
      return parseSymbol(state);
    }
    function parseSymbol(state) {
      let node;
      let name323;
      if (state.tokenType === 3 /* SYMBOL */ || state.tokenType === 1 /* DELIMITER */ && state.token in NAMED_DELIMITERS) {
        name323 = state.token;
        getToken(state);
        if (hasOwnProperty(CONSTANTS, name323)) {
          node = new ConstantNode(CONSTANTS[name323]);
        } else if (NUMERIC_CONSTANTS.includes(name323)) {
          node = new ConstantNode(numeric(name323, "number"));
        } else {
          node = new SymbolNode(name323);
        }
        node = parseAccessors(state, node);
        return node;
      }
      return parseString(state);
    }
    function parseAccessors(state, node, types) {
      let params;
      while (true) {
        let optional = false;
        if (state.token === "?.") {
          optional = true;
          getToken(state);
        }
        const hasNextAccessor = (state.token === "(" || state.token === "[" || state.token === ".") && (true);
        if (!(optional || hasNextAccessor)) {
          break;
        }
        params = [];
        if (state.token === "(") {
          if (optional || isSymbolNode(node) || isAccessorNode(node)) {
            openParams(state);
            getToken(state);
            if (state.token !== ")") {
              params.push(parseAssignment(state));
              while (state.token === ",") {
                getToken(state);
                params.push(parseAssignment(state));
              }
            }
            if (state.token !== ")") {
              throw createSyntaxError(state, "Parenthesis ) expected");
            }
            closeParams(state);
            getToken(state);
            node = new FunctionNode(node, params, optional);
          } else {
            return node;
          }
        } else if (state.token === "[") {
          openParams(state);
          getToken(state);
          if (state.token !== "]") {
            params.push(parseAssignment(state));
            while (state.token === ",") {
              getToken(state);
              params.push(parseAssignment(state));
            }
          }
          if (state.token !== "]") {
            throw createSyntaxError(state, "Parenthesis ] expected");
          }
          closeParams(state);
          getToken(state);
          node = new AccessorNode(node, new IndexNode(params), optional);
        } else {
          if (!optional) getToken(state);
          const isPropertyName = state.tokenType === 3 /* SYMBOL */ || state.tokenType === 1 /* DELIMITER */ && state.token in NAMED_DELIMITERS;
          if (!isPropertyName) {
            let message = "Property name expected after ";
            message += optional ? "optional chain" : "dot";
            throw createSyntaxError(state, message);
          }
          params.push(new ConstantNode(state.token));
          getToken(state);
          const dotNotation = true;
          node = new AccessorNode(
            node,
            new IndexNode(params, dotNotation),
            optional
          );
        }
      }
      return node;
    }
    function parseString(state) {
      let node;
      let str;
      if (state.token === '"' || state.token === "'") {
        str = parseStringToken(state, state.token);
        node = new ConstantNode(str);
        node = parseAccessors(state, node);
        return node;
      }
      return parseMatrix(state);
    }
    function parseStringToken(state, quote) {
      let str = "";
      while (currentCharacter(state) !== "" && currentCharacter(state) !== quote) {
        if (currentCharacter(state) === "\\") {
          next(state);
          const char = currentCharacter(state);
          const escapeChar = ESCAPE_CHARACTERS[char];
          if (escapeChar !== void 0) {
            str += escapeChar;
            state.index += 1;
          } else if (char === "u") {
            const unicode = state.expression.slice(
              state.index + 1,
              state.index + 5
            );
            if (/^[0-9A-Fa-f]{4}$/.test(unicode)) {
              str += String.fromCharCode(parseInt(unicode, 16));
              state.index += 5;
            } else {
              throw createSyntaxError(
                state,
                `Invalid unicode character \\u${unicode}`
              );
            }
          } else {
            throw createSyntaxError(state, `Bad escape character \\${char}`);
          }
        } else {
          str += currentCharacter(state);
          next(state);
        }
      }
      getToken(state);
      if (state.token !== quote) {
        throw createSyntaxError(state, `End of string ${quote} expected`);
      }
      getToken(state);
      return str;
    }
    function parseMatrix(state) {
      let array;
      let params;
      let rows;
      let cols;
      if (state.token === "[") {
        openParams(state);
        getToken(state);
        if (state.token !== "]") {
          const row = parseRow(state);
          if (state.token === ";") {
            rows = 1;
            params = [row];
            while (state.token === ";") {
              getToken(state);
              if (state.token !== "]") {
                params[rows] = parseRow(state);
                rows++;
              }
            }
            if (state.token !== "]") {
              throw createSyntaxError(state, "End of matrix ] expected");
            }
            closeParams(state);
            getToken(state);
            cols = params[0].items.length;
            for (let r = 1; r < rows; r++) {
              if (params[r].items.length !== cols) {
                throw createError(
                  state,
                  "Column dimensions mismatch (" + params[r].items.length + " !== " + cols + ")"
                );
              }
            }
            array = new ArrayNode(params);
          } else {
            if (state.token !== "]") {
              throw createSyntaxError(state, "End of matrix ] expected");
            }
            closeParams(state);
            getToken(state);
            array = row;
          }
        } else {
          closeParams(state);
          getToken(state);
          array = new ArrayNode([]);
        }
        return parseAccessors(state, array);
      }
      return parseObject(state);
    }
    function parseRow(state) {
      const params = [parseAssignment(state)];
      let len = 1;
      while (state.token === ",") {
        getToken(state);
        if (state.token !== "]" && state.token !== ";") {
          params[len] = parseAssignment(state);
          len++;
        }
      }
      return new ArrayNode(params);
    }
    function parseObject(state) {
      if (state.token === "{") {
        openParams(state);
        let key;
        const properties2 = {};
        do {
          getToken(state);
          if (state.token !== "}") {
            if (state.token === '"' || state.token === "'") {
              key = parseStringToken(state, state.token);
            } else if (state.tokenType === 3 /* SYMBOL */ || state.tokenType === 1 /* DELIMITER */ && state.token in NAMED_DELIMITERS) {
              key = state.token;
              getToken(state);
            } else {
              throw createSyntaxError(
                state,
                "Symbol or string expected as object key"
              );
            }
            if (state.token !== ":") {
              throw createSyntaxError(
                state,
                "Colon : expected after object key"
              );
            }
            getToken(state);
            properties2[key] = parseAssignment(state);
          }
        } while (state.token === ",");
        if (state.token !== "}") {
          throw createSyntaxError(
            state,
            "Comma , or bracket } expected after object value"
          );
        }
        closeParams(state);
        getToken(state);
        let node = new ObjectNode(properties2);
        node = parseAccessors(state, node);
        return node;
      }
      return parseNumber(state);
    }
    function parseNumber(state) {
      let numberStr;
      if (state.tokenType === 2 /* NUMBER */) {
        numberStr = state.token;
        getToken(state);
        const numericType = safeNumberType(numberStr, config);
        const value = numeric(numberStr, numericType);
        return new ConstantNode(value);
      }
      return parseParentheses(state);
    }
    function parseParentheses(state) {
      let node;
      if (state.token === "(") {
        openParams(state);
        getToken(state);
        node = parseAssignment(state);
        if (state.token !== ")") {
          throw createSyntaxError(state, "Parenthesis ) expected");
        }
        closeParams(state);
        getToken(state);
        node = new ParenthesisNode(node);
        node = parseAccessors(state, node);
        return node;
      }
      return parseEnd(state);
    }
    function parseEnd(state) {
      if (state.token === "") {
        throw createSyntaxError(state, "Unexpected end of expression");
      } else {
        throw createSyntaxError(state, "Value expected");
      }
    }
    function col(state) {
      return state.index - state.token.length + 1;
    }
    function createSyntaxError(state, message) {
      const c = col(state);
      const error = new SyntaxError(message + " (char " + c + ")");
      error.char = c;
      return error;
    }
    function createError(state, message) {
      const c = col(state);
      const error = new SyntaxError(message + " (char " + c + ")");
      error.char = c;
      return error;
    }
    try {
      typed2.addConversion({ from: "string", to: "Node", convert: parse });
    } catch (e2) {
      if (!e2.message?.includes("already a conversion")) {
        throw e2;
      }
    }
    return parse;
  }
);

// src/expression/function/compile.ts
var name229 = "compile";
var dependencies230 = ["typed", "parse"];
var createCompile = /* @__PURE__ */ factory(
  name229,
  dependencies230,
  ({ typed: typed2, parse }) => {
    return typed2(name229, {
      string: function(expr) {
        return parse(expr).compile();
      },
      "Array | Matrix": function(expr) {
        return deepMap2(expr, function(entry) {
          return parse(entry).compile();
        });
      }
    });
  }
);

// src/expression/function/evaluate.ts
var name230 = "evaluate";
var dependencies231 = ["typed", "parse"];
var createEvaluate = /* @__PURE__ */ factory(
  name230,
  dependencies231,
  ({ typed: typed2, parse }) => {
    return typed2(name230, {
      string: function(expr) {
        const scope = createEmptyMap();
        return parse(expr).compile().evaluate(scope);
      },
      "string, Map | Object": function(expr, scope) {
        return parse(expr).compile().evaluate(scope);
      },
      "Array | Matrix": function(expr) {
        const scope = createEmptyMap();
        return deepMap2(expr, function(entry) {
          return parse(entry).compile().evaluate(scope);
        });
      },
      "Array | Matrix, Map | Object": function(expr, scope) {
        return deepMap2(expr, function(entry) {
          return parse(entry).compile().evaluate(scope);
        });
      }
    });
  }
);

// src/expression/Parser.ts
var name231 = "Parser";
var dependencies232 = ["evaluate", "parse"];
var createParserClass = /* @__PURE__ */ factory(
  name231,
  dependencies232,
  ({ evaluate, parse }) => {
    function Parser() {
      if (!(this instanceof Parser)) {
        throw new SyntaxError(
          "Constructor must be called with the new operator"
        );
      }
      Object.defineProperty(this, "scope", {
        value: createEmptyMap(),
        writable: false
      });
    }
    Parser.prototype.type = "Parser";
    Parser.prototype.isParser = true;
    Parser.prototype.evaluate = function(expr) {
      return evaluate(expr, this.scope);
    };
    Parser.prototype.get = function(name323) {
      if (this.scope.has(name323)) {
        return this.scope.get(name323);
      }
    };
    Parser.prototype.getAll = function() {
      return toObject(this.scope);
    };
    Parser.prototype.getAllAsMap = function() {
      return this.scope;
    };
    function isValidVariableName(name323) {
      if (name323.length === 0) {
        return false;
      }
      for (let i = 0; i < name323.length; i++) {
        const cPrev = name323.charAt(i - 1);
        const c = name323.charAt(i);
        const cNext = name323.charAt(i + 1);
        const valid = parse.isAlpha(c, cPrev, cNext) || i > 0 && parse.isDigit(c);
        if (!valid) {
          return false;
        }
      }
      return true;
    }
    Parser.prototype.set = function(name323, value) {
      if (!isValidVariableName(name323)) {
        throw new Error(
          `Invalid variable name: '${name323}'. Variable names must follow the specified rules.`
        );
      }
      this.scope.set(name323, value);
      return value;
    };
    Parser.prototype.remove = function(name323) {
      this.scope.delete(name323);
    };
    Parser.prototype.clear = function() {
      this.scope.clear();
    };
    Parser.prototype.toJSON = function() {
      const json = {
        mathjs: "Parser",
        variables: {},
        functions: {}
      };
      for (const [name323, value] of this.scope) {
        if (isFunction(value)) {
          if (!isExpressionFunction(value)) {
            throw new Error(`Cannot serialize external function ${name323}`);
          }
          json.functions[name323] = `${value.syntax} = ${value.expr}`;
        } else {
          json.variables[name323] = value;
        }
      }
      return json;
    };
    Parser.fromJSON = function(json) {
      const parser = new Parser();
      Object.entries(json.variables || {}).forEach(
        ([name323, value]) => parser.set(name323, value)
      );
      Object.entries(json.functions || {}).forEach(
        ([_name, fn]) => parser.evaluate(fn)
      );
      return parser;
    };
    return Parser;
  },
  { isClass: true }
);
function isExpressionFunction(value) {
  return typeof value === "function" && typeof value.syntax === "string" && typeof value.expr === "string";
}

// src/expression/function/parser.ts
var name232 = "parser";
var dependencies233 = ["typed", "Parser"];
var createParser = /* @__PURE__ */ factory(
  name232,
  dependencies233,
  ({ typed: typed2, Parser }) => {
    return typed2(name232, {
      "": function() {
        return new Parser();
      }
    });
  }
);

// src/function/algebra/decomposition/lup.ts
var WASM_LUP_THRESHOLD = 16;
function isPlainNumberMatrix4(matrix) {
  for (let i = 0; i < matrix.length; i++) {
    const row = matrix[i];
    for (let j = 0; j < row.length; j++) {
      if (typeof row[j] !== "number") {
        return false;
      }
    }
  }
  return true;
}
function flattenToFloat644(matrix, rows, cols) {
  const result = new Float64Array(rows * cols);
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      result[i * cols + j] = matrix[i][j];
    }
  }
  return result;
}
var name233 = "lup";
var dependencies234 = [
  "typed",
  "matrix",
  "abs",
  "addScalar",
  "divideScalar",
  "multiplyScalar",
  "subtractScalar",
  "larger",
  "equalScalar",
  "unaryMinus",
  "DenseMatrix",
  "SparseMatrix",
  "Spa"
];
var createLup = /* @__PURE__ */ factory(
  name233,
  dependencies234,
  ({
    typed: typed2,
    matrix,
    abs,
    addScalar,
    divideScalar,
    multiplyScalar,
    subtractScalar,
    larger,
    equalScalar,
    unaryMinus,
    DenseMatrix,
    SparseMatrix,
    Spa
  }) => {
    return typed2(name233, {
      DenseMatrix: function(m) {
        return _denseLUP(m);
      },
      SparseMatrix: function(m) {
        return _sparseLUP(m);
      },
      Array: function(a) {
        const m = matrix(a);
        const r = _denseLUP(m);
        return {
          L: r.L.valueOf(),
          U: r.U.valueOf(),
          p: r.p
        };
      }
    });
    function _denseLUP(m) {
      const rows = m._size[0];
      const columns = m._size[1];
      let n = Math.min(rows, columns);
      const wasm = wasmLoader.getModule();
      if (wasm && rows === columns && rows * rows >= WASM_LUP_THRESHOLD && isPlainNumberMatrix4(m._data)) {
        try {
          const flat = flattenToFloat644(m._data, rows, columns);
          const aAlloc = wasmLoader.allocateFloat64Array(flat);
          const permAlloc = wasmLoader.allocateInt32ArrayEmpty(rows);
          try {
            const result = wasm.luDecomposition(aAlloc.ptr, rows, permAlloc.ptr);
            if (result !== 0) {
              throw new Error("Matrix is singular and cannot be decomposed");
            }
            const ldata2 = [];
            const udata2 = [];
            for (let i2 = 0; i2 < rows; i2++) {
              ldata2[i2] = [];
              udata2[i2] = [];
              for (let j2 = 0; j2 < columns; j2++) {
                const val = aAlloc.array[i2 * columns + j2];
                if (i2 > j2) {
                  ldata2[i2][j2] = val;
                  udata2[i2][j2] = 0;
                } else if (i2 === j2) {
                  ldata2[i2][j2] = 1;
                  udata2[i2][j2] = val;
                } else {
                  ldata2[i2][j2] = 0;
                  udata2[i2][j2] = val;
                }
              }
            }
            const p2 = [];
            for (let i2 = 0; i2 < rows; i2++) {
              p2[i2] = permAlloc.array[i2];
            }
            const l2 = new DenseMatrix({
              data: ldata2,
              size: [rows, n]
            });
            const u2 = new DenseMatrix({
              data: udata2,
              size: [n, columns]
            });
            return {
              L: l2,
              U: u2,
              p: p2,
              toString: function() {
                return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
              }
            };
          } finally {
            wasmLoader.free(aAlloc.ptr);
            wasmLoader.free(permAlloc.ptr);
          }
        } catch (e2) {
          if (e2 instanceof Error && e2.message.includes("singular")) {
            throw e2;
          }
        }
      }
      const data = clone(m._data);
      const ldata = [];
      const lsize = [rows, n];
      const udata = [];
      const usize = [n, columns];
      let i, j, k;
      const p = [];
      for (i = 0; i < rows; i++) {
        p[i] = i;
      }
      for (j = 0; j < columns; j++) {
        if (j > 0) {
          for (i = 0; i < rows; i++) {
            const min = Math.min(i, j);
            let s = 0;
            for (k = 0; k < min; k++) {
              s = addScalar(s, multiplyScalar(data[i][k], data[k][j]));
            }
            data[i][j] = subtractScalar(data[i][j], s);
          }
        }
        let pi2 = j;
        let pabsv = 0;
        let vjj = 0;
        for (i = j; i < rows; i++) {
          const v = data[i][j];
          const absv = abs(v);
          if (larger(absv, pabsv)) {
            pi2 = i;
            pabsv = absv;
            vjj = v;
          }
        }
        if (j !== pi2) {
          p[j] = [p[pi2], p[pi2] = p[j]][0];
          DenseMatrix._swapRows(j, pi2, data);
        }
        if (j < rows) {
          for (i = j + 1; i < rows; i++) {
            const vij = data[i][j];
            if (!equalScalar(vij, 0)) {
              data[i][j] = divideScalar(data[i][j], vjj);
            }
          }
        }
      }
      for (j = 0; j < columns; j++) {
        for (i = 0; i < rows; i++) {
          if (j === 0) {
            if (i < columns) {
              udata[i] = [];
            }
            ldata[i] = [];
          }
          if (i < j) {
            if (i < columns) {
              udata[i][j] = data[i][j];
            }
            if (j < rows) {
              ldata[i][j] = 0;
            }
            continue;
          }
          if (i === j) {
            if (i < columns) {
              udata[i][j] = data[i][j];
            }
            if (j < rows) {
              ldata[i][j] = 1;
            }
            continue;
          }
          if (i < columns) {
            udata[i][j] = 0;
          }
          if (j < rows) {
            ldata[i][j] = data[i][j];
          }
        }
      }
      const l = new DenseMatrix({
        data: ldata,
        size: lsize
      });
      const u = new DenseMatrix({
        data: udata,
        size: usize
      });
      const pv = [];
      for (i = 0, n = p.length; i < n; i++) {
        pv[p[i]] = i;
      }
      return {
        L: l,
        U: u,
        p: pv,
        toString: function() {
          return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
        }
      };
    }
    function _sparseLUP(m) {
      const rows = m._size[0];
      const columns = m._size[1];
      const n = Math.min(rows, columns);
      const values = m._values;
      const index = m._index;
      const ptr = m._ptr;
      const lvalues = [];
      const lindex = [];
      const lptr = [];
      const lsize = [rows, n];
      const uvalues = [];
      const uindex = [];
      const uptr = [];
      const usize = [n, columns];
      let i, j, k;
      const pvCo = [];
      const pvOc = [];
      for (i = 0; i < rows; i++) {
        pvCo[i] = i;
        pvOc[i] = i;
      }
      const swapIndeces = function(x, y) {
        const kx = pvOc[x];
        const ky = pvOc[y];
        pvCo[kx] = y;
        pvCo[ky] = x;
        pvOc[x] = ky;
        pvOc[y] = kx;
      };
      for (j = 0; j < columns; j++) {
        const spa = new Spa();
        if (j < rows) {
          lptr.push(lvalues.length);
          lvalues.push(1);
          lindex.push(j);
        }
        uptr.push(uvalues.length);
        const k0 = ptr[j];
        const k1 = ptr[j + 1];
        for (k = k0; k < k1; k++) {
          i = index[k];
          spa.set(pvCo[i], values[k]);
        }
        if (j > 0) {
          spa.forEach(0, j - 1, function(k2, vkj) {
            SparseMatrix._forEachRow(
              k2,
              lvalues,
              lindex,
              lptr,
              function(i2, vik) {
                if (i2 > k2) {
                  spa.accumulate(i2, unaryMinus(multiplyScalar(vik, vkj)));
                }
              }
            );
          });
        }
        let pi2 = j;
        let vjj = spa.get(j);
        let pabsv = abs(vjj);
        spa.forEach(j + 1, rows - 1, function(x, v) {
          const absv = abs(v);
          if (larger(absv, pabsv)) {
            pi2 = x;
            pabsv = absv;
            vjj = v;
          }
        });
        if (j !== pi2) {
          SparseMatrix._swapRows(j, pi2, lsize[1], lvalues, lindex, lptr);
          SparseMatrix._swapRows(j, pi2, usize[1], uvalues, uindex, uptr);
          spa.swap(j, pi2);
          swapIndeces(j, pi2);
        }
        spa.forEach(0, rows - 1, function(x, v) {
          if (x <= j) {
            uvalues.push(v);
            uindex.push(x);
          } else {
            v = divideScalar(v, vjj);
            if (!equalScalar(v, 0)) {
              lvalues.push(v);
              lindex.push(x);
            }
          }
        });
      }
      uptr.push(uvalues.length);
      lptr.push(lvalues.length);
      return {
        L: new SparseMatrix({
          values: lvalues,
          index: lindex,
          ptr: lptr,
          size: lsize
        }),
        U: new SparseMatrix({
          values: uvalues,
          index: uindex,
          ptr: uptr,
          size: usize
        }),
        p: pvCo,
        toString: function() {
          return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
        }
      };
    }
  }
);

// src/function/algebra/decomposition/qr.ts
var WASM_QR_THRESHOLD = 16;
function isPlainNumberMatrix5(matrix) {
  for (let i = 0; i < matrix.length; i++) {
    const row = matrix[i];
    for (let j = 0; j < row.length; j++) {
      if (typeof row[j] !== "number") {
        return false;
      }
    }
  }
  return true;
}
function flattenToFloat645(matrix, rows, cols) {
  const result = new Float64Array(rows * cols);
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      result[i * cols + j] = matrix[i][j];
    }
  }
  return result;
}
var name234 = "qr";
var dependencies235 = [
  "typed",
  "matrix",
  "zeros",
  "identity",
  "isZero",
  "equal",
  "sign",
  "sqrt",
  "conj",
  "unaryMinus",
  "addScalar",
  "divideScalar",
  "multiplyScalar",
  "subtractScalar",
  "complex"
];
var createQr = /* @__PURE__ */ factory(
  name234,
  dependencies235,
  ({
    typed: typed2,
    matrix,
    zeros: zeros2,
    identity,
    isZero,
    equal,
    sign: sign2,
    sqrt,
    conj,
    unaryMinus,
    addScalar,
    divideScalar,
    multiplyScalar,
    subtractScalar,
    complex
  }) => {
    const qrTyped = typed2(name234, {
      DenseMatrix: function(m) {
        return _denseQR(m);
      },
      SparseMatrix: function(m) {
        return _sparseQR();
      },
      Array: function(a) {
        const m = matrix(a);
        const r = _denseQR(m);
        return {
          Q: r.Q.valueOf(),
          R: r.R.valueOf()
        };
      }
    });
    qrTyped._denseQRimpl = _denseQRimpl;
    return qrTyped;
    function _denseQRimpl(m) {
      const rows = m._size[0];
      const cols = m._size[1];
      const wasm = wasmLoader.getModule();
      if (wasm && rows * cols >= WASM_QR_THRESHOLD && isPlainNumberMatrix5(m._data)) {
        try {
          const flat = flattenToFloat645(m._data, rows, cols);
          const aAlloc = wasmLoader.allocateFloat64Array(flat);
          const qAlloc = wasmLoader.allocateFloat64ArrayEmpty(rows * rows);
          try {
            wasm.qrDecomposition(aAlloc.ptr, rows, cols, qAlloc.ptr);
            const Rdata2 = [];
            for (let i2 = 0; i2 < rows; i2++) {
              Rdata2[i2] = [];
              for (let j2 = 0; j2 < cols; j2++) {
                Rdata2[i2][j2] = aAlloc.array[i2 * cols + j2];
              }
            }
            const Qdata2 = [];
            for (let i2 = 0; i2 < rows; i2++) {
              Qdata2[i2] = [];
              for (let j2 = 0; j2 < rows; j2++) {
                Qdata2[i2][j2] = qAlloc.array[i2 * rows + j2];
              }
            }
            const Q3 = matrix(Qdata2);
            const R2 = matrix(Rdata2);
            return {
              Q: Q3,
              R: R2,
              toString: function() {
                return "Q: " + this.Q.toString() + "\nR: " + this.R.toString();
              }
            };
          } finally {
            wasmLoader.free(aAlloc.ptr);
            wasmLoader.free(qAlloc.ptr);
          }
        } catch (e2) {
        }
      }
      const Q2 = identity([rows], "dense");
      const Qdata = Q2._data;
      const R = m.clone();
      const Rdata = R._data;
      let i, j, k;
      const w = zeros2([rows], "");
      for (k = 0; k < Math.min(cols, rows); ++k) {
        const pivot = Rdata[k][k];
        const sgn = unaryMinus(equal(pivot, 0) ? 1 : sign2(pivot));
        const conjSgn = conj(sgn);
        let alphaSquared = 0;
        for (i = k; i < rows; i++) {
          alphaSquared = addScalar(
            alphaSquared,
            multiplyScalar(Rdata[i][k], conj(Rdata[i][k]))
          );
        }
        const alpha = multiplyScalar(sgn, sqrt(alphaSquared));
        if (!isZero(alpha)) {
          const u1 = subtractScalar(pivot, alpha);
          w[k] = 1;
          for (i = k + 1; i < rows; i++) {
            w[i] = divideScalar(Rdata[i][k], u1);
          }
          const tau2 = unaryMinus(conj(divideScalar(u1, alpha)));
          let s;
          for (j = k; j < cols; j++) {
            s = 0;
            for (i = k; i < rows; i++) {
              s = addScalar(s, multiplyScalar(conj(w[i]), Rdata[i][j]));
            }
            s = multiplyScalar(s, tau2);
            for (i = k; i < rows; i++) {
              Rdata[i][j] = multiplyScalar(
                subtractScalar(Rdata[i][j], multiplyScalar(w[i], s)),
                conjSgn
              );
            }
          }
          for (i = 0; i < rows; i++) {
            s = 0;
            for (j = k; j < rows; j++) {
              s = addScalar(s, multiplyScalar(Qdata[i][j], w[j]));
            }
            s = multiplyScalar(s, tau2);
            for (j = k; j < rows; ++j) {
              Qdata[i][j] = divideScalar(
                subtractScalar(Qdata[i][j], multiplyScalar(s, conj(w[j]))),
                conjSgn
              );
            }
          }
        }
      }
      return {
        Q: Q2,
        R,
        toString: function() {
          return "Q: " + this.Q.toString() + "\nR: " + this.R.toString();
        }
      };
    }
    function _denseQR(m) {
      const ret = _denseQRimpl(m);
      const Rdata = ret.R._data;
      if (m._data.length > 0) {
        const zero = Rdata[0][0].type === "Complex" ? complex(0) : 0;
        for (let i = 0; i < Rdata.length; ++i) {
          for (let j = 0; j < i && j < (Rdata[0] || []).length; ++j) {
            Rdata[i][j] = zero;
          }
        }
      }
      return ret;
    }
    function _sparseQR(_m) {
      throw new Error("qr not implemented for sparse matrices yet");
    }
  }
);

// src/function/algebra/sparse/csPermute.ts
function csPermute(a, pinv, q, values) {
  a._values;
  const aindex = a._index;
  const aptr = a._ptr;
  const asize = a._size;
  const adt = a._datatype;
  const m = asize[0];
  const n = asize[1];
  const cvalues = null;
  const cindex = [];
  const cptr = [];
  let nz = 0;
  for (let k = 0; k < n; k++) {
    cptr[k] = nz;
    const j = q ? q[k] : k;
    for (let t0 = aptr[j], t1 = aptr[j + 1], t = t0; t < t1; t++) {
      const r = aindex[t];
      cindex[nz] = r;
      nz++;
    }
  }
  cptr[n] = nz;
  return a.createSparseMatrix({
    values: cvalues,
    index: cindex,
    ptr: cptr,
    size: [m, n],
    datatype: adt
  });
}

// src/function/algebra/sparse/csTdfs.ts
function csTdfs(j, k, w, head, next, post, stack) {
  let top = 0;
  w[stack] = j;
  while (top >= 0) {
    const p = w[stack + top];
    const i = w[head + p];
    if (i === -1) {
      top--;
      post[k++] = p;
    } else {
      w[head + p] = w[next + i];
      ++top;
      w[stack + top] = i;
    }
  }
  return k;
}

// src/function/algebra/sparse/csPost.ts
function csPost(parent, n) {
  if (!parent) {
    return null;
  }
  let k = 0;
  let j;
  const post = [];
  const w = [];
  const head = 0;
  const next = n;
  const stack = 2 * n;
  for (j = 0; j < n; j++) {
    w[head + j] = -1;
  }
  for (j = n - 1; j >= 0; j--) {
    if (parent[j] === -1) {
      continue;
    }
    w[next + j] = w[head + parent[j]];
    w[head + parent[j]] = j;
  }
  for (j = 0; j < n; j++) {
    if (parent[j] !== -1) {
      continue;
    }
    k = csTdfs(j, k, w, head, next, post, stack);
  }
  return post;
}

// src/function/algebra/sparse/csEtree.ts
function csEtree(a, ata) {
  if (!a) {
    return null;
  }
  const aindex = a._index;
  const aptr = a._ptr;
  const asize = a._size;
  const m = asize[0];
  const n = asize[1];
  const parent = [];
  const w = [];
  const ancestor = 0;
  const prev = n;
  let i, inext;
  {
    for (i = 0; i < m; i++) {
      w[prev + i] = -1;
    }
  }
  for (let k = 0; k < n; k++) {
    parent[k] = -1;
    w[ancestor + k] = -1;
    for (let p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {
      const r = aindex[p];
      i = w[prev + r] ;
      for (; i !== -1 && i < k; i = inext) {
        inext = w[ancestor + i];
        w[ancestor + i] = k;
        if (inext === -1) {
          parent[i] = k;
        }
      }
      {
        w[prev + r] = k;
      }
    }
  }
  return parent;
}

// src/function/algebra/sparse/csFkeep.ts
function csFkeep(a, callback, other) {
  const avalues = a._values;
  const aindex = a._index;
  const aptr = a._ptr;
  const asize = a._size;
  const n = asize[1];
  let nz = 0;
  for (let j = 0; j < n; j++) {
    let p = aptr[j];
    aptr[j] = nz;
    for (; p < aptr[j + 1]; p++) {
      if (callback(aindex[p], j, avalues ? avalues[p] : 1, other)) {
        aindex[nz] = aindex[p];
        if (avalues) {
          avalues[nz] = avalues[p];
        }
        nz++;
      }
    }
  }
  aptr[n] = nz;
  aindex.splice(nz, aindex.length - nz);
  if (avalues) {
    avalues.splice(nz, avalues.length - nz);
  }
  return nz;
}

// src/function/algebra/sparse/csFlip.ts
function csFlip(i) {
  return -i - 2;
}

// src/function/algebra/sparse/csAmd.ts
var name235 = "csAmd";
var dependencies236 = ["add", "multiply", "transpose"];
var createCsAmd = /* @__PURE__ */ factory(
  name235,
  dependencies236,
  ({ add, multiply, transpose }) => {
    return function csAmd(order, a) {
      if (!a || order <= 0 || order > 3) {
        return null;
      }
      const asize = a._size;
      const m = asize[0];
      const n = asize[1];
      let lemax = 0;
      let dense = Math.max(16, 10 * Math.sqrt(n));
      dense = Math.min(n - 2, dense);
      const cm = _createTargetMatrix(order, a, m, n, dense);
      csFkeep(cm, _diag, null);
      const cindex = cm._index;
      const cptr = cm._ptr;
      let cnz = cptr[n];
      const P2 = [];
      const W = [];
      const len = 0;
      const nv = n + 1;
      const next = 2 * (n + 1);
      const head = 3 * (n + 1);
      const elen = 4 * (n + 1);
      const degree = 5 * (n + 1);
      const w = 6 * (n + 1);
      const hhead = 7 * (n + 1);
      const last = P2;
      let mark = _initializeQuotientGraph(
        n,
        cptr,
        W,
        len,
        head,
        last,
        next,
        hhead,
        nv,
        w,
        elen,
        degree
      );
      let nel = _initializeDegreeLists(
        n,
        cptr,
        W,
        degree,
        elen,
        w,
        dense,
        nv,
        head,
        last,
        next
      );
      let mindeg = 0;
      let i, j, k, k1, k2, e2, pj, ln, nvi, pk, eln, p1, p2, pn, h, d;
      while (nel < n) {
        for (k = -1; mindeg < n && (k = W[head + mindeg]) === -1; mindeg++) ;
        if (W[next + k] !== -1) {
          last[W[next + k]] = -1;
        }
        W[head + mindeg] = W[next + k];
        const elenk = W[elen + k];
        let nvk = W[nv + k];
        nel += nvk;
        let dk = 0;
        W[nv + k] = -nvk;
        let p = cptr[k];
        const pk1 = elenk === 0 ? p : cnz;
        let pk2 = pk1;
        for (k1 = 1; k1 <= elenk + 1; k1++) {
          if (k1 > elenk) {
            e2 = k;
            pj = p;
            ln = W[len + k] - elenk;
          } else {
            e2 = cindex[p++];
            pj = cptr[e2];
            ln = W[len + e2];
          }
          for (k2 = 1; k2 <= ln; k2++) {
            i = cindex[pj++];
            if ((nvi = W[nv + i]) <= 0) {
              continue;
            }
            dk += nvi;
            W[nv + i] = -nvi;
            cindex[pk2++] = i;
            if (W[next + i] !== -1) {
              last[W[next + i]] = last[i];
            }
            if (last[i] !== -1) {
              W[next + last[i]] = W[next + i];
            } else {
              W[head + W[degree + i]] = W[next + i];
            }
          }
          if (e2 !== k) {
            cptr[e2] = csFlip(k);
            W[w + e2] = 0;
          }
        }
        if (elenk !== 0) {
          cnz = pk2;
        }
        W[degree + k] = dk;
        cptr[k] = pk1;
        W[len + k] = pk2 - pk1;
        W[elen + k] = -2;
        mark = _wclear(mark, lemax, W, w, n);
        for (pk = pk1; pk < pk2; pk++) {
          i = cindex[pk];
          if ((eln = W[elen + i]) <= 0) {
            continue;
          }
          nvi = -W[nv + i];
          const wnvi = mark - nvi;
          for (p = cptr[i], p1 = cptr[i] + eln - 1; p <= p1; p++) {
            e2 = cindex[p];
            if (W[w + e2] >= mark) {
              W[w + e2] -= nvi;
            } else if (W[w + e2] !== 0) {
              W[w + e2] = W[degree + e2] + wnvi;
            }
          }
        }
        for (pk = pk1; pk < pk2; pk++) {
          i = cindex[pk];
          p1 = cptr[i];
          p2 = p1 + W[elen + i] - 1;
          pn = p1;
          for (h = 0, d = 0, p = p1; p <= p2; p++) {
            e2 = cindex[p];
            if (W[w + e2] !== 0) {
              const dext = W[w + e2] - mark;
              if (dext > 0) {
                d += dext;
                cindex[pn++] = e2;
                h += e2;
              } else {
                cptr[e2] = csFlip(k);
                W[w + e2] = 0;
              }
            }
          }
          W[elen + i] = pn - p1 + 1;
          const p3 = pn;
          const p4 = p1 + W[len + i];
          for (p = p2 + 1; p < p4; p++) {
            j = cindex[p];
            const nvj = W[nv + j];
            if (nvj <= 0) {
              continue;
            }
            d += nvj;
            cindex[pn++] = j;
            h += j;
          }
          if (d === 0) {
            cptr[i] = csFlip(k);
            nvi = -W[nv + i];
            dk -= nvi;
            nvk += nvi;
            nel += nvi;
            W[nv + i] = 0;
            W[elen + i] = -1;
          } else {
            W[degree + i] = Math.min(W[degree + i], d);
            cindex[pn] = cindex[p3];
            cindex[p3] = cindex[p1];
            cindex[p1] = k;
            W[len + i] = pn - p1 + 1;
            h = (h < 0 ? -h : h) % n;
            W[next + i] = W[hhead + h];
            W[hhead + h] = i;
            last[i] = h;
          }
        }
        W[degree + k] = dk;
        lemax = Math.max(lemax, dk);
        mark = _wclear(mark + lemax, lemax, W, w, n);
        for (pk = pk1; pk < pk2; pk++) {
          i = cindex[pk];
          if (W[nv + i] >= 0) {
            continue;
          }
          h = last[i];
          i = W[hhead + h];
          W[hhead + h] = -1;
          for (; i !== -1 && W[next + i] !== -1; i = W[next + i], mark++) {
            ln = W[len + i];
            eln = W[elen + i];
            for (p = cptr[i] + 1; p <= cptr[i] + ln - 1; p++) {
              W[w + cindex[p]] = mark;
            }
            let jlast = i;
            for (j = W[next + i]; j !== -1; ) {
              let ok = W[len + j] === ln && W[elen + j] === eln;
              for (p = cptr[j] + 1; ok && p <= cptr[j] + ln - 1; p++) {
                if (W[w + cindex[p]] !== mark) {
                  ok = false;
                }
              }
              if (ok) {
                cptr[j] = csFlip(i);
                W[nv + i] += W[nv + j];
                W[nv + j] = 0;
                W[elen + j] = -1;
                j = W[next + j];
                W[next + jlast] = j;
              } else {
                jlast = j;
                j = W[next + j];
              }
            }
          }
        }
        for (p = pk1, pk = pk1; pk < pk2; pk++) {
          i = cindex[pk];
          if ((nvi = -W[nv + i]) <= 0) {
            continue;
          }
          W[nv + i] = nvi;
          d = W[degree + i] + dk - nvi;
          d = Math.min(d, n - nel - nvi);
          if (W[head + d] !== -1) {
            last[W[head + d]] = i;
          }
          W[next + i] = W[head + d];
          last[i] = -1;
          W[head + d] = i;
          mindeg = Math.min(mindeg, d);
          W[degree + i] = d;
          cindex[p++] = i;
        }
        W[nv + k] = nvk;
        if ((W[len + k] = p - pk1) === 0) {
          cptr[k] = -1;
          W[w + k] = 0;
        }
        if (elenk !== 0) {
          cnz = p;
        }
      }
      for (i = 0; i < n; i++) {
        cptr[i] = csFlip(cptr[i]);
      }
      for (j = 0; j <= n; j++) {
        W[head + j] = -1;
      }
      for (j = n; j >= 0; j--) {
        if (W[nv + j] > 0) {
          continue;
        }
        W[next + j] = W[head + cptr[j]];
        W[head + cptr[j]] = j;
      }
      for (e2 = n; e2 >= 0; e2--) {
        if (W[nv + e2] <= 0) {
          continue;
        }
        if (cptr[e2] !== -1) {
          W[next + e2] = W[head + cptr[e2]];
          W[head + cptr[e2]] = e2;
        }
      }
      for (k = 0, i = 0; i <= n; i++) {
        if (cptr[i] === -1) {
          k = csTdfs(i, k, W, head, next, P2, w);
        }
      }
      P2.splice(P2.length - 1, 1);
      return P2;
    };
    function _createTargetMatrix(order, a, m, n, dense) {
      const at = transpose(a);
      if (order === 1 && n === m) {
        return add(a, at);
      }
      if (order === 2) {
        const tindex = at._index;
        const tptr = at._ptr;
        let p2 = 0;
        for (let j = 0; j < m; j++) {
          let p = tptr[j];
          tptr[j] = p2;
          if (tptr[j + 1] - p > dense) {
            continue;
          }
          for (const p1 = tptr[j + 1]; p < p1; p++) {
            tindex[p2++] = tindex[p];
          }
        }
        tptr[m] = p2;
        a = transpose(at);
        return multiply(at, a);
      }
      return multiply(at, a);
    }
    function _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree) {
      for (let k = 0; k < n; k++) {
        W[len + k] = cptr[k + 1] - cptr[k];
      }
      W[len + n] = 0;
      for (let i = 0; i <= n; i++) {
        W[head + i] = -1;
        last[i] = -1;
        W[next + i] = -1;
        W[hhead + i] = -1;
        W[nv + i] = 1;
        W[w + i] = 1;
        W[elen + i] = 0;
        W[degree + i] = W[len + i];
      }
      const mark = _wclear(0, 0, W, w, n);
      W[elen + n] = -2;
      cptr[n] = -1;
      W[w + n] = 0;
      return mark;
    }
    function _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next) {
      let nel = 0;
      for (let i = 0; i < n; i++) {
        const d = W[degree + i];
        if (d === 0) {
          W[elen + i] = -2;
          nel++;
          cptr[i] = -1;
          W[w + i] = 0;
        } else if (d > dense) {
          W[nv + i] = 0;
          W[elen + i] = -1;
          nel++;
          cptr[i] = csFlip(n);
          W[nv + n]++;
        } else {
          const h = W[head + d];
          if (h !== -1) {
            last[h] = i;
          }
          W[next + i] = W[head + d];
          W[head + d] = i;
        }
      }
      return nel;
    }
    function _wclear(mark, lemax, W, w, n) {
      if (mark < 2 || mark + lemax < 0) {
        for (let k = 0; k < n; k++) {
          if (W[w + k] !== 0) {
            W[w + k] = 1;
          }
        }
        mark = 2;
      }
      return mark;
    }
    function _diag(i, j) {
      return i !== j;
    }
  }
);

// src/function/algebra/sparse/csLeaf.ts
function csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor) {
  let s, sparent;
  let jleaf = 0;
  let q;
  if (i <= j || w[first + j] <= w[maxfirst + i]) {
    return -1;
  }
  w[maxfirst + i] = w[first + j];
  const jprev = w[prevleaf + i];
  w[prevleaf + i] = j;
  if (jprev === -1) {
    jleaf = 1;
    q = i;
  } else {
    jleaf = 2;
    for (q = jprev; q !== w[ancestor + q]; q = w[ancestor + q]) ;
    for (s = jprev; s !== q; s = sparent) {
      sparent = w[ancestor + s];
      w[ancestor + s] = q;
    }
  }
  return { jleaf, q };
}

// src/function/algebra/sparse/csCounts.ts
var name236 = "csCounts";
var dependencies237 = ["transpose"];
var createCsCounts = /* @__PURE__ */ factory(
  name236,
  dependencies237,
  ({ transpose }) => {
    return function csCounts(a, parent, post, ata) {
      if (!a || !parent || !post) {
        return null;
      }
      const asize = a._size;
      const m = asize[0];
      const n = asize[1];
      let i, j, k, J, p, p0, p1;
      const s = 4 * n + (ata ? n + m + 1 : 0);
      const w = [];
      const ancestor = 0;
      const maxfirst = n;
      const prevleaf = 2 * n;
      const first = 3 * n;
      const head = 4 * n;
      const next = 5 * n + 1;
      for (k = 0; k < s; k++) {
        w[k] = -1;
      }
      const colcount = [];
      const at = transpose(a);
      const tindex = at._index;
      const tptr = at._ptr;
      for (k = 0; k < n; k++) {
        j = post[k];
        colcount[j] = w[first + j] === -1 ? 1 : 0;
        for (; j !== -1 && w[first + j] === -1; j = parent[j]) {
          w[first + j] = k;
        }
      }
      if (ata) {
        for (k = 0; k < n; k++) {
          w[post[k]] = k;
        }
        for (i = 0; i < m; i++) {
          for (k = n, p0 = tptr[i], p1 = tptr[i + 1], p = p0; p < p1; p++) {
            k = Math.min(k, w[tindex[p]]);
          }
          w[next + i] = w[head + k];
          w[head + k] = i;
        }
      }
      for (i = 0; i < n; i++) {
        w[ancestor + i] = i;
      }
      for (k = 0; k < n; k++) {
        j = post[k];
        if (parent[j] !== -1) {
          colcount[parent[j]]--;
        }
        for (J = ata ? w[head + k] : j; J !== -1; J = ata ? w[next + J] : -1) {
          for (p = tptr[J]; p < tptr[J + 1]; p++) {
            i = tindex[p];
            const r = csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor);
            if (typeof r === "object" && r.jleaf >= 1) {
              colcount[j]++;
            }
            if (typeof r === "object" && r.jleaf === 2) {
              colcount[r.q]--;
            }
          }
        }
        if (parent[j] !== -1) {
          w[ancestor + j] = parent[j];
        }
      }
      for (j = 0; j < n; j++) {
        if (parent[j] !== -1) {
          colcount[parent[j]] += colcount[j];
        }
      }
      return colcount;
    };
  }
);

// src/function/algebra/sparse/csSqr.ts
var name237 = "csSqr";
var dependencies238 = ["add", "multiply", "transpose"];
var createCsSqr = /* @__PURE__ */ factory(
  name237,
  dependencies238,
  ({ add, multiply, transpose }) => {
    const csAmd = createCsAmd({ add, multiply, transpose });
    const csCounts = createCsCounts({ transpose });
    return function csSqr(order, a, qr) {
      const aptr = a._ptr;
      const asize = a._size;
      const n = asize[1];
      let k;
      const s = {};
      s.q = csAmd(order, a);
      if (order && !s.q) {
        return null;
      }
      if (qr) {
        const c = order ? csPermute(a, null, s.q) : a;
        s.parent = csEtree(c);
        const post = csPost(s.parent, n);
        s.cp = csCounts(c, s.parent, post, true);
        if (c && s.parent && s.cp && _vcount(c, s)) {
          for (s.unz = 0, k = 0; k < n; k++) {
            s.unz += s.cp[k];
          }
        }
      } else {
        s.unz = 4 * aptr[n] + n;
        s.lnz = s.unz;
      }
      return s;
    };
    function _vcount(a, s) {
      const aptr = a._ptr;
      const aindex = a._index;
      const asize = a._size;
      const m = asize[0];
      const n = asize[1];
      s.pinv = [];
      s.leftmost = [];
      const parent = s.parent;
      const pinv = s.pinv;
      const leftmost = s.leftmost;
      const w = [];
      const next = 0;
      const head = m;
      const tail = m + n;
      const nque = m + 2 * n;
      let i, k, p, p0, p1;
      for (k = 0; k < n; k++) {
        w[head + k] = -1;
        w[tail + k] = -1;
        w[nque + k] = 0;
      }
      for (i = 0; i < m; i++) {
        leftmost[i] = -1;
      }
      for (k = n - 1; k >= 0; k--) {
        for (p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {
          leftmost[aindex[p]] = k;
        }
      }
      for (i = m - 1; i >= 0; i--) {
        pinv[i] = -1;
        k = leftmost[i];
        if (k === -1) {
          continue;
        }
        if (w[nque + k]++ === 0) {
          w[tail + k] = i;
        }
        w[next + i] = w[head + k];
        w[head + k] = i;
      }
      s.lnz = 0;
      s.m2 = m;
      for (k = 0; k < n; k++) {
        i = w[head + k];
        s.lnz++;
        if (i < 0) {
          i = s.m2++;
        }
        pinv[i] = k;
        if (--nque[k] <= 0) {
          continue;
        }
        s.lnz += w[nque + k];
        const pa = parent[k];
        if (pa !== -1) {
          if (w[nque + pa] === 0) {
            w[tail + pa] = w[tail + k];
          }
          w[next + w[tail + k]] = w[head + pa];
          w[head + pa] = w[next + i];
          w[nque + pa] += w[nque + k];
        }
      }
      for (i = 0; i < m; i++) {
        if (pinv[i] < 0) {
          pinv[i] = k++;
        }
      }
      return true;
    }
  }
);

// src/function/algebra/sparse/csMarked.ts
function csMarked(w, j) {
  return w[j] < 0;
}

// src/function/algebra/sparse/csMark.ts
function csMark(w, j) {
  w[j] = csFlip(w[j]);
}

// src/function/algebra/sparse/csUnflip.ts
function csUnflip(i) {
  return i < 0 ? csFlip(i) : i;
}

// src/function/algebra/sparse/csDfs.ts
function csDfs(j, g, top, xi, pinv) {
  const index = g._index;
  const ptr = g._ptr;
  const size = g._size;
  const n = size[1];
  let i, p, p2;
  let head = 0;
  xi[0] = j;
  while (head >= 0) {
    j = xi[head];
    const jnew = pinv ? pinv[j] : j;
    if (!csMarked(ptr, j)) {
      csMark(ptr, j);
      xi[n + head] = jnew < 0 ? 0 : csUnflip(ptr[jnew]);
    }
    let done = 1;
    for (p = xi[n + head], p2 = jnew < 0 ? 0 : csUnflip(ptr[jnew + 1]); p < p2; p++) {
      i = index[p];
      if (csMarked(ptr, i)) {
        continue;
      }
      xi[n + head] = p;
      xi[++head] = i;
      done = 0;
      break;
    }
    if (done) {
      head--;
      xi[--top] = j;
    }
  }
  return top;
}

// src/function/algebra/sparse/csReach.ts
function csReach(g, b, k, xi, pinv) {
  const gptr = g._ptr;
  const gsize = g._size;
  const bindex = b._index;
  const bptr = b._ptr;
  const n = gsize[1];
  let p, p0, p1;
  let top = n;
  for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {
    const i = bindex[p];
    if (!csMarked(gptr, i)) {
      top = csDfs(i, g, top, xi, pinv);
    }
  }
  for (p = top; p < n; p++) {
    csMark(gptr, xi[p]);
  }
  return top;
}

// src/function/algebra/sparse/csSpsolve.ts
var name238 = "csSpsolve";
var dependencies239 = ["divideScalar", "multiply", "subtract"];
var createCsSpsolve = /* @__PURE__ */ factory(
  name238,
  dependencies239,
  ({ divideScalar, multiply, subtract }) => {
    return function csSpsolve(g, b, k, xi, x, pinv, lo) {
      const gvalues = g._values;
      const gindex = g._index;
      const gptr = g._ptr;
      const gsize = g._size;
      const n = gsize[1];
      const bvalues = b._values;
      const bindex = b._index;
      const bptr = b._ptr;
      let p, p0, p1, q;
      const top = csReach(g, b, k, xi, pinv);
      for (p = top; p < n; p++) {
        x[xi[p]] = 0;
      }
      for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {
        x[bindex[p]] = bvalues[p];
      }
      for (let px = top; px < n; px++) {
        const j = xi[px];
        const J = pinv ? pinv[j] : j;
        if (J < 0) {
          continue;
        }
        p0 = gptr[J];
        p1 = gptr[J + 1];
        x[j] = divideScalar(x[j], gvalues[lo ? p0 : p1 - 1]);
        p = lo ? p0 + 1 : p0;
        q = lo ? p1 : p1 - 1;
        for (; p < q; p++) {
          const i = gindex[p];
          x[i] = subtract(x[i], multiply(gvalues[p], x[j]));
        }
      }
      return top;
    };
  }
);

// src/function/algebra/sparse/csLu.ts
var name239 = "csLu";
var dependencies240 = [
  "abs",
  "divideScalar",
  "multiply",
  "subtract",
  "larger",
  "largerEq",
  "SparseMatrix"
];
var createCsLu = /* @__PURE__ */ factory(
  name239,
  dependencies240,
  ({
    abs,
    divideScalar,
    multiply,
    subtract,
    larger,
    largerEq,
    SparseMatrix
  }) => {
    const csSpsolve = createCsSpsolve({ divideScalar, multiply, subtract });
    return function csLu(m, s, tol) {
      if (!m) {
        return null;
      }
      const size = m._size;
      const n = size[1];
      let q;
      let lnz = 100;
      let unz = 100;
      if (s) {
        q = s.q;
        lnz = s.lnz || lnz;
        unz = s.unz || unz;
      }
      const lvalues = [];
      const lindex = [];
      const lptr = [];
      const L = new SparseMatrix({
        values: lvalues,
        index: lindex,
        ptr: lptr,
        size: [n, n]
      });
      const uvalues = [];
      const uindex = [];
      const uptr = [];
      const U = new SparseMatrix({
        values: uvalues,
        index: uindex,
        ptr: uptr,
        size: [n, n]
      });
      const pinv = [];
      let i, p;
      const x = [];
      const xi = [];
      for (i = 0; i < n; i++) {
        x[i] = 0;
        pinv[i] = -1;
        lptr[i + 1] = 0;
      }
      lnz = 0;
      unz = 0;
      for (let k = 0; k < n; k++) {
        lptr[k] = lnz;
        uptr[k] = unz;
        const col = q ? q[k] : k;
        const top = csSpsolve(L, m, col, xi, x, pinv, true);
        let ipiv = -1;
        let a = -1;
        for (p = top; p < n; p++) {
          i = xi[p];
          if (pinv[i] < 0) {
            const xabs = abs(x[i]);
            if (larger(xabs, a)) {
              a = xabs;
              ipiv = i;
            }
          } else {
            uindex[unz] = pinv[i];
            uvalues[unz++] = x[i];
          }
        }
        if (ipiv === -1 || a <= 0) {
          return null;
        }
        if (pinv[col] < 0 && largerEq(abs(x[col]), multiply(a, tol))) {
          ipiv = col;
        }
        const pivot = x[ipiv];
        uindex[unz] = k;
        uvalues[unz++] = pivot;
        pinv[ipiv] = k;
        lindex[lnz] = ipiv;
        lvalues[lnz++] = 1;
        for (p = top; p < n; p++) {
          i = xi[p];
          if (pinv[i] < 0) {
            lindex[lnz] = i;
            lvalues[lnz++] = divideScalar(x[i], pivot);
          }
          x[i] = 0;
        }
      }
      lptr[n] = lnz;
      uptr[n] = unz;
      for (p = 0; p < lnz; p++) {
        lindex[p] = pinv[lindex[p]];
      }
      lvalues.splice(lnz, lvalues.length - lnz);
      lindex.splice(lnz, lindex.length - lnz);
      uvalues.splice(unz, uvalues.length - unz);
      uindex.splice(unz, uindex.length - unz);
      return { L, U, pinv };
    };
  }
);

// src/function/algebra/decomposition/slu.ts
var name240 = "slu";
var dependencies241 = [
  "typed",
  "abs",
  "add",
  "multiply",
  "transpose",
  "divideScalar",
  "subtract",
  "larger",
  "largerEq",
  "SparseMatrix"
];
var createSlu = /* @__PURE__ */ factory(
  name240,
  dependencies241,
  ({
    typed: typed2,
    abs,
    add,
    multiply,
    transpose,
    divideScalar,
    subtract,
    larger,
    largerEq,
    SparseMatrix
  }) => {
    const csSqr = createCsSqr({ add, multiply, transpose });
    const csLu = createCsLu({
      abs,
      divideScalar,
      multiply,
      subtract,
      larger,
      largerEq,
      SparseMatrix
    });
    return typed2(name240, {
      "SparseMatrix, number, number": function(a, order, threshold) {
        if (!isInteger(order) || order < 0 || order > 3) {
          throw new Error(
            "Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]"
          );
        }
        if (threshold < 0 || threshold > 1) {
          throw new Error(
            "Partial pivoting threshold must be a number from 0 to 1"
          );
        }
        const s = csSqr(order, a, false);
        const f = csLu(a, s, threshold);
        return {
          L: f.L,
          U: f.U,
          p: f.pinv,
          q: s.q,
          toString: function() {
            return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\np: " + this.p.toString() + (this.q ? "\nq: " + this.q.toString() : "") + "\n";
          }
        };
      }
    });
  }
);

// src/function/algebra/sparse/csIpvec.ts
function csIpvec(p, b) {
  let k;
  const n = b.length;
  const x = [];
  if (p) {
    for (k = 0; k < n; k++) {
      x[p[k]] = b[k];
    }
  } else {
    for (k = 0; k < n; k++) {
      x[k] = b[k];
    }
  }
  return x;
}

// src/function/algebra/solver/lusolve.ts
var WASM_LUSOLVE_THRESHOLD = 16;
function isPlainNumberMatrix6(matrix) {
  for (let i = 0; i < matrix.length; i++) {
    const row = matrix[i];
    for (let j = 0; j < row.length; j++) {
      if (typeof row[j] !== "number") {
        return false;
      }
    }
  }
  return true;
}
function isPlainNumberVector3(vec) {
  for (let i = 0; i < vec.length; i++) {
    if (typeof vec[i][0] !== "number") {
      return false;
    }
  }
  return true;
}
function flattenToFloat646(matrix, rows, cols) {
  const result = new Float64Array(rows * cols);
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      result[i * cols + j] = matrix[i][j];
    }
  }
  return result;
}
function vectorToFloat643(vec) {
  const result = new Float64Array(vec.length);
  for (let i = 0; i < vec.length; i++) {
    result[i] = vec[i][0];
  }
  return result;
}
var name241 = "lusolve";
var dependencies242 = [
  "typed",
  "matrix",
  "lup",
  "slu",
  "usolve",
  "lsolve",
  "DenseMatrix"
];
var createLusolve = /* @__PURE__ */ factory(
  name241,
  dependencies242,
  ({ typed: typed2, matrix, lup, slu, usolve, lsolve, DenseMatrix }) => {
    const solveValidation = createSolveValidation({
      DenseMatrix
    });
    return typed2(name241, {
      "Array, Array | Matrix": function(a, b) {
        const rows = a.length;
        const columns = a[0]?.length || 0;
        const wasm = wasmLoader.getModule();
        if (wasm && rows === columns && rows * rows >= WASM_LUSOLVE_THRESHOLD && isPlainNumberMatrix6(a)) {
          const aMatrix2 = matrix(a);
          const bMatrix = solveValidation(aMatrix2, b, true);
          const bdata = bMatrix._data;
          if (isPlainNumberVector3(bdata) && bdata.length === rows) {
            try {
              const aFlat = flattenToFloat646(a, rows, columns);
              const bFlat = vectorToFloat643(bdata);
              const aAlloc = wasmLoader.allocateFloat64Array(aFlat);
              const bAlloc = wasmLoader.allocateFloat64Array(bFlat);
              const resultAlloc = wasmLoader.allocateFloat64ArrayEmpty(rows);
              const workAlloc = wasmLoader.allocateFloat64ArrayEmpty(rows * rows);
              try {
                const success = wasm.laSolve(
                  aAlloc.ptr,
                  bAlloc.ptr,
                  rows,
                  resultAlloc.ptr,
                  workAlloc.ptr
                );
                if (success === 0) {
                  throw new Error(
                    "Linear system cannot be solved since matrix is singular"
                  );
                }
                const x2 = [];
                for (let i = 0; i < rows; i++) {
                  x2[i] = [resultAlloc.array[i]];
                }
                return x2;
              } finally {
                wasmLoader.free(aAlloc.ptr);
                wasmLoader.free(bAlloc.ptr);
                wasmLoader.free(resultAlloc.ptr);
                wasmLoader.free(workAlloc.ptr);
              }
            } catch (e2) {
              if (e2 instanceof Error && e2.message.includes("singular")) {
                throw e2;
              }
            }
          }
        }
        const aMatrix = matrix(a);
        const d = lup(aMatrix);
        const x = _lusolve(d.L, d.U, d.p, null, b);
        return x.valueOf();
      },
      "DenseMatrix, Array | Matrix": function(a, b) {
        const rows = a._size[0];
        const columns = a._size[1];
        const wasm = wasmLoader.getModule();
        if (wasm && rows === columns && rows * rows >= WASM_LUSOLVE_THRESHOLD && isPlainNumberMatrix6(a._data)) {
          const bMatrix = solveValidation(a, b, true);
          const bdata = bMatrix._data;
          if (isPlainNumberVector3(bdata) && bdata.length === rows) {
            try {
              const aFlat = flattenToFloat646(a._data, rows, columns);
              const bFlat = vectorToFloat643(bdata);
              const aAlloc = wasmLoader.allocateFloat64Array(aFlat);
              const bAlloc = wasmLoader.allocateFloat64Array(bFlat);
              const resultAlloc = wasmLoader.allocateFloat64ArrayEmpty(rows);
              const workAlloc = wasmLoader.allocateFloat64ArrayEmpty(rows * rows);
              try {
                const success = wasm.laSolve(
                  aAlloc.ptr,
                  bAlloc.ptr,
                  rows,
                  resultAlloc.ptr,
                  workAlloc.ptr
                );
                if (success === 0) {
                  throw new Error(
                    "Linear system cannot be solved since matrix is singular"
                  );
                }
                const x = [];
                for (let i = 0; i < rows; i++) {
                  x[i] = [resultAlloc.array[i]];
                }
                return new DenseMatrix({
                  data: x,
                  size: [rows, 1]
                });
              } finally {
                wasmLoader.free(aAlloc.ptr);
                wasmLoader.free(bAlloc.ptr);
                wasmLoader.free(resultAlloc.ptr);
                wasmLoader.free(workAlloc.ptr);
              }
            } catch (e2) {
              if (e2 instanceof Error && e2.message.includes("singular")) {
                throw e2;
              }
            }
          }
        }
        const d = lup(a);
        return _lusolve(d.L, d.U, d.p, null, b);
      },
      "SparseMatrix, Array | Matrix": function(a, b) {
        const d = lup(a);
        return _lusolve(d.L, d.U, d.p, null, b);
      },
      "SparseMatrix, Array | Matrix, number, number": function(a, b, order, threshold) {
        const d = slu(a, order, threshold);
        return _lusolve(d.L, d.U, d.p, d.q, b);
      },
      "Object, Array | Matrix": function(d, b) {
        return _lusolve(d.L, d.U, d.p, d.q, b);
      }
    });
    function _toMatrix(a) {
      if (isMatrix(a)) {
        return a;
      }
      if (isArray(a)) {
        return matrix(a);
      }
      throw new TypeError("Invalid Matrix LU decomposition");
    }
    function _lusolve(l, u, p, q, b) {
      const L = _toMatrix(l);
      const U = _toMatrix(u);
      let bMatrix;
      if (p) {
        bMatrix = solveValidation(L, b, true);
        bMatrix._data = csIpvec(p, bMatrix._data);
      } else {
        bMatrix = solveValidation(L, b, true);
      }
      const y = lsolve(L, bMatrix);
      const x = usolve(U, y);
      if (q) {
        x._data = csIpvec(q, x._data);
      }
      return x;
    }
  }
);

// src/function/algebra/polynomialRoot.ts
var name242 = "polynomialRoot";
var dependencies243 = [
  "typed",
  "isZero",
  "equalScalar",
  "add",
  "subtract",
  "multiply",
  "divide",
  "sqrt",
  "unaryMinus",
  "cbrt",
  "typeOf",
  "im",
  "re"
];
var createPolynomialRoot = /* @__PURE__ */ factory(
  name242,
  dependencies243,
  ({
    typed: typed2,
    isZero,
    equalScalar,
    add,
    subtract,
    multiply,
    divide,
    sqrt,
    unaryMinus,
    cbrt: cbrt3,
    typeOf: typeOf2,
    im,
    re
  }) => {
    return typed2(name242, {
      "number|Complex, ...number|Complex": (constant, restCoeffs) => {
        const coeffs = [constant, ...restCoeffs];
        while (coeffs.length > 0 && isZero(coeffs[coeffs.length - 1])) {
          coeffs.pop();
        }
        if (coeffs.length < 2) {
          throw new RangeError(
            `Polynomial [${constant}, ${restCoeffs}] must have a non-zero non-constant coefficient`
          );
        }
        switch (coeffs.length) {
          case 2:
            return [unaryMinus(divide(coeffs[0], coeffs[1]))];
          case 3: {
            const [c, b, a] = coeffs;
            const denom = multiply(2, a);
            const d1 = multiply(b, b);
            const d2 = multiply(4, a, c);
            if (equalScalar(d1, d2)) return [divide(unaryMinus(b), denom)];
            const discriminant = sqrt(subtract(d1, d2));
            return [
              divide(subtract(discriminant, b), denom),
              divide(subtract(unaryMinus(discriminant), b), denom)
            ];
          }
          case 4: {
            const [d, c, b, a] = coeffs;
            const denom = unaryMinus(multiply(3, a));
            const D0_1 = multiply(b, b);
            const D0_2 = multiply(3, a, c);
            const D1_1 = add(multiply(2, b, b, b), multiply(27, a, a, d));
            const D1_2 = multiply(9, a, b, c);
            if (equalScalar(D0_1, D0_2) && equalScalar(D1_1, D1_2)) {
              return [divide(b, denom)];
            }
            const Delta0 = subtract(D0_1, D0_2);
            const Delta1 = subtract(D1_1, D1_2);
            const discriminant1 = add(
              multiply(18, a, b, c, d),
              multiply(b, b, c, c)
            );
            const discriminant2 = add(
              multiply(4, b, b, b, d),
              multiply(4, a, c, c, c),
              multiply(27, a, a, d, d)
            );
            if (equalScalar(discriminant1, discriminant2)) {
              return [
                divide(
                  subtract(
                    multiply(4, a, b, c),
                    add(multiply(9, a, a, d), multiply(b, b, b))
                  ),
                  multiply(a, Delta0)
                ),
                // simple root
                divide(
                  subtract(multiply(9, a, d), multiply(b, c)),
                  multiply(2, Delta0)
                )
                // double root
              ];
            }
            let Ccubed;
            if (equalScalar(D0_1, D0_2)) {
              Ccubed = Delta1;
            } else {
              Ccubed = divide(
                add(
                  Delta1,
                  sqrt(
                    subtract(
                      multiply(Delta1, Delta1),
                      multiply(4, Delta0, Delta0, Delta0)
                    )
                  )
                ),
                2
              );
            }
            const allRoots = true;
            const rawRoots = cbrt3(Ccubed, allRoots).toArray().map((C) => divide(add(b, C, divide(Delta0, C)), denom));
            return rawRoots.map((r) => {
              if (typeOf2(r) === "Complex" && equalScalar(re(r), re(r) + im(r))) {
                return re(r);
              }
              return r;
            });
          }
          default:
            throw new RangeError(
              `only implemented for cubic or lower-order polynomials, not ${coeffs}`
            );
        }
      }
    });
  }
);

// src/expression/Help.ts
var name243 = "Help";
var dependencies244 = ["evaluate"];
var createHelpClass = /* @__PURE__ */ factory(
  name243,
  dependencies244,
  ({ evaluate }) => {
    function Help(doc) {
      if (!(this instanceof Help)) {
        throw new SyntaxError(
          "Constructor must be called with the new operator"
        );
      }
      if (!doc) throw new Error('Argument "doc" missing');
      this.doc = doc;
    }
    Help.prototype.type = "Help";
    Help.prototype.isHelp = true;
    Help.prototype.toString = function() {
      const doc = this.doc || {};
      let desc = "\n";
      if (doc.name) {
        desc += "Name: " + doc.name + "\n\n";
      }
      if (doc.category) {
        desc += "Category: " + doc.category + "\n\n";
      }
      if (doc.description) {
        desc += "Description:\n    " + doc.description + "\n\n";
      }
      if (doc.syntax) {
        desc += "Syntax:\n    " + doc.syntax.join("\n    ") + "\n\n";
      }
      if (doc.examples) {
        desc += "Examples:\n";
        let configChanged = false;
        const originalConfig = evaluate("config()");
        const scope = {
          config: (newConfig) => {
            configChanged = true;
            return evaluate("config(newConfig)", { newConfig });
          }
        };
        for (let i = 0; i < doc.examples.length; i++) {
          const expr = doc.examples[i];
          desc += "    " + expr + "\n";
          let res;
          try {
            res = evaluate(expr, scope);
          } catch (e2) {
            res = e2;
          }
          if (res !== void 0 && !isHelp(res)) {
            desc += "        " + format3(res, { precision: 14 }) + "\n";
          }
        }
        desc += "\n";
        if (configChanged) {
          evaluate("config(originalConfig)", { originalConfig });
        }
      }
      if (doc.mayThrow && doc.mayThrow.length) {
        desc += "Throws: " + doc.mayThrow.join(", ") + "\n\n";
      }
      if (doc.seealso && doc.seealso.length) {
        desc += "See also: " + doc.seealso.join(", ") + "\n";
      }
      return desc;
    };
    Help.prototype.toJSON = function() {
      const obj = clone(this.doc);
      obj.mathjs = "Help";
      return obj;
    };
    Help.fromJSON = function(json) {
      const doc = {};
      Object.keys(json).filter((prop) => prop !== "mathjs").forEach((prop) => {
        doc[prop] = json[prop];
      });
      return new Help(doc);
    };
    Help.prototype.valueOf = Help.prototype.toString;
    return Help;
  },
  { isClass: true }
);

// src/type/chain/Chain.ts
var name244 = "Chain";
var dependencies245 = ["?on", "math", "typed"];
var createChainClass = /* @__PURE__ */ factory(
  name244,
  dependencies245,
  ({ on, math, typed: typed2 }) => {
    function Chain(value) {
      if (!(this instanceof Chain)) {
        throw new SyntaxError(
          "Constructor must be called with the new operator"
        );
      }
      if (isChain(value)) {
        this.value = value.value;
      } else {
        this.value = value;
      }
    }
    Chain.prototype.type = "Chain";
    Chain.prototype.isChain = true;
    Chain.prototype.done = function() {
      return this.value;
    };
    Chain.prototype.valueOf = function() {
      return this.value;
    };
    Chain.prototype.toString = function() {
      return format3(this.value, {});
    };
    Chain.prototype.toJSON = function() {
      return {
        mathjs: "Chain",
        value: this.value
      };
    };
    Chain.fromJSON = function(json) {
      return new Chain(json.value);
    };
    function createProxy(name323, fn) {
      if (typeof fn === "function") {
        Chain.prototype[name323] = chainify(fn);
      }
    }
    function createLazyProxy(name323, resolver) {
      lazy(Chain.prototype, name323, function outerResolver() {
        const fn = resolver();
        if (typeof fn === "function") {
          return chainify(fn);
        }
        return void 0;
      });
    }
    function chainify(fn) {
      return function(...rest) {
        if (rest.length === 0) {
          return new Chain(fn(this.value));
        }
        const args = [this.value];
        for (let i = 0; i < rest.length; i++) {
          args[i + 1] = rest[i];
        }
        if (typed2.isTypedFunction(fn)) {
          const sigObject = typed2.resolve(fn, args);
          if (sigObject && sigObject.params.length === 1) {
            throw new Error(
              "chain function " + fn.name + " cannot match rest parameter between chain value and additional arguments."
            );
          }
          if (sigObject) {
            return new Chain(sigObject.implementation.apply(fn, args));
          }
        }
        return new Chain(fn.apply(fn, args));
      };
    }
    Chain.createProxy = function(arg0, arg1) {
      if (typeof arg0 === "string") {
        createProxy(arg0, arg1);
      } else {
        for (const name323 in arg0) {
          if (hasOwnProperty(arg0, name323) && excludedNames[name323] === void 0) {
            createLazyProxy(name323, () => arg0[name323]);
          }
        }
      }
    };
    const excludedNames = {
      expression: true,
      docs: true,
      type: true,
      classes: true,
      json: true,
      error: true,
      isChain: true
      // conflicts with the property isChain of a Chain instance
    };
    Chain.createProxy(math);
    if (on) {
      on(
        "import",
        function(name323, resolver, path) {
          if (!path) {
            createLazyProxy(name323, resolver);
          }
        }
      );
    }
    return Chain;
  },
  { isClass: true }
);

// src/expression/embeddedDocs/constants/e.ts
var eDocs = {
  name: "e",
  category: "Constants",
  syntax: ["e"],
  description: "Euler's number, the base of the natural logarithm. Approximately equal to 2.71828",
  examples: ["e", "e ^ 2", "exp(2)", "log(e)"],
  seealso: ["exp"]
};

// src/expression/embeddedDocs/constants/false.ts
var falseDocs = {
  name: "false",
  category: "Constants",
  syntax: ["false"],
  description: "Boolean value false",
  examples: ["false"],
  seealso: ["true"]
};

// src/expression/embeddedDocs/constants/i.ts
var iDocs = {
  name: "i",
  category: "Constants",
  syntax: ["i"],
  description: "Imaginary unit, defined as i*i=-1. A complex number is described as a + b*i, where a is the real part, and b is the imaginary part.",
  examples: ["i", "i * i", "sqrt(-1)"],
  seealso: []
};

// src/expression/embeddedDocs/constants/Infinity.ts
var InfinityDocs = {
  name: "Infinity",
  category: "Constants",
  syntax: ["Infinity"],
  description: "Infinity, a number which is larger than the maximum number that can be handled by a floating point number.",
  examples: ["Infinity", "1 / 0"],
  seealso: []
};

// src/expression/embeddedDocs/constants/LN10.ts
var LN10Docs = {
  name: "LN10",
  category: "Constants",
  syntax: ["LN10"],
  description: "Returns the natural logarithm of 10, approximately equal to 2.302",
  examples: ["LN10", "log(10)"],
  seealso: []
};

// src/expression/embeddedDocs/constants/LN2.ts
var LN2Docs = {
  name: "LN2",
  category: "Constants",
  syntax: ["LN2"],
  description: "Returns the natural logarithm of 2, approximately equal to 0.693",
  examples: ["LN2", "log(2)"],
  seealso: []
};

// src/expression/embeddedDocs/constants/LOG10E.ts
var LOG10EDocs = {
  name: "LOG10E",
  category: "Constants",
  syntax: ["LOG10E"],
  description: "Returns the base-10 logarithm of E, approximately equal to 0.434",
  examples: ["LOG10E", "log(e, 10)"],
  seealso: []
};

// src/expression/embeddedDocs/constants/LOG2E.ts
var LOG2EDocs = {
  name: "LOG2E",
  category: "Constants",
  syntax: ["LOG2E"],
  description: "Returns the base-2 logarithm of E, approximately equal to 1.442",
  examples: ["LOG2E", "log(e, 2)"],
  seealso: []
};

// src/expression/embeddedDocs/constants/NaN.ts
var NaNDocs = {
  name: "NaN",
  category: "Constants",
  syntax: ["NaN"],
  description: "Not a number",
  examples: ["NaN", "0 / 0"],
  seealso: []
};

// src/expression/embeddedDocs/constants/null.ts
var nullDocs = {
  name: "null",
  category: "Constants",
  syntax: ["null"],
  description: "Value null",
  examples: ["null"],
  seealso: ["true", "false"]
};

// src/expression/embeddedDocs/constants/phi.ts
var phiDocs = {
  name: "phi",
  category: "Constants",
  syntax: ["phi"],
  description: "Phi is the golden ratio. Two quantities are in the golden ratio if their ratio is the same as the ratio of their sum to the larger of the two quantities. Phi is defined as `(1 + sqrt(5)) / 2` and is approximately 1.618034...",
  examples: ["phi"],
  seealso: []
};

// src/expression/embeddedDocs/constants/pi.ts
var piDocs = {
  name: "pi",
  category: "Constants",
  syntax: ["pi"],
  description: "The number pi is a mathematical constant that is the ratio of a circle's circumference to its diameter, and is approximately equal to 3.14159",
  examples: ["pi", "sin(pi/2)"],
  seealso: ["tau"]
};

// src/expression/embeddedDocs/constants/SQRT1_2.ts
var SQRT12Docs = {
  name: "SQRT1_2",
  category: "Constants",
  syntax: ["SQRT1_2"],
  description: "Returns the square root of 1/2, approximately equal to 0.707",
  examples: ["SQRT1_2", "sqrt(1/2)"],
  seealso: []
};

// src/expression/embeddedDocs/constants/SQRT2.ts
var SQRT2Docs = {
  name: "SQRT2",
  category: "Constants",
  syntax: ["SQRT2"],
  description: "Returns the square root of 2, approximately equal to 1.414",
  examples: ["SQRT2", "sqrt(2)"],
  seealso: []
};

// src/expression/embeddedDocs/constants/tau.ts
var tauDocs = {
  name: "tau",
  category: "Constants",
  syntax: ["tau"],
  description: "Tau is the ratio constant of a circle's circumference to radius, equal to 2 * pi, approximately 6.2832.",
  examples: ["tau", "2 * pi"],
  seealso: ["pi"]
};

// src/expression/embeddedDocs/constants/true.ts
var trueDocs = {
  name: "true",
  category: "Constants",
  syntax: ["true"],
  description: "Boolean value true",
  examples: ["true"],
  seealso: ["false"]
};

// src/expression/embeddedDocs/constants/version.ts
var versionDocs = {
  name: "version",
  category: "Constants",
  syntax: ["version"],
  description: "A string with the version number of math.js",
  examples: ["version"],
  seealso: []
};

// src/expression/embeddedDocs/construction/bignumber.ts
var bignumberDocs = {
  name: "bignumber",
  category: "Construction",
  syntax: ["bignumber(x)"],
  description: "Create a big number from a number or string.",
  examples: [
    "0.1 + 0.2",
    "bignumber(0.1) + bignumber(0.2)",
    'bignumber("7.2")',
    'bignumber("7.2e500")',
    "bignumber([0.1, 0.2, 0.3])"
  ],
  seealso: [
    "boolean",
    "bigint",
    "complex",
    "fraction",
    "index",
    "matrix",
    "string",
    "unit"
  ]
};

// src/expression/embeddedDocs/construction/bigint.ts
var bigintDocs = {
  name: "bigint",
  category: "Construction",
  syntax: ["bigint(x)"],
  description: "Create a bigint, an integer with an arbitrary number of digits, from a number or string.",
  examples: [
    "123123123123123123 # a large number will lose digits",
    'bigint("123123123123123123")',
    'bignumber(["1", "3", "5"])'
  ],
  seealso: [
    "boolean",
    "bignumber",
    "number",
    "complex",
    "fraction",
    "index",
    "matrix",
    "string",
    "unit"
  ]
};

// src/expression/embeddedDocs/construction/boolean.ts
var booleanDocs = {
  name: "boolean",
  category: "Construction",
  syntax: ["x", "boolean(x)"],
  description: "Convert a string or number into a boolean.",
  examples: [
    "boolean(0)",
    "boolean(1)",
    "boolean(3)",
    'boolean("true")',
    'boolean("false")',
    "boolean([1, 0, 1, 1])"
  ],
  seealso: [
    "bignumber",
    "complex",
    "index",
    "matrix",
    "number",
    "string",
    "unit"
  ]
};

// src/expression/embeddedDocs/construction/complex.ts
var complexDocs = {
  name: "complex",
  category: "Construction",
  syntax: ["complex()", "complex(re, im)", "complex(string)"],
  description: "Create a complex number.",
  examples: ["complex()", "complex(2, 3)", 'complex("7 - 2i")'],
  seealso: [
    "bignumber",
    "boolean",
    "index",
    "matrix",
    "number",
    "string",
    "unit"
  ]
};

// src/expression/embeddedDocs/construction/createUnit.ts
var createUnitDocs = {
  name: "createUnit",
  category: "Construction",
  syntax: ["createUnit(definitions)", "createUnit(name, definition)"],
  description: "Create a user-defined unit and register it with the Unit type.",
  examples: [
    'createUnit("foo")',
    'createUnit("knot", {definition: "0.514444444 m/s", aliases: ["knots", "kt", "kts"]})',
    'createUnit("mph", "1 mile/hour")'
  ],
  seealso: ["unit", "splitUnit"]
};

// src/expression/embeddedDocs/construction/fraction.ts
var fractionDocs = {
  name: "fraction",
  category: "Construction",
  syntax: [
    "fraction(num)",
    "fraction(matrix)",
    "fraction(num,den)",
    "fraction({n: num, d: den})"
  ],
  description: "Create a fraction from a number or from integer numerator and denominator.",
  examples: [
    "fraction(0.125)",
    "fraction(1, 3) + fraction(2, 5)",
    "fraction({n: 333, d: 53})",
    "fraction([sqrt(9), sqrt(10), sqrt(11)])"
  ],
  seealso: [
    "bignumber",
    "boolean",
    "complex",
    "index",
    "matrix",
    "string",
    "unit"
  ]
};

// src/expression/embeddedDocs/construction/index.ts
var indexDocs = {
  name: "index",
  category: "Construction",
  syntax: [
    "[start]",
    "[start:end]",
    "[start:step:end]",
    "[start1, start 2, ...]",
    "[start1:end1, start2:end2, ...]",
    "[start1:step1:end1, start2:step2:end2, ...]"
  ],
  description: "Create an index to get or replace a subset of a matrix",
  examples: [
    "A = [1, 2, 3; 4, 5, 6]",
    "A[1, :]",
    "A[1, 2] = 50",
    "A[1:2, 1:2] = 1",
    "B = [1, 2, 3]",
    "B[B>1 and B<3]"
  ],
  seealso: [
    "bignumber",
    "boolean",
    "complex",
    "matrix",
    "number",
    "range",
    "string",
    "unit"
  ]
};

// src/expression/embeddedDocs/construction/matrix.ts
var matrixDocs = {
  name: "matrix",
  category: "Construction",
  syntax: [
    "[]",
    "[a1, b1, ...; a2, b2, ...]",
    "matrix()",
    'matrix("dense")',
    "matrix([...])"
  ],
  description: "Create a matrix.",
  examples: [
    "[]",
    "[1, 2, 3]",
    "[1, 2, 3; 4, 5, 6]",
    "matrix()",
    "matrix([3, 4])",
    'matrix([3, 4; 5, 6], "sparse")',
    'matrix([3, 4; 5, 6], "sparse", "number")'
  ],
  seealso: [
    "bignumber",
    "boolean",
    "complex",
    "index",
    "number",
    "string",
    "unit",
    "sparse"
  ]
};

// src/expression/embeddedDocs/construction/number.ts
var numberDocs = {
  name: "number",
  category: "Construction",
  syntax: ["x", "number(x)", "number(unit, valuelessUnit)"],
  description: "Create a number or convert a string or boolean into a number.",
  examples: [
    "2",
    "2e3",
    "4.05",
    "number(2)",
    'number("7.2")',
    "number(true)",
    "number([true, false, true, true])",
    'number(unit("52cm"), "m")'
  ],
  seealso: [
    "bignumber",
    "bigint",
    "boolean",
    "complex",
    "fraction",
    "index",
    "matrix",
    "string",
    "unit"
  ]
};

// src/expression/embeddedDocs/construction/sparse.ts
var sparseDocs = {
  name: "sparse",
  category: "Construction",
  syntax: [
    "sparse()",
    "sparse([a1, b1, ...; a1, b2, ...])",
    'sparse([a1, b1, ...; a1, b2, ...], "number")'
  ],
  description: "Create a sparse matrix.",
  examples: [
    "sparse()",
    "sparse([3, 4; 5, 6])",
    'sparse([3, 0; 5, 0], "number")'
  ],
  seealso: [
    "bignumber",
    "boolean",
    "complex",
    "index",
    "number",
    "string",
    "unit",
    "matrix"
  ]
};

// src/expression/embeddedDocs/construction/splitUnit.ts
var splitUnitDocs = {
  name: "splitUnit",
  category: "Construction",
  syntax: ["splitUnit(unit: Unit, parts: Unit[])"],
  description: "Split a unit in an array of units whose sum is equal to the original unit.",
  examples: ['splitUnit(1 m, ["feet", "inch"])'],
  seealso: ["unit", "createUnit"]
};

// src/expression/embeddedDocs/construction/string.ts
var stringDocs = {
  name: "string",
  category: "Construction",
  syntax: ['"text"', "string(x)"],
  description: "Create a string or convert a value to a string",
  examples: ['"Hello World!"', "string(4.2)", "string(3 + 2i)"],
  seealso: [
    "bignumber",
    "boolean",
    "complex",
    "index",
    "matrix",
    "number",
    "unit"
  ]
};

// src/expression/embeddedDocs/construction/unit.ts
var unitDocs = {
  name: "unit",
  category: "Construction",
  syntax: ["value unit", "unit(value, unit)", "unit(string)"],
  description: "Create a unit.",
  examples: ["5.5 mm", "3 inch", 'unit(7.1, "kilogram")', 'unit("23 deg")'],
  seealso: [
    "bignumber",
    "boolean",
    "complex",
    "index",
    "matrix",
    "number",
    "string"
  ]
};

// src/expression/embeddedDocs/core/config.ts
var configDocs = {
  name: "config",
  category: "Core",
  syntax: ["config()", "config(options)"],
  description: "Get configuration or change configuration.",
  examples: [
    "config()",
    "1/3 + 1/4",
    'config({number: "Fraction"})',
    "1/3 + 1/4"
  ],
  seealso: []
};

// src/expression/embeddedDocs/core/import.ts
var importDocs = {
  name: "import",
  category: "Core",
  syntax: ["import(functions)", "import(functions, options)"],
  description: "Import functions or constants from an object.",
  examples: [
    "import({myFn: f(x)=x^2, myConstant: 32 })",
    "myFn(2)",
    "myConstant"
  ],
  seealso: []
};

// src/expression/embeddedDocs/core/typed.ts
var typedDocs = {
  name: "typed",
  category: "Core",
  syntax: ["typed(signatures)", "typed(name, signatures)"],
  description: "Create a typed function.",
  examples: [
    'double = typed({ "number": f(x)=x+x, "string": f(x)=concat(x,x) })',
    "double(2)",
    'double("hello")'
  ],
  seealso: []
};

// src/expression/embeddedDocs/function/algebra/derivative.ts
var derivativeDocs = {
  name: "derivative",
  category: "Algebra",
  syntax: [
    "derivative(expr, variable)",
    "derivative(expr, variable, {simplify: boolean})"
  ],
  description: "Takes the derivative of an expression expressed in parser Nodes. The derivative will be taken over the supplied variable in the second parameter. If there are multiple variables in the expression, it will return a partial derivative.",
  examples: [
    'derivative("2x^3", "x")',
    'derivative("2x^3", "x", {simplify: false})',
    'derivative("2x^2 + 3x + 4", "x")',
    'derivative("sin(2x)", "x")',
    'f = parse("x^2 + x")',
    'x = parse("x")',
    "df = derivative(f, x)",
    "df.evaluate({x: 3})"
  ],
  seealso: ["simplify", "parse", "evaluate"]
};

// src/expression/embeddedDocs/function/algebra/leafCount.ts
var leafCountDocs = {
  name: "leafCount",
  category: "Algebra",
  syntax: ["leafCount(expr)"],
  description: "Computes the number of leaves in the parse tree of the given expression",
  examples: [
    'leafCount("e^(i*pi)-1")',
    'leafCount(parse("{a: 22/7, b: 10^(1/2)}"))'
  ],
  seealso: ["simplify"]
};

// src/expression/embeddedDocs/function/algebra/lsolve.ts
var lsolveDocs = {
  name: "lsolve",
  category: "Algebra",
  syntax: ["x=lsolve(L, b)"],
  description: "Finds one solution of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
  examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
  seealso: ["lsolveAll", "lup", "lusolve", "usolve", "matrix", "sparse"]
};

// src/expression/embeddedDocs/function/algebra/lsolveAll.ts
var lsolveAllDocs = {
  name: "lsolveAll",
  category: "Algebra",
  syntax: ["x=lsolveAll(L, b)"],
  description: "Finds all solutions of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
  examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
  seealso: ["lsolve", "lup", "lusolve", "usolve", "matrix", "sparse"]
};

// src/expression/embeddedDocs/function/algebra/lup.ts
var lupDocs = {
  name: "lup",
  category: "Algebra",
  syntax: ["lup(m)"],
  description: "Calculate the Matrix LU decomposition with partial pivoting. Matrix A is decomposed in three matrices (L, U, P) where P * A = L * U",
  examples: [
    "lup([[2, 1], [1, 4]])",
    "lup(matrix([[2, 1], [1, 4]]))",
    "lup(sparse([[2, 1], [1, 4]]))"
  ],
  seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "slu", "qr"]
};

// src/expression/embeddedDocs/function/algebra/lusolve.ts
var lusolveDocs = {
  name: "lusolve",
  category: "Algebra",
  syntax: ["x=lusolve(A, b)", "x=lusolve(lu, b)"],
  description: "Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.",
  examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lusolve(a, b)"],
  seealso: ["lup", "slu", "lsolve", "usolve", "matrix", "sparse"]
};

// src/expression/embeddedDocs/function/algebra/polynomialRoot.ts
var polynomialRootDocs = {
  name: "polynomialRoot",
  category: "Algebra",
  syntax: [
    "x=polynomialRoot(-6, 3)",
    "x=polynomialRoot(4, -4, 1)",
    "x=polynomialRoot(-8, 12, -6, 1)"
  ],
  description: "Finds the roots of a univariate polynomial given by its coefficients starting from constant, linear, and so on, increasing in degree.",
  examples: ["a = polynomialRoot(-6, 11, -6, 1)"],
  seealso: ["cbrt", "sqrt"]
};

// src/expression/embeddedDocs/function/algebra/qr.ts
var qrDocs = {
  name: "qr",
  category: "Algebra",
  syntax: ["qr(A)"],
  description: "Calculates the Matrix QR decomposition. Matrix `A` is decomposed in two matrices (`Q`, `R`) where `Q` is an orthogonal matrix and `R` is an upper triangular matrix.",
  examples: ["qr([[1, -1,  4], [1,  4, -2], [1,  4,  2], [1,  -1, 0]])"],
  seealso: ["lup", "slu", "matrix"]
};

// src/expression/embeddedDocs/function/algebra/rationalize.ts
var rationalizeDocs = {
  name: "rationalize",
  category: "Algebra",
  syntax: [
    "rationalize(expr)",
    "rationalize(expr, scope)",
    "rationalize(expr, scope, detailed)"
  ],
  description: "Transform a rationalizable expression in a rational fraction. If rational fraction is one variable polynomial then converts the numerator and denominator in canonical form, with decreasing exponents, returning the coefficients of numerator.",
  examples: [
    'rationalize("2x/y - y/(x+1)")',
    'rationalize("2x/y - y/(x+1)", true)'
  ],
  seealso: ["simplify"]
};

// src/expression/embeddedDocs/function/algebra/resolve.ts
var resolveDocs = {
  name: "resolve",
  category: "Algebra",
  syntax: ["resolve(node, scope)"],
  description: "Recursively substitute variables in an expression tree.",
  examples: [
    'resolve(parse("1 + x"), { x: 7 })',
    'resolve(parse("size(text)"), { text: "Hello World" })',
    'resolve(parse("x + y"), { x: parse("3z") })',
    'resolve(parse("3x"), { x: parse("y+z"), z: parse("w^y") })'
  ],
  seealso: ["simplify", "evaluate"],
  mayThrow: ["ReferenceError"]
};

// src/expression/embeddedDocs/function/algebra/simplify.ts
var simplifyDocs = {
  name: "simplify",
  category: "Algebra",
  syntax: ["simplify(expr)", "simplify(expr, rules)"],
  description: "Simplify an expression tree.",
  examples: [
    'simplify("3 + 2 / 4")',
    'simplify("2x + x")',
    'f = parse("x * (x + 2 + x)")',
    "simplified = simplify(f)",
    "simplified.evaluate({x: 2})"
  ],
  seealso: [
    "simplifyCore",
    "derivative",
    "evaluate",
    "parse",
    "rationalize",
    "resolve"
  ]
};

// src/expression/embeddedDocs/function/algebra/simplifyConstant.ts
var simplifyConstantDocs = {
  name: "simplifyConstant",
  category: "Algebra",
  syntax: ["simplifyConstant(expr)", "simplifyConstant(expr, options)"],
  description: "Replace constant subexpressions of node with their values.",
  examples: [
    'simplifyConstant("(3-3)*x")',
    'simplifyConstant(parse("z-cos(tau/8)"))'
  ],
  seealso: ["simplify", "simplifyCore", "evaluate"]
};

// src/expression/embeddedDocs/function/algebra/simplifyCore.ts
var simplifyCoreDocs = {
  name: "simplifyCore",
  category: "Algebra",
  syntax: ["simplifyCore(node)"],
  description: "Perform simple one-pass simplifications on an expression tree.",
  examples: ['simplifyCore(parse("0*x"))', 'simplifyCore(parse("(x+0)*2"))'],
  seealso: ["simplify", "simplifyConstant", "evaluate"]
};

// src/expression/embeddedDocs/function/algebra/slu.ts
var sluDocs = {
  name: "slu",
  category: "Algebra",
  syntax: ["slu(A, order, threshold)"],
  description: "Calculate the Matrix LU decomposition with full pivoting. Matrix A is decomposed in two matrices (L, U) and two permutation vectors (pinv, q) where P * A * Q = L * U",
  examples: [
    "slu(sparse([4.5, 0, 3.2, 0; 3.1, 2.9, 0, 0.9; 0, 1.7, 3, 0; 3.5, 0.4, 0, 1]), 1, 0.001)"
  ],
  seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "lup", "qr"]
};

// src/expression/embeddedDocs/function/algebra/symbolicEqual.ts
var symbolicEqualDocs = {
  name: "symbolicEqual",
  category: "Algebra",
  syntax: [
    "symbolicEqual(expr1, expr2)",
    "symbolicEqual(expr1, expr2, options)"
  ],
  description: "Returns true if the difference of the expressions simplifies to 0",
  examples: [
    'symbolicEqual("x*y","y*x")',
    'symbolicEqual("abs(x^2)", "x^2")',
    'symbolicEqual("abs(x)", "x", {context: {abs: {trivial: true}}})'
  ],
  seealso: ["simplify", "evaluate"]
};

// src/expression/embeddedDocs/function/algebra/usolve.ts
var usolveDocs = {
  name: "usolve",
  category: "Algebra",
  syntax: ["x=usolve(U, b)"],
  description: "Finds one solution of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
  examples: [
    "x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"
  ],
  seealso: ["usolveAll", "lup", "lusolve", "lsolve", "matrix", "sparse"]
};

// src/expression/embeddedDocs/function/algebra/usolveAll.ts
var usolveAllDocs = {
  name: "usolveAll",
  category: "Algebra",
  syntax: ["x=usolve(U, b)"],
  description: "Finds all solutions of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
  examples: [
    "x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"
  ],
  seealso: ["usolve", "lup", "lusolve", "lsolve", "matrix", "sparse"]
};

// src/expression/embeddedDocs/function/arithmetic/abs.ts
var absDocs = {
  name: "abs",
  category: "Arithmetic",
  syntax: ["abs(x)"],
  description: "Compute the absolute value.",
  examples: ["abs(3.5)", "abs(-4.2)"],
  seealso: ["sign"]
};

// src/expression/embeddedDocs/function/arithmetic/add.ts
var addDocs = {
  name: "add",
  category: "Operators",
  syntax: ["x + y", "add(x, y)"],
  description: "Add two values.",
  examples: [
    "a = 2.1 + 3.6",
    "a - 3.6",
    "3 + 2i",
    "3 cm + 2 inch",
    '"2.3" + "4"'
  ],
  seealso: ["subtract"]
};

// src/expression/embeddedDocs/function/arithmetic/cbrt.ts
var cbrtDocs = {
  name: "cbrt",
  category: "Arithmetic",
  syntax: ["cbrt(x)", "cbrt(x, allRoots)"],
  description: "Compute the cubic root value. If x = y * y * y, then y is the cubic root of x. When `x` is a number or complex number, an optional second argument `allRoots` can be provided to return all three cubic roots. If not provided, the principal root is returned",
  examples: [
    "cbrt(64)",
    "cube(4)",
    "cbrt(-8)",
    "cbrt(2 + 3i)",
    "cbrt(8i)",
    "cbrt(8i, true)",
    "cbrt(27 m^3)"
  ],
  seealso: ["square", "sqrt", "cube", "multiply"]
};

// src/expression/embeddedDocs/function/arithmetic/ceil.ts
var ceilDocs = {
  name: "ceil",
  category: "Arithmetic",
  syntax: [
    "ceil(x)",
    "ceil(x, n)",
    "ceil(unit, valuelessUnit)",
    "ceil(unit, n, valuelessUnit)"
  ],
  description: "Round a value towards plus infinity. If x is complex, both real and imaginary part are rounded towards plus infinity.",
  examples: [
    "ceil(3.2)",
    "ceil(3.8)",
    "ceil(-4.2)",
    "ceil(3.241cm, cm)",
    "ceil(3.241cm, 2, cm)"
  ],
  seealso: ["floor", "fix", "round"]
};

// src/expression/embeddedDocs/function/arithmetic/cube.ts
var cubeDocs = {
  name: "cube",
  category: "Arithmetic",
  syntax: ["cube(x)"],
  description: "Compute the cube of a value. The cube of x is x * x * x.",
  examples: ["cube(2)", "2^3", "2 * 2 * 2"],
  seealso: ["multiply", "square", "pow"]
};

// src/expression/embeddedDocs/function/arithmetic/divide.ts
var divideDocs = {
  name: "divide",
  category: "Operators",
  syntax: ["x / y", "divide(x, y)"],
  description: "Divide two values.",
  examples: [
    "a = 2 / 3",
    "a * 3",
    "4.5 / 2",
    "3 + 4 / 2",
    "(3 + 4) / 2",
    "18 km / 4.5"
  ],
  seealso: ["multiply"]
};

// src/expression/embeddedDocs/function/arithmetic/dotDivide.ts
var dotDivideDocs = {
  name: "dotDivide",
  category: "Operators",
  syntax: ["x ./ y", "dotDivide(x, y)"],
  description: "Divide two values element wise.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a ./ b"],
  seealso: ["multiply", "dotMultiply", "divide"]
};

// src/expression/embeddedDocs/function/arithmetic/dotMultiply.ts
var dotMultiplyDocs = {
  name: "dotMultiply",
  category: "Operators",
  syntax: ["x .* y", "dotMultiply(x, y)"],
  description: "Multiply two values element wise.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a .* b"],
  seealso: ["multiply", "divide", "dotDivide"]
};

// src/expression/embeddedDocs/function/arithmetic/dotPow.ts
var dotPowDocs = {
  name: "dotPow",
  category: "Operators",
  syntax: ["x .^ y", "dotPow(x, y)"],
  description: "Calculates the power of x to y element wise.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "a .^ 2"],
  seealso: ["pow"]
};

// src/expression/embeddedDocs/function/arithmetic/exp.ts
var expDocs = {
  name: "exp",
  category: "Arithmetic",
  syntax: ["exp(x)"],
  description: "Calculate the exponent of a value.",
  examples: [
    "exp(1.3)",
    "e ^ 1.3",
    "log(exp(1.3))",
    "x = 2.4",
    "(exp(i*x) == cos(x) + i*sin(x))   # Euler's formula"
  ],
  seealso: ["expm", "expm1", "pow", "log"]
};

// src/expression/embeddedDocs/function/arithmetic/expm.ts
var expmDocs = {
  name: "expm",
  category: "Arithmetic",
  syntax: ["exp(x)"],
  description: "Compute the matrix exponential, expm(A) = e^A. The matrix must be square. Not to be confused with exp(a), which performs element-wise exponentiation.",
  examples: ["expm([[0,2],[0,0]])"],
  seealso: ["exp"]
};

// src/expression/embeddedDocs/function/arithmetic/expm1.ts
var expm1Docs = {
  name: "expm1",
  category: "Arithmetic",
  syntax: ["expm1(x)"],
  description: "Calculate the value of subtracting 1 from the exponential value.",
  examples: ["expm1(2)", "pow(e, 2) - 1", "log(expm1(2) + 1)"],
  seealso: ["exp", "pow", "log"]
};

// src/expression/embeddedDocs/function/arithmetic/fix.ts
var fixDocs = {
  name: "fix",
  category: "Arithmetic",
  syntax: [
    "fix(x)",
    "fix(x, n)",
    "fix(unit, valuelessUnit)",
    "fix(unit, n, valuelessUnit)"
  ],
  description: "Round a value towards zero. If x is complex, both real and imaginary part are rounded towards zero.",
  examples: [
    "fix(3.2)",
    "fix(3.8)",
    "fix(-4.2)",
    "fix(-4.8)",
    "fix(3.241cm, cm)",
    "fix(3.241cm, 2, cm)"
  ],
  seealso: ["ceil", "floor", "round"]
};

// src/expression/embeddedDocs/function/arithmetic/floor.ts
var floorDocs = {
  name: "floor",
  category: "Arithmetic",
  syntax: [
    "floor(x)",
    "floor(x, n)",
    "floor(unit, valuelessUnit)",
    "floor(unit, n, valuelessUnit)"
  ],
  description: "Round a value towards minus infinity.If x is complex, both real and imaginary part are rounded towards minus infinity.",
  examples: [
    "floor(3.2)",
    "floor(3.8)",
    "floor(-4.2)",
    "floor(3.241cm, cm)",
    "floor(3.241cm, 2, cm)"
  ],
  seealso: ["ceil", "fix", "round"]
};

// src/expression/embeddedDocs/function/arithmetic/gcd.ts
var gcdDocs = {
  name: "gcd",
  category: "Arithmetic",
  syntax: ["gcd(a, b)", "gcd(a, b, c, ...)"],
  description: "Compute the greatest common divisor.",
  examples: ["gcd(8, 12)", "gcd(-4, 6)", "gcd(25, 15, -10)"],
  seealso: ["lcm", "xgcd"]
};

// src/expression/embeddedDocs/function/arithmetic/hypot.ts
var hypotDocs = {
  name: "hypot",
  category: "Arithmetic",
  syntax: ["hypot(a, b, c, ...)", "hypot([a, b, c, ...])"],
  description: "Calculate the hypotenuse of a list with values.",
  examples: ["hypot(3, 4)", "sqrt(3^2 + 4^2)", "hypot(-2)", "hypot([3, 4, 5])"],
  seealso: ["abs", "norm"]
};

// src/expression/embeddedDocs/function/arithmetic/invmod.ts
var invmodDocs = {
  name: "invmod",
  category: "Arithmetic",
  syntax: ["invmod(a, b)"],
  description: "Calculate the (modular) multiplicative inverse of a modulo b. Solution to the equation ax \u2263 1 (mod b)",
  examples: ["invmod(8, 12)", "invmod(7, 13)", "invmod(15151, 15122)"],
  seealso: ["gcd", "xgcd"]
};

// src/expression/embeddedDocs/function/arithmetic/lcm.ts
var lcmDocs = {
  name: "lcm",
  category: "Arithmetic",
  syntax: ["lcm(x, y)"],
  description: "Compute the least common multiple.",
  examples: ["lcm(4, 6)", "lcm(6, 21)", "lcm(6, 21, 5)"],
  seealso: ["gcd"]
};

// src/expression/embeddedDocs/function/arithmetic/log.ts
var logDocs = {
  name: "log",
  category: "Arithmetic",
  syntax: ["log(x)", "log(x, base)"],
  description: "Compute the logarithm of a value. If no base is provided, the natural logarithm of x is calculated. If base if provided, the logarithm is calculated for the specified base. log(x, base) is defined as log(x) / log(base).",
  examples: [
    "log(3.5)",
    "a = log(2.4)",
    "exp(a)",
    "10 ^ 4",
    "log(10000, 10)",
    "log(10000) / log(10)",
    "b = log(1024, 2)",
    "2 ^ b"
  ],
  seealso: ["exp", "log1p", "log2", "log10"]
};

// src/expression/embeddedDocs/function/arithmetic/log10.ts
var log10Docs = {
  name: "log10",
  category: "Arithmetic",
  syntax: ["log10(x)"],
  description: "Compute the 10-base logarithm of a value.",
  examples: [
    "log10(0.00001)",
    "log10(10000)",
    "10 ^ 4",
    "log(10000) / log(10)",
    "log(10000, 10)"
  ],
  seealso: ["exp", "log"]
};

// src/expression/embeddedDocs/function/arithmetic/log1p.ts
var log1pDocs = {
  name: "log1p",
  category: "Arithmetic",
  syntax: ["log1p(x)", "log1p(x, base)"],
  description: "Calculate the logarithm of a `value+1`",
  examples: [
    "log1p(2.5)",
    "exp(log1p(1.4))",
    "pow(10, 4)",
    "log1p(9999, 10)",
    "log1p(9999) / log(10)"
  ],
  seealso: ["exp", "log", "log2", "log10"]
};

// src/expression/embeddedDocs/function/arithmetic/log2.ts
var log2Docs = {
  name: "log2",
  category: "Arithmetic",
  syntax: ["log2(x)"],
  description: "Calculate the 2-base of a value. This is the same as calculating `log(x, 2)`.",
  examples: ["log2(0.03125)", "log2(16)", "log2(16) / log2(2)", "pow(2, 4)"],
  seealso: ["exp", "log1p", "log", "log10"]
};

// src/expression/embeddedDocs/function/arithmetic/mod.ts
var modDocs = {
  name: "mod",
  category: "Operators",
  syntax: ["x % y", "x mod y", "mod(x, y)"],
  description: "Calculates the modulus, the remainder of an integer division.",
  examples: [
    "7 % 3",
    "11 % 2",
    "10 mod 4",
    "isOdd(x) = x % 2",
    "isOdd(2)",
    "isOdd(3)"
  ],
  seealso: ["divide"]
};

// src/expression/embeddedDocs/function/arithmetic/multiply.ts
var multiplyDocs = {
  name: "multiply",
  category: "Operators",
  syntax: ["x * y", "multiply(x, y)"],
  description: "multiply two values.",
  examples: [
    "a = 2.1 * 3.4",
    "a / 3.4",
    "2 * 3 + 4",
    "2 * (3 + 4)",
    "3 * 2.1 km"
  ],
  seealso: ["divide"]
};

// src/expression/embeddedDocs/function/arithmetic/norm.ts
var normDocs = {
  name: "norm",
  category: "Arithmetic",
  syntax: ["norm(x)", "norm(x, p)"],
  description: "Calculate the norm of a number, vector or matrix.",
  examples: [
    "abs(-3.5)",
    "norm(-3.5)",
    "norm(3 - 4i)",
    "norm([1, 2, -3], Infinity)",
    "norm([1, 2, -3], -Infinity)",
    "norm([3, 4], 2)",
    "norm([[1, 2], [3, 4]], 1)",
    'norm([[1, 2], [3, 4]], "inf")',
    'norm([[1, 2], [3, 4]], "fro")'
  ],
  seealso: ["abs", "hypot"]
};

// src/expression/embeddedDocs/function/arithmetic/nthRoot.ts
var nthRootDocs = {
  name: "nthRoot",
  category: "Arithmetic",
  syntax: ["nthRoot(a)", "nthRoot(a, root)"],
  description: 'Calculate the nth root of a value. The principal nth root of a positive real number A, is the positive real solution of the equation "x^root = A".',
  examples: ["4 ^ 3", "nthRoot(64, 3)", "nthRoot(9, 2)", "sqrt(9)"],
  seealso: ["nthRoots", "pow", "sqrt"]
};

// src/expression/embeddedDocs/function/arithmetic/nthRoots.ts
var nthRootsDocs = {
  name: "nthRoots",
  category: "Arithmetic",
  syntax: ["nthRoots(A)", "nthRoots(A, root)"],
  description: 'Calculate the nth roots of a value. An nth root of a positive real number A, is a positive real solution of the equation "x^root = A". This function returns an array of complex values.',
  examples: ["nthRoots(1)", "nthRoots(1, 3)"],
  seealso: ["sqrt", "pow", "nthRoot"]
};

// src/expression/embeddedDocs/function/arithmetic/pow.ts
var powDocs = {
  name: "pow",
  category: "Operators",
  syntax: ["x ^ y", "pow(x, y)"],
  description: "Calculates the power of x to y, x^y.",
  examples: [
    "2^3",
    "2*2*2",
    "1 + e ^ (pi * i)",
    "pow([[1, 2], [4, 3]], 2)",
    "pow([[1, 2], [4, 3]], -1)"
  ],
  seealso: ["multiply", "nthRoot", "nthRoots", "sqrt"]
};

// src/expression/embeddedDocs/function/arithmetic/round.ts
var roundDocs = {
  name: "round",
  category: "Arithmetic",
  syntax: [
    "round(x)",
    "round(x, n)",
    "round(unit, valuelessUnit)",
    "round(unit, n, valuelessUnit)"
  ],
  description: "round a value towards the nearest integer.If x is complex, both real and imaginary part are rounded towards the nearest integer. When n is specified, the value is rounded to n decimals.",
  examples: [
    "round(3.2)",
    "round(3.8)",
    "round(-4.2)",
    "round(-4.8)",
    "round(pi, 3)",
    "round(123.45678, 2)",
    "round(3.241cm, 2, cm)",
    "round([3.2, 3.8, -4.7])"
  ],
  seealso: ["ceil", "floor", "fix"]
};

// src/expression/embeddedDocs/function/arithmetic/sign.ts
var signDocs = {
  name: "sign",
  category: "Arithmetic",
  syntax: ["sign(x)"],
  description: "Compute the sign of a value. The sign of a value x is 1 when x>0, -1 when x<0, and 0 when x=0.",
  examples: ["sign(3.5)", "sign(-4.2)", "sign(0)"],
  seealso: ["abs"]
};

// src/expression/embeddedDocs/function/arithmetic/sqrt.ts
var sqrtDocs = {
  name: "sqrt",
  category: "Arithmetic",
  syntax: ["sqrt(x)"],
  description: "Compute the square root value. If x = y * y, then y is the square root of x.",
  examples: ["sqrt(25)", "5 * 5", "sqrt(-1)"],
  seealso: ["square", "sqrtm", "multiply", "nthRoot", "nthRoots", "pow"]
};

// src/expression/embeddedDocs/function/arithmetic/sqrtm.ts
var sqrtmDocs = {
  name: "sqrtm",
  category: "Arithmetic",
  syntax: ["sqrtm(x)"],
  description: "Calculate the principal square root of a square matrix. The principal square root matrix `X` of another matrix `A` is such that `X * X = A`.",
  examples: ["sqrtm([[33, 24], [48, 57]])"],
  seealso: ["sqrt", "abs", "square", "multiply"]
};

// src/expression/embeddedDocs/function/algebra/sylvester.ts
var sylvesterDocs = {
  name: "sylvester",
  category: "Algebra",
  syntax: ["sylvester(A,B,C)"],
  description: "Solves the real-valued Sylvester equation AX+XB=C for X",
  examples: [
    "sylvester([[-1, -2], [1, 1]], [[-2, 1], [-1, 2]], [[-3, 2], [3, 0]])",
    "A = [[-1, -2], [1, 1]]; B = [[2, -1], [1, -2]]; C = [[-3, 2], [3, 0]]",
    "sylvester(A, B, C)"
  ],
  seealso: ["schur", "lyap"]
};

// src/expression/embeddedDocs/function/algebra/schur.ts
var schurDocs = {
  name: "schur",
  category: "Algebra",
  syntax: ["schur(A)"],
  description: "Performs a real Schur decomposition of the real matrix A = UTU'",
  examples: ["schur([[1, 0], [-4, 3]])", "A = [[1, 0], [-4, 3]]", "schur(A)"],
  seealso: ["lyap", "sylvester"]
};

// src/expression/embeddedDocs/function/algebra/lyap.ts
var lyapDocs = {
  name: "lyap",
  category: "Algebra",
  syntax: ["lyap(A,Q)"],
  description: "Solves the Continuous-time Lyapunov equation AP+PA'+Q=0 for P",
  examples: [
    "lyap([[-2, 0], [1, -4]], [[3, 1], [1, 3]])",
    "A = [[-2, 0], [1, -4]]",
    "Q = [[3, 1], [1, 3]]",
    "lyap(A,Q)"
  ],
  seealso: ["schur", "sylvester"]
};

// src/expression/embeddedDocs/function/arithmetic/square.ts
var squareDocs = {
  name: "square",
  category: "Arithmetic",
  syntax: ["square(x)"],
  description: "Compute the square of a value. The square of x is x * x.",
  examples: ["square(3)", "sqrt(9)", "3^2", "3 * 3"],
  seealso: ["multiply", "pow", "sqrt", "cube"]
};

// src/expression/embeddedDocs/function/arithmetic/subtract.ts
var subtractDocs = {
  name: "subtract",
  category: "Operators",
  syntax: ["x - y", "subtract(x, y)"],
  description: "subtract two values.",
  examples: ["a = 5.3 - 2", "a + 2", "2/3 - 1/6", "2 * 3 - 3", "2.1 km - 500m"],
  seealso: ["add"]
};

// src/expression/embeddedDocs/function/arithmetic/unaryMinus.ts
var unaryMinusDocs = {
  name: "unaryMinus",
  category: "Operators",
  syntax: ["-x", "unaryMinus(x)"],
  description: "Inverse the sign of a value. Converts booleans and strings to numbers.",
  examples: ["-4.5", "-(-5.6)", '-"22"'],
  seealso: ["add", "subtract", "unaryPlus"]
};

// src/expression/embeddedDocs/function/arithmetic/unaryPlus.ts
var unaryPlusDocs = {
  name: "unaryPlus",
  category: "Operators",
  syntax: ["+x", "unaryPlus(x)"],
  description: "Converts booleans and strings to numbers.",
  examples: ["+true", '+"2"'],
  seealso: ["add", "subtract", "unaryMinus"]
};

// src/expression/embeddedDocs/function/arithmetic/xgcd.ts
var xgcdDocs = {
  name: "xgcd",
  category: "Arithmetic",
  syntax: ["xgcd(a, b)"],
  description: "Calculate the extended greatest common divisor for two values. The result is an array [d, x, y] with 3 entries, where d is the greatest common divisor, and d = x * a + y * b.",
  examples: ["xgcd(8, 12)", "gcd(8, 12)", "xgcd(36163, 21199)"],
  seealso: ["gcd", "lcm"]
};

// src/expression/embeddedDocs/function/bitwise/bitAnd.ts
var bitAndDocs = {
  name: "bitAnd",
  category: "Bitwise",
  syntax: ["x & y", "bitAnd(x, y)"],
  description: "Bitwise AND operation. Performs the logical AND operation on each pair of the corresponding bits of the two given values by multiplying them. If both bits in the compared position are 1, the bit in the resulting binary representation is 1, otherwise, the result is 0",
  examples: ["5 & 3", "bitAnd(53, 131)", "[1, 12, 31] & 42"],
  seealso: [
    "bitNot",
    "bitOr",
    "bitXor",
    "leftShift",
    "rightArithShift",
    "rightLogShift"
  ]
};

// src/expression/embeddedDocs/function/bitwise/bitNot.ts
var bitNotDocs = {
  name: "bitNot",
  category: "Bitwise",
  syntax: ["~x", "bitNot(x)"],
  description: "Bitwise NOT operation. Performs a logical negation on each bit of the given value. Bits that are 0 become 1, and those that are 1 become 0.",
  examples: ["~1", "~2", "bitNot([2, -3, 4])"],
  seealso: [
    "bitAnd",
    "bitOr",
    "bitXor",
    "leftShift",
    "rightArithShift",
    "rightLogShift"
  ]
};

// src/expression/embeddedDocs/function/bitwise/bitOr.ts
var bitOrDocs = {
  name: "bitOr",
  category: "Bitwise",
  syntax: ["x | y", "bitOr(x, y)"],
  description: "Bitwise OR operation. Performs the logical inclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if the first bit is 1 or the second bit is 1 or both bits are 1, otherwise, the result is 0.",
  examples: ["5 | 3", "bitOr([1, 2, 3], 4)"],
  seealso: [
    "bitAnd",
    "bitNot",
    "bitXor",
    "leftShift",
    "rightArithShift",
    "rightLogShift"
  ]
};

// src/expression/embeddedDocs/function/bitwise/bitXor.ts
var bitXorDocs = {
  name: "bitXor",
  category: "Bitwise",
  syntax: ["bitXor(x, y)"],
  description: "Bitwise XOR operation, exclusive OR. Performs the logical exclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1.",
  examples: ["bitOr(1, 2)", "bitXor([2, 3, 4], 4)"],
  seealso: [
    "bitAnd",
    "bitNot",
    "bitOr",
    "leftShift",
    "rightArithShift",
    "rightLogShift"
  ]
};

// src/expression/embeddedDocs/function/bitwise/leftShift.ts
var leftShiftDocs = {
  name: "leftShift",
  category: "Bitwise",
  syntax: ["x << y", "leftShift(x, y)"],
  description: "Bitwise left logical shift of a value x by y number of bits.",
  examples: ["4 << 1", "8 >> 1"],
  seealso: [
    "bitAnd",
    "bitNot",
    "bitOr",
    "bitXor",
    "rightArithShift",
    "rightLogShift"
  ]
};

// src/expression/embeddedDocs/function/bitwise/rightArithShift.ts
var rightArithShiftDocs = {
  name: "rightArithShift",
  category: "Bitwise",
  syntax: ["x >> y", "rightArithShift(x, y)"],
  description: "Bitwise right arithmetic shift of a value x by y number of bits.",
  examples: ["8 >> 1", "4 << 1", "-12 >> 2"],
  seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "leftShift", "rightLogShift"]
};

// src/expression/embeddedDocs/function/bitwise/rightLogShift.ts
var rightLogShiftDocs = {
  name: "rightLogShift",
  category: "Bitwise",
  syntax: ["x >>> y", "rightLogShift(x, y)"],
  description: "Bitwise right logical shift of a value x by y number of bits.",
  examples: ["8 >>> 1", "4 << 1", "-12 >>> 2"],
  seealso: [
    "bitAnd",
    "bitNot",
    "bitOr",
    "bitXor",
    "leftShift",
    "rightArithShift"
  ]
};

// src/expression/embeddedDocs/function/combinatorics/bellNumbers.ts
var bellNumbersDocs = {
  name: "bellNumbers",
  category: "Combinatorics",
  syntax: ["bellNumbers(n)"],
  description: "The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S. `bellNumbers` only takes integer arguments. The following condition must be enforced: n >= 0.",
  examples: ["bellNumbers(3)", "bellNumbers(8)"],
  seealso: ["stirlingS2"]
};

// src/expression/embeddedDocs/function/combinatorics/catalan.ts
var catalanDocs = {
  name: "catalan",
  category: "Combinatorics",
  syntax: ["catalan(n)"],
  description: "The Catalan Numbers enumerate combinatorial structures of many different types. catalan only takes integer arguments. The following condition must be enforced: n >= 0.",
  examples: ["catalan(3)", "catalan(8)"],
  seealso: ["bellNumbers"]
};

// src/expression/embeddedDocs/function/combinatorics/composition.ts
var compositionDocs = {
  name: "composition",
  category: "Combinatorics",
  syntax: ["composition(n, k)"],
  description: "The composition counts of n into k parts. composition only takes integer arguments. The following condition must be enforced: k <= n.",
  examples: ["composition(5, 3)"],
  seealso: ["combinations"]
};

// src/expression/embeddedDocs/function/combinatorics/stirlingS2.ts
var stirlingS2Docs = {
  name: "stirlingS2",
  category: "Combinatorics",
  syntax: ["stirlingS2(n, k)"],
  description: "The Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets. `stirlingS2` only takes integer arguments. The following condition must be enforced: k <= n. If n = k or k = 1, then s(n,k) = 1.",
  examples: ["stirlingS2(5, 3)"],
  seealso: ["bellNumbers", "bernoulli"]
};

// src/expression/embeddedDocs/function/complex/arg.ts
var argDocs = {
  name: "arg",
  category: "Complex",
  syntax: ["arg(x)"],
  description: "Compute the argument of a complex value. If x = a+bi, the argument is computed as atan2(b, a).",
  examples: ["arg(2 + 2i)", "atan2(3, 2)", "arg(2 + 3i)"],
  seealso: ["re", "im", "conj", "abs"]
};

// src/expression/embeddedDocs/function/complex/conj.ts
var conjDocs = {
  name: "conj",
  category: "Complex",
  syntax: ["conj(x)"],
  description: "Compute the complex conjugate of a complex value. If x = a+bi, the complex conjugate is a-bi.",
  examples: ["conj(2 + 3i)", "conj(2 - 3i)", "conj(-5.2i)"],
  seealso: ["re", "im", "abs", "arg"]
};

// src/expression/embeddedDocs/function/complex/im.ts
var imDocs = {
  name: "im",
  category: "Complex",
  syntax: ["im(x)"],
  description: "Get the imaginary part of a complex number.",
  examples: ["im(2 + 3i)", "re(2 + 3i)", "im(-5.2i)", "im(2.4)"],
  seealso: ["re", "conj", "abs", "arg"]
};

// src/expression/embeddedDocs/function/complex/re.ts
var reDocs = {
  name: "re",
  category: "Complex",
  syntax: ["re(x)"],
  description: "Get the real part of a complex number.",
  examples: ["re(2 + 3i)", "im(2 + 3i)", "re(-5.2i)", "re(2.4)"],
  seealso: ["im", "conj", "abs", "arg"]
};

// src/expression/embeddedDocs/function/expression/evaluate.ts
var evaluateDocs = {
  name: "evaluate",
  category: "Expression",
  syntax: [
    "evaluate(expression)",
    "evaluate(expression, scope)",
    "evaluate([expr1, expr2, expr3, ...])",
    "evaluate([expr1, expr2, expr3, ...], scope)"
  ],
  description: "Evaluate an expression or an array with expressions.",
  examples: [
    'evaluate("2 + 3")',
    'evaluate("sqrt(16)")',
    'evaluate("2 inch to cm")',
    'evaluate("sin(x * pi)", { "x": 1/2 })',
    'evaluate(["width=2", "height=4","width*height"])'
  ],
  seealso: ["parser", "parse", "compile"]
};

// src/expression/embeddedDocs/function/expression/parser.ts
var parserDocs = {
  name: "parser",
  category: "Expression",
  syntax: ["parser()"],
  description: "Create a parser object that keeps a context of variables and their values, allowing the evaluation of expressions in that context.",
  examples: [
    "myParser = parser()",
    'myParser.evaluate("sqrt(3^2 + 4^2)")',
    'myParser.set("x", 3)',
    'myParser.evaluate("y = x + 3")',
    'myParser.evaluate(["y = x + 3", "y = y + 1"])',
    'myParser.get("y")'
  ],
  seealso: ["evaluate", "parse", "compile"]
};

// src/expression/embeddedDocs/function/expression/parse.ts
var parseDocs = {
  name: "parse",
  category: "Expression",
  syntax: [
    "parse(expr)",
    "parse(expr, options)",
    "parse([expr1, expr2, expr3, ...])",
    "parse([expr1, expr2, expr3, ...], options)"
  ],
  description: "Parse an expression. Returns a node tree, which can be evaluated by invoking node.evaluate() or transformed into a functional object via node.compile().",
  examples: [
    'node1 = parse("sqrt(3^2 + 4^2)")',
    "node1.evaluate()",
    "code1 = node1.compile()",
    "code1.evaluate()",
    "scope = {a: 3, b: 4}",
    'node2 = parse("a * b")',
    "node2.evaluate(scope)",
    "code2 = node2.compile()",
    "code2.evaluate(scope)"
  ],
  seealso: ["parser", "evaluate", "compile"]
};

// src/expression/embeddedDocs/function/expression/compile.ts
var compileDocs = {
  name: "compile",
  category: "Expression",
  syntax: ["compile(expr) ", "compile([expr1, expr2, expr3, ...])"],
  description: "Parse and compile an expression. Returns a an object with a function evaluate([scope]) to evaluate the compiled expression.",
  examples: [
    'code1 = compile("sqrt(3^2 + 4^2)")',
    "code1.evaluate() ",
    'code2 = compile("a * b")',
    "code2.evaluate({a: 3, b: 4})"
  ],
  seealso: ["parser", "parse", "evaluate"]
};

// src/expression/embeddedDocs/function/expression/help.ts
var helpDocs = {
  name: "help",
  category: "Expression",
  syntax: ["help(object)", "help(string)"],
  description: "Display documentation on a function or data type.",
  examples: ["help(sqrt)", 'help("complex")'],
  seealso: []
};

// src/expression/embeddedDocs/function/geometry/distance.ts
var distanceDocs = {
  name: "distance",
  category: "Geometry",
  syntax: ["distance([x1, y1], [x2, y2])", "distance([[x1, y1], [x2, y2]])"],
  description: "Calculates the Euclidean distance between two points.",
  examples: ["distance([0,0], [4,4])", "distance([[0,0], [4,4]])"],
  seealso: []
};

// src/expression/embeddedDocs/function/geometry/intersect.ts
var intersectDocs = {
  name: "intersect",
  category: "Geometry",
  syntax: [
    "intersect(expr1, expr2, expr3, expr4)",
    "intersect(expr1, expr2, expr3)"
  ],
  description: "Computes the intersection point of lines and/or planes.",
  examples: [
    "intersect([0, 0], [10, 10], [10, 0], [0, 10])",
    "intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6])"
  ],
  seealso: []
};

// src/expression/embeddedDocs/function/logical/and.ts
var andDocs = {
  name: "and",
  category: "Logical",
  syntax: ["x and y", "and(x, y)"],
  description: "Logical and. Test whether two values are both defined with a nonzero/nonempty value.",
  examples: ["true and false", "true and true", "2 and 4"],
  seealso: ["not", "or", "xor"]
};

// src/expression/embeddedDocs/function/logical/not.ts
var notDocs = {
  name: "not",
  category: "Logical",
  syntax: ["not x", "not(x)"],
  description: "Logical not. Flips the boolean value of given argument.",
  examples: ["not true", "not false", "not 2", "not 0"],
  seealso: ["and", "or", "xor"]
};

// src/expression/embeddedDocs/function/logical/nullish.ts
var nullishDocs = {
  name: "nullish",
  category: "Logical",
  syntax: ["x ?? y", "nullish(x, y)"],
  description: "Nullish coalescing operator. Returns the right-hand operand when the left-hand operand is null or undefined, and otherwise returns the left-hand operand.",
  examples: [
    "null ?? 42",
    "undefined ?? 42",
    "0 ?? 42",
    "false ?? 42",
    "null ?? undefined ?? 42"
  ],
  seealso: ["and", "or", "not"]
};

// src/expression/embeddedDocs/function/logical/or.ts
var orDocs = {
  name: "or",
  category: "Logical",
  syntax: ["x or y", "or(x, y)"],
  description: "Logical or. Test if at least one value is defined with a nonzero/nonempty value.",
  examples: ["true or false", "false or false", "0 or 4"],
  seealso: ["not", "and", "xor"]
};

// src/expression/embeddedDocs/function/logical/xor.ts
var xorDocs = {
  name: "xor",
  category: "Logical",
  syntax: ["x xor y", "xor(x, y)"],
  description: "Logical exclusive or, xor. Test whether one and only one value is defined with a nonzero/nonempty value.",
  examples: ["true xor false", "false xor false", "true xor true", "0 xor 4"],
  seealso: ["not", "and", "or"]
};

// src/expression/embeddedDocs/function/matrix/mapSlices.ts
var mapSlicesDocs = {
  name: "mapSlices",
  category: "Matrix",
  syntax: ["mapSlices(A, dim, callback)"],
  description: "Generate a matrix one dimension less than A by applying callback to each slice of A along dimension dim.",
  examples: [
    "A = [[1, 2], [3, 4]]",
    "mapSlices(A, 1, sum)",
    // returns [4, 6]
    "mapSlices(A, 2, prod)"
    // returns [2, 12]
  ],
  seealso: ["map", "forEach"]
};

// src/expression/embeddedDocs/function/matrix/column.ts
var columnDocs = {
  name: "column",
  category: "Matrix",
  syntax: ["column(x, index)"],
  description: "Return a column from a matrix or array.",
  examples: ["A = [[1, 2], [3, 4]]", "column(A, 1)", "column(A, 2)"],
  seealso: ["row", "matrixFromColumns"]
};

// src/expression/embeddedDocs/function/matrix/concat.ts
var concatDocs = {
  name: "concat",
  category: "Matrix",
  syntax: ["concat(A, B, C, ...)", "concat(A, B, C, ..., dim)"],
  description: "Concatenate matrices. By default, the matrices are concatenated by the last dimension. The dimension on which to concatenate can be provided as last argument.",
  examples: [
    "A = [1, 2; 5, 6]",
    "B = [3, 4; 7, 8]",
    "concat(A, B)",
    "concat(A, B, 1)",
    "concat(A, B, 2)"
  ],
  seealso: [
    "det",
    "diag",
    "identity",
    "inv",
    "ones",
    "range",
    "size",
    "squeeze",
    "subset",
    "trace",
    "transpose",
    "zeros"
  ]
};

// src/expression/embeddedDocs/function/matrix/count.ts
var countDocs = {
  name: "count",
  category: "Matrix",
  syntax: ["count(x)"],
  description: "Count the number of elements of a matrix, array or string.",
  examples: [
    "a = [1, 2; 3, 4; 5, 6]",
    "count(a)",
    "size(a)",
    'count("hello world")'
  ],
  seealso: ["size"]
};

// src/expression/embeddedDocs/function/matrix/cross.ts
var crossDocs = {
  name: "cross",
  category: "Matrix",
  syntax: ["cross(A, B)"],
  description: "Calculate the cross product for two vectors in three dimensional space.",
  examples: [
    "cross([1, 1, 0],  [0, 1, 1])",
    "cross([3, -3, 1], [4, 9, 2])",
    "cross([2, 3, 4],  [5, 6, 7])"
  ],
  seealso: ["multiply", "dot"]
};

// src/expression/embeddedDocs/function/matrix/ctranspose.ts
var ctransposeDocs = {
  name: "ctranspose",
  category: "Matrix",
  syntax: ["x'", "ctranspose(x)"],
  description: "Complex Conjugate and Transpose a matrix",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "ctranspose(a)"],
  seealso: [
    "concat",
    "det",
    "diag",
    "identity",
    "inv",
    "ones",
    "range",
    "size",
    "squeeze",
    "subset",
    "trace",
    "zeros"
  ]
};

// src/expression/embeddedDocs/function/matrix/det.ts
var detDocs = {
  name: "det",
  category: "Matrix",
  syntax: ["det(x)"],
  description: "Calculate the determinant of a matrix",
  examples: ["det([1, 2; 3, 4])", "det([-2, 2, 3; -1, 1, 3; 2, 0, -1])"],
  seealso: [
    "concat",
    "diag",
    "identity",
    "inv",
    "ones",
    "range",
    "size",
    "squeeze",
    "subset",
    "trace",
    "transpose",
    "zeros"
  ]
};

// src/expression/embeddedDocs/function/matrix/diag.ts
var diagDocs = {
  name: "diag",
  category: "Matrix",
  syntax: ["diag(x)", "diag(x, k)"],
  description: "Create a diagonal matrix or retrieve the diagonal of a matrix. When x is a vector, a matrix with the vector values on the diagonal will be returned. When x is a matrix, a vector with the diagonal values of the matrix is returned. When k is provided, the k-th diagonal will be filled in or retrieved, if k is positive, the values are placed on the super diagonal. When k is negative, the values are placed on the sub diagonal.",
  examples: [
    "diag(1:3)",
    "diag(1:3, 1)",
    "a = [1, 2, 3; 4, 5, 6; 7, 8, 9]",
    "diag(a)"
  ],
  seealso: [
    "concat",
    "det",
    "identity",
    "inv",
    "ones",
    "range",
    "size",
    "squeeze",
    "subset",
    "trace",
    "transpose",
    "zeros"
  ]
};

// src/expression/embeddedDocs/function/matrix/diff.ts
var diffDocs = {
  name: "diff",
  category: "Matrix",
  syntax: ["diff(arr)", "diff(arr, dim)"],
  description: [
    "Create a new matrix or array with the difference of the passed matrix or array.",
    "Dim parameter is optional and used to indicate the dimension of the array/matrix to apply the difference",
    "If no dimension parameter is passed it is assumed as dimension 0",
    "Dimension is zero-based in javascript and one-based in the parser",
    "Arrays must be 'rectangular' meaning arrays like [1, 2]",
    "If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays"
  ],
  examples: [
    "A = [1, 2, 4, 7, 0]",
    "diff(A)",
    "diff(A, 1)",
    "B = [[1, 2], [3, 4]]",
    "diff(B)",
    "diff(B, 1)",
    "diff(B, 2)",
    "diff(B, bignumber(2))",
    "diff([[1, 2], matrix([3, 4])], 2)"
  ],
  seealso: ["subtract", "partitionSelect"]
};

// src/expression/embeddedDocs/function/matrix/dot.ts
var dotDocs = {
  name: "dot",
  category: "Matrix",
  syntax: ["dot(A, B)", "A * B"],
  description: "Calculate the dot product of two vectors. The dot product of A = [a1, a2, a3, ..., an] and B = [b1, b2, b3, ..., bn] is defined as dot(A, B) = a1 * b1 + a2 * b2 + a3 * b3 + ... + an * bn",
  examples: ["dot([2, 4, 1], [2, 2, 3])", "[2, 4, 1] * [2, 2, 3]"],
  seealso: ["multiply", "cross"]
};

// src/expression/embeddedDocs/function/matrix/eigs.ts
var eigsDocs = {
  name: "eigs",
  category: "Matrix",
  syntax: ["eigs(x)"],
  description: "Calculate the eigenvalues and optionally eigenvectors of a square matrix",
  examples: [
    "eigs([[5, 2.3], [2.3, 1]])",
    "eigs([[1, 2, 3], [4, 5, 6], [7, 8, 9]], { precision: 1e-6, eigenvectors: false })"
  ],
  seealso: ["inv"]
};

// src/expression/embeddedDocs/function/matrix/filter.ts
var filterDocs = {
  name: "filter",
  category: "Matrix",
  syntax: ["filter(x, test)"],
  description: "Filter items in a matrix.",
  examples: [
    "isPositive(x) = x > 0",
    "filter([6, -2, -1, 4, 3], isPositive)",
    "filter([6, -2, 0, 1, 0], x != 0)"
  ],
  seealso: ["sort", "map", "forEach"]
};

// src/expression/embeddedDocs/function/matrix/flatten.ts
var flattenDocs = {
  name: "flatten",
  category: "Matrix",
  syntax: ["flatten(x)"],
  description: "Flatten a multi dimensional matrix into a single dimensional matrix.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "size(a)", "b = flatten(a)", "size(b)"],
  seealso: ["concat", "resize", "size", "squeeze"]
};

// src/expression/embeddedDocs/function/matrix/forEach.ts
var forEachDocs = {
  name: "forEach",
  category: "Matrix",
  syntax: ["forEach(x, callback)"],
  description: "Iterates over all elements of a matrix/array, and executes the given callback function.",
  examples: [
    "numberOfPets = {}",
    "addPet(n) = numberOfPets[n] = (numberOfPets[n] ? numberOfPets[n]:0 ) + 1;",
    'forEach(["Dog","Cat","Cat"], addPet)',
    "numberOfPets"
  ],
  seealso: ["map", "sort", "filter"]
};

// src/expression/embeddedDocs/function/matrix/getMatrixDataType.ts
var getMatrixDataTypeDocs = {
  name: "getMatrixDataType",
  category: "Matrix",
  syntax: ["getMatrixDataType(x)"],
  description: 'Find the data type of all elements in a matrix or array, for example "number" if all items are a number and "Complex" if all values are complex numbers. If a matrix contains more than one data type, it will return "mixed".',
  examples: [
    "getMatrixDataType([1, 2, 3])",
    "getMatrixDataType([[5 cm], [2 inch]])",
    'getMatrixDataType([1, "text"])',
    "getMatrixDataType([1, bignumber(4)])"
  ],
  seealso: ["matrix", "sparse", "typeOf"]
};

// src/expression/embeddedDocs/function/matrix/identity.ts
var identityDocs = {
  name: "identity",
  category: "Matrix",
  syntax: ["identity(n)", "identity(m, n)", "identity([m, n])"],
  description: "Returns the identity matrix with size m-by-n. The matrix has ones on the diagonal and zeros elsewhere.",
  examples: [
    "identity(3)",
    "identity(3, 5)",
    "a = [1, 2, 3; 4, 5, 6]",
    "identity(size(a))"
  ],
  seealso: [
    "concat",
    "det",
    "diag",
    "inv",
    "ones",
    "range",
    "size",
    "squeeze",
    "subset",
    "trace",
    "transpose",
    "zeros"
  ]
};

// src/expression/embeddedDocs/function/matrix/inv.ts
var invDocs = {
  name: "inv",
  category: "Matrix",
  syntax: ["inv(x)"],
  description: "Calculate the inverse of a matrix",
  examples: ["inv([1, 2; 3, 4])", "inv(4)", "1 / 4"],
  seealso: [
    "concat",
    "det",
    "diag",
    "identity",
    "ones",
    "range",
    "size",
    "squeeze",
    "subset",
    "trace",
    "transpose",
    "zeros"
  ]
};

// src/expression/embeddedDocs/function/matrix/pinv.ts
var pinvDocs = {
  name: "pinv",
  category: "Matrix",
  syntax: ["pinv(x)"],
  description: "Calculate the Moore\u2013Penrose inverse of a matrix",
  examples: ["pinv([1, 2; 3, 4])", "pinv([[1, 0], [0, 1], [0, 1]])", "pinv(4)"],
  seealso: ["inv"]
};

// src/expression/embeddedDocs/function/matrix/kron.ts
var kronDocs = {
  name: "kron",
  category: "Matrix",
  syntax: ["kron(x, y)"],
  description: "Calculates the Kronecker product of 2 matrices or vectors.",
  examples: [
    "kron([[1, 0], [0, 1]], [[1, 2], [3, 4]])",
    "kron([1,1], [2,3,4])"
  ],
  seealso: ["multiply", "dot", "cross"]
};

// src/expression/embeddedDocs/function/matrix/map.ts
var mapDocs = {
  name: "map",
  category: "Matrix",
  syntax: ["map(x, callback)", "map(x, y, ..., callback)"],
  description: "Create a new matrix or array with the results of the callback function executed on each entry of the matrix/array or the matrices/arrays.",
  examples: ["map([1, 2, 3], square)", "map([1, 2], [3, 4], f(a,b) = a + b)"],
  seealso: ["filter", "forEach"]
};

// src/expression/embeddedDocs/function/matrix/matrixFromColumns.ts
var matrixFromColumnsDocs = {
  name: "matrixFromColumns",
  category: "Matrix",
  syntax: [
    "matrixFromColumns(...arr)",
    "matrixFromColumns(row1, row2)",
    "matrixFromColumns(row1, row2, row3)"
  ],
  description: "Create a dense matrix from vectors as individual columns.",
  examples: ["matrixFromColumns([1, 2, 3], [[4],[5],[6]])"],
  seealso: ["matrix", "matrixFromRows", "matrixFromFunction", "zeros"]
};

// src/expression/embeddedDocs/function/matrix/matrixFromFunction.ts
var matrixFromFunctionDocs = {
  name: "matrixFromFunction",
  category: "Matrix",
  syntax: [
    "matrixFromFunction(size, fn)",
    "matrixFromFunction(size, fn, format)",
    "matrixFromFunction(size, fn, format, datatype)",
    "matrixFromFunction(size, format, fn)",
    "matrixFromFunction(size, format, datatype, fn)"
  ],
  description: "Create a matrix by evaluating a generating function at each index.",
  examples: [
    "f(I) = I[1] - I[2]",
    "matrixFromFunction([3,3], f)",
    "g(I) = I[1] - I[2] == 1 ? 4 : 0",
    'matrixFromFunction([100, 100], "sparse", g)',
    "matrixFromFunction([5], random)"
  ],
  seealso: ["matrix", "matrixFromRows", "matrixFromColumns", "zeros"]
};

// src/expression/embeddedDocs/function/matrix/matrixFromRows.ts
var matrixFromRowsDocs = {
  name: "matrixFromRows",
  category: "Matrix",
  syntax: [
    "matrixFromRows(...arr)",
    "matrixFromRows(row1, row2)",
    "matrixFromRows(row1, row2, row3)"
  ],
  description: "Create a dense matrix from vectors as individual rows.",
  examples: ["matrixFromRows([1, 2, 3], [[4],[5],[6]])"],
  seealso: ["matrix", "matrixFromColumns", "matrixFromFunction", "zeros"]
};

// src/expression/embeddedDocs/function/matrix/ones.ts
var onesDocs = {
  name: "ones",
  category: "Matrix",
  syntax: [
    "ones(m)",
    "ones(m, n)",
    "ones(m, n, p, ...)",
    "ones([m])",
    "ones([m, n])",
    "ones([m, n, p, ...])"
  ],
  description: "Create a matrix containing ones.",
  examples: [
    "ones(3)",
    "ones(3, 5)",
    "ones([2,3]) * 4.5",
    "a = [1, 2, 3; 4, 5, 6]",
    "ones(size(a))"
  ],
  seealso: [
    "concat",
    "det",
    "diag",
    "identity",
    "inv",
    "range",
    "size",
    "squeeze",
    "subset",
    "trace",
    "transpose",
    "zeros"
  ]
};

// src/expression/embeddedDocs/function/matrix/partitionSelect.ts
var partitionSelectDocs = {
  name: "partitionSelect",
  category: "Matrix",
  syntax: ["partitionSelect(x, k)", "partitionSelect(x, k, compare)"],
  description: "Partition-based selection of an array or 1D matrix. Will find the kth smallest value, and mutates the input array. Uses Quickselect.",
  examples: [
    "partitionSelect([5, 10, 1], 2)",
    'partitionSelect(["C", "B", "A", "D"], 1, compareText)',
    "arr = [5, 2, 1]",
    "partitionSelect(arr, 0) # returns 1, arr is now: [1, 2, 5]",
    "arr",
    "partitionSelect(arr, 1, 'desc') # returns 2, arr is now: [5, 2, 1]",
    "arr"
  ],
  seealso: ["sort"]
};

// src/expression/embeddedDocs/function/matrix/range.ts
var rangeDocs = {
  name: "range",
  category: "Type",
  syntax: [
    "start:end",
    "start:step:end",
    "range(start, end)",
    "range(start, end, step)",
    "range(string)"
  ],
  description: "Create a range. Lower bound of the range is included, upper bound is excluded.",
  examples: [
    "1:5",
    "3:-1:-3",
    "range(3, 7)",
    "range(0, 12, 2)",
    'range("4:10")',
    "range(1m, 1m, 3m)",
    "a = [1, 2, 3, 4; 5, 6, 7, 8]",
    "a[1:2, 1:2]"
  ],
  seealso: [
    "concat",
    "det",
    "diag",
    "identity",
    "inv",
    "ones",
    "size",
    "squeeze",
    "subset",
    "trace",
    "transpose",
    "zeros"
  ]
};

// src/expression/embeddedDocs/function/matrix/reshape.ts
var reshapeDocs = {
  name: "reshape",
  category: "Matrix",
  syntax: ["reshape(x, sizes)"],
  description: "Reshape a multi dimensional array to fit the specified dimensions.",
  examples: [
    "reshape([1, 2, 3, 4, 5, 6], [2, 3])",
    "reshape([[1, 2], [3, 4]], [1, 4])",
    "reshape([[1, 2], [3, 4]], [4])",
    "reshape([1, 2, 3, 4], [-1, 2])"
  ],
  seealso: ["size", "squeeze", "resize"]
};

// src/expression/embeddedDocs/function/matrix/resize.ts
var resizeDocs = {
  name: "resize",
  category: "Matrix",
  syntax: ["resize(x, size)", "resize(x, size, defaultValue)"],
  description: "Resize a matrix.",
  examples: [
    "resize([1,2,3,4,5], [3])",
    "resize([1,2,3], [5])",
    "resize([1,2,3], [5], -1)",
    "resize(2, [2, 3])",
    'resize("hello", [8], "!")'
  ],
  seealso: ["size", "subset", "squeeze", "reshape"]
};

// src/expression/embeddedDocs/function/matrix/rotate.ts
var rotateDocs = {
  name: "rotate",
  category: "Matrix",
  syntax: ["rotate(w, theta)", "rotate(w, theta, v)"],
  description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
  examples: [
    "rotate([1, 0], pi / 2)",
    'rotate(matrix([1, 0]), unit("35deg"))',
    'rotate([1, 0, 0], unit("90deg"), [0, 0, 1])',
    'rotate(matrix([1, 0, 0]), unit("90deg"), matrix([0, 0, 1]))'
  ],
  seealso: ["matrix", "rotationMatrix"]
};

// src/expression/embeddedDocs/function/matrix/rotationMatrix.ts
var rotationMatrixDocs = {
  name: "rotationMatrix",
  category: "Matrix",
  syntax: [
    "rotationMatrix(theta)",
    "rotationMatrix(theta, v)",
    "rotationMatrix(theta, v, format)"
  ],
  description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
  examples: [
    "rotationMatrix(pi / 2)",
    'rotationMatrix(unit("45deg"), [0, 0, 1])',
    'rotationMatrix(1, matrix([0, 0, 1]), "sparse")'
  ],
  seealso: ["cos", "sin"]
};

// src/expression/embeddedDocs/function/matrix/row.ts
var rowDocs = {
  name: "row",
  category: "Matrix",
  syntax: ["row(x, index)"],
  description: "Return a row from a matrix or array.",
  examples: ["A = [[1, 2], [3, 4]]", "row(A, 1)", "row(A, 2)"],
  seealso: ["column", "matrixFromRows"]
};

// src/expression/embeddedDocs/function/matrix/size.ts
var sizeDocs = {
  name: "size",
  category: "Matrix",
  syntax: ["size(x)"],
  description: "Calculate the size of a matrix.",
  examples: [
    "size(2.3)",
    'size("hello world")',
    "a = [1, 2; 3, 4; 5, 6]",
    "size(a)",
    "size(1:6)"
  ],
  seealso: [
    "concat",
    "count",
    "det",
    "diag",
    "identity",
    "inv",
    "ones",
    "range",
    "squeeze",
    "subset",
    "trace",
    "transpose",
    "zeros"
  ]
};

// src/expression/embeddedDocs/function/matrix/sort.ts
var sortDocs = {
  name: "sort",
  category: "Matrix",
  syntax: ["sort(x)", "sort(x, compare)"],
  description: 'Sort the items in a matrix. Compare can be a string "asc", "desc", "natural", or a custom sort function.',
  examples: [
    "sort([5, 10, 1])",
    'sort(["C", "B", "A", "D"], "natural")',
    "sortByLength(a, b) = size(a)[1] - size(b)[1]",
    'sort(["Langdon", "Tom", "Sara"], sortByLength)',
    'sort(["10", "1", "2"], "natural")'
  ],
  seealso: ["map", "filter", "forEach"]
};

// src/expression/embeddedDocs/function/matrix/squeeze.ts
var squeezeDocs = {
  name: "squeeze",
  category: "Matrix",
  syntax: ["squeeze(x)"],
  description: "Remove inner and outer singleton dimensions from a matrix.",
  examples: [
    "a = zeros(3,2,1)",
    "size(squeeze(a))",
    "b = zeros(1,1,3)",
    "size(squeeze(b))"
  ],
  seealso: [
    "concat",
    "det",
    "diag",
    "identity",
    "inv",
    "ones",
    "range",
    "size",
    "subset",
    "trace",
    "transpose",
    "zeros"
  ]
};

// src/expression/embeddedDocs/function/matrix/subset.ts
var subsetDocs = {
  name: "subset",
  category: "Matrix",
  syntax: [
    "value(index)",
    "value(index) = replacement",
    "subset(value, [index])",
    "subset(value, [index], replacement)"
  ],
  description: "Get or set a subset of the entries of a matrix or characters of a string. Indexes are one-based. There should be one index specification for each dimension of the target. Each specification can be a single index, a list of indices, or a range in colon notation `l:u`. In a range, both the lower bound l and upper bound u are included; and if a bound is omitted it defaults to the most extreme valid value. The cartesian product of the indices specified in each dimension determines the target of the operation.",
  examples: [
    "d = [1, 2; 3, 4]",
    "e = []",
    "e[1, 1:2] = [5, 6]",
    "e[2, :] = [7, 8]",
    "f = d * e",
    "f[2, 1]",
    "f[:, 1]",
    "f[[1,2], [1,3]] = [9, 10; 11, 12]",
    "f"
  ],
  seealso: [
    "concat",
    "det",
    "diag",
    "identity",
    "inv",
    "ones",
    "range",
    "size",
    "squeeze",
    "trace",
    "transpose",
    "zeros"
  ]
};

// src/expression/embeddedDocs/function/matrix/trace.ts
var traceDocs = {
  name: "trace",
  category: "Matrix",
  syntax: ["trace(A)"],
  description: "Calculate the trace of a matrix: the sum of the elements on the main diagonal of a square matrix.",
  examples: ["A = [1, 2, 3; -1, 2, 3; 2, 0, 3]", "trace(A)"],
  seealso: [
    "concat",
    "det",
    "diag",
    "identity",
    "inv",
    "ones",
    "range",
    "size",
    "squeeze",
    "subset",
    "transpose",
    "zeros"
  ]
};

// src/expression/embeddedDocs/function/matrix/transpose.ts
var transposeDocs = {
  name: "transpose",
  category: "Matrix",
  syntax: ["x'", "transpose(x)"],
  description: "Transpose a matrix",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "transpose(a)"],
  seealso: [
    "concat",
    "det",
    "diag",
    "identity",
    "inv",
    "ones",
    "range",
    "size",
    "squeeze",
    "subset",
    "trace",
    "zeros"
  ]
};

// src/expression/embeddedDocs/function/matrix/zeros.ts
var zerosDocs = {
  name: "zeros",
  category: "Matrix",
  syntax: [
    "zeros(m)",
    "zeros(m, n)",
    "zeros(m, n, p, ...)",
    "zeros([m])",
    "zeros([m, n])",
    "zeros([m, n, p, ...])"
  ],
  description: "Create a matrix containing zeros.",
  examples: [
    "zeros(3)",
    "zeros(3, 5)",
    "a = [1, 2, 3; 4, 5, 6]",
    "zeros(size(a))"
  ],
  seealso: [
    "concat",
    "det",
    "diag",
    "identity",
    "inv",
    "ones",
    "range",
    "size",
    "squeeze",
    "subset",
    "trace",
    "transpose"
  ]
};

// src/expression/embeddedDocs/function/matrix/fft.ts
var fftDocs = {
  name: "fft",
  category: "Matrix",
  syntax: ["fft(x)"],
  description: "Calculate N-dimensional Fourier transform",
  examples: ["fft([[1, 0], [1, 0]])"],
  seealso: ["ifft"]
};

// src/expression/embeddedDocs/function/matrix/ifft.ts
var ifftDocs = {
  name: "ifft",
  category: "Matrix",
  syntax: ["ifft(x)"],
  description: "Calculate N-dimensional inverse Fourier transform",
  examples: ["ifft([[2, 2], [0, 0]])"],
  seealso: ["fft"]
};

// src/expression/embeddedDocs/function/probability/bernoulli.ts
var bernoulliDocs = {
  name: "bernoulli",
  category: "Probability",
  syntax: ["bernoulli(n)"],
  description: "The nth Bernoulli number",
  examples: ["bernoulli(4)", "bernoulli(fraction(12))"],
  seealso: ["combinations", "gamma", "stirlingS2"]
};

// src/expression/embeddedDocs/function/probability/combinations.ts
var combinationsDocs = {
  name: "combinations",
  category: "Probability",
  syntax: ["combinations(n, k)"],
  description: "Compute the number of combinations of n items taken k at a time",
  examples: ["combinations(7, 5)"],
  seealso: ["combinationsWithRep", "permutations", "factorial"]
};

// src/expression/embeddedDocs/function/probability/combinationsWithRep.ts
var combinationsWithRepDocs = {
  name: "combinationsWithRep",
  category: "Probability",
  syntax: ["combinationsWithRep(n, k)"],
  description: "Compute the number of combinations of n items taken k at a time with replacements.",
  examples: ["combinationsWithRep(7, 5)"],
  seealso: ["combinations", "permutations", "factorial"]
};

// src/expression/embeddedDocs/function/probability/factorial.ts
var factorialDocs = {
  name: "factorial",
  category: "Probability",
  syntax: ["n!", "factorial(n)"],
  description: "Compute the factorial of a value",
  examples: ["5!", "5 * 4 * 3 * 2 * 1", "3!"],
  seealso: ["combinations", "combinationsWithRep", "permutations", "gamma"]
};

// src/expression/embeddedDocs/function/probability/gamma.ts
var gammaDocs = {
  name: "gamma",
  category: "Probability",
  syntax: ["gamma(n)"],
  description: "Compute the gamma function. For small values, the Lanczos approximation is used, and for large values the extended Stirling approximation.",
  examples: ["gamma(4)", "3!", "gamma(1/2)", "sqrt(pi)"],
  seealso: ["factorial"]
};

// src/expression/embeddedDocs/function/probability/lgamma.ts
var lgammaDocs = {
  name: "lgamma",
  category: "Probability",
  syntax: ["lgamma(n)"],
  description: "Logarithm of the gamma function for real, positive numbers and complex numbers, using Lanczos approximation for numbers and Stirling series for complex numbers.",
  examples: [
    "lgamma(4)",
    "lgamma(1/2)",
    "lgamma(i)",
    "lgamma(complex(1.1, 2))"
  ],
  seealso: ["gamma"]
};

// src/expression/embeddedDocs/function/probability/kldivergence.ts
var kldivergenceDocs = {
  name: "kldivergence",
  category: "Probability",
  syntax: ["kldivergence(x, y)"],
  description: "Calculate the Kullback-Leibler (KL) divergence  between two distributions.",
  examples: ["kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])"],
  seealso: []
};

// src/expression/embeddedDocs/function/probability/multinomial.ts
var multinomialDocs = {
  name: "multinomial",
  category: "Probability",
  syntax: ["multinomial(A)"],
  description: "Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities. multinomial takes one array of integers as an argument. The following condition must be enforced: every ai > 0.",
  examples: ["multinomial([1, 2, 1])"],
  seealso: ["combinations", "factorial"]
};

// src/expression/embeddedDocs/function/probability/permutations.ts
var permutationsDocs = {
  name: "permutations",
  category: "Probability",
  syntax: ["permutations(n)", "permutations(n, k)"],
  description: "Compute the number of permutations of n items taken k at a time",
  examples: ["permutations(5)", "permutations(5, 3)"],
  seealso: ["combinations", "combinationsWithRep", "factorial"]
};

// src/expression/embeddedDocs/function/probability/pickRandom.ts
var pickRandomDocs = {
  name: "pickRandom",
  category: "Probability",
  syntax: [
    "pickRandom(array)",
    "pickRandom(array, number)",
    "pickRandom(array, weights)",
    "pickRandom(array, number, weights)",
    "pickRandom(array, weights, number)"
  ],
  description: "Pick a random entry from a given array.",
  examples: [
    "pickRandom(0:10)",
    "pickRandom([1, 3, 1, 6])",
    "pickRandom([1, 3, 1, 6], 2)",
    "pickRandom([1, 3, 1, 6], [2, 3, 2, 1])",
    "pickRandom([1, 3, 1, 6], 2, [2, 3, 2, 1])",
    "pickRandom([1, 3, 1, 6], [2, 3, 2, 1], 2)"
  ],
  seealso: ["random", "randomInt"]
};

// src/expression/embeddedDocs/function/probability/random.ts
var randomDocs = {
  name: "random",
  category: "Probability",
  syntax: [
    "random()",
    "random(max)",
    "random(min, max)",
    "random(size)",
    "random(size, max)",
    "random(size, min, max)"
  ],
  description: "Return a random number.",
  examples: ["random()", "random(10, 20)", "random([2, 3])"],
  seealso: ["pickRandom", "randomInt"]
};

// src/expression/embeddedDocs/function/probability/randomInt.ts
var randomIntDocs = {
  name: "randomInt",
  category: "Probability",
  syntax: [
    "randomInt(max)",
    "randomInt(min, max)",
    "randomInt(size)",
    "randomInt(size, max)",
    "randomInt(size, min, max)"
  ],
  description: "Return a random integer number",
  examples: ["randomInt(10, 20)", "randomInt([2, 3], 10)"],
  seealso: ["pickRandom", "random"]
};

// src/expression/embeddedDocs/function/relational/compare.ts
var compareDocs = {
  name: "compare",
  category: "Relational",
  syntax: ["compare(x, y)"],
  description: "Compare two values. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
  examples: [
    "compare(2, 3)",
    "compare(3, 2)",
    "compare(2, 2)",
    "compare(5cm, 40mm)",
    "compare(2, [1, 2, 3])"
  ],
  seealso: [
    "equal",
    "unequal",
    "smaller",
    "smallerEq",
    "largerEq",
    "compareNatural",
    "compareText"
  ]
};

// src/expression/embeddedDocs/function/relational/compareNatural.ts
var compareNaturalDocs = {
  name: "compareNatural",
  category: "Relational",
  syntax: ["compareNatural(x, y)"],
  description: "Compare two values of any type in a deterministic, natural way. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
  examples: [
    "compareNatural(2, 3)",
    "compareNatural(3, 2)",
    "compareNatural(2, 2)",
    "compareNatural(5cm, 40mm)",
    'compareNatural("2", "10")',
    "compareNatural(2 + 3i, 2 + 4i)",
    "compareNatural([1, 2, 4], [1, 2, 3])",
    "compareNatural([1, 5], [1, 2, 3])",
    "compareNatural([1, 2], [1, 2])",
    "compareNatural({a: 2}, {a: 4})"
  ],
  seealso: [
    "equal",
    "unequal",
    "smaller",
    "smallerEq",
    "largerEq",
    "compare",
    "compareText"
  ]
};

// src/expression/embeddedDocs/function/relational/compareText.ts
var compareTextDocs = {
  name: "compareText",
  category: "Relational",
  syntax: ["compareText(x, y)"],
  description: "Compare two strings lexically. Comparison is case sensitive. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
  examples: [
    'compareText("B", "A")',
    'compareText("A", "B")',
    'compareText("A", "A")',
    'compareText("2", "10")',
    'compare("2", "10")',
    "compare(2, 10)",
    'compareNatural("2", "10")',
    'compareText("B", ["A", "B", "C"])'
  ],
  seealso: ["compare", "compareNatural"]
};

// src/expression/embeddedDocs/function/relational/deepEqual.ts
var deepEqualDocs = {
  name: "deepEqual",
  category: "Relational",
  syntax: ["deepEqual(x, y)"],
  description: "Check equality of two matrices element wise. Returns true if the size of both matrices is equal and when and each of the elements are equal.",
  examples: ["deepEqual([1,3,4], [1,3,4])", "deepEqual([1,3,4], [1,3])"],
  seealso: [
    "equal",
    "unequal",
    "smaller",
    "larger",
    "smallerEq",
    "largerEq",
    "compare"
  ]
};

// src/expression/embeddedDocs/function/relational/equal.ts
var equalDocs = {
  name: "equal",
  category: "Relational",
  syntax: ["x == y", "equal(x, y)"],
  description: "Check equality of two values. Returns true if the values are equal, and false if not.",
  examples: [
    "2+2 == 3",
    "2+2 == 4",
    "a = 3.2",
    "b = 6-2.8",
    "a == b",
    "50cm == 0.5m"
  ],
  seealso: [
    "unequal",
    "smaller",
    "larger",
    "smallerEq",
    "largerEq",
    "compare",
    "deepEqual",
    "equalText"
  ]
};

// src/expression/embeddedDocs/function/relational/equalText.ts
var equalTextDocs = {
  name: "equalText",
  category: "Relational",
  syntax: ["equalText(x, y)"],
  description: "Check equality of two strings. Comparison is case sensitive. Returns true if the values are equal, and false if not.",
  examples: [
    'equalText("Hello", "Hello")',
    'equalText("a", "A")',
    'equal("2e3", "2000")',
    'equalText("2e3", "2000")',
    'equalText("B", ["A", "B", "C"])'
  ],
  seealso: ["compare", "compareNatural", "compareText", "equal"]
};

// src/expression/embeddedDocs/function/relational/larger.ts
var largerDocs = {
  name: "larger",
  category: "Relational",
  syntax: ["x > y", "larger(x, y)"],
  description: "Check if value x is larger than y. Returns true if x is larger than y, and false if not. Comparing a value with NaN returns false.",
  examples: [
    "2 > 3",
    "5 > 2*2",
    "a = 3.3",
    "b = 6-2.8",
    "(a > b)",
    "(b < a)",
    "5 cm > 2 inch"
  ],
  seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compare"]
};

// src/expression/embeddedDocs/function/relational/largerEq.ts
var largerEqDocs = {
  name: "largerEq",
  category: "Relational",
  syntax: ["x >= y", "largerEq(x, y)"],
  description: "Check if value x is larger or equal to y. Returns true if x is larger or equal to y, and false if not.",
  examples: ["2 >= 1+1", "2 > 1+1", "a = 3.2", "b = 6-2.8", "(a >= b)"],
  seealso: ["equal", "unequal", "smallerEq", "smaller", "compare"]
};

// src/expression/embeddedDocs/function/relational/smaller.ts
var smallerDocs = {
  name: "smaller",
  category: "Relational",
  syntax: ["x < y", "smaller(x, y)"],
  description: "Check if value x is smaller than value y. Returns true if x is smaller than y, and false if not. Comparing a value with NaN returns false.",
  examples: [
    "2 < 3",
    "5 < 2*2",
    "a = 3.3",
    "b = 6-2.8",
    "(a < b)",
    "5 cm < 2 inch"
  ],
  seealso: ["equal", "unequal", "larger", "smallerEq", "largerEq", "compare"]
};

// src/expression/embeddedDocs/function/relational/smallerEq.ts
var smallerEqDocs = {
  name: "smallerEq",
  category: "Relational",
  syntax: ["x <= y", "smallerEq(x, y)"],
  description: "Check if value x is smaller or equal to value y. Returns true if x is smaller than y, and false if not.",
  examples: ["2 <= 1+1", "2 < 1+1", "a = 3.2", "b = 6-2.8", "(a <= b)"],
  seealso: ["equal", "unequal", "larger", "smaller", "largerEq", "compare"]
};

// src/expression/embeddedDocs/function/relational/unequal.ts
var unequalDocs = {
  name: "unequal",
  category: "Relational",
  syntax: ["x != y", "unequal(x, y)"],
  description: "Check unequality of two values. Returns true if the values are unequal, and false if they are equal.",
  examples: [
    "2+2 != 3",
    "2+2 != 4",
    "a = 3.2",
    "b = 6-2.8",
    "a != b",
    "50cm != 0.5m",
    "5 cm != 2 inch"
  ],
  seealso: [
    "equal",
    "smaller",
    "larger",
    "smallerEq",
    "largerEq",
    "compare",
    "deepEqual"
  ]
};

// src/expression/embeddedDocs/function/set/setCartesian.ts
var setCartesianDocs = {
  name: "setCartesian",
  category: "Set",
  syntax: ["setCartesian(set1, set2)"],
  description: "Create the cartesian product of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays and the values will be sorted in ascending order before the operation.",
  examples: ["setCartesian([1, 2], [3, 4])"],
  seealso: ["setUnion", "setIntersect", "setDifference", "setPowerset"]
};

// src/expression/embeddedDocs/function/set/setDifference.ts
var setDifferenceDocs = {
  name: "setDifference",
  category: "Set",
  syntax: ["setDifference(set1, set2)"],
  description: "Create the difference of two (multi)sets: every element of set1, that is not the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: [
    "setDifference([1, 2, 3, 4], [3, 4, 5, 6])",
    "setDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"
  ],
  seealso: ["setUnion", "setIntersect", "setSymDifference"]
};

// src/expression/embeddedDocs/function/set/setDistinct.ts
var setDistinctDocs = {
  name: "setDistinct",
  category: "Set",
  syntax: ["setDistinct(set)"],
  description: "Collect the distinct elements of a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
  examples: ["setDistinct([1, 1, 1, 2, 2, 3])"],
  seealso: ["setMultiplicity"]
};

// src/expression/embeddedDocs/function/set/setIntersect.ts
var setIntersectDocs = {
  name: "setIntersect",
  category: "Set",
  syntax: ["setIntersect(set1, set2)"],
  description: "Create the intersection of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: [
    "setIntersect([1, 2, 3, 4], [3, 4, 5, 6])",
    "setIntersect([[1, 2], [3, 4]], [[3, 4], [5, 6]])"
  ],
  seealso: ["setUnion", "setDifference"]
};

// src/expression/embeddedDocs/function/set/setIsSubset.ts
var setIsSubsetDocs = {
  name: "setIsSubset",
  category: "Set",
  syntax: ["setIsSubset(set1, set2)"],
  description: "Check whether a (multi)set is a subset of another (multi)set: every element of set1 is the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: [
    "setIsSubset([1, 2], [3, 4, 5, 6])",
    "setIsSubset([3, 4], [3, 4, 5, 6])"
  ],
  seealso: ["setUnion", "setIntersect", "setDifference"]
};

// src/expression/embeddedDocs/function/set/setMultiplicity.ts
var setMultiplicityDocs = {
  name: "setMultiplicity",
  category: "Set",
  syntax: ["setMultiplicity(element, set)"],
  description: "Count the multiplicity of an element in a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
  examples: [
    "setMultiplicity(1, [1, 2, 2, 4])",
    "setMultiplicity(2, [1, 2, 2, 4])"
  ],
  seealso: ["setDistinct", "setSize"]
};

// src/expression/embeddedDocs/function/set/setPowerset.ts
var setPowersetDocs = {
  name: "setPowerset",
  category: "Set",
  syntax: ["setPowerset(set)"],
  description: "Create the powerset of a (multi)set: the powerset contains very possible subsets of a (multi)set. A multi-dimension array will be converted to a single-dimension array before the operation.",
  examples: ["setPowerset([1, 2, 3])"],
  seealso: ["setCartesian"]
};

// src/expression/embeddedDocs/function/set/setSize.ts
var setSizeDocs = {
  name: "setSize",
  category: "Set",
  syntax: ["setSize(set)", "setSize(set, unique)"],
  description: 'Count the number of elements of a (multi)set. When the second parameter "unique" is true, count only the unique values. A multi-dimension array will be converted to a single-dimension array before the operation.',
  examples: ["setSize([1, 2, 2, 4])", "setSize([1, 2, 2, 4], true)"],
  seealso: ["setUnion", "setIntersect", "setDifference"]
};

// src/expression/embeddedDocs/function/set/setSymDifference.ts
var setSymDifferenceDocs = {
  name: "setSymDifference",
  category: "Set",
  syntax: ["setSymDifference(set1, set2)"],
  description: "Create the symmetric difference of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: [
    "setSymDifference([1, 2, 3, 4], [3, 4, 5, 6])",
    "setSymDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"
  ],
  seealso: ["setUnion", "setIntersect", "setDifference"]
};

// src/expression/embeddedDocs/function/set/setUnion.ts
var setUnionDocs = {
  name: "setUnion",
  category: "Set",
  syntax: ["setUnion(set1, set2)"],
  description: "Create the union of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: [
    "setUnion([1, 2, 3, 4], [3, 4, 5, 6])",
    "setUnion([[1, 2], [3, 4]], [[3, 4], [5, 6]])"
  ],
  seealso: ["setIntersect", "setDifference"]
};

// src/expression/embeddedDocs/function/signal/zpk2tf.ts
var zpk2tfDocs = {
  name: "zpk2tf",
  category: "Signal",
  syntax: ["zpk2tf(z, p, k)"],
  description: "Compute the transfer function of a zero-pole-gain model.",
  examples: [
    "zpk2tf([1, 2], [-1, -2], 1)",
    "zpk2tf([1, 2], [-1, -2])",
    "zpk2tf([1 - 3i, 2 + 2i], [-1, -2])"
  ],
  seealso: []
};

// src/expression/embeddedDocs/function/signal/freqz.ts
var freqzDocs = {
  name: "freqz",
  category: "Signal",
  syntax: ["freqz(b, a)", "freqz(b, a, w)"],
  description: "Calculates the frequency response of a filter given its numerator and denominator coefficients.",
  examples: [
    "freqz([1, 2], [1, 2, 3])",
    "freqz([1, 2], [1, 2, 3], [0, 1])",
    "freqz([1, 2], [1, 2, 3], 512)"
  ],
  seealso: []
};

// src/expression/embeddedDocs/function/special/erf.ts
var erfDocs = {
  name: "erf",
  category: "Special",
  syntax: ["erf(x)"],
  description: "Compute the erf function of a value using a rational Chebyshev approximations for different intervals of x",
  examples: ["erf(0.2)", "erf(-0.5)", "erf(4)"],
  seealso: []
};

// src/expression/embeddedDocs/function/special/zeta.ts
var zetaDocs = {
  name: "zeta",
  category: "Special",
  syntax: ["zeta(s)"],
  description: "Compute the Riemann Zeta Function using an infinite series and Riemann's Functional Equation for the entire complex plane",
  examples: ["zeta(0.2)", "zeta(-0.5)", "zeta(4)"],
  seealso: []
};

// src/expression/embeddedDocs/function/statistics/mad.ts
var madDocs = {
  name: "mad",
  category: "Statistics",
  syntax: ["mad(a, b, c, ...)", "mad(A)"],
  description: "Compute the median absolute deviation of a matrix or a list with values. The median absolute deviation is defined as the median of the absolute deviations from the median.",
  examples: ["mad(10, 20, 30)", "mad([1, 2, 3])"],
  seealso: ["mean", "median", "std", "abs"]
};

// src/expression/embeddedDocs/function/statistics/max.ts
var maxDocs = {
  name: "max",
  category: "Statistics",
  syntax: ["max(a, b, c, ...)", "max(A)", "max(A, dimension)"],
  description: "Compute the maximum value of a list of values. If any NaN values are found, the function yields the last NaN in the input.",
  examples: [
    "max(2, 3, 4, 1)",
    "max([2, 3, 4, 1])",
    "max([2, 5; 4, 3])",
    "max([2, 5; 4, 3], 1)",
    "max([2, 5; 4, 3], 2)",
    "max(2.7, 7.1, -4.5, 2.0, 4.1)",
    "min(2.7, 7.1, -4.5, 2.0, 4.1)"
  ],
  seealso: ["mean", "median", "min", "prod", "std", "sum", "variance"]
};

// src/expression/embeddedDocs/function/statistics/mean.ts
var meanDocs = {
  name: "mean",
  category: "Statistics",
  syntax: ["mean(a, b, c, ...)", "mean(A)", "mean(A, dimension)"],
  description: "Compute the arithmetic mean of a list of values.",
  examples: [
    "mean(2, 3, 4, 1)",
    "mean([2, 3, 4, 1])",
    "mean([2, 5; 4, 3])",
    "mean([2, 5; 4, 3], 1)",
    "mean([2, 5; 4, 3], 2)",
    "mean([1.0, 2.7, 3.2, 4.0])"
  ],
  seealso: ["max", "median", "min", "prod", "std", "sum", "variance"]
};

// src/expression/embeddedDocs/function/statistics/median.ts
var medianDocs = {
  name: "median",
  category: "Statistics",
  syntax: ["median(a, b, c, ...)", "median(A)"],
  description: "Compute the median of all values. The values are sorted and the middle value is returned. In case of an even number of values, the average of the two middle values is returned.",
  examples: ["median(5, 2, 7)", "median([3, -1, 5, 7])"],
  seealso: [
    "max",
    "mean",
    "min",
    "prod",
    "std",
    "sum",
    "variance",
    "quantileSeq"
  ]
};

// src/expression/embeddedDocs/function/statistics/min.ts
var minDocs = {
  name: "min",
  category: "Statistics",
  syntax: ["min(a, b, c, ...)", "min(A)", "min(A, dimension)"],
  description: "Compute the minimum value of a list of values. If any NaN values are found, the function yields the last NaN in the input.",
  examples: [
    "min(2, 3, 4, 1)",
    "min([2, 3, 4, 1])",
    "min([2, 5; 4, 3])",
    "min([2, 5; 4, 3], 1)",
    "min([2, 5; 4, 3], 2)",
    "min(2.7, 7.1, -4.5, 2.0, 4.1)",
    "max(2.7, 7.1, -4.5, 2.0, 4.1)"
  ],
  seealso: ["max", "mean", "median", "prod", "std", "sum", "variance"]
};

// src/expression/embeddedDocs/function/statistics/mode.ts
var modeDocs = {
  name: "mode",
  category: "Statistics",
  syntax: ["mode(a, b, c, ...)", "mode(A)", "mode(A, a, b, B, c, ...)"],
  description: "Computes the mode of all values as an array. In case mode being more than one, multiple values are returned in an array.",
  examples: [
    "mode(2, 1, 4, 3, 1)",
    "mode([1, 2.7, 3.2, 4, 2.7])",
    "mode(1, 4, 6, 1, 6)"
  ],
  seealso: ["max", "mean", "min", "median", "prod", "std", "sum", "variance"]
};

// src/expression/embeddedDocs/function/statistics/prod.ts
var prodDocs = {
  name: "prod",
  category: "Statistics",
  syntax: ["prod(a, b, c, ...)", "prod(A)"],
  description: "Compute the product of all values.",
  examples: ["prod(2, 3, 4)", "prod([2, 3, 4])", "prod([2, 5; 4, 3])"],
  seealso: ["max", "mean", "min", "median", "min", "std", "sum", "variance"]
};

// src/expression/embeddedDocs/function/statistics/quantileSeq.ts
var quantileSeqDocs = {
  name: "quantileSeq",
  category: "Statistics",
  syntax: [
    "quantileSeq(A, prob[, sorted])",
    "quantileSeq(A, [prob1, prob2, ...][, sorted])",
    "quantileSeq(A, N[, sorted])"
  ],
  description: "Compute the prob order quantile of a matrix or a list with values. The sequence is sorted and the middle value is returned. Supported types of sequence values are: Number, BigNumber, Unit Supported types of probability are: Number, BigNumber. \n\nIn case of a (multi dimensional) array or matrix, the prob order quantile of all elements will be calculated.",
  examples: [
    "quantileSeq([3, -1, 5, 7], 0.5)",
    "quantileSeq([3, -1, 5, 7], [1/3, 2/3])",
    "quantileSeq([3, -1, 5, 7], 2)",
    "quantileSeq([-1, 3, 5, 7], 0.5, true)"
  ],
  seealso: ["mean", "median", "min", "max", "prod", "std", "sum", "variance"]
};

// src/expression/embeddedDocs/function/statistics/std.ts
var stdDocs = {
  name: "std",
  category: "Statistics",
  syntax: [
    "std(a, b, c, ...)",
    "std(A)",
    "std(A, dimension)",
    "std(A, normalization)",
    "std(A, dimension, normalization)"
  ],
  description: 'Compute the standard deviation of all values, defined as std(A) = sqrt(variance(A)). Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
  examples: [
    "std(2, 4, 6)",
    "std([2, 4, 6, 8])",
    'std([2, 4, 6, 8], "uncorrected")',
    'std([2, 4, 6, 8], "biased")',
    "std([1, 2, 3; 4, 5, 6])"
  ],
  seealso: ["max", "mean", "min", "median", "prod", "sum", "variance"]
};

// src/expression/embeddedDocs/function/statistics/cumsum.ts
var cumSumDocs = {
  name: "cumsum",
  category: "Statistics",
  syntax: ["cumsum(a, b, c, ...)", "cumsum(A)"],
  description: "Compute the cumulative sum of all values.",
  examples: [
    "cumsum(2, 3, 4, 1)",
    "cumsum([2, 3, 4, 1])",
    "cumsum([1, 2; 3, 4])",
    "cumsum([1, 2; 3, 4], 1)",
    "cumsum([1, 2; 3, 4], 2)"
  ],
  seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"]
};

// src/expression/embeddedDocs/function/statistics/sum.ts
var sumDocs = {
  name: "sum",
  category: "Statistics",
  syntax: ["sum(a, b, c, ...)", "sum(A)", "sum(A, dimension)"],
  description: "Compute the sum of all values.",
  examples: ["sum(2, 3, 4, 1)", "sum([2, 3, 4, 1])", "sum([2, 5; 4, 3])"],
  seealso: ["max", "mean", "median", "min", "prod", "std", "variance"]
};

// src/expression/embeddedDocs/function/statistics/variance.ts
var varianceDocs = {
  name: "variance",
  category: "Statistics",
  syntax: [
    "variance(a, b, c, ...)",
    "variance(A)",
    "variance(A, dimension)",
    "variance(A, normalization)",
    "variance(A, dimension, normalization)"
  ],
  description: 'Compute the variance of all values. Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
  examples: [
    "variance(2, 4, 6)",
    "variance([2, 4, 6, 8])",
    'variance([2, 4, 6, 8], "uncorrected")',
    'variance([2, 4, 6, 8], "biased")',
    "variance([1, 2, 3; 4, 5, 6])"
  ],
  seealso: ["max", "mean", "min", "median", "min", "prod", "std", "sum"]
};

// src/expression/embeddedDocs/function/statistics/corr.ts
var corrDocs = {
  name: "corr",
  category: "Statistics",
  syntax: ["corr(A,B)"],
  description: "Compute the correlation coefficient of a two list with values, For matrices, the matrix correlation coefficient is calculated.",
  examples: [
    "corr([2, 4, 6, 8],[1, 2, 3, 6])",
    "corr(matrix([[1, 2.2, 3, 4.8, 5], [1, 2, 3, 4, 5]]), matrix([[4, 5.3, 6.6, 7, 8], [1, 2, 3, 4, 5]]))"
  ],
  seealso: ["max", "mean", "min", "median", "min", "prod", "std", "sum"]
};

// src/expression/embeddedDocs/function/trigonometry/acos.ts
var acosDocs = {
  name: "acos",
  category: "Trigonometry",
  syntax: ["acos(x)"],
  description: "Compute the inverse cosine of a value in radians.",
  examples: ["acos(0.5)", "acos(cos(2.3))"],
  seealso: ["cos", "atan", "asin"]
};

// src/expression/embeddedDocs/function/trigonometry/acosh.ts
var acoshDocs = {
  name: "acosh",
  category: "Trigonometry",
  syntax: ["acosh(x)"],
  description: "Calculate the hyperbolic arccos of a value, defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.",
  examples: ["acosh(1.5)"],
  seealso: ["cosh", "asinh", "atanh"]
};

// src/expression/embeddedDocs/function/trigonometry/acot.ts
var acotDocs = {
  name: "acot",
  category: "Trigonometry",
  syntax: ["acot(x)"],
  description: "Calculate the inverse cotangent of a value.",
  examples: ["acot(0.5)", "acot(cot(0.5))", "acot(2)"],
  seealso: ["cot", "atan"]
};

// src/expression/embeddedDocs/function/trigonometry/acoth.ts
var acothDocs = {
  name: "acoth",
  category: "Trigonometry",
  syntax: ["acoth(x)"],
  description: "Calculate the inverse hyperbolic tangent of a value, defined as `acoth(x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.",
  examples: ["acoth(2)", "acoth(0.5)"],
  seealso: ["acsch", "asech"]
};

// src/expression/embeddedDocs/function/trigonometry/acsc.ts
var acscDocs = {
  name: "acsc",
  category: "Trigonometry",
  syntax: ["acsc(x)"],
  description: "Calculate the inverse cotangent of a value.",
  examples: ["acsc(2)", "acsc(csc(0.5))", "acsc(0.5)"],
  seealso: ["csc", "asin", "asec"]
};

// src/expression/embeddedDocs/function/trigonometry/acsch.ts
var acschDocs = {
  name: "acsch",
  category: "Trigonometry",
  syntax: ["acsch(x)"],
  description: "Calculate the inverse hyperbolic cosecant of a value, defined as `acsch(x) = ln(1/x + sqrt(1/x^2 + 1))`.",
  examples: ["acsch(0.5)"],
  seealso: ["asech", "acoth"]
};

// src/expression/embeddedDocs/function/trigonometry/asec.ts
var asecDocs = {
  name: "asec",
  category: "Trigonometry",
  syntax: ["asec(x)"],
  description: "Calculate the inverse secant of a value.",
  examples: ["asec(0.5)", "asec(sec(0.5))", "asec(2)"],
  seealso: ["acos", "acot", "acsc"]
};

// src/expression/embeddedDocs/function/trigonometry/asech.ts
var asechDocs = {
  name: "asech",
  category: "Trigonometry",
  syntax: ["asech(x)"],
  description: "Calculate the inverse secant of a value.",
  examples: ["asech(0.5)"],
  seealso: ["acsch", "acoth"]
};

// src/expression/embeddedDocs/function/trigonometry/asin.ts
var asinDocs = {
  name: "asin",
  category: "Trigonometry",
  syntax: ["asin(x)"],
  description: "Compute the inverse sine of a value in radians.",
  examples: ["asin(0.5)", "asin(sin(0.5))"],
  seealso: ["sin", "acos", "atan"]
};

// src/expression/embeddedDocs/function/trigonometry/asinh.ts
var asinhDocs = {
  name: "asinh",
  category: "Trigonometry",
  syntax: ["asinh(x)"],
  description: "Calculate the hyperbolic arcsine of a value, defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.",
  examples: ["asinh(0.5)"],
  seealso: ["acosh", "atanh"]
};

// src/expression/embeddedDocs/function/trigonometry/atan.ts
var atanDocs = {
  name: "atan",
  category: "Trigonometry",
  syntax: ["atan(x)"],
  description: "Compute the inverse tangent of a value in radians.",
  examples: ["atan(0.5)", "atan(tan(0.5))"],
  seealso: ["tan", "acos", "asin"]
};

// src/expression/embeddedDocs/function/trigonometry/atan2.ts
var atan2Docs = {
  name: "atan2",
  category: "Trigonometry",
  syntax: ["atan2(y, x)"],
  description: "Computes the principal value of the arc tangent of y/x in radians.",
  examples: [
    "atan2(2, 2) / pi",
    "angle = 60 deg in rad",
    "x = cos(angle)",
    "y = sin(angle)",
    "atan2(y, x)"
  ],
  seealso: ["sin", "cos", "tan"]
};

// src/expression/embeddedDocs/function/trigonometry/atanh.ts
var atanhDocs = {
  name: "atanh",
  category: "Trigonometry",
  syntax: ["atanh(x)"],
  description: "Calculate the hyperbolic arctangent of a value, defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.",
  examples: ["atanh(0.5)"],
  seealso: ["acosh", "asinh"]
};

// src/expression/embeddedDocs/function/trigonometry/cos.ts
var cosDocs = {
  name: "cos",
  category: "Trigonometry",
  syntax: ["cos(x)"],
  description: "Compute the cosine of x in radians.",
  examples: [
    "cos(2)",
    "cos(pi / 4) ^ 2",
    "cos(180 deg)",
    "cos(60 deg)",
    "sin(0.2)^2 + cos(0.2)^2"
  ],
  seealso: ["acos", "sin", "tan"]
};

// src/expression/embeddedDocs/function/trigonometry/cosh.ts
var coshDocs = {
  name: "cosh",
  category: "Trigonometry",
  syntax: ["cosh(x)"],
  description: "Compute the hyperbolic cosine of x in radians.",
  examples: ["cosh(0.5)"],
  seealso: ["sinh", "tanh", "coth"]
};

// src/expression/embeddedDocs/function/trigonometry/cot.ts
var cotDocs = {
  name: "cot",
  category: "Trigonometry",
  syntax: ["cot(x)"],
  description: "Compute the cotangent of x in radians. Defined as 1/tan(x)",
  examples: ["cot(2)", "1 / tan(2)"],
  seealso: ["sec", "csc", "tan"]
};

// src/expression/embeddedDocs/function/trigonometry/coth.ts
var cothDocs = {
  name: "coth",
  category: "Trigonometry",
  syntax: ["coth(x)"],
  description: "Compute the hyperbolic cotangent of x in radians.",
  examples: ["coth(2)", "1 / tanh(2)"],
  seealso: ["sech", "csch", "tanh"]
};

// src/expression/embeddedDocs/function/trigonometry/csc.ts
var cscDocs = {
  name: "csc",
  category: "Trigonometry",
  syntax: ["csc(x)"],
  description: "Compute the cosecant of x in radians. Defined as 1/sin(x)",
  examples: ["csc(2)", "1 / sin(2)"],
  seealso: ["sec", "cot", "sin"]
};

// src/expression/embeddedDocs/function/trigonometry/csch.ts
var cschDocs = {
  name: "csch",
  category: "Trigonometry",
  syntax: ["csch(x)"],
  description: "Compute the hyperbolic cosecant of x in radians. Defined as 1/sinh(x)",
  examples: ["csch(2)", "1 / sinh(2)"],
  seealso: ["sech", "coth", "sinh"]
};

// src/expression/embeddedDocs/function/trigonometry/sec.ts
var secDocs = {
  name: "sec",
  category: "Trigonometry",
  syntax: ["sec(x)"],
  description: "Compute the secant of x in radians. Defined as 1/cos(x)",
  examples: ["sec(2)", "1 / cos(2)"],
  seealso: ["cot", "csc", "cos"]
};

// src/expression/embeddedDocs/function/trigonometry/sech.ts
var sechDocs = {
  name: "sech",
  category: "Trigonometry",
  syntax: ["sech(x)"],
  description: "Compute the hyperbolic secant of x in radians. Defined as 1/cosh(x)",
  examples: ["sech(2)", "1 / cosh(2)"],
  seealso: ["coth", "csch", "cosh"]
};

// src/expression/embeddedDocs/function/trigonometry/sin.ts
var sinDocs = {
  name: "sin",
  category: "Trigonometry",
  syntax: ["sin(x)"],
  description: "Compute the sine of x in radians.",
  examples: [
    "sin(2)",
    "sin(pi / 4) ^ 2",
    "sin(90 deg)",
    "sin(30 deg)",
    "sin(0.2)^2 + cos(0.2)^2"
  ],
  seealso: ["asin", "cos", "tan"]
};

// src/expression/embeddedDocs/function/trigonometry/sinh.ts
var sinhDocs = {
  name: "sinh",
  category: "Trigonometry",
  syntax: ["sinh(x)"],
  description: "Compute the hyperbolic sine of x in radians.",
  examples: ["sinh(0.5)"],
  seealso: ["cosh", "tanh"]
};

// src/expression/embeddedDocs/function/trigonometry/tan.ts
var tanDocs = {
  name: "tan",
  category: "Trigonometry",
  syntax: ["tan(x)"],
  description: "Compute the tangent of x in radians.",
  examples: ["tan(0.5)", "sin(0.5) / cos(0.5)", "tan(pi / 4)", "tan(45 deg)"],
  seealso: ["atan", "sin", "cos"]
};

// src/expression/embeddedDocs/function/trigonometry/tanh.ts
var tanhDocs = {
  name: "tanh",
  category: "Trigonometry",
  syntax: ["tanh(x)"],
  description: "Compute the hyperbolic tangent of x in radians.",
  examples: ["tanh(0.5)", "sinh(0.5) / cosh(0.5)"],
  seealso: ["sinh", "cosh"]
};

// src/expression/embeddedDocs/function/units/to.ts
var toDocs = {
  name: "to",
  category: "Units",
  syntax: ["x to unit", "to(x, unit)"],
  description: "Change the unit of a value.",
  examples: ["5 inch to cm", "3.2kg to g", "16 bytes in bits"],
  seealso: []
};

// src/expression/embeddedDocs/function/units/toBest.ts
var toBestDocs = {
  name: "toBest",
  category: "Units",
  syntax: ["toBest(x)", "toBest(x, unitList)", "toBest(x, unitList, options)"],
  description: "Converts to the most appropriate display unit.",
  examples: [
    'toBest(unit(5000, "m"))',
    'toBest(unit(3500000, "W"))',
    'toBest(unit(0.000000123, "A"))',
    'toBest(unit(10, "m"), "cm")',
    'toBest(unit(10, "m"), "mm,km", {offset: 1.5})'
  ],
  seealso: []
};

// src/expression/embeddedDocs/function/utils/bin.ts
var binDocs = {
  name: "bin",
  category: "Utils",
  syntax: ["bin(value)"],
  description: "Format a number as binary",
  examples: ["bin(2)"],
  seealso: ["oct", "hex"]
};

// src/expression/embeddedDocs/function/utils/clone.ts
var cloneDocs = {
  name: "clone",
  category: "Utils",
  syntax: ["clone(x)"],
  description: "Clone a variable. Creates a copy of primitive variables, and a deep copy of matrices",
  examples: [
    "clone(3.5)",
    "clone(2 - 4i)",
    "clone(45 deg)",
    "clone([1, 2; 3, 4])",
    'clone("hello world")'
  ],
  seealso: []
};

// src/expression/embeddedDocs/function/utils/format.ts
var formatDocs = {
  name: "format",
  category: "Utils",
  syntax: ["format(value)", "format(value, precision)"],
  description: "Format a value of any type as string.",
  examples: ["format(2.3)", "format(3 - 4i)", "format([])", "format(pi, 3)"],
  seealso: ["print"]
};

// src/expression/embeddedDocs/function/utils/hasNumericValue.ts
var hasNumericValueDocs = {
  name: "hasNumericValue",
  category: "Utils",
  syntax: ["hasNumericValue(x)"],
  description: "Test whether a value is an numeric value. In case of a string, true is returned if the string contains a numeric value.",
  examples: [
    "hasNumericValue(2)",
    'hasNumericValue("2")',
    'isNumeric("2")',
    "hasNumericValue(0)",
    "hasNumericValue(bignumber(500))",
    "hasNumericValue(fraction(0.125))",
    "hasNumericValue(2 + 3i)",
    'hasNumericValue([2.3, "foo", false])'
  ],
  seealso: [
    "isInteger",
    "isZero",
    "isNegative",
    "isPositive",
    "isNaN",
    "isNumeric"
  ]
};

// src/expression/embeddedDocs/function/utils/hex.ts
var hexDocs = {
  name: "hex",
  category: "Utils",
  syntax: ["hex(value)"],
  description: "Format a number as hexadecimal",
  examples: ["hex(240)"],
  seealso: ["bin", "oct"]
};

// src/expression/embeddedDocs/function/utils/isInteger.ts
var isIntegerDocs = {
  name: "isInteger",
  category: "Utils",
  syntax: ["isInteger(x)"],
  description: "Test whether a value is an integer number.",
  examples: ["isInteger(2)", "isInteger(3.5)", "isInteger([3, 0.5, -2])"],
  seealso: ["isNegative", "isNumeric", "isPositive", "isZero"]
};

// src/expression/embeddedDocs/function/utils/isNaN.ts
var isNaNDocs = {
  name: "isNaN",
  category: "Utils",
  syntax: ["isNaN(x)"],
  description: "Test whether a value is NaN (not a number)",
  examples: ["isNaN(2)", "isNaN(0 / 0)", "isNaN(NaN)", "isNaN(Infinity)"],
  seealso: [
    "isNegative",
    "isNumeric",
    "isPositive",
    "isZero",
    "isFinite",
    "isBounded"
  ]
};

// src/expression/embeddedDocs/function/utils/isBounded.ts
var isBoundedDocs = {
  name: "isBounded",
  category: "Utils",
  syntax: ["isBounded(x)"],
  description: "Test whether a value or its entries are bounded.",
  examples: [
    "isBounded(Infinity)",
    "isBounded(bigint(3))",
    "isBounded([3, -Infinity, -3])"
  ],
  seealso: ["isFinite", "isNumeric", "isNaN", "isNegative", "isPositive"]
};

// src/expression/embeddedDocs/function/utils/isFinite.ts
var isFiniteDocs = {
  name: "isFinite",
  category: "Utils",
  syntax: ["isFinite(x)"],
  description: "Test whether a value is finite, elementwise on collections.",
  examples: [
    "isFinite(Infinity)",
    "isFinite(bigint(3))",
    "isFinite([3, -Infinity, -3])"
  ],
  seealso: ["isBounded", "isNumeric", "isNaN", "isNegative", "isPositive"]
};

// src/expression/embeddedDocs/function/utils/isNegative.ts
var isNegativeDocs = {
  name: "isNegative",
  category: "Utils",
  syntax: ["isNegative(x)"],
  description: "Test whether a value is negative: smaller than zero.",
  examples: [
    "isNegative(2)",
    "isNegative(0)",
    "isNegative(-4)",
    "isNegative([3, 0.5, -2])"
  ],
  seealso: ["isInteger", "isNumeric", "isPositive", "isZero"]
};

// src/expression/embeddedDocs/function/utils/isNumeric.ts
var isNumericDocs = {
  name: "isNumeric",
  category: "Utils",
  syntax: ["isNumeric(x)"],
  description: "Test whether a value is a numeric value. Returns true when the input is a number, BigNumber, Fraction, or boolean.",
  examples: [
    "isNumeric(2)",
    'isNumeric("2")',
    'hasNumericValue("2")',
    "isNumeric(0)",
    "isNumeric(bignumber(500))",
    "isNumeric(fraction(0.125))",
    "isNumeric(2 + 3i)",
    'isNumeric([2.3, "foo", false])'
  ],
  seealso: [
    "isInteger",
    "isZero",
    "isNegative",
    "isPositive",
    "isNaN",
    "hasNumericValue",
    "isFinite",
    "isBounded"
  ]
};

// src/expression/embeddedDocs/function/utils/isPositive.ts
var isPositiveDocs = {
  name: "isPositive",
  category: "Utils",
  syntax: ["isPositive(x)"],
  description: "Test whether a value is positive: larger than zero.",
  examples: [
    "isPositive(2)",
    "isPositive(0)",
    "isPositive(-4)",
    "isPositive([3, 0.5, -2])"
  ],
  seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
};

// src/expression/embeddedDocs/function/utils/isPrime.ts
var isPrimeDocs = {
  name: "isPrime",
  category: "Utils",
  syntax: ["isPrime(x)"],
  description: "Test whether a value is prime: has no divisors other than itself and one.",
  examples: ["isPrime(3)", "isPrime(-2)", "isPrime([2, 17, 100])"],
  seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
};

// src/expression/embeddedDocs/function/utils/isZero.ts
var isZeroDocs = {
  name: "isZero",
  category: "Utils",
  syntax: ["isZero(x)"],
  description: "Test whether a value is zero.",
  examples: ["isZero(2)", "isZero(0)", "isZero(-4)", "isZero([3, 0, -2, 0])"],
  seealso: ["isInteger", "isNumeric", "isNegative", "isPositive"]
};

// src/expression/embeddedDocs/function/utils/numeric.ts
var numericDocs = {
  name: "numeric",
  category: "Utils",
  syntax: ["numeric(x)"],
  description: "Convert a numeric input to a specific numeric type: number, BigNumber, bigint, or Fraction.",
  examples: [
    'numeric("4")',
    'numeric("4", "number")',
    'numeric("4", "bigint")',
    'numeric("4", "BigNumber")',
    'numeric("4", "Fraction")',
    'numeric(4, "Fraction")',
    'numeric(fraction(2, 5), "number")'
  ],
  seealso: ["number", "bigint", "fraction", "bignumber", "string", "format"]
};

// src/expression/embeddedDocs/function/utils/oct.ts
var octDocs = {
  name: "oct",
  category: "Utils",
  syntax: ["oct(value)"],
  description: "Format a number as octal",
  examples: ["oct(56)"],
  seealso: ["bin", "hex"]
};

// src/expression/embeddedDocs/function/utils/print.ts
var printDocs = {
  name: "print",
  category: "Utils",
  syntax: ["print(template, values)", "print(template, values, precision)"],
  description: "Interpolate values into a string template.",
  examples: [
    'print("Lucy is $age years old", {age: 5})',
    'print("The value of pi is $pi", {pi: pi}, 3)',
    'print("Hello, $user.name!", {user: {name: "John"}})',
    'print("Values: $1, $2, $3", [6, 9, 4])'
  ],
  seealso: ["format"]
};

// src/expression/embeddedDocs/function/utils/typeOf.ts
var typeOfDocs = {
  name: "typeOf",
  category: "Utils",
  syntax: ["typeOf(x)"],
  description: "Get the type of a variable.",
  examples: [
    "typeOf(3.5)",
    "typeOf(2 - 4i)",
    "typeOf(45 deg)",
    'typeOf("hello world")'
  ],
  seealso: ["getMatrixDataType"]
};

// src/expression/embeddedDocs/function/numeric/solveODE.ts
var solveODEDocs = {
  name: "solveODE",
  category: "Numeric",
  syntax: ["solveODE(func, tspan, y0)", "solveODE(func, tspan, y0, options)"],
  description: "Numerical Integration of Ordinary Differential Equations.",
  examples: [
    "f(t,y) = y",
    "tspan = [0, 4]",
    "solveODE(f, tspan, 1)",
    "solveODE(f, tspan, [1, 2])",
    'solveODE(f, tspan, 1, { method:"RK23", maxStep:0.1 })'
  ],
  seealso: ["derivative", "simplifyCore"]
};

// src/expression/embeddedDocs/embeddedDocs.ts
var embeddedDocs = {
  // construction functions
  bignumber: bignumberDocs,
  bigint: bigintDocs,
  boolean: booleanDocs,
  complex: complexDocs,
  createUnit: createUnitDocs,
  fraction: fractionDocs,
  index: indexDocs,
  matrix: matrixDocs,
  number: numberDocs,
  sparse: sparseDocs,
  splitUnit: splitUnitDocs,
  string: stringDocs,
  unit: unitDocs,
  // constants
  e: eDocs,
  E: eDocs,
  false: falseDocs,
  i: iDocs,
  Infinity: InfinityDocs,
  LN2: LN2Docs,
  LN10: LN10Docs,
  LOG2E: LOG2EDocs,
  LOG10E: LOG10EDocs,
  NaN: NaNDocs,
  null: nullDocs,
  pi: piDocs,
  PI: piDocs,
  phi: phiDocs,
  SQRT1_2: SQRT12Docs,
  SQRT2: SQRT2Docs,
  tau: tauDocs,
  true: trueDocs,
  version: versionDocs,
  // physical constants
  // TODO: more detailed docs for physical constants
  speedOfLight: {
    description: "Speed of light in vacuum",
    examples: ["speedOfLight"]
  },
  gravitationConstant: {
    description: "Newtonian constant of gravitation",
    examples: ["gravitationConstant"]
  },
  planckConstant: {
    description: "Planck constant",
    examples: ["planckConstant"]
  },
  reducedPlanckConstant: {
    description: "Reduced Planck constant",
    examples: ["reducedPlanckConstant"]
  },
  magneticConstant: {
    description: "Magnetic constant (vacuum permeability)",
    examples: ["magneticConstant"]
  },
  electricConstant: {
    description: "Electric constant (vacuum permeability)",
    examples: ["electricConstant"]
  },
  vacuumImpedance: {
    description: "Characteristic impedance of vacuum",
    examples: ["vacuumImpedance"]
  },
  coulomb: {
    description: "Coulomb's constant. Deprecated in favor of coulombConstant",
    examples: ["coulombConstant"]
  },
  coulombConstant: {
    description: "Coulomb's constant",
    examples: ["coulombConstant"]
  },
  elementaryCharge: {
    description: "Elementary charge",
    examples: ["elementaryCharge"]
  },
  bohrMagneton: { description: "Bohr magneton", examples: ["bohrMagneton"] },
  conductanceQuantum: {
    description: "Conductance quantum",
    examples: ["conductanceQuantum"]
  },
  inverseConductanceQuantum: {
    description: "Inverse conductance quantum",
    examples: ["inverseConductanceQuantum"]
  },
  // josephson: {description: 'Josephson constant', examples: ['josephson']},
  magneticFluxQuantum: {
    description: "Magnetic flux quantum",
    examples: ["magneticFluxQuantum"]
  },
  nuclearMagneton: {
    description: "Nuclear magneton",
    examples: ["nuclearMagneton"]
  },
  klitzing: { description: "Von Klitzing constant", examples: ["klitzing"] },
  bohrRadius: { description: "Bohr radius", examples: ["bohrRadius"] },
  classicalElectronRadius: {
    description: "Classical electron radius",
    examples: ["classicalElectronRadius"]
  },
  electronMass: { description: "Electron mass", examples: ["electronMass"] },
  fermiCoupling: {
    description: "Fermi coupling constant",
    examples: ["fermiCoupling"]
  },
  fineStructure: {
    description: "Fine-structure constant",
    examples: ["fineStructure"]
  },
  hartreeEnergy: { description: "Hartree energy", examples: ["hartreeEnergy"] },
  protonMass: { description: "Proton mass", examples: ["protonMass"] },
  deuteronMass: { description: "Deuteron Mass", examples: ["deuteronMass"] },
  neutronMass: { description: "Neutron mass", examples: ["neutronMass"] },
  quantumOfCirculation: {
    description: "Quantum of circulation",
    examples: ["quantumOfCirculation"]
  },
  rydberg: { description: "Rydberg constant", examples: ["rydberg"] },
  thomsonCrossSection: {
    description: "Thomson cross section",
    examples: ["thomsonCrossSection"]
  },
  weakMixingAngle: {
    description: "Weak mixing angle",
    examples: ["weakMixingAngle"]
  },
  efimovFactor: { description: "Efimov factor", examples: ["efimovFactor"] },
  atomicMass: { description: "Atomic mass constant", examples: ["atomicMass"] },
  avogadro: { description: "Avogadro's number", examples: ["avogadro"] },
  boltzmann: { description: "Boltzmann constant", examples: ["boltzmann"] },
  faraday: { description: "Faraday constant", examples: ["faraday"] },
  firstRadiation: {
    description: "First radiation constant",
    examples: ["firstRadiation"]
  },
  loschmidt: {
    description: "Loschmidt constant at T=273.15 K and p=101.325 kPa",
    examples: ["loschmidt"]
  },
  gasConstant: { description: "Gas constant", examples: ["gasConstant"] },
  molarPlanckConstant: {
    description: "Molar Planck constant",
    examples: ["molarPlanckConstant"]
  },
  molarVolume: {
    description: "Molar volume of an ideal gas at T=273.15 K and p=101.325 kPa",
    examples: ["molarVolume"]
  },
  sackurTetrode: {
    description: "Sackur-Tetrode constant at T=1 K and p=101.325 kPa",
    examples: ["sackurTetrode"]
  },
  secondRadiation: {
    description: "Second radiation constant",
    examples: ["secondRadiation"]
  },
  stefanBoltzmann: {
    description: "Stefan-Boltzmann constant",
    examples: ["stefanBoltzmann"]
  },
  wienDisplacement: {
    description: "Wien displacement law constant",
    examples: ["wienDisplacement"]
  },
  // spectralRadiance: {description: 'First radiation constant for spectral radiance', examples: ['spectralRadiance']},
  molarMass: { description: "Molar mass constant", examples: ["molarMass"] },
  molarMassC12: {
    description: "Molar mass constant of carbon-12",
    examples: ["molarMassC12"]
  },
  gravity: {
    description: "Standard acceleration of gravity (standard acceleration of free-fall on Earth)",
    examples: ["gravity"]
  },
  planckLength: { description: "Planck length", examples: ["planckLength"] },
  planckMass: { description: "Planck mass", examples: ["planckMass"] },
  planckTime: { description: "Planck time", examples: ["planckTime"] },
  planckCharge: { description: "Planck charge", examples: ["planckCharge"] },
  planckTemperature: {
    description: "Planck temperature",
    examples: ["planckTemperature"]
  },
  // functions - algebra
  derivative: derivativeDocs,
  lsolve: lsolveDocs,
  lsolveAll: lsolveAllDocs,
  lup: lupDocs,
  lusolve: lusolveDocs,
  leafCount: leafCountDocs,
  polynomialRoot: polynomialRootDocs,
  resolve: resolveDocs,
  simplify: simplifyDocs,
  simplifyConstant: simplifyConstantDocs,
  simplifyCore: simplifyCoreDocs,
  symbolicEqual: symbolicEqualDocs,
  rationalize: rationalizeDocs,
  slu: sluDocs,
  usolve: usolveDocs,
  usolveAll: usolveAllDocs,
  qr: qrDocs,
  // functions - arithmetic
  abs: absDocs,
  add: addDocs,
  cbrt: cbrtDocs,
  ceil: ceilDocs,
  cube: cubeDocs,
  divide: divideDocs,
  dotDivide: dotDivideDocs,
  dotMultiply: dotMultiplyDocs,
  dotPow: dotPowDocs,
  exp: expDocs,
  expm: expmDocs,
  expm1: expm1Docs,
  fix: fixDocs,
  floor: floorDocs,
  gcd: gcdDocs,
  hypot: hypotDocs,
  lcm: lcmDocs,
  log: logDocs,
  log2: log2Docs,
  log1p: log1pDocs,
  log10: log10Docs,
  mod: modDocs,
  multiply: multiplyDocs,
  norm: normDocs,
  nthRoot: nthRootDocs,
  nthRoots: nthRootsDocs,
  pow: powDocs,
  round: roundDocs,
  sign: signDocs,
  sqrt: sqrtDocs,
  sqrtm: sqrtmDocs,
  square: squareDocs,
  subtract: subtractDocs,
  unaryMinus: unaryMinusDocs,
  unaryPlus: unaryPlusDocs,
  xgcd: xgcdDocs,
  invmod: invmodDocs,
  // functions - bitwise
  bitAnd: bitAndDocs,
  bitNot: bitNotDocs,
  bitOr: bitOrDocs,
  bitXor: bitXorDocs,
  leftShift: leftShiftDocs,
  rightArithShift: rightArithShiftDocs,
  rightLogShift: rightLogShiftDocs,
  // functions - combinatorics
  bellNumbers: bellNumbersDocs,
  catalan: catalanDocs,
  composition: compositionDocs,
  stirlingS2: stirlingS2Docs,
  // functions - core
  config: configDocs,
  import: importDocs,
  typed: typedDocs,
  // functions - complex
  arg: argDocs,
  conj: conjDocs,
  re: reDocs,
  im: imDocs,
  // functions - expression
  evaluate: evaluateDocs,
  help: helpDocs,
  parse: parseDocs,
  parser: parserDocs,
  compile: compileDocs,
  // functions - geometry
  distance: distanceDocs,
  intersect: intersectDocs,
  // functions - logical
  and: andDocs,
  not: notDocs,
  nullish: nullishDocs,
  or: orDocs,
  xor: xorDocs,
  // functions - matrix
  mapSlices: mapSlicesDocs,
  concat: concatDocs,
  count: countDocs,
  cross: crossDocs,
  column: columnDocs,
  ctranspose: ctransposeDocs,
  det: detDocs,
  diag: diagDocs,
  diff: diffDocs,
  dot: dotDocs,
  getMatrixDataType: getMatrixDataTypeDocs,
  identity: identityDocs,
  filter: filterDocs,
  flatten: flattenDocs,
  forEach: forEachDocs,
  inv: invDocs,
  pinv: pinvDocs,
  eigs: eigsDocs,
  kron: kronDocs,
  matrixFromFunction: matrixFromFunctionDocs,
  matrixFromRows: matrixFromRowsDocs,
  matrixFromColumns: matrixFromColumnsDocs,
  map: mapDocs,
  ones: onesDocs,
  partitionSelect: partitionSelectDocs,
  range: rangeDocs,
  resize: resizeDocs,
  reshape: reshapeDocs,
  rotate: rotateDocs,
  rotationMatrix: rotationMatrixDocs,
  row: rowDocs,
  size: sizeDocs,
  sort: sortDocs,
  squeeze: squeezeDocs,
  subset: subsetDocs,
  trace: traceDocs,
  transpose: transposeDocs,
  zeros: zerosDocs,
  fft: fftDocs,
  ifft: ifftDocs,
  sylvester: sylvesterDocs,
  schur: schurDocs,
  lyap: lyapDocs,
  // functions - numeric
  solveODE: solveODEDocs,
  // functions - probability
  bernoulli: bernoulliDocs,
  combinations: combinationsDocs,
  combinationsWithRep: combinationsWithRepDocs,
  // distribution: distributionDocs,
  factorial: factorialDocs,
  gamma: gammaDocs,
  kldivergence: kldivergenceDocs,
  lgamma: lgammaDocs,
  multinomial: multinomialDocs,
  permutations: permutationsDocs,
  pickRandom: pickRandomDocs,
  random: randomDocs,
  randomInt: randomIntDocs,
  // functions - relational
  compare: compareDocs,
  compareNatural: compareNaturalDocs,
  compareText: compareTextDocs,
  deepEqual: deepEqualDocs,
  equal: equalDocs,
  equalText: equalTextDocs,
  larger: largerDocs,
  largerEq: largerEqDocs,
  smaller: smallerDocs,
  smallerEq: smallerEqDocs,
  unequal: unequalDocs,
  // functions - set
  setCartesian: setCartesianDocs,
  setDifference: setDifferenceDocs,
  setDistinct: setDistinctDocs,
  setIntersect: setIntersectDocs,
  setIsSubset: setIsSubsetDocs,
  setMultiplicity: setMultiplicityDocs,
  setPowerset: setPowersetDocs,
  setSize: setSizeDocs,
  setSymDifference: setSymDifferenceDocs,
  setUnion: setUnionDocs,
  // functions - signal
  zpk2tf: zpk2tfDocs,
  freqz: freqzDocs,
  // functions - special
  erf: erfDocs,
  zeta: zetaDocs,
  // functions - statistics
  cumsum: cumSumDocs,
  mad: madDocs,
  max: maxDocs,
  mean: meanDocs,
  median: medianDocs,
  min: minDocs,
  mode: modeDocs,
  prod: prodDocs,
  quantileSeq: quantileSeqDocs,
  std: stdDocs,
  sum: sumDocs,
  variance: varianceDocs,
  corr: corrDocs,
  // functions - trigonometry
  acos: acosDocs,
  acosh: acoshDocs,
  acot: acotDocs,
  acoth: acothDocs,
  acsc: acscDocs,
  acsch: acschDocs,
  asec: asecDocs,
  asech: asechDocs,
  asin: asinDocs,
  asinh: asinhDocs,
  atan: atanDocs,
  atanh: atanhDocs,
  atan2: atan2Docs,
  cos: cosDocs,
  cosh: coshDocs,
  cot: cotDocs,
  coth: cothDocs,
  csc: cscDocs,
  csch: cschDocs,
  sec: secDocs,
  sech: sechDocs,
  sin: sinDocs,
  sinh: sinhDocs,
  tan: tanDocs,
  tanh: tanhDocs,
  // functions - units
  to: toDocs,
  toBest: toBestDocs,
  // functions - utils
  clone: cloneDocs,
  format: formatDocs,
  bin: binDocs,
  oct: octDocs,
  hex: hexDocs,
  isNaN: isNaNDocs,
  isBounded: isBoundedDocs,
  isFinite: isFiniteDocs,
  isInteger: isIntegerDocs,
  isNegative: isNegativeDocs,
  isNumeric: isNumericDocs,
  hasNumericValue: hasNumericValueDocs,
  isPositive: isPositiveDocs,
  isPrime: isPrimeDocs,
  isZero: isZeroDocs,
  print: printDocs,
  typeOf: typeOfDocs,
  numeric: numericDocs
};

// src/expression/function/help.ts
var name245 = "help";
var dependencies246 = ["typed", "mathWithTransform", "Help"];
var createHelp = /* @__PURE__ */ factory(
  name245,
  dependencies246,
  ({
    typed: typed2,
    mathWithTransform,
    Help
  }) => {
    return typed2(name245, {
      any: function(search) {
        let prop;
        let searchName = search;
        if (typeof search !== "string") {
          for (prop in mathWithTransform) {
            if (hasOwnProperty(mathWithTransform, prop) && search === mathWithTransform[prop]) {
              searchName = prop;
              break;
            }
          }
        }
        const doc = getSafeProperty(embeddedDocs, searchName);
        if (!doc) {
          const searchText = typeof searchName === "function" ? searchName.name : searchName;
          throw new Error('No documentation found on "' + searchText + '"');
        }
        return new Help(doc);
      }
    });
  }
);

// src/type/chain/function/chain.ts
var name246 = "chain";
var dependencies247 = ["typed", "Chain"];
var createChain = /* @__PURE__ */ factory(
  name246,
  dependencies247,
  ({ typed: typed2, Chain }) => {
    return typed2(name246, {
      "": function() {
        return new Chain();
      },
      any: function(value) {
        return new Chain(value);
      }
    });
  }
);

// src/function/matrix/det.ts
var WASM_DET_THRESHOLD = 16;
function isPlainNumberMatrix7(matrix) {
  for (let i = 0; i < matrix.length; i++) {
    const row = matrix[i];
    for (let j = 0; j < row.length; j++) {
      if (typeof row[j] !== "number") {
        return false;
      }
    }
  }
  return true;
}
function flattenToFloat647(matrix, rows, cols) {
  const result = new Float64Array(rows * cols);
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      result[i * cols + j] = matrix[i][j];
    }
  }
  return result;
}
var name247 = "det";
var dependencies248 = [
  "typed",
  "matrix",
  "subtractScalar",
  "multiply",
  "divideScalar",
  "isZero",
  "unaryMinus"
];
var createDet = /* @__PURE__ */ factory(
  name247,
  dependencies248,
  ({
    typed: typed2,
    matrix,
    subtractScalar,
    multiply,
    divideScalar,
    isZero,
    unaryMinus
  }) => {
    return typed2(name247, {
      any: function(x) {
        return clone(x);
      },
      "Array | Matrix": function det(x) {
        let size;
        let matrixValue;
        if (isMatrix(x)) {
          matrixValue = x;
          size = matrixValue.size();
        } else if (Array.isArray(x)) {
          matrixValue = matrix(x);
          size = matrixValue.size();
        } else {
          return clone(x);
        }
        switch (size.length) {
          case 0:
            return clone(x);
          case 1:
            if (size[0] === 1) {
              return clone(matrixValue.valueOf()[0]);
            }
            if (size[0] === 0) {
              return 1;
            } else {
              throw new RangeError(
                "Matrix must be square (size: " + format3(size, {}) + ")"
              );
            }
          case 2: {
            const rows = size[0];
            const cols = size[1];
            if (rows === cols) {
              return _det(matrixValue.clone().valueOf(), rows);
            }
            if (cols === 0) {
              return 1;
            } else {
              throw new RangeError(
                "Matrix must be square (size: " + format3(size, {}) + ")"
              );
            }
          }
          default:
            throw new RangeError(
              "Matrix must be two dimensional (size: " + format3(size, {}) + ")"
            );
        }
      }
    });
    function _det(matrix2, rows, _cols) {
      const wasm = wasmLoader.getModule();
      if (wasm && rows * rows >= WASM_DET_THRESHOLD && isPlainNumberMatrix7(matrix2)) {
        try {
          const flat = flattenToFloat647(matrix2, rows, rows);
          const a = wasmLoader.allocateFloat64Array(flat);
          const work = wasmLoader.allocateFloat64ArrayEmpty(rows * rows);
          try {
            const result = wasm.laDet(a.ptr, rows, work.ptr);
            return result;
          } finally {
            wasmLoader.free(a.ptr);
            wasmLoader.free(work.ptr);
          }
        } catch {
        }
      }
      if (rows === 1) {
        return clone(matrix2[0][0]);
      } else if (rows === 2) {
        return subtractScalar(
          multiply(matrix2[0][0], matrix2[1][1]),
          multiply(matrix2[1][0], matrix2[0][1])
        );
      } else {
        let negated = false;
        const rowIndices = [];
        for (let i = 0; i < rows; i++) {
          rowIndices[i] = i;
        }
        for (let k = 0; k < rows; k++) {
          let k_ = rowIndices[k];
          if (isZero(matrix2[k_][k])) {
            let _k;
            for (_k = k + 1; _k < rows; _k++) {
              if (!isZero(matrix2[rowIndices[_k]][k])) {
                k_ = rowIndices[_k];
                rowIndices[_k] = rowIndices[k];
                rowIndices[k] = k_;
                negated = !negated;
                break;
              }
            }
            if (_k === rows) return matrix2[k_][k];
          }
          const piv = matrix2[k_][k];
          const piv_ = k === 0 ? 1 : matrix2[rowIndices[k - 1]][k - 1];
          for (let i = k + 1; i < rows; i++) {
            const i_ = rowIndices[i];
            for (let j = k + 1; j < rows; j++) {
              matrix2[i_][j] = divideScalar(
                subtractScalar(
                  multiply(matrix2[i_][j], piv),
                  multiply(matrix2[i_][k], matrix2[k_][j])
                ),
                piv_
              );
            }
          }
        }
        const det = matrix2[rowIndices[rows - 1]][rows - 1];
        return negated ? unaryMinus(det) : det;
      }
    }
  }
);

// src/function/matrix/inv.ts
var WASM_INV_THRESHOLD = 16;
function isPlainNumberMatrix8(matrix) {
  for (let i = 0; i < matrix.length; i++) {
    const row = matrix[i];
    for (let j = 0; j < row.length; j++) {
      if (typeof row[j] !== "number") {
        return false;
      }
    }
  }
  return true;
}
function flattenToFloat648(matrix, rows, cols) {
  const result = new Float64Array(rows * cols);
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      result[i * cols + j] = matrix[i][j];
    }
  }
  return result;
}
var name248 = "inv";
var dependencies249 = [
  "typed",
  "matrix",
  "divideScalar",
  "addScalar",
  "multiply",
  "unaryMinus",
  "det",
  "identity",
  "abs"
];
var createInv = /* @__PURE__ */ factory(
  name248,
  dependencies249,
  ({
    typed: typed2,
    matrix,
    divideScalar,
    addScalar,
    multiply,
    unaryMinus,
    det,
    identity,
    abs
  }) => {
    return typed2(name248, {
      "Array | Matrix": function(x) {
        const size = isMatrix(x) ? x.size() : arraySize(x);
        switch (size.length) {
          case 1:
            if (size[0] === 1) {
              if (isMatrix(x)) {
                const matX = x;
                return matrix([divideScalar(1, matX.valueOf()[0])]);
              } else {
                return [divideScalar(1, x[0])];
              }
            } else {
              throw new RangeError(
                "Matrix must be square (size: " + format3(size, {}) + ")"
              );
            }
          case 2: {
            const rows = size[0];
            const cols = size[1];
            if (rows === cols) {
              if (isMatrix(x)) {
                const matX = x;
                const storage = matX.storage();
                return matrix(
                  _inv(matX.valueOf(), rows, cols),
                  storage
                );
              } else {
                return _inv(x, rows, cols);
              }
            } else {
              throw new RangeError(
                "Matrix must be square (size: " + format3(size, {}) + ")"
              );
            }
          }
          default:
            throw new RangeError(
              "Matrix must be two dimensional (size: " + format3(size, {}) + ")"
            );
        }
      },
      any: function(x) {
        return divideScalar(1, x);
      }
    });
    function _inv(mat, rows, cols) {
      let r, s, f, value, temp;
      const wasm = wasmLoader.getModule();
      if (wasm && rows >= 3 && rows * rows >= WASM_INV_THRESHOLD && isPlainNumberMatrix8(mat)) {
        try {
          const flat = flattenToFloat648(mat, rows, rows);
          const input = wasmLoader.allocateFloat64Array(flat);
          const result = wasmLoader.allocateFloat64ArrayEmpty(rows * rows);
          const work = wasmLoader.allocateFloat64ArrayEmpty(rows * 2 * rows);
          try {
            const success = wasm.laInv(input.ptr, rows, result.ptr, work.ptr);
            if (success === 0) {
              throw Error("Cannot calculate inverse, determinant is zero");
            }
            const invMatrix = [];
            for (let i = 0; i < rows; i++) {
              const row = [];
              for (let j = 0; j < rows; j++) {
                row[j] = result.array[i * rows + j];
              }
              invMatrix[i] = row;
            }
            return invMatrix;
          } finally {
            wasmLoader.free(input.ptr);
            wasmLoader.free(result.ptr);
            wasmLoader.free(work.ptr);
          }
        } catch (e2) {
          if (e2 instanceof Error && e2.message.includes("determinant is zero")) {
            throw e2;
          }
        }
      }
      if (rows === 1) {
        value = mat[0][0];
        if (value === 0) {
          throw Error("Cannot calculate inverse, determinant is zero");
        }
        return [[divideScalar(1, value)]];
      } else if (rows === 2) {
        const d = det(mat);
        if (d === 0) {
          throw Error("Cannot calculate inverse, determinant is zero");
        }
        return [
          [divideScalar(mat[1][1], d), divideScalar(unaryMinus(mat[0][1]), d)],
          [divideScalar(unaryMinus(mat[1][0]), d), divideScalar(mat[0][0], d)]
        ];
      } else {
        const A = mat.concat();
        for (r = 0; r < rows; r++) {
          A[r] = A[r].concat();
        }
        const B = identity(rows).valueOf();
        for (let c = 0; c < cols; c++) {
          let ABig = abs(A[c][c]);
          let rBig = c;
          r = c + 1;
          while (r < rows) {
            if (abs(A[r][c]) > ABig) {
              ABig = abs(A[r][c]);
              rBig = r;
            }
            r++;
          }
          if (ABig === 0) {
            throw Error("Cannot calculate inverse, determinant is zero");
          }
          r = rBig;
          if (r !== c) {
            temp = A[c];
            A[c] = A[r];
            A[r] = temp;
            temp = B[c];
            B[c] = B[r];
            B[r] = temp;
          }
          const Ac = A[c];
          const Bc = B[c];
          for (r = 0; r < rows; r++) {
            const Ar = A[r];
            const Br = B[r];
            if (r !== c) {
              if (Ar[c] !== 0) {
                f = divideScalar(unaryMinus(Ar[c]), Ac[c]);
                for (s = c; s < cols; s++) {
                  Ar[s] = addScalar(Ar[s], multiply(f, Ac[s]));
                }
                for (s = 0; s < cols; s++) {
                  Br[s] = addScalar(Br[s], multiply(f, Bc[s]));
                }
              }
            } else {
              f = Ac[c];
              for (s = c; s < cols; s++) {
                Ar[s] = divideScalar(Ar[s], f);
              }
              for (s = 0; s < cols; s++) {
                Br[s] = divideScalar(Br[s], f);
              }
            }
          }
        }
        return B;
      }
    }
  }
);

// src/function/matrix/pinv.ts
var name249 = "pinv";
var dependencies250 = [
  "typed",
  "matrix",
  "inv",
  "deepEqual",
  "equal",
  "dotDivide",
  "dot",
  "ctranspose",
  "divideScalar",
  "multiply",
  "add",
  "Complex"
];
var createPinv = /* @__PURE__ */ factory(
  name249,
  dependencies250,
  ({
    typed: typed2,
    matrix,
    inv,
    deepEqual,
    equal,
    dotDivide,
    dot,
    ctranspose,
    divideScalar,
    multiply,
    add,
    Complex: Complex2
  }) => {
    return typed2(name249, {
      "Array | Matrix": function(x) {
        const size = isMatrix(x) ? x.size() : arraySize(x);
        switch (size.length) {
          case 1:
            if (_isZeros(x)) return ctranspose(x);
            if (size[0] === 1) {
              return inv(x);
            } else {
              return dotDivide(ctranspose(x), dot(x, x));
            }
          case 2: {
            if (_isZeros(x)) return ctranspose(x);
            const rows = size[0];
            const cols = size[1];
            if (rows === cols) {
              try {
                return inv(x);
              } catch (err) {
                if (err instanceof Error && err.message.match(
                  /Cannot calculate inverse, determinant is zero/
                )) ; else {
                  throw err;
                }
              }
            }
            if (isMatrix(x)) {
              const matX = x;
              return matrix(
                _pinv(matX.valueOf(), rows, cols),
                matX.storage()
              );
            } else {
              return _pinv(x, rows, cols);
            }
          }
          default:
            throw new RangeError(
              "Matrix must be two dimensional (size: " + format3(size, {}) + ")"
            );
        }
      },
      any: function(x) {
        if (equal(x, 0)) return clone(x);
        return divideScalar(1, x);
      }
    });
    function _pinv(mat, rows, cols) {
      const { C, F } = _rankFact(mat, rows, cols);
      const Cpinv = multiply(inv(multiply(ctranspose(C), C)), ctranspose(C));
      const Fpinv = multiply(ctranspose(F), inv(multiply(F, ctranspose(F))));
      return multiply(Fpinv, Cpinv);
    }
    function _rref(mat, rows, cols) {
      const M = clone(mat);
      let lead = 0;
      for (let r = 0; r < rows; r++) {
        if (cols <= lead) {
          return M;
        }
        let i = r;
        while (_isZero(M[i][lead])) {
          i++;
          if (rows === i) {
            i = r;
            lead++;
            if (cols === lead) {
              return M;
            }
          }
        }
        [M[i], M[r]] = [M[r], M[i]];
        let val = M[r][lead];
        for (let j = 0; j < cols; j++) {
          M[r][j] = dotDivide(M[r][j], val);
        }
        for (let i2 = 0; i2 < rows; i2++) {
          if (i2 === r) continue;
          val = M[i2][lead];
          for (let j = 0; j < cols; j++) {
            M[i2][j] = add(M[i2][j], multiply(-1, multiply(val, M[r][j])));
          }
        }
        lead++;
      }
      return M;
    }
    function _rankFact(mat, rows, cols) {
      const rref = _rref(mat, rows, cols);
      const C = mat.map(
        (row) => row.filter((_, j) => j < rows && !_isZero(dot(rref[j], rref[j])))
      );
      const F = rref.filter((_, i) => !_isZero(dot(rref[i], rref[i])));
      return { C, F };
    }
    function _isZero(x) {
      return equal(add(x, Complex2(1, 1)), add(0, Complex2(1, 1)));
    }
    function _isZeros(arr) {
      return deepEqual(
        add(arr, Complex2(1, 1)),
        add(multiply(arr, 0), Complex2(1, 1))
      );
    }
  }
);

// src/function/matrix/eigs/complexEigs.ts
var WASM_EIGS_THRESHOLD = 16;
function flattenToFloat649(matrix, rows, cols) {
  const result = new Float64Array(rows * cols);
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      result[i * cols + j] = matrix[i][j];
    }
  }
  return result;
}
function createComplexEigs({
  addScalar,
  subtract,
  flatten: flatten2,
  multiply,
  multiplyScalar,
  divideScalar,
  sqrt,
  abs,
  bignumber,
  diag,
  size,
  reshape: reshape2,
  inv,
  qr,
  usolve,
  usolveAll,
  equal,
  complex,
  larger,
  smaller,
  matrixFromColumns: _matrixFromColumns,
  dot
}) {
  function complexEigs(arr, N, prec, type, findVectors = true) {
    if (!findVectors && type === "number" && N * N >= WASM_EIGS_THRESHOLD) {
      const wasm = wasmLoader.getModule();
      if (wasm) {
        try {
          const flat = flattenToFloat649(arr, N, N);
          const matrixAlloc = wasmLoader.allocateFloat64Array(flat);
          const eigenvaluesRealAlloc = wasmLoader.allocateFloat64ArrayEmpty(N);
          const eigenvaluesImagAlloc = wasmLoader.allocateFloat64ArrayEmpty(N);
          const workAlloc = wasmLoader.allocateFloat64ArrayEmpty(N * N);
          try {
            const iterations = wasm.qrAlgorithm(
              matrixAlloc.ptr,
              N,
              eigenvaluesRealAlloc.ptr,
              eigenvaluesImagAlloc.ptr,
              workAlloc.ptr,
              1e3,
              // maxIterations
              typeof prec === "number" ? prec : 1e-12
            );
            if (iterations >= 0) {
              const values2 = [];
              for (let i = 0; i < N; i++) {
                const re = eigenvaluesRealAlloc.array[i];
                const im = eigenvaluesImagAlloc.array[i];
                if (Math.abs(im) < 1e-14) {
                  values2.push(re);
                } else {
                  values2.push(complex(re, im));
                }
              }
              values2.sort((a, b) => {
                const absA = typeof a === "number" ? Math.abs(a) : Math.sqrt(a.re ** 2 + a.im ** 2);
                const absB = typeof b === "number" ? Math.abs(b) : Math.sqrt(b.re ** 2 + b.im ** 2);
                return absA - absB;
              });
              return { values: values2 };
            }
          } finally {
            wasmLoader.free(matrixAlloc.ptr);
            wasmLoader.free(eigenvaluesRealAlloc.ptr);
            wasmLoader.free(eigenvaluesImagAlloc.ptr);
            wasmLoader.free(workAlloc.ptr);
          }
        } catch (e2) {
        }
      }
    }
    const R = balance(arr, N, prec, type, findVectors);
    reduceToHessenberg(arr, N, prec, type, findVectors, R);
    const { values, C } = iterateUntilTriangular(
      arr,
      N,
      prec,
      type,
      findVectors
    );
    if (findVectors) {
      const eigenvectors = findEigenvectors(arr, N, C, R, values, prec, type);
      return { values, eigenvectors };
    }
    return { values };
  }
  function balance(arr, N, prec, type, findVectors) {
    const big = type === "BigNumber";
    const cplx = type === "Complex";
    const realzero = big ? bignumber(0) : 0;
    const one = big ? bignumber(1) : cplx ? complex(1) : 1;
    const realone = big ? bignumber(1) : 1;
    const radix = big ? bignumber(10) : 2;
    const radixSq = multiplyScalar(radix, radix);
    let Rdiag;
    if (findVectors) {
      Rdiag = Array(N).fill(one);
    }
    let last = false;
    while (!last) {
      last = true;
      for (let i = 0; i < N; i++) {
        let colNorm = realzero;
        let rowNorm = realzero;
        for (let j = 0; j < N; j++) {
          if (i === j) continue;
          colNorm = addScalar(colNorm, abs(arr[j][i]));
          rowNorm = addScalar(rowNorm, abs(arr[i][j]));
        }
        if (!equal(colNorm, 0) && !equal(rowNorm, 0)) {
          let f = realone;
          let c = colNorm;
          const rowDivRadix = divideScalar(rowNorm, radix);
          const rowMulRadix = multiplyScalar(rowNorm, radix);
          while (smaller(c, rowDivRadix)) {
            c = multiplyScalar(c, radixSq);
            f = multiplyScalar(f, radix);
          }
          while (larger(c, rowMulRadix)) {
            c = divideScalar(c, radixSq);
            f = divideScalar(f, radix);
          }
          const condition = smaller(
            divideScalar(addScalar(c, rowNorm), f),
            multiplyScalar(addScalar(colNorm, rowNorm), 0.95)
          );
          if (condition) {
            last = false;
            const g = divideScalar(1, f);
            for (let j = 0; j < N; j++) {
              if (i === j) {
                continue;
              }
              arr[i][j] = multiplyScalar(arr[i][j], g);
              arr[j][i] = multiplyScalar(arr[j][i], f);
            }
            if (findVectors) {
              Rdiag[i] = multiplyScalar(Rdiag[i], g);
            }
          }
        }
      }
    }
    return findVectors ? diag(Rdiag) : null;
  }
  function reduceToHessenberg(arr, N, prec, type, findVectors, R) {
    const big = type === "BigNumber";
    const cplx = type === "Complex";
    const zero = big ? bignumber(0) : cplx ? complex(0) : 0;
    if (big) {
      prec = bignumber(prec);
    }
    for (let i = 0; i < N - 2; i++) {
      let maxIndex = 0;
      let max = zero;
      for (let j = i + 1; j < N; j++) {
        const el = arr[j][i];
        if (smaller(abs(max), abs(el))) {
          max = el;
          maxIndex = j;
        }
      }
      if (smaller(abs(max), prec)) {
        continue;
      }
      if (maxIndex !== i + 1) {
        const tmp1 = arr[maxIndex];
        arr[maxIndex] = arr[i + 1];
        arr[i + 1] = tmp1;
        for (let j = 0; j < N; j++) {
          const tmp2 = arr[j][maxIndex];
          arr[j][maxIndex] = arr[j][i + 1];
          arr[j][i + 1] = tmp2;
        }
        if (findVectors) {
          const tmp3 = R[maxIndex];
          R[maxIndex] = R[i + 1];
          R[i + 1] = tmp3;
        }
      }
      for (let j = i + 2; j < N; j++) {
        const n = divideScalar(arr[j][i], max);
        if (n === 0) {
          continue;
        }
        for (let k = 0; k < N; k++) {
          arr[j][k] = subtract(arr[j][k], multiplyScalar(n, arr[i + 1][k]));
        }
        for (let k = 0; k < N; k++) {
          arr[k][i + 1] = addScalar(arr[k][i + 1], multiplyScalar(n, arr[k][j]));
        }
        if (findVectors) {
          for (let k = 0; k < N; k++) {
            R[j][k] = subtract(R[j][k], multiplyScalar(n, R[i + 1][k]));
          }
        }
      }
    }
  }
  function iterateUntilTriangular(A, N, prec, type, findVectors) {
    const big = type === "BigNumber";
    const cplx = type === "Complex";
    const one = big ? bignumber(1) : cplx ? complex(1) : 1;
    if (big) {
      prec = bignumber(prec);
    }
    let arr = clone(A);
    const lambdas = [];
    let n = N;
    const Sdiag = [];
    let Qtotal = findVectors ? diag(Array(N).fill(one)) : void 0;
    let Qpartial = findVectors ? diag(Array(n).fill(one)) : void 0;
    let lastConvergenceBefore = 0;
    while (lastConvergenceBefore <= 100) {
      lastConvergenceBefore += 1;
      const k = arr[n - 1][n - 1];
      for (let i = 0; i < n; i++) {
        arr[i][i] = subtract(arr[i][i], k);
      }
      const { Q: Q2, R } = qr(arr);
      arr = multiply(R, Q2);
      for (let i = 0; i < n; i++) {
        arr[i][i] = addScalar(arr[i][i], k);
      }
      if (findVectors) {
        Qpartial = multiply(Qpartial, Q2);
      }
      if (n === 1 || smaller(abs(arr[n - 1][n - 2]), prec)) {
        lastConvergenceBefore = 0;
        lambdas.push(arr[n - 1][n - 1]);
        if (findVectors) {
          Sdiag.unshift([[1]]);
          inflateMatrix(Qpartial, N);
          Qtotal = multiply(Qtotal, Qpartial);
          if (n > 1) {
            Qpartial = diag(Array(n - 1).fill(one));
          }
        }
        n -= 1;
        arr.pop();
        for (let i = 0; i < n; i++) {
          arr[i].pop();
        }
      } else if (n === 2 || smaller(abs(arr[n - 2][n - 3]), prec)) {
        lastConvergenceBefore = 0;
        const ll = eigenvalues2x2(
          arr[n - 2][n - 2],
          arr[n - 2][n - 1],
          arr[n - 1][n - 2],
          arr[n - 1][n - 1]
        );
        lambdas.push(...ll);
        if (findVectors) {
          Sdiag.unshift(
            jordanBase2x2(
              arr[n - 2][n - 2],
              arr[n - 2][n - 1],
              arr[n - 1][n - 2],
              arr[n - 1][n - 1],
              ll[0],
              ll[1],
              prec,
              type
            )
          );
          inflateMatrix(Qpartial, N);
          Qtotal = multiply(Qtotal, Qpartial);
          if (n > 2) {
            Qpartial = diag(Array(n - 2).fill(one));
          }
        }
        n -= 2;
        arr.pop();
        arr.pop();
        for (let i = 0; i < n; i++) {
          arr[i].pop();
          arr[i].pop();
        }
      }
      if (n === 0) {
        break;
      }
    }
    lambdas.sort((a, b) => +subtract(abs(a), abs(b)));
    if (lastConvergenceBefore > 100) {
      const err = new Error(
        "The eigenvalues failed to converge. Only found these eigenvalues: " + lambdas.join(", ")
      );
      err.values = lambdas;
      err.vectors = [];
      throw err;
    }
    const C = findVectors ? multiply(Qtotal, blockDiag(Sdiag, N)) : void 0;
    return { values: lambdas, C };
  }
  function findEigenvectors(A, N, C, R, values, prec, type) {
    const Cinv = inv(C);
    const U = multiply(Cinv, A, C);
    const big = type === "BigNumber";
    const cplx = type === "Complex";
    const zero = big ? bignumber(0) : cplx ? complex(0) : 0;
    const one = big ? bignumber(1) : cplx ? complex(1) : 1;
    const uniqueValues = [];
    const multiplicities = [];
    for (const lambda of values) {
      const i = indexOf(uniqueValues, lambda, equal);
      if (i === -1) {
        uniqueValues.push(lambda);
        multiplicities.push(1);
      } else {
        multiplicities[i] += 1;
      }
    }
    const vectors = [];
    const len = uniqueValues.length;
    const b = Array(N).fill(zero);
    const E = diag(Array(N).fill(one));
    for (let i = 0; i < len; i++) {
      const lambda = uniqueValues[i];
      const S = subtract(U, multiply(lambda, E));
      let solutions = usolveAll(S, b);
      solutions.shift();
      while (solutions.length < multiplicities[i]) {
        const approxVec = inverseIterate(S, N, solutions, prec, type);
        if (approxVec === null) {
          break;
        }
        solutions.push(approxVec);
      }
      const correction = multiply(inv(R), C);
      solutions = solutions.map((v) => multiply(correction, v));
      vectors.push(
        ...solutions.map((v) => ({ value: lambda, vector: flatten2(v) }))
      );
    }
    return vectors;
  }
  function eigenvalues2x2(a, b, c, d) {
    const trA = addScalar(a, d);
    const detA = subtract(multiplyScalar(a, d), multiplyScalar(b, c));
    const x = multiplyScalar(trA, 0.5);
    const y = multiplyScalar(
      sqrt(subtract(multiplyScalar(trA, trA), multiplyScalar(4, detA))),
      0.5
    );
    return [addScalar(x, y), subtract(x, y)];
  }
  function jordanBase2x2(a, b, c, d, l1, l2, prec, type) {
    const big = type === "BigNumber";
    const cplx = type === "Complex";
    const zero = big ? bignumber(0) : cplx ? complex(0) : 0;
    const one = big ? bignumber(1) : cplx ? complex(1) : 1;
    if (smaller(abs(c), prec)) {
      return [
        [one, zero],
        [zero, one]
      ];
    }
    if (larger(abs(subtract(l1, l2)), prec)) {
      return [
        [subtract(l1, d), subtract(l2, d)],
        [c, c]
      ];
    }
    const na = subtract(a, l1);
    const nd = subtract(d, l1);
    if (smaller(abs(b), prec) && smaller(abs(nd), prec)) {
      return [
        [na, one],
        [c, zero]
      ];
    } else {
      return [
        [b, zero],
        [nd, one]
      ];
    }
  }
  function inflateMatrix(arr, N) {
    for (let i = 0; i < arr.length; i++) {
      arr[i].push(...Array(N - arr[i].length).fill(0));
    }
    for (let i = arr.length; i < N; i++) {
      arr.push(Array(N).fill(0));
      arr[i][i] = 1;
    }
    return arr;
  }
  function blockDiag(arr, N) {
    const M = [];
    for (let i = 0; i < N; i++) {
      M[i] = Array(N).fill(0);
    }
    let I = 0;
    for (const sub of arr) {
      const n = sub.length;
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          M[I + i][I + j] = sub[i][j];
        }
      }
      I += n;
    }
    return M;
  }
  function indexOf(arr, el, fn) {
    for (let i = 0; i < arr.length; i++) {
      if (fn(arr[i], el)) {
        return i;
      }
    }
    return -1;
  }
  function inverseIterate(A, N, orthog, prec, type) {
    const largeNum = type === "BigNumber" ? bignumber(1e3) : 1e3;
    let b;
    let i = 0;
    for (; i < 5; ++i) {
      b = randomOrthogonalVector(N, orthog, type);
      try {
        b = usolve(A, b);
      } catch {
        continue;
      }
      if (larger(norm(b), largeNum)) {
        break;
      }
    }
    if (i >= 5) {
      return null;
    }
    i = 0;
    while (true) {
      const c = usolve(A, b);
      if (smaller(norm(orthogonalComplement(b, [c])), prec)) {
        break;
      }
      if (++i >= 10) {
        return null;
      }
      b = normalize(c, type);
    }
    return b;
  }
  function randomOrthogonalVector(N, orthog, type) {
    const big = type === "BigNumber";
    const cplx = type === "Complex";
    let v = Array(N).fill(0).map(() => 2 * Math.random() - 1);
    if (big) {
      v = v.map((n) => bignumber(n));
    }
    if (cplx) {
      v = v.map((n) => complex(n));
    }
    v = orthogonalComplement(v, orthog);
    return normalize(v, type);
  }
  function orthogonalComplement(v, orthog) {
    const vectorShape = size(v);
    for (let w of orthog) {
      w = reshape2(w, vectorShape);
      v = subtract(v, multiply(divideScalar(dot(w, v), dot(w, w)), w));
    }
    return v;
  }
  function norm(v) {
    return abs(sqrt(dot(v, v)));
  }
  function normalize(v, type) {
    const big = type === "BigNumber";
    const cplx = type === "Complex";
    const one = big ? bignumber(1) : cplx ? complex(1) : 1;
    return multiply(divideScalar(one, norm(v)), v);
  }
  return complexEigs;
}

// src/function/matrix/eigs/realSymmetric.ts
var WASM_EIGS_THRESHOLD2 = 16;
function flattenToFloat6410(matrix, rows, cols) {
  const result = new Float64Array(rows * cols);
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      result[i * cols + j] = matrix[i][j];
    }
  }
  return result;
}
function createRealSymmetric({
  config,
  addScalar,
  subtract,
  abs,
  atan,
  cos,
  sin,
  multiplyScalar,
  inv,
  bignumber,
  multiply,
  add
}) {
  function main(arr, N, prec = config.relTol, type, computeVectors) {
    if (type === "number") {
      return diag(arr, prec, computeVectors);
    }
    if (type === "BigNumber") {
      return diagBig(arr, prec, computeVectors);
    }
    throw TypeError("Unsupported data type: " + type);
  }
  function diag(x, precision, computeVectors) {
    const N = x.length;
    const wasm = wasmLoader.getModule();
    if (wasm && N * N >= WASM_EIGS_THRESHOLD2) {
      try {
        const flat = flattenToFloat6410(x, N, N);
        const matrixAlloc = wasmLoader.allocateFloat64Array(flat);
        const eigenvaluesAlloc = wasmLoader.allocateFloat64ArrayEmpty(N);
        const eigenvectorsAlloc = computeVectors ? wasmLoader.allocateFloat64ArrayEmpty(N * N) : { ptr: 0, array: new Float64Array(0) };
        const workAlloc = wasmLoader.allocateFloat64ArrayEmpty(N * N);
        try {
          const iterations = wasm.eigsSymmetric(
            matrixAlloc.ptr,
            N,
            eigenvaluesAlloc.ptr,
            eigenvectorsAlloc.ptr,
            workAlloc.ptr,
            1e3,
            // maxIterations
            precision
          );
          if (iterations >= 0) {
            const values = Array(N);
            for (let i = 0; i < N; i++) {
              values[i] = eigenvaluesAlloc.array[i];
            }
            if (!computeVectors) {
              const sortedValues = values.map((v, i) => ({ v, i })).sort((a, b) => Math.abs(a.v) - Math.abs(b.v)).map((x2) => x2.v);
              return { values: sortedValues };
            }
            const eigenvectors = [];
            const sortedIndices = values.map((v, i) => ({ v, i })).sort((a, b) => Math.abs(a.v) - Math.abs(b.v)).map((x2) => x2.i);
            for (const origIdx of sortedIndices) {
              const vector = Array(N);
              for (let i = 0; i < N; i++) {
                vector[i] = eigenvectorsAlloc.array[i * N + origIdx];
              }
              eigenvectors.push({
                value: values[origIdx],
                vector
              });
            }
            return {
              values: sortedIndices.map((i) => values[i]),
              eigenvectors
            };
          }
        } finally {
          wasmLoader.free(matrixAlloc.ptr);
          wasmLoader.free(eigenvaluesAlloc.ptr);
          if (computeVectors) {
            wasmLoader.free(eigenvectorsAlloc.ptr);
          }
          wasmLoader.free(workAlloc.ptr);
        }
      } catch (e2) {
      }
    }
    const e0 = Math.abs(precision / N);
    let psi;
    let Sij;
    if (computeVectors) {
      Sij = new Array(N);
      for (let i = 0; i < N; i++) {
        Sij[i] = Array(N).fill(0);
        Sij[i][i] = 1;
      }
    }
    let Vab = getAij(x);
    while (Math.abs(Vab[1]) >= Math.abs(e0)) {
      const i = Vab[0][0];
      const j = Vab[0][1];
      psi = getTheta(x[i][i], x[j][j], x[i][j]);
      x = x1(x, psi, i, j);
      if (computeVectors) Sij = Sij1(Sij, psi, i, j);
      Vab = getAij(x);
    }
    const Ei = Array(N).fill(0);
    for (let i = 0; i < N; i++) {
      Ei[i] = x[i][i];
    }
    return sorting(clone(Ei), Sij, computeVectors);
  }
  function diagBig(x, precision, computeVectors) {
    const N = x.length;
    const e0 = abs(multiplyScalar(precision, bignumber(1 / N)));
    let psi;
    let Sij;
    if (computeVectors) {
      Sij = new Array(N);
      for (let i = 0; i < N; i++) {
        Sij[i] = Array(N).fill(bignumber(0));
        Sij[i][i] = bignumber(1);
      }
    }
    let Vab = getAijBig(x);
    while (abs(Vab[1]) >= abs(e0)) {
      const i = Vab[0][0];
      const j = Vab[0][1];
      psi = getThetaBig(x[i][i], x[j][j], x[i][j]);
      x = x1Big(x, psi, i, j);
      if (computeVectors) Sij = Sij1Big(Sij, psi, i, j);
      Vab = getAijBig(x);
    }
    const Ei = Array(N).fill(bignumber(0));
    for (let i = 0; i < N; i++) {
      Ei[i] = x[i][i];
    }
    return sorting(clone(Ei), Sij, computeVectors);
  }
  function getTheta(aii, ajj, aij) {
    const denom = ajj - aii;
    if (Math.abs(denom) <= config.relTol) {
      return Math.PI / 4;
    } else {
      return 0.5 * Math.atan(2 * aij / (ajj - aii));
    }
  }
  function getThetaBig(aii, ajj, aij) {
    const denom = subtract(ajj, aii);
    if (abs(denom) <= config.relTol) {
      return bignumber(-1).acos().div(4);
    } else {
      return multiplyScalar(0.5, atan(multiply(bignumber(2), aij, inv(denom))));
    }
  }
  function Sij1(Sij, theta, i, j) {
    const N = Sij.length;
    const c = Math.cos(theta);
    const s = Math.sin(theta);
    const Ski = Array(N).fill(0);
    const Skj = Array(N).fill(0);
    for (let k = 0; k < N; k++) {
      Ski[k] = c * Sij[k][i] - s * Sij[k][j];
      Skj[k] = s * Sij[k][i] + c * Sij[k][j];
    }
    for (let k = 0; k < N; k++) {
      Sij[k][i] = Ski[k];
      Sij[k][j] = Skj[k];
    }
    return Sij;
  }
  function Sij1Big(Sij, theta, i, j) {
    const N = Sij.length;
    const c = cos(theta);
    const s = sin(theta);
    const Ski = Array(N).fill(bignumber(0));
    const Skj = Array(N).fill(bignumber(0));
    for (let k = 0; k < N; k++) {
      Ski[k] = subtract(
        multiplyScalar(c, Sij[k][i]),
        multiplyScalar(s, Sij[k][j])
      );
      Skj[k] = addScalar(
        multiplyScalar(s, Sij[k][i]),
        multiplyScalar(c, Sij[k][j])
      );
    }
    for (let k = 0; k < N; k++) {
      Sij[k][i] = Ski[k];
      Sij[k][j] = Skj[k];
    }
    return Sij;
  }
  function x1Big(Hij, theta, i, j) {
    const N = Hij.length;
    const c = bignumber(cos(theta).toString());
    const s = bignumber(sin(theta).toString());
    const c2 = multiplyScalar(c, c);
    const s2 = multiplyScalar(s, s);
    const Aki = Array(N).fill(bignumber(0));
    const Akj = Array(N).fill(bignumber(0));
    const csHij = multiply(bignumber(2), c, s, Hij[i][j]);
    const Aii = addScalar(
      subtract(multiplyScalar(c2, Hij[i][i]), csHij),
      multiplyScalar(s2, Hij[j][j])
    );
    const Ajj = add(
      multiplyScalar(s2, Hij[i][i]),
      csHij,
      multiplyScalar(c2, Hij[j][j])
    );
    for (let k = 0; k < N; k++) {
      Aki[k] = subtract(
        multiplyScalar(c, Hij[i][k]),
        multiplyScalar(s, Hij[j][k])
      );
      Akj[k] = addScalar(
        multiplyScalar(s, Hij[i][k]),
        multiplyScalar(c, Hij[j][k])
      );
    }
    Hij[i][i] = Aii;
    Hij[j][j] = Ajj;
    Hij[i][j] = bignumber(0);
    Hij[j][i] = bignumber(0);
    for (let k = 0; k < N; k++) {
      if (k !== i && k !== j) {
        Hij[i][k] = Aki[k];
        Hij[k][i] = Aki[k];
        Hij[j][k] = Akj[k];
        Hij[k][j] = Akj[k];
      }
    }
    return Hij;
  }
  function x1(Hij, theta, i, j) {
    const N = Hij.length;
    const c = Math.cos(theta);
    const s = Math.sin(theta);
    const c2 = c * c;
    const s2 = s * s;
    const Aki = Array(N).fill(0);
    const Akj = Array(N).fill(0);
    const Aii = c2 * Hij[i][i] - 2 * c * s * Hij[i][j] + s2 * Hij[j][j];
    const Ajj = s2 * Hij[i][i] + 2 * c * s * Hij[i][j] + c2 * Hij[j][j];
    for (let k = 0; k < N; k++) {
      Aki[k] = c * Hij[i][k] - s * Hij[j][k];
      Akj[k] = s * Hij[i][k] + c * Hij[j][k];
    }
    Hij[i][i] = Aii;
    Hij[j][j] = Ajj;
    Hij[i][j] = 0;
    Hij[j][i] = 0;
    for (let k = 0; k < N; k++) {
      if (k !== i && k !== j) {
        Hij[i][k] = Aki[k];
        Hij[k][i] = Aki[k];
        Hij[j][k] = Akj[k];
        Hij[k][j] = Akj[k];
      }
    }
    return Hij;
  }
  function getAij(Mij) {
    const N = Mij.length;
    let maxMij = 0;
    let maxIJ = [0, 1];
    for (let i = 0; i < N; i++) {
      for (let j = i + 1; j < N; j++) {
        if (Math.abs(maxMij) < Math.abs(Mij[i][j])) {
          maxMij = Math.abs(Mij[i][j]);
          maxIJ = [i, j];
        }
      }
    }
    return [maxIJ, maxMij];
  }
  function getAijBig(Mij) {
    const N = Mij.length;
    let maxMij = bignumber(0);
    let maxIJ = [0, 1];
    for (let i = 0; i < N; i++) {
      for (let j = i + 1; j < N; j++) {
        if (abs(maxMij) < abs(Mij[i][j])) {
          maxMij = abs(Mij[i][j]);
          maxIJ = [i, j];
        }
      }
    }
    return [maxIJ, maxMij];
  }
  function sorting(E, S, computeVectors) {
    const N = E.length;
    const values = Array(N);
    let vecs;
    if (computeVectors) {
      vecs = Array(N);
      for (let k = 0; k < N; k++) {
        vecs[k] = Array(N);
      }
    }
    for (let i = 0; i < N; i++) {
      let minID = 0;
      let minE = E[0];
      for (let j = 0; j < E.length; j++) {
        if (abs(E[j]) < abs(minE)) {
          minID = j;
          minE = E[minID];
        }
      }
      values[i] = E.splice(minID, 1)[0];
      if (computeVectors) {
        for (let k = 0; k < N; k++) {
          vecs[i][k] = S[k][minID];
          S[k].splice(minID, 1);
        }
      }
    }
    if (!computeVectors) return { values };
    const eigenvectors = vecs.map((vector, i) => ({
      value: values[i],
      vector
    }));
    return { values, eigenvectors };
  }
  return main;
}

// src/function/matrix/eigs.ts
var name250 = "eigs";
var dependencies251 = [
  "config",
  "typed",
  "matrix",
  "addScalar",
  "equal",
  "subtract",
  "abs",
  "atan",
  "cos",
  "sin",
  "multiplyScalar",
  "divideScalar",
  "inv",
  "bignumber",
  "multiply",
  "add",
  "larger",
  "column",
  "flatten",
  "number",
  "complex",
  "sqrt",
  "diag",
  "size",
  "reshape",
  "qr",
  "usolve",
  "usolveAll",
  "im",
  "re",
  "smaller",
  "matrixFromColumns",
  "dot"
];
var createEigs = /* @__PURE__ */ factory(
  name250,
  dependencies251,
  ({
    config,
    typed: typed2,
    matrix,
    addScalar,
    subtract,
    equal,
    abs,
    atan,
    cos,
    sin,
    multiplyScalar,
    divideScalar,
    inv,
    bignumber,
    multiply,
    add,
    larger,
    column: _column,
    flatten: flatten2,
    number,
    complex,
    sqrt,
    diag,
    size,
    reshape: reshape2,
    qr,
    usolve,
    usolveAll,
    im,
    re,
    smaller,
    matrixFromColumns,
    dot
  }) => {
    const doRealSymmetric = createRealSymmetric({
      config,
      addScalar,
      subtract,
      abs,
      atan,
      cos,
      sin,
      multiplyScalar,
      inv,
      bignumber,
      multiply,
      add
    });
    const doComplexEigs = createComplexEigs({
      addScalar,
      subtract,
      multiply,
      multiplyScalar,
      flatten: flatten2,
      divideScalar,
      sqrt,
      abs,
      bignumber,
      diag,
      size,
      reshape: reshape2,
      qr,
      inv,
      usolve,
      usolveAll,
      equal,
      complex,
      larger,
      smaller,
      matrixFromColumns,
      dot
    });
    return typed2("eigs", {
      // The conversion to matrix in the first two implementations,
      // just to convert back to an array right away in
      // computeValuesAndVectors, is unfortunate, and should perhaps be
      // streamlined. It is done because the Matrix object carries some
      // type information about its entries, and so constructing the matrix
      // is a roundabout way of doing type detection.
      Array: function(x) {
        return doEigs(matrix(x));
      },
      "Array, number|BigNumber": function(x, prec) {
        return doEigs(matrix(x), { precision: prec });
      },
      "Array, Object"(x, opts) {
        return doEigs(matrix(x), opts);
      },
      Matrix: function(mat) {
        return doEigs(mat, { matricize: true });
      },
      "Matrix, number|BigNumber": function(mat, prec) {
        return doEigs(mat, { precision: prec, matricize: true });
      },
      "Matrix, Object": function(mat, opts) {
        const useOpts = { matricize: true };
        Object.assign(useOpts, opts);
        return doEigs(mat, useOpts);
      }
    });
    function doEigs(mat, opts = {}) {
      const computeVectors = "eigenvectors" in opts ? opts.eigenvectors : true;
      const prec = opts.precision ?? config.relTol;
      const result = computeValuesAndVectors(mat, prec, computeVectors);
      if (opts.matricize) {
        result.values = matrix(result.values);
        if (computeVectors) {
          result.eigenvectors = result.eigenvectors.map(
            ({ value, vector }) => ({ value, vector: matrix(vector) })
          );
        }
      }
      if (computeVectors) {
        Object.defineProperty(result, "vectors", {
          enumerable: false,
          // to make sure that the eigenvectors can still be
          // converted to string.
          get: () => {
            throw new Error(
              "eigs(M).vectors replaced with eigs(M).eigenvectors"
            );
          }
        });
      }
      return result;
    }
    function computeValuesAndVectors(mat, prec, computeVectors) {
      const arr = mat.toArray();
      const asize = mat.size();
      if (asize.length !== 2 || asize[0] !== asize[1]) {
        throw new RangeError(
          `Matrix must be square (size: ${format3(asize, {})})`
        );
      }
      const N = asize[0];
      if (isReal(arr, N, prec)) {
        coerceReal(arr, N);
        if (isSymmetric(arr, N, prec)) {
          const type2 = coerceTypes(mat, arr, N);
          return doRealSymmetric(arr, N, prec, type2, computeVectors);
        }
      }
      const type = coerceTypes(mat, arr, N);
      return doComplexEigs(arr, N, prec, type, computeVectors);
    }
    function isSymmetric(arr, N, prec) {
      for (let i = 0; i < N; i++) {
        for (let j = i; j < N; j++) {
          if (larger(bignumber(abs(subtract(arr[i][j], arr[j][i]))), prec)) {
            return false;
          }
        }
      }
      return true;
    }
    function isReal(arr, N, prec) {
      for (let i = 0; i < N; i++) {
        for (let j = 0; j < N; j++) {
          if (larger(bignumber(abs(im(arr[i][j]))), prec)) {
            return false;
          }
        }
      }
      return true;
    }
    function coerceReal(arr, N) {
      for (let i = 0; i < N; i++) {
        for (let j = 0; j < N; j++) {
          arr[i][j] = re(arr[i][j]);
        }
      }
    }
    function coerceTypes(mat, arr, N) {
      const type = mat.datatype();
      if (type === "number" || type === "BigNumber" || type === "Complex") {
        return type;
      }
      let hasNumber = false;
      let hasBig = false;
      let hasComplex = false;
      for (let i = 0; i < N; i++) {
        for (let j = 0; j < N; j++) {
          const el = arr[i][j];
          if (isNumber(el) || isFraction(el)) {
            hasNumber = true;
          } else if (isBigNumber(el)) {
            hasBig = true;
          } else if (isComplex(el)) {
            hasComplex = true;
          } else {
            throw TypeError("Unsupported type in Matrix: " + typeOf(el));
          }
        }
      }
      if (hasBig && hasComplex) {
        console.warn(
          "Complex BigNumbers not supported, this operation will lose precission."
        );
      }
      if (hasComplex) {
        for (let i = 0; i < N; i++) {
          for (let j = 0; j < N; j++) {
            arr[i][j] = complex(arr[i][j]);
          }
        }
        return "Complex";
      }
      if (hasBig) {
        for (let i = 0; i < N; i++) {
          for (let j = 0; j < N; j++) {
            arr[i][j] = bignumber(arr[i][j]);
          }
        }
        return "BigNumber";
      }
      if (hasNumber) {
        for (let i = 0; i < N; i++) {
          for (let j = 0; j < N; j++) {
            arr[i][j] = number(arr[i][j]);
          }
        }
        return "number";
      } else {
        throw TypeError("Matrix contains unsupported types only.");
      }
    }
  }
);

// src/function/matrix/expm.ts
var name251 = "expm";
var dependencies252 = ["typed", "abs", "add", "identity", "inv", "multiply"];
var createExpm = /* @__PURE__ */ factory(
  name251,
  dependencies252,
  ({ typed: typed2, abs, add, identity, inv, multiply }) => {
    return typed2(name251, {
      Matrix: function(A) {
        const size = A.size();
        if (size.length !== 2 || size[0] !== size[1]) {
          throw new RangeError(
            "Matrix must be square (size: " + format3(size, {}) + ")"
          );
        }
        const n = size[0];
        const eps = 1e-15;
        const infNorm = infinityNorm(A);
        const params = findParams(infNorm, eps);
        const q = params.q;
        const j = params.j;
        const Apos = multiply(A, Math.pow(2, -j));
        let N = identity(n);
        let D = identity(n);
        let factor = 1;
        let AposToI = Apos;
        let alternate = -1;
        for (let i = 1; i <= q; i++) {
          if (i > 1) {
            AposToI = multiply(AposToI, Apos);
            alternate = -alternate;
          }
          factor = factor * (q - i + 1) / ((2 * q - i + 1) * i);
          N = add(N, multiply(factor, AposToI));
          D = add(D, multiply(factor * alternate, AposToI));
        }
        let R = multiply(inv(D), N);
        for (let i = 0; i < j; i++) {
          R = multiply(R, R);
        }
        return isSparseMatrix(A) ? A.createSparseMatrix(R) : R;
      }
    });
    function infinityNorm(A) {
      const n = A.size()[0];
      let infNorm = 0;
      for (let i = 0; i < n; i++) {
        let rowSum = 0;
        for (let j = 0; j < n; j++) {
          rowSum += abs(A.get([i, j]));
        }
        infNorm = Math.max(rowSum, infNorm);
      }
      return infNorm;
    }
    function findParams(infNorm, eps) {
      const maxSearchSize = 30;
      for (let k = 0; k < maxSearchSize; k++) {
        for (let q = 0; q <= k; q++) {
          const j = k - q;
          if (errorEstimate(infNorm, q, j) < eps) {
            return { q, j };
          }
        }
      }
      throw new Error(
        "Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)"
      );
    }
    function errorEstimate(infNorm, q, j) {
      let qfac = 1;
      for (let i = 2; i <= q; i++) {
        qfac *= i;
      }
      let twoqfac = qfac;
      for (let i = q + 1; i <= 2 * q; i++) {
        twoqfac *= i;
      }
      const twoqp1fac = twoqfac * (2 * q + 1);
      return 8 * Math.pow(infNorm / Math.pow(2, j), 2 * q) * qfac * qfac / (twoqfac * twoqp1fac);
    }
  }
);

// src/function/matrix/sqrtm.ts
var name252 = "sqrtm";
var dependencies253 = [
  "typed",
  "abs",
  "add",
  "multiply",
  "map",
  "sqrt",
  "subtract",
  "inv",
  "size",
  "max",
  "identity"
];
var createSqrtm = /* @__PURE__ */ factory(
  name252,
  dependencies253,
  ({
    typed: typed2,
    abs,
    add,
    multiply,
    map: map2,
    sqrt,
    subtract,
    inv,
    size,
    max,
    identity
  }) => {
    const _maxIterations = 1e3;
    const _tolerance = 1e-6;
    function _denmanBeavers(A) {
      let error;
      let iterations = 0;
      let Y = A;
      let Z = identity(size(A));
      do {
        const Yk = Y;
        Y = multiply(0.5, add(Yk, inv(Z)));
        Z = multiply(0.5, add(Z, inv(Yk)));
        error = max(abs(subtract(Y, Yk)));
        if (error > _tolerance && ++iterations > _maxIterations) {
          throw new Error(
            "computing square root of matrix: iterative method could not converge"
          );
        }
      } while (error > _tolerance);
      return Y;
    }
    return typed2(name252, {
      "Array | Matrix": function(A) {
        const sizeArray = isMatrix(A) ? A.size() : arraySize(A);
        switch (sizeArray.length) {
          case 1:
            if (sizeArray[0] === 1) {
              return map2(A, sqrt);
            } else {
              throw new RangeError(
                "Matrix must be square (size: " + format3(sizeArray, {}) + ")"
              );
            }
          case 2: {
            const rows = sizeArray[0];
            const cols = sizeArray[1];
            if (rows === cols) {
              return _denmanBeavers(A);
            } else {
              throw new RangeError(
                "Matrix must be square (size: " + format3(sizeArray, {}) + ")"
              );
            }
          }
          default:
            throw new RangeError(
              "Matrix must be at most two dimensional (size: " + format3(sizeArray, {}) + ")"
            );
        }
      }
    });
  }
);

// src/function/algebra/sylvester.ts
var name253 = "sylvester";
var dependencies254 = [
  "typed",
  "schur",
  "matrixFromColumns",
  "matrix",
  "multiply",
  "range",
  "concat",
  "transpose",
  "index",
  "subset",
  "add",
  "subtract",
  "identity",
  "lusolve",
  "abs"
];
var createSylvester = /* @__PURE__ */ factory(
  name253,
  dependencies254,
  ({
    typed: typed2,
    schur,
    matrixFromColumns,
    matrix,
    multiply,
    range,
    concat: concat2,
    transpose,
    index,
    subset,
    add,
    subtract,
    identity,
    lusolve,
    abs
  }) => {
    return typed2(name253, {
      "Matrix, Matrix, Matrix": _sylvester,
      "Array, Matrix, Matrix": function(A, B, C) {
        return _sylvester(matrix(A), B, C);
      },
      "Array, Array, Matrix": function(A, B, C) {
        return _sylvester(matrix(A), matrix(B), C);
      },
      "Array, Matrix, Array": function(A, B, C) {
        return _sylvester(matrix(A), B, matrix(C));
      },
      "Matrix, Array, Matrix": function(A, B, C) {
        return _sylvester(A, matrix(B), C);
      },
      "Matrix, Array, Array": function(A, B, C) {
        return _sylvester(A, matrix(B), matrix(C));
      },
      "Matrix, Matrix, Array": function(A, B, C) {
        return _sylvester(A, B, matrix(C));
      },
      "Array, Array, Array": function(A, B, C) {
        return _sylvester(matrix(A), matrix(B), matrix(C)).toArray();
      }
    });
    function _sylvester(A, B, C) {
      const n = B.size()[0];
      const m = A.size()[0];
      const sA = schur(A);
      const F = sA.T;
      const U = sA.U;
      const sB = schur(multiply(-1, B));
      const G = sB.T;
      const V = sB.U;
      const D = multiply(multiply(transpose(U), C), V);
      const all = range(0, m);
      const y = [];
      const hc = (a, b) => concat2(a, b, 1);
      const vc = (a, b) => concat2(a, b, 0);
      for (let k = 0; k < n; k++) {
        if (k < n - 1 && abs(subset(G, index(k + 1, k))) > 1e-5) {
          let RHS = vc(
            subset(D, index(all, [k])),
            subset(D, index(all, [k + 1]))
          );
          for (let j = 0; j < k; j++) {
            RHS = add(
              RHS,
              vc(
                multiply(y[j], subset(G, index(j, k))),
                multiply(y[j], subset(G, index(j, k + 1)))
              )
            );
          }
          const gkk = multiply(
            identity(m),
            multiply(-1, subset(G, index(k, k)))
          );
          const gmk = multiply(
            identity(m),
            multiply(-1, subset(G, index(k + 1, k)))
          );
          const gkm = multiply(
            identity(m),
            multiply(-1, subset(G, index(k, k + 1)))
          );
          const gmm = multiply(
            identity(m),
            multiply(-1, subset(G, index(k + 1, k + 1)))
          );
          const LHS = vc(hc(add(F, gkk), gmk), hc(gkm, add(F, gmm)));
          const yAux = lusolve(LHS, RHS);
          y[k] = yAux.subset(index(range(0, m), [0]));
          y[k + 1] = yAux.subset(index(range(m, 2 * m), [0]));
          k++;
        } else {
          let RHS = subset(D, index(all, [k]));
          for (let j = 0; j < k; j++) {
            RHS = add(RHS, multiply(y[j], subset(G, index(j, k))));
          }
          const gkk = subset(G, index(k, k));
          const LHS = subtract(F, multiply(gkk, identity(m)));
          y[k] = lusolve(LHS, RHS);
        }
      }
      const Y = matrix(matrixFromColumns(...y));
      const X = multiply(U, multiply(Y, transpose(V)));
      return X;
    }
  }
);

// src/function/algebra/decomposition/schur.ts
var WASM_SCHUR_THRESHOLD = 16;
function isPlainNumberMatrix9(matrix) {
  for (let i = 0; i < matrix.length; i++) {
    const row = matrix[i];
    for (let j = 0; j < row.length; j++) {
      if (typeof row[j] !== "number") {
        return false;
      }
    }
  }
  return true;
}
function flattenToFloat6411(matrix, rows, cols) {
  const result = new Float64Array(rows * cols);
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      result[i * cols + j] = matrix[i][j];
    }
  }
  return result;
}
var name254 = "schur";
var dependencies255 = [
  "typed",
  "matrix",
  "identity",
  "multiply",
  "qr",
  "norm",
  "subtract"
];
var createSchur = /* @__PURE__ */ factory(
  name254,
  dependencies255,
  ({ typed: typed2, matrix, identity, multiply, qr, norm, subtract }) => {
    return typed2(name254, {
      Array: function(X) {
        const r = _schur(matrix(X));
        return {
          U: r.U.valueOf(),
          T: r.T.valueOf()
        };
      },
      Matrix: function(X) {
        return _schur(X);
      }
    });
    function _schur(X) {
      const n = X.size()[0];
      const wasm = wasmLoader.getModule();
      const data = X._data;
      if (wasm && X.storage() === "dense" && n * n >= WASM_SCHUR_THRESHOLD && data && isPlainNumberMatrix9(data)) {
        try {
          const flat = flattenToFloat6411(data, n, n);
          const aAlloc = wasmLoader.allocateFloat64Array(flat);
          const qAlloc = wasmLoader.allocateFloat64ArrayEmpty(n * n);
          const tAlloc = wasmLoader.allocateFloat64ArrayEmpty(n * n);
          const workAlloc = wasmLoader.allocateFloat64ArrayEmpty(n * n);
          try {
            const result = wasm.schur(
              aAlloc.ptr,
              n,
              100,
              // maxIter
              1e-4,
              // tol
              qAlloc.ptr,
              tAlloc.ptr,
              workAlloc.ptr
            );
            if (result !== 0) {
              const Udata = [];
              for (let i = 0; i < n; i++) {
                Udata[i] = [];
                for (let j = 0; j < n; j++) {
                  Udata[i][j] = qAlloc.array[i * n + j];
                }
              }
              const Tdata = [];
              for (let i = 0; i < n; i++) {
                Tdata[i] = [];
                for (let j = 0; j < n; j++) {
                  Tdata[i][j] = tAlloc.array[i * n + j];
                }
              }
              const U2 = matrix(Udata);
              const T = matrix(Tdata);
              return {
                U: U2,
                T,
                toString: function() {
                  return "U: " + this.U.toString() + "\nT: " + this.T.toString();
                }
              };
            }
          } finally {
            wasmLoader.free(aAlloc.ptr);
            wasmLoader.free(qAlloc.ptr);
            wasmLoader.free(tAlloc.ptr);
            wasmLoader.free(workAlloc.ptr);
          }
        } catch (e2) {
        }
      }
      let A = X;
      let U = identity(n);
      let k = 0;
      let A0;
      do {
        A0 = A;
        const QR = qr(A);
        const Q2 = QR.Q;
        const R = QR.R;
        A = multiply(R, Q2);
        U = multiply(U, Q2);
        if (k++ > 100) {
          break;
        }
      } while (norm(subtract(A, A0)) > 1e-4);
      return {
        U,
        T: A,
        toString: function() {
          return "U: " + this.U.toString() + "\nT: " + this.T.toString();
        }
      };
    }
  }
);

// src/function/algebra/lyap.ts
var name255 = "lyap";
var dependencies256 = ["typed", "matrix", "sylvester", "multiply", "transpose"];
var createLyap = /* @__PURE__ */ factory(
  name255,
  dependencies256,
  ({
    typed: typed2,
    matrix,
    sylvester,
    multiply,
    transpose
  }) => {
    return typed2(name255, {
      "Matrix, Matrix": function(A, Q2) {
        return sylvester(A, transpose(A), multiply(-1, Q2));
      },
      "Array, Matrix": function(A, Q2) {
        return sylvester(matrix(A), transpose(matrix(A)), multiply(-1, Q2));
      },
      "Matrix, Array": function(A, Q2) {
        return sylvester(A, transpose(matrix(A)), matrix(multiply(-1, Q2)));
      },
      "Array, Array": function(A, Q2) {
        return sylvester(
          matrix(A),
          transpose(matrix(A)),
          matrix(multiply(-1, Q2))
        ).toArray();
      }
    });
  }
);

// src/function/arithmetic/divide.ts
var name256 = "divide";
var dependencies257 = [
  "typed",
  "matrix",
  "multiply",
  "equalScalar",
  "divideScalar",
  "inv",
  "nodeOperations"
];
var createDivide = /* @__PURE__ */ factory(
  name256,
  dependencies257,
  ({
    typed: typed2,
    matrix,
    multiply,
    equalScalar,
    divideScalar,
    inv,
    nodeOperations
  }) => {
    const matAlgo11xS0s = createMatAlgo11xS0s({ typed: typed2, equalScalar });
    const matAlgo14xDs = createMatAlgo14xDs({ typed: typed2 });
    return typed2(
      "divide",
      extend(
        {
          // =========================================================================
          // NODE SIGNATURES - Must be FIRST (before divideScalar signatures)
          // When any operand is a Node, return an OperatorNode for symbolic computation
          // =========================================================================
          "Node, Node": (x, y) => nodeOperations.createBinaryNode("/", "divide", x, y),
          "number, Node": (x, y) => nodeOperations.createBinaryNode("/", "divide", x, y),
          "Node, number": (x, y) => nodeOperations.createBinaryNode("/", "divide", x, y),
          "BigNumber, Node": (x, y) => nodeOperations.createBinaryNode("/", "divide", x, y),
          "Node, BigNumber": (x, y) => nodeOperations.createBinaryNode("/", "divide", x, y),
          "Complex, Node": (x, y) => nodeOperations.createBinaryNode("/", "divide", x, y),
          "Node, Complex": (x, y) => nodeOperations.createBinaryNode("/", "divide", x, y),
          "Fraction, Node": (x, y) => nodeOperations.createBinaryNode("/", "divide", x, y),
          "Node, Fraction": (x, y) => nodeOperations.createBinaryNode("/", "divide", x, y),
          "Unit, Node": (x, y) => nodeOperations.createBinaryNode("/", "divide", x, y),
          "Node, Unit": (x, y) => nodeOperations.createBinaryNode("/", "divide", x, y),
          "string, Node": (x, y) => nodeOperations.createBinaryNode("/", "divide", x, y),
          "Node, string": (x, y) => nodeOperations.createBinaryNode("/", "divide", x, y),
          // =========================================================================
          // MATRIX SIGNATURES - Deal with matrices
          // =========================================================================
          "Array | Matrix, Array | Matrix": function(x, y) {
            return multiply(x, inv(y));
          },
          "DenseMatrix, any": function(x, y) {
            return matAlgo14xDs(
              x,
              y,
              divideScalar,
              false
            );
          },
          "SparseMatrix, any": function(x, y) {
            return matAlgo11xS0s(
              x,
              y,
              divideScalar,
              false
            );
          },
          "Array, any": function(x, y) {
            return matAlgo14xDs(
              matrix(x),
              y,
              divideScalar,
              false
            ).valueOf();
          },
          "any, Array | Matrix": function(x, y) {
            return multiply(x, inv(y));
          }
        },
        divideScalar.signatures
      )
    );
  }
);

// src/function/geometry/distance.ts
var name257 = "distance";
var dependencies258 = [
  "typed",
  "addScalar",
  "subtractScalar",
  "divideScalar",
  "multiplyScalar",
  "deepEqual",
  "sqrt",
  "abs"
];
var createDistance = /* @__PURE__ */ factory(
  name257,
  dependencies258,
  ({
    typed: typed2,
    addScalar,
    subtractScalar,
    multiplyScalar,
    divideScalar,
    deepEqual,
    sqrt,
    abs
  }) => {
    return typed2(name257, {
      "Array, Array, Array": function(x, y, z) {
        if (x.length === 2 && y.length === 2 && z.length === 2) {
          if (!_2d(x)) {
            throw new TypeError(
              "Array with 2 numbers or BigNumbers expected for first argument"
            );
          }
          if (!_2d(y)) {
            throw new TypeError(
              "Array with 2 numbers or BigNumbers expected for second argument"
            );
          }
          if (!_2d(z)) {
            throw new TypeError(
              "Array with 2 numbers or BigNumbers expected for third argument"
            );
          }
          if (deepEqual(y, z)) {
            throw new TypeError("LinePoint1 should not be same with LinePoint2");
          }
          const xCoeff = subtractScalar(z[1], y[1]);
          const yCoeff = subtractScalar(y[0], z[0]);
          const constant = subtractScalar(
            multiplyScalar(z[0], y[1]),
            multiplyScalar(y[0], z[1])
          );
          return _distancePointLine2D(x[0], x[1], xCoeff, yCoeff, constant);
        } else {
          throw new TypeError("Invalid Arguments: Try again");
        }
      },
      "Object, Object, Object": function(x, y, z) {
        if (Object.keys(x).length === 2 && Object.keys(y).length === 2 && Object.keys(z).length === 2) {
          if (!_2d(x)) {
            throw new TypeError(
              "Values of pointX and pointY should be numbers or BigNumbers"
            );
          }
          if (!_2d(y)) {
            throw new TypeError(
              "Values of lineOnePtX and lineOnePtY should be numbers or BigNumbers"
            );
          }
          if (!_2d(z)) {
            throw new TypeError(
              "Values of lineTwoPtX and lineTwoPtY should be numbers or BigNumbers"
            );
          }
          if (deepEqual(_objectToArray(y), _objectToArray(z))) {
            throw new TypeError("LinePoint1 should not be same with LinePoint2");
          }
          if ("pointX" in x && "pointY" in x && "lineOnePtX" in y && "lineOnePtY" in y && "lineTwoPtX" in z && "lineTwoPtY" in z) {
            const xCoeff = subtractScalar(z.lineTwoPtY, y.lineOnePtY);
            const yCoeff = subtractScalar(y.lineOnePtX, z.lineTwoPtX);
            const constant = subtractScalar(
              multiplyScalar(z.lineTwoPtX, y.lineOnePtY),
              multiplyScalar(y.lineOnePtX, z.lineTwoPtY)
            );
            return _distancePointLine2D(
              x.pointX,
              x.pointY,
              xCoeff,
              yCoeff,
              constant
            );
          } else {
            throw new TypeError("Key names do not match");
          }
        } else {
          throw new TypeError("Invalid Arguments: Try again");
        }
      },
      "Array, Array": function(x, y) {
        if (x.length === 2 && y.length === 3) {
          if (!_2d(x)) {
            throw new TypeError(
              "Array with 2 numbers or BigNumbers expected for first argument"
            );
          }
          if (!_3d(y)) {
            throw new TypeError(
              "Array with 3 numbers or BigNumbers expected for second argument"
            );
          }
          return _distancePointLine2D(x[0], x[1], y[0], y[1], y[2]);
        } else if (x.length === 3 && y.length === 6) {
          if (!_3d(x)) {
            throw new TypeError(
              "Array with 3 numbers or BigNumbers expected for first argument"
            );
          }
          if (!_parametricLine(y)) {
            throw new TypeError(
              "Array with 6 numbers or BigNumbers expected for second argument"
            );
          }
          return _distancePointLine3D(
            x[0],
            x[1],
            x[2],
            y[0],
            y[1],
            y[2],
            y[3],
            y[4],
            y[5]
          );
        } else if (x.length === y.length && x.length > 0) {
          if (!_containsOnlyNumbers(x)) {
            throw new TypeError(
              "All values of an array should be numbers or BigNumbers"
            );
          }
          if (!_containsOnlyNumbers(y)) {
            throw new TypeError(
              "All values of an array should be numbers or BigNumbers"
            );
          }
          return _euclideanDistance(x, y);
        } else {
          throw new TypeError("Invalid Arguments: Try again");
        }
      },
      "Object, Object": function(x, y) {
        if (Object.keys(x).length === 2 && Object.keys(y).length === 3) {
          if (!_2d(x)) {
            throw new TypeError(
              "Values of pointX and pointY should be numbers or BigNumbers"
            );
          }
          if (!_3d(y)) {
            throw new TypeError(
              "Values of xCoeffLine, yCoeffLine and constant should be numbers or BigNumbers"
            );
          }
          if ("pointX" in x && "pointY" in x && "xCoeffLine" in y && "yCoeffLine" in y && "constant" in y) {
            return _distancePointLine2D(
              x.pointX,
              x.pointY,
              y.xCoeffLine,
              y.yCoeffLine,
              y.constant
            );
          } else {
            throw new TypeError("Key names do not match");
          }
        } else if (Object.keys(x).length === 3 && Object.keys(y).length === 6) {
          if (!_3d(x)) {
            throw new TypeError(
              "Values of pointX, pointY and pointZ should be numbers or BigNumbers"
            );
          }
          if (!_parametricLine(y)) {
            throw new TypeError(
              "Values of x0, y0, z0, a, b and c should be numbers or BigNumbers"
            );
          }
          if ("pointX" in x && "pointY" in x && "x0" in y && "y0" in y && "z0" in y && "a" in y && "b" in y && "c" in y) {
            return _distancePointLine3D(
              x.pointX,
              x.pointY,
              x.pointZ,
              y.x0,
              y.y0,
              y.z0,
              y.a,
              y.b,
              y.c
            );
          } else {
            throw new TypeError("Key names do not match");
          }
        } else if (Object.keys(x).length === 2 && Object.keys(y).length === 2) {
          if (!_2d(x)) {
            throw new TypeError(
              "Values of pointOneX and pointOneY should be numbers or BigNumbers"
            );
          }
          if (!_2d(y)) {
            throw new TypeError(
              "Values of pointTwoX and pointTwoY should be numbers or BigNumbers"
            );
          }
          if ("pointOneX" in x && "pointOneY" in x && "pointTwoX" in y && "pointTwoY" in y) {
            return _euclideanDistance(
              [x.pointOneX, x.pointOneY],
              [y.pointTwoX, y.pointTwoY]
            );
          } else {
            throw new TypeError("Key names do not match");
          }
        } else if (Object.keys(x).length === 3 && Object.keys(y).length === 3) {
          if (!_3d(x)) {
            throw new TypeError(
              "Values of pointOneX, pointOneY and pointOneZ should be numbers or BigNumbers"
            );
          }
          if (!_3d(y)) {
            throw new TypeError(
              "Values of pointTwoX, pointTwoY and pointTwoZ should be numbers or BigNumbers"
            );
          }
          if ("pointOneX" in x && "pointOneY" in x && "pointOneZ" in x && "pointTwoX" in y && "pointTwoY" in y && "pointTwoZ" in y) {
            return _euclideanDistance(
              [x.pointOneX, x.pointOneY, x.pointOneZ],
              [y.pointTwoX, y.pointTwoY, y.pointTwoZ]
            );
          } else {
            throw new TypeError("Key names do not match");
          }
        } else {
          throw new TypeError("Invalid Arguments: Try again");
        }
      },
      Array: function(arr) {
        if (!_pairwise(arr)) {
          throw new TypeError(
            "Incorrect array format entered for pairwise distance calculation"
          );
        }
        return _distancePairwise(arr);
      }
    });
    function _isNumber(a) {
      return typeof a === "number" || isBigNumber(a);
    }
    function _2d(a) {
      if (!Array.isArray(a)) {
        a = _objectToArray(a);
      }
      const arr = a;
      return _isNumber(arr[0]) && _isNumber(arr[1]);
    }
    function _3d(a) {
      if (!Array.isArray(a)) {
        a = _objectToArray(a);
      }
      const arr = a;
      return _isNumber(arr[0]) && _isNumber(arr[1]) && _isNumber(arr[2]);
    }
    function _containsOnlyNumbers(a) {
      if (!Array.isArray(a)) {
        a = _objectToArray(a);
      }
      return a.every(_isNumber);
    }
    function _parametricLine(a) {
      if (!Array.isArray(a)) {
        a = _objectToArray(a);
      }
      const arr = a;
      return _isNumber(arr[0]) && _isNumber(arr[1]) && _isNumber(arr[2]) && _isNumber(arr[3]) && _isNumber(arr[4]) && _isNumber(arr[5]);
    }
    function _objectToArray(o) {
      const keys = Object.keys(o);
      const a = [];
      for (let i = 0; i < keys.length; i++) {
        a.push(o[keys[i]]);
      }
      return a;
    }
    function _pairwise(a) {
      if (a[0].length === 2 && _isNumber(a[0][0]) && _isNumber(a[0][1])) {
        if (a.some(
          (aI) => aI.length !== 2 || !_isNumber(aI[0]) || !_isNumber(aI[1])
        )) {
          return false;
        }
      } else if (a[0].length === 3 && _isNumber(a[0][0]) && _isNumber(a[0][1]) && _isNumber(a[0][2])) {
        if (a.some(
          (aI) => aI.length !== 3 || !_isNumber(aI[0]) || !_isNumber(aI[1]) || !_isNumber(aI[2])
        )) {
          return false;
        }
      } else {
        return false;
      }
      return true;
    }
    function _distancePointLine2D(x, y, a, b, c) {
      const num = abs(
        addScalar(addScalar(multiplyScalar(a, x), multiplyScalar(b, y)), c)
      );
      const den = sqrt(addScalar(multiplyScalar(a, a), multiplyScalar(b, b)));
      return divideScalar(num, den);
    }
    function _distancePointLine3D(x, y, z, x0, y0, z0, a, b, c) {
      const numComponents = [
        subtractScalar(
          multiplyScalar(subtractScalar(y0, y), c),
          multiplyScalar(subtractScalar(z0, z), b)
        ),
        subtractScalar(
          multiplyScalar(subtractScalar(z0, z), a),
          multiplyScalar(subtractScalar(x0, x), c)
        ),
        subtractScalar(
          multiplyScalar(subtractScalar(x0, x), b),
          multiplyScalar(subtractScalar(y0, y), a)
        )
      ];
      const num = sqrt(
        addScalar(
          addScalar(
            multiplyScalar(numComponents[0], numComponents[0]),
            multiplyScalar(numComponents[1], numComponents[1])
          ),
          multiplyScalar(numComponents[2], numComponents[2])
        )
      );
      const den = sqrt(
        addScalar(
          addScalar(multiplyScalar(a, a), multiplyScalar(b, b)),
          multiplyScalar(c, c)
        )
      );
      return divideScalar(num, den);
    }
    function _euclideanDistance(x, y) {
      const vectorSize = x.length;
      let result = 0;
      for (let i = 0; i < vectorSize; i++) {
        const diff = subtractScalar(x[i], y[i]);
        result = addScalar(multiplyScalar(diff, diff), result);
      }
      return sqrt(result);
    }
    function _distancePairwise(a) {
      const result = [];
      let pointA = [];
      let pointB = [];
      for (let i = 0; i < a.length - 1; i++) {
        for (let j = i + 1; j < a.length; j++) {
          if (a[0].length === 2) {
            pointA = [a[i][0], a[i][1]];
            pointB = [a[j][0], a[j][1]];
          } else if (a[0].length === 3) {
            pointA = [a[i][0], a[i][1], a[i][2]];
            pointB = [a[j][0], a[j][1], a[j][2]];
          }
          result.push(_euclideanDistance(pointA, pointB));
        }
      }
      return result;
    }
  }
);

// src/function/geometry/intersect.ts
var name258 = "intersect";
var dependencies259 = [
  "typed",
  "config",
  "abs",
  "add",
  "addScalar",
  "matrix",
  "multiply",
  "multiplyScalar",
  "divideScalar",
  "subtract",
  "smaller",
  "equalScalar",
  "flatten",
  "isZero",
  "isNumeric"
];
var createIntersect = /* @__PURE__ */ factory(
  name258,
  dependencies259,
  ({
    typed: typed2,
    config,
    abs,
    add,
    addScalar,
    matrix,
    multiply,
    multiplyScalar,
    divideScalar,
    subtract,
    smaller,
    equalScalar,
    flatten: flatten2,
    isZero,
    isNumeric
  }) => {
    return typed2("intersect", {
      "Array, Array, Array": _AAA,
      "Array, Array, Array, Array": _AAAA,
      "Matrix, Matrix, Matrix": function(x, y, plane) {
        const arr = _AAA(
          x.valueOf(),
          y.valueOf(),
          plane.valueOf()
        );
        return arr === null ? null : matrix(arr);
      },
      "Matrix, Matrix, Matrix, Matrix": function(w, x, y, z) {
        const arr = _AAAA(
          w.valueOf(),
          x.valueOf(),
          y.valueOf(),
          z.valueOf()
        );
        return arr === null ? null : matrix(arr);
      }
    });
    function _AAA(x, y, plane) {
      x = _coerceArr(x);
      y = _coerceArr(y);
      plane = _coerceArr(plane);
      if (!_3d(x)) {
        throw new TypeError(
          "Array with 3 numbers or BigNumbers expected for first argument"
        );
      }
      if (!_3d(y)) {
        throw new TypeError(
          "Array with 3 numbers or BigNumbers expected for second argument"
        );
      }
      if (!_4d(plane)) {
        throw new TypeError("Array with 4 numbers expected as third argument");
      }
      return _intersectLinePlane(
        x[0],
        x[1],
        x[2],
        y[0],
        y[1],
        y[2],
        plane[0],
        plane[1],
        plane[2],
        plane[3]
      );
    }
    function _AAAA(w, x, y, z) {
      w = _coerceArr(w);
      x = _coerceArr(x);
      y = _coerceArr(y);
      z = _coerceArr(z);
      if (w.length === 2) {
        if (!_2d(w)) {
          throw new TypeError(
            "Array with 2 numbers or BigNumbers expected for first argument"
          );
        }
        if (!_2d(x)) {
          throw new TypeError(
            "Array with 2 numbers or BigNumbers expected for second argument"
          );
        }
        if (!_2d(y)) {
          throw new TypeError(
            "Array with 2 numbers or BigNumbers expected for third argument"
          );
        }
        if (!_2d(z)) {
          throw new TypeError(
            "Array with 2 numbers or BigNumbers expected for fourth argument"
          );
        }
        return _intersect2d(w, x, y, z);
      } else if (w.length === 3) {
        if (!_3d(w)) {
          throw new TypeError(
            "Array with 3 numbers or BigNumbers expected for first argument"
          );
        }
        if (!_3d(x)) {
          throw new TypeError(
            "Array with 3 numbers or BigNumbers expected for second argument"
          );
        }
        if (!_3d(y)) {
          throw new TypeError(
            "Array with 3 numbers or BigNumbers expected for third argument"
          );
        }
        if (!_3d(z)) {
          throw new TypeError(
            "Array with 3 numbers or BigNumbers expected for fourth argument"
          );
        }
        return _intersect3d(
          w[0],
          w[1],
          w[2],
          x[0],
          x[1],
          x[2],
          y[0],
          y[1],
          y[2],
          z[0],
          z[1],
          z[2]
        );
      } else {
        throw new TypeError(
          "Arrays with two or thee dimensional points expected"
        );
      }
    }
    function _coerceArr(arr) {
      if (arr.length === 1 && Array.isArray(arr[0])) return arr[0];
      if (arr.length > 1 && Array.isArray(arr[0])) {
        if (arr.every((el) => Array.isArray(el) && el.length === 1))
          return flatten2(arr);
      }
      return arr;
    }
    function _2d(x) {
      return x.length === 2 && isNumeric(x[0]) && isNumeric(x[1]);
    }
    function _3d(x) {
      return x.length === 3 && isNumeric(x[0]) && isNumeric(x[1]) && isNumeric(x[2]);
    }
    function _4d(x) {
      return x.length === 4 && isNumeric(x[0]) && isNumeric(x[1]) && isNumeric(x[2]) && isNumeric(x[3]);
    }
    function _intersect2d(p1a, p1b, p2a, p2b) {
      const o1 = p1a;
      const o2 = p2a;
      const d1 = subtract(o1, p1b);
      const d2 = subtract(o2, p2b);
      const det = subtract(
        multiplyScalar(d1[0], d2[1]),
        multiplyScalar(d2[0], d1[1])
      );
      if (isZero(det)) return null;
      if (smaller(abs(det), config.relTol)) {
        return null;
      }
      const d20o11 = multiplyScalar(d2[0], o1[1]);
      const d21o10 = multiplyScalar(d2[1], o1[0]);
      const d20o21 = multiplyScalar(d2[0], o2[1]);
      const d21o20 = multiplyScalar(d2[1], o2[0]);
      const t = divideScalar(
        addScalar(subtract(subtract(d20o11, d21o10), d20o21), d21o20),
        det
      );
      return add(multiply(d1, t), o1);
    }
    function _intersect3dHelper(a, b, c, d, e2, f, g, h, i, j, k, l) {
      const add1 = multiplyScalar(subtract(a, b), subtract(c, d));
      const add2 = multiplyScalar(subtract(e2, f), subtract(g, h));
      const add3 = multiplyScalar(subtract(i, j), subtract(k, l));
      return addScalar(addScalar(add1, add2), add3);
    }
    function _intersect3d(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
      const d1343 = _intersect3dHelper(
        x1,
        x3,
        x4,
        x3,
        y1,
        y3,
        y4,
        y3,
        z1,
        z3,
        z4,
        z3
      );
      const d4321 = _intersect3dHelper(
        x4,
        x3,
        x2,
        x1,
        y4,
        y3,
        y2,
        y1,
        z4,
        z3,
        z2,
        z1
      );
      const d1321 = _intersect3dHelper(
        x1,
        x3,
        x2,
        x1,
        y1,
        y3,
        y2,
        y1,
        z1,
        z3,
        z2,
        z1
      );
      const d4343 = _intersect3dHelper(
        x4,
        x3,
        x4,
        x3,
        y4,
        y3,
        y4,
        y3,
        z4,
        z3,
        z4,
        z3
      );
      const d2121 = _intersect3dHelper(
        x2,
        x1,
        x2,
        x1,
        y2,
        y1,
        y2,
        y1,
        z2,
        z1,
        z2,
        z1
      );
      const numerator = subtract(
        multiplyScalar(d1343, d4321),
        multiplyScalar(d1321, d4343)
      );
      const denominator = subtract(
        multiplyScalar(d2121, d4343),
        multiplyScalar(d4321, d4321)
      );
      if (isZero(denominator)) return null;
      const ta = divideScalar(numerator, denominator);
      const tb = divideScalar(
        addScalar(d1343, multiplyScalar(ta, d4321)),
        d4343
      );
      const pax = addScalar(x1, multiplyScalar(ta, subtract(x2, x1)));
      const pay = addScalar(y1, multiplyScalar(ta, subtract(y2, y1)));
      const paz = addScalar(z1, multiplyScalar(ta, subtract(z2, z1)));
      const pbx = addScalar(x3, multiplyScalar(tb, subtract(x4, x3)));
      const pby = addScalar(y3, multiplyScalar(tb, subtract(y4, y3)));
      const pbz = addScalar(z3, multiplyScalar(tb, subtract(z4, z3)));
      if (equalScalar(pax, pbx) && equalScalar(pay, pby) && equalScalar(paz, pbz)) {
        return [pax, pay, paz];
      } else {
        return null;
      }
    }
    function _intersectLinePlane(x1, y1, z1, x2, y2, z2, x, y, z, c) {
      const x1x = multiplyScalar(x1, x);
      const x2x = multiplyScalar(x2, x);
      const y1y = multiplyScalar(y1, y);
      const y2y = multiplyScalar(y2, y);
      const z1z = multiplyScalar(z1, z);
      const z2z = multiplyScalar(z2, z);
      const numerator = subtract(subtract(subtract(c, x1x), y1y), z1z);
      const denominator = subtract(
        subtract(subtract(addScalar(addScalar(x2x, y2y), z2z), x1x), y1y),
        z1z
      );
      const t = divideScalar(numerator, denominator);
      const px = addScalar(x1, multiplyScalar(t, subtract(x2, x1)));
      const py = addScalar(y1, multiplyScalar(t, subtract(y2, y1)));
      const pz = addScalar(z1, multiplyScalar(t, subtract(z2, z1)));
      return [px, py, pz];
    }
  }
);

// src/function/statistics/sum.ts
var WASM_SUM_THRESHOLD = 100;
function isFlatNumberArray5(arr) {
  for (let i = 0; i < arr.length; i++) {
    if (typeof arr[i] !== "number") {
      return false;
    }
  }
  return true;
}
var name259 = "sum";
var dependencies260 = [
  "typed",
  "config",
  "add",
  "numeric",
  "parseNumberWithConfig"
];
var createSum = /* @__PURE__ */ factory(
  name259,
  dependencies260,
  ({ typed: typed2, config, add, numeric, parseNumberWithConfig }) => {
    return typed2(name259, {
      // sum(string) - single string input
      string: function(x) {
        return parseNumberWithConfig(x);
      },
      // sum([a, b, c, d, ...])
      "Array | Matrix": _sum,
      // sum([a, b, c, d, ...], dim)
      "Array | Matrix, number | BigNumber": _nsumDim,
      // sum(a, b, c, d, ...)
      "...": function(args) {
        if (containsCollections(args)) {
          throw new TypeError("Scalar values expected in function sum");
        }
        return _sum(args);
      }
    });
    function _sum(array) {
      if (Array.isArray(array) && array.length >= WASM_SUM_THRESHOLD) {
        if (isFlatNumberArray5(array)) {
          const wasm = wasmLoader.getModule();
          if (wasm) {
            try {
              const alloc = wasmLoader.allocateFloat64Array(array);
              try {
                return wasm.statsSum(alloc.ptr, array.length);
              } finally {
                wasmLoader.free(alloc.ptr);
              }
            } catch {
            }
          }
        }
      }
      let sum;
      deepForEach2(array, function(value) {
        try {
          const converted = typeof value === "string" ? parseNumberWithConfig(value) : value;
          sum = sum === void 0 ? converted : add(sum, converted);
        } catch (err) {
          throw improveErrorMessage(err, "sum", value);
        }
      });
      if (sum === void 0) {
        sum = numeric(0, config.number);
      }
      return sum;
    }
    function _nsumDim(array, dim) {
      try {
        const dimValue = typeof dim === "number" ? dim : dim.valueOf();
        const sum = reduce(array, dimValue, add);
        return sum;
      } catch (err) {
        throw improveErrorMessage(err, "sum", void 0);
      }
    }
  }
);

// src/function/statistics/cumsum.ts
var WASM_CUMSUM_THRESHOLD = 100;
function isFlatNumberArray6(arr) {
  for (let i = 0; i < arr.length; i++) {
    if (typeof arr[i] !== "number") {
      return false;
    }
  }
  return true;
}
var name260 = "cumsum";
var dependencies261 = ["typed", "add", "unaryPlus"];
var createCumSum = /* @__PURE__ */ factory(
  name260,
  dependencies261,
  ({ typed: typed2, add, unaryPlus }) => {
    return typed2(name260, {
      // sum([a, b, c, d, ...])
      Array: _cumsum,
      Matrix: function(matrix) {
        return matrix.create(_cumsum(matrix.valueOf(), matrix.datatype()), matrix.datatype());
      },
      // sum([a, b, c, d, ...], dim)
      "Array, number | BigNumber": _ncumSumDim,
      "Matrix, number | BigNumber": function(matrix, dim) {
        return matrix.create(
          _ncumSumDim(matrix.valueOf(), dim),
          matrix.datatype()
        );
      },
      // cumsum(a, b, c, d, ...)
      "...": function(args) {
        if (containsCollections(args)) {
          throw new TypeError(
            "All values expected to be scalar in function cumsum"
          );
        }
        return _cumsum(args);
      }
    });
    function _cumsum(array, _datatype) {
      try {
        return _cumsummap(array);
      } catch (err) {
        throw improveErrorMessage(err, name260, void 0);
      }
    }
    function _cumsummap(array) {
      if (array.length === 0) {
        return [];
      }
      if (array.length >= WASM_CUMSUM_THRESHOLD && isFlatNumberArray6(array)) {
        const wasm = wasmLoader.getModule();
        if (wasm) {
          try {
            const alloc = wasmLoader.allocateFloat64Array(array);
            try {
              wasm.statsCumsum(alloc.ptr, array.length);
              const result = new Array(array.length);
              for (let i = 0; i < array.length; i++) {
                result[i] = alloc.array[i];
              }
              return result;
            } finally {
              wasmLoader.free(alloc.ptr);
            }
          } catch {
          }
        }
      }
      const sums = [unaryPlus(array[0])];
      for (let i = 1; i < array.length; ++i) {
        sums.push(add(sums[i - 1], array[i]));
      }
      return sums;
    }
    function _ncumSumDim(array, dim) {
      const size = arraySize(array);
      const dimValue = typeof dim === "number" ? dim : dim.valueOf();
      if (dimValue < 0 || dimValue >= size.length) {
        throw new IndexError(dimValue, 0, size.length);
      }
      try {
        return _cumsumDimensional(array, dimValue);
      } catch (err) {
        throw improveErrorMessage(err, name260, void 0);
      }
    }
    function _cumsumDimensional(mat, dim) {
      let i;
      let ret;
      let tran;
      if (dim <= 0) {
        const initialValue = mat[0][0];
        if (!Array.isArray(initialValue)) {
          return _cumsummap(mat);
        } else {
          tran = _switch(mat);
          ret = [];
          for (i = 0; i < tran.length; i++) {
            ret[i] = _cumsumDimensional(tran[i], dim - 1);
          }
          return ret;
        }
      } else {
        ret = [];
        for (i = 0; i < mat.length; i++) {
          ret[i] = _cumsumDimensional(mat[i], dim - 1);
        }
        return ret;
      }
    }
  }
);

// src/function/statistics/mean.ts
var WASM_MEAN_THRESHOLD = 100;
function isFlatNumberArray7(arr) {
  for (let i = 0; i < arr.length; i++) {
    if (typeof arr[i] !== "number") {
      return false;
    }
  }
  return true;
}
var name261 = "mean";
var dependencies262 = ["typed", "add", "divide"];
var createMean = /* @__PURE__ */ factory(
  name261,
  dependencies262,
  ({ typed: typed2, add, divide }) => {
    return typed2(name261, {
      // mean([a, b, c, d, ...])
      "Array | Matrix": _mean,
      // mean([a, b, c, d, ...], dim)
      "Array | Matrix, number | BigNumber": _nmeanDim,
      // mean(a, b, c, d, ...)
      "...": function(args) {
        if (containsCollections(args)) {
          throw new TypeError("Scalar values expected in function mean");
        }
        return _mean(args);
      }
    });
    function _nmeanDim(array, dim) {
      try {
        const dimValue = typeof dim === "number" ? dim : dim.valueOf();
        const sum = reduce(array, dimValue, add);
        const s = Array.isArray(array) ? arraySize(array) : array.size();
        return divide(sum, s[dimValue]);
      } catch (err) {
        throw improveErrorMessage(err, "mean", void 0);
      }
    }
    function _mean(array) {
      if (Array.isArray(array) && array.length >= WASM_MEAN_THRESHOLD) {
        if (isFlatNumberArray7(array)) {
          const wasm = wasmLoader.getModule();
          if (wasm) {
            try {
              const alloc = wasmLoader.allocateFloat64Array(array);
              try {
                return wasm.statsMean(alloc.ptr, array.length);
              } finally {
                wasmLoader.free(alloc.ptr);
              }
            } catch {
            }
          }
        }
      }
      let sum;
      let num = 0;
      deepForEach2(array, function(value) {
        try {
          sum = sum === void 0 ? value : add(sum, value);
          num++;
        } catch (err) {
          throw improveErrorMessage(err, "mean", value);
        }
      });
      if (num === 0) {
        throw new Error("Cannot calculate the mean of an empty array");
      }
      return divide(sum, num);
    }
  }
);

// src/function/statistics/median.ts
var name262 = "median";
var dependencies263 = ["typed", "add", "divide", "compare", "partitionSelect"];
var createMedian = /* @__PURE__ */ factory(
  name262,
  dependencies263,
  ({ typed: typed2, add, divide, compare, partitionSelect }) => {
    function _median(array) {
      try {
        const flat = flatten(array.valueOf());
        const num = flat.length;
        if (num === 0) {
          throw new Error("Cannot calculate median of an empty array");
        }
        if (num % 2 === 0) {
          const mid = num / 2 - 1;
          const right = partitionSelect(flat, mid + 1);
          let left = flat[mid];
          for (let i = 0; i < mid; ++i) {
            if (compare(flat[i], left) > 0) {
              left = flat[i];
            }
          }
          return middle2(left, right);
        } else {
          const m = partitionSelect(flat, (num - 1) / 2);
          return middle(m);
        }
      } catch (err) {
        throw improveErrorMessage(err, "median", void 0);
      }
    }
    const middle = typed2({
      "number | BigNumber | Complex | Unit": function(value) {
        return value;
      }
    });
    const middle2 = typed2({
      "number | BigNumber | Complex | Unit, number | BigNumber | Complex | Unit": function(left, right) {
        return divide(add(left, right), 2);
      }
    });
    return typed2(name262, {
      // median([a, b, c, d, ...])
      "Array | Matrix": _median,
      // median([a, b, c, d, ...], dim)
      "Array | Matrix, number | BigNumber": function(_array, _dim) {
        throw new Error("median(A, dim) is not yet supported");
      },
      // median(a, b, c, d, ...)
      "...": function(args) {
        if (containsCollections(args)) {
          throw new TypeError("Scalar values expected in function median");
        }
        return _median(args);
      }
    });
  }
);

// src/function/statistics/mad.ts
var WASM_MAD_THRESHOLD = 500;
function isPlainNumberArray(arr) {
  for (let i = 0; i < arr.length; i++) {
    if (typeof arr[i] !== "number") {
      return false;
    }
  }
  return true;
}
var name263 = "mad";
var dependencies264 = ["typed", "abs", "map", "median", "subtract"];
var createMad = /* @__PURE__ */ factory(
  name263,
  dependencies264,
  ({ typed: typed2, abs, map: map2, median, subtract }) => {
    return typed2(name263, {
      // mad([a, b, c, d, ...])
      "Array | Matrix": _mad,
      // mad(a, b, c, d, ...)
      "...": function(args) {
        return _mad(args);
      }
    });
    function _mad(array) {
      const flat = flatten(array.valueOf());
      if (flat.length === 0) {
        throw new Error(
          "Cannot calculate median absolute deviation (mad) of an empty array"
        );
      }
      const wasm = wasmLoader.getModule();
      if (wasm && flat.length >= WASM_MAD_THRESHOLD && isPlainNumberArray(flat)) {
        try {
          const aAlloc = wasmLoader.allocateFloat64Array(flat);
          try {
            const result = wasm.statsMad(aAlloc.ptr, flat.length);
            return result;
          } finally {
            wasmLoader.free(aAlloc.ptr);
          }
        } catch {
        }
      }
      try {
        const med = median(flat);
        return median(
          map2(flat, function(value) {
            return abs(subtract(value, med));
          })
        );
      } catch (err) {
        if (err instanceof TypeError && err.message.includes("median")) {
          throw new TypeError(err.message.replace("median", "mad"));
        } else {
          throw improveErrorMessage(err, "mad", void 0);
        }
      }
    }
  }
);

// src/function/statistics/variance.ts
var WASM_VARIANCE_THRESHOLD = 100;
function isFlatNumberArray8(arr) {
  for (let i = 0; i < arr.length; i++) {
    if (typeof arr[i] !== "number") {
      return false;
    }
  }
  return true;
}
var DEFAULT_NORMALIZATION = "unbiased";
var name264 = "variance";
var dependencies265 = [
  "typed",
  "add",
  "subtract",
  "multiply",
  "divide",
  "mapSlices",
  "isNaN"
];
var createVariance = /* @__PURE__ */ factory(
  name264,
  dependencies265,
  ({
    typed: typed2,
    add,
    subtract,
    multiply,
    divide,
    mapSlices,
    isNaN: mathIsNaN
  }) => {
    return typed2(name264, {
      // variance([a, b, c, d, ...])
      "Array | Matrix": function(array) {
        return _var(array, DEFAULT_NORMALIZATION);
      },
      // variance([a, b, c, d, ...], normalization)
      "Array | Matrix, string": _var,
      // variance([a, b, c, c, ...], dim)
      "Array | Matrix, number | BigNumber": function(array, dim) {
        return _varDim(array, dim, DEFAULT_NORMALIZATION);
      },
      // variance([a, b, c, c, ...], dim, normalization)
      "Array | Matrix, number | BigNumber, string": _varDim,
      // variance(a, b, c, d, ...)
      "...": function(args) {
        return _var(args, DEFAULT_NORMALIZATION);
      }
    });
    function _var(array, normalization) {
      if (array.length === 0) {
        throw new SyntaxError(
          "Function variance requires one or more parameters (0 provided)"
        );
      }
      if (Array.isArray(array) && array.length >= WASM_VARIANCE_THRESHOLD && (normalization === "unbiased" || normalization === "uncorrected")) {
        if (isFlatNumberArray8(array)) {
          const wasm = wasmLoader.getModule();
          if (wasm) {
            try {
              const alloc = wasmLoader.allocateFloat64Array(array);
              try {
                const ddof = normalization === "unbiased" ? 1 : 0;
                return wasm.statsVariance(alloc.ptr, array.length, ddof);
              } finally {
                wasmLoader.free(alloc.ptr);
              }
            } catch {
            }
          }
        }
      }
      let sum;
      let num = 0;
      deepForEach2(array, function(value) {
        try {
          sum = sum === void 0 ? value : add(sum, value);
          num++;
        } catch (err) {
          throw improveErrorMessage(err, "variance", value);
        }
      });
      if (num === 0)
        throw new Error("Cannot calculate variance of an empty array");
      const mean = divide(sum, num);
      sum = void 0;
      deepForEach2(array, function(value) {
        const diff = subtract(value, mean);
        sum = sum === void 0 ? multiply(diff, diff) : add(sum, multiply(diff, diff));
      });
      if (mathIsNaN(sum)) {
        return sum;
      }
      switch (normalization) {
        case "uncorrected":
          return divide(sum, num);
        case "biased":
          return divide(sum, num + 1);
        case "unbiased": {
          const zero = isBigNumber(sum) ? sum.mul(0) : 0;
          return num === 1 ? zero : divide(sum, num - 1);
        }
        default:
          throw new Error(
            'Unknown normalization "' + normalization + '". Choose "unbiased" (default), "uncorrected", or "biased".'
          );
      }
    }
    function _varDim(array, dim, normalization) {
      try {
        if (array.length === 0) {
          throw new SyntaxError(
            "Function variance requires one or more parameters (0 provided)"
          );
        }
        return mapSlices(array, dim, (x) => _var(x, normalization));
      } catch (err) {
        throw improveErrorMessage(err, "variance", void 0);
      }
    }
  }
);

// src/function/statistics/quantileSeq.ts
var name265 = "quantileSeq";
var dependencies266 = [
  "typed",
  "?bignumber",
  "add",
  "subtract",
  "divide",
  "multiply",
  "partitionSelect",
  "compare",
  "isInteger",
  "smaller",
  "smallerEq",
  "larger",
  "mapSlices"
];
var createQuantileSeq = /* @__PURE__ */ factory(
  name265,
  dependencies266,
  ({
    typed: typed2,
    bignumber,
    add,
    subtract,
    divide,
    multiply,
    partitionSelect,
    compare,
    isInteger: isInteger2,
    smaller,
    smallerEq,
    larger,
    mapSlices
  }) => {
    return typed2(name265, {
      "Array | Matrix, number | BigNumber": (data, p) => _quantileSeqProbNumber(data, p, false),
      "Array | Matrix, number | BigNumber, number": (data, prob, dim) => _quantileSeqDim(data, prob, false, dim, _quantileSeqProbNumber),
      "Array | Matrix, number | BigNumber, boolean": _quantileSeqProbNumber,
      "Array | Matrix, number | BigNumber, boolean, number": (data, prob, sorted, dim) => _quantileSeqDim(data, prob, sorted, dim, _quantileSeqProbNumber),
      "Array | Matrix, Array | Matrix": (data, p) => _quantileSeqProbCollection(data, p, false),
      "Array | Matrix, Array | Matrix, number": (data, prob, dim) => _quantileSeqDim(data, prob, false, dim, _quantileSeqProbCollection),
      "Array | Matrix, Array | Matrix, boolean": _quantileSeqProbCollection,
      "Array | Matrix, Array | Matrix, boolean, number": (data, prob, sorted, dim) => _quantileSeqDim(data, prob, sorted, dim, _quantileSeqProbCollection)
    });
    function _quantileSeqDim(data, prob, sorted, dim, fn) {
      return mapSlices(data, dim, (x) => fn(x, prob, sorted));
    }
    function _quantileSeqProbNumber(data, probOrN, sorted) {
      let probArr;
      const dataArr = data.valueOf();
      if (smaller(probOrN, 0)) {
        throw new Error("N/prob must be non-negative");
      }
      if (smallerEq(probOrN, 1)) {
        return isNumber(probOrN) ? _quantileSeq(dataArr, probOrN, sorted) : bignumber(_quantileSeq(dataArr, probOrN, sorted));
      }
      if (larger(probOrN, 1)) {
        if (!isInteger2(probOrN)) {
          throw new Error("N must be a positive integer");
        }
        if (larger(probOrN, 4294967295)) {
          throw new Error(
            "N must be less than or equal to 2^32-1, as that is the maximum length of an Array"
          );
        }
        const nPlusOne = add(probOrN, 1);
        probArr = [];
        for (let i = 0; smaller(i, probOrN); i++) {
          const prob = divide(i + 1, nPlusOne);
          probArr.push(_quantileSeq(dataArr, prob, sorted));
        }
        return isNumber(probOrN) ? probArr : bignumber(probArr);
      }
    }
    function _quantileSeqProbCollection(data, probOrN, sorted) {
      const dataArr = data.valueOf();
      const probOrNArr = probOrN.valueOf();
      const probArr = [];
      for (let i = 0; i < probOrNArr.length; ++i) {
        probArr.push(_quantileSeq(dataArr, probOrNArr[i], sorted));
      }
      return probArr;
    }
    function _quantileSeq(array, prob, sorted) {
      const flat = flatten(array);
      const len = flat.length;
      if (len === 0) {
        throw new Error("Cannot calculate quantile of an empty sequence");
      }
      const index = isNumber(prob) ? prob * (len - 1) : prob.times(len - 1);
      const integerPart = isNumber(prob) ? Math.floor(index) : index.floor().toNumber();
      const fracPart = isNumber(prob) ? index % 1 : index.minus(integerPart);
      if (isInteger2(index)) {
        return sorted ? flat[index] : partitionSelect(flat, isNumber(prob) ? index : index.valueOf());
      }
      let left;
      let right;
      if (sorted) {
        left = flat[integerPart];
        right = flat[integerPart + 1];
      } else {
        right = partitionSelect(flat, integerPart + 1);
        left = flat[integerPart];
        for (let i = 0; i < integerPart; ++i) {
          if (compare(flat[i], left) > 0) {
            left = flat[i];
          }
        }
      }
      const fracPartConverted = isBigNumber(left) && isNumber(fracPart) ? bignumber(fracPart) : fracPart;
      return add(
        multiply(left, subtract(1, fracPartConverted)),
        multiply(right, fracPartConverted)
      );
    }
  }
);

// src/function/statistics/std.ts
var WASM_STD_THRESHOLD = 100;
function isFlatNumberArray9(arr) {
  for (let i = 0; i < arr.length; i++) {
    if (typeof arr[i] !== "number") {
      return false;
    }
  }
  return true;
}
var name266 = "std";
var dependencies267 = ["typed", "map", "sqrt", "variance"];
var createStd = /* @__PURE__ */ factory(
  name266,
  dependencies267,
  ({ typed: typed2, map: map2, sqrt, variance }) => {
    return typed2(name266, {
      // std([a, b, c, d, ...])
      "Array | Matrix": _std,
      // std([a, b, c, d, ...], normalization)
      "Array | Matrix, string": _std,
      // std([a, b, c, c, ...], dim)
      "Array | Matrix, number | BigNumber": _std,
      // std([a, b, c, c, ...], dim, normalization)
      "Array | Matrix, number | BigNumber, string": _std,
      // std(a, b, c, d, ...)
      "...": function(args) {
        return _std(args);
      }
    });
    function _std(array, normalizationOrDim) {
      if (array.length === 0) {
        throw new SyntaxError(
          "Function std requires one or more parameters (0 provided)"
        );
      }
      const normalization = typeof normalizationOrDim === "string" ? normalizationOrDim : "unbiased";
      const isDimension = typeof normalizationOrDim === "number" || normalizationOrDim !== void 0 && typeof normalizationOrDim === "object";
      if (!isDimension && Array.isArray(array) && array.length >= WASM_STD_THRESHOLD && (normalization === "unbiased" || normalization === "uncorrected")) {
        if (isFlatNumberArray9(array)) {
          const wasm = wasmLoader.getModule();
          if (wasm) {
            try {
              const alloc = wasmLoader.allocateFloat64Array(array);
              try {
                const ddof = normalization === "unbiased" ? 1 : 0;
                return wasm.statsStd(alloc.ptr, array.length, ddof);
              } finally {
                wasmLoader.free(alloc.ptr);
              }
            } catch {
            }
          }
        }
      }
      try {
        const v = variance.apply(null, arguments);
        if (isCollection(v)) {
          return map2(v, sqrt);
        } else {
          return sqrt(v);
        }
      } catch (err) {
        if (err instanceof TypeError && err.message.includes(" variance")) {
          throw new TypeError(err.message.replace(" variance", " std"));
        } else {
          throw err;
        }
      }
    }
  }
);

// src/function/statistics/corr.ts
var WASM_CORR_THRESHOLD = 200;
function isPlainNumberArray2(arr) {
  for (let i = 0; i < arr.length; i++) {
    if (typeof arr[i] !== "number") {
      return false;
    }
  }
  return true;
}
var name267 = "corr";
var dependencies268 = [
  "typed",
  "matrix",
  "mean",
  "sqrt",
  "sum",
  "add",
  "subtract",
  "multiply",
  "pow",
  "divide"
];
var createCorr = /* @__PURE__ */ factory(
  name267,
  dependencies268,
  ({
    typed: typed2,
    matrix,
    sqrt,
    sum,
    add,
    subtract,
    multiply,
    pow,
    divide
  }) => {
    return typed2(name267, {
      "Array, Array": function(A, B) {
        return _corr(A, B);
      },
      "Matrix, Matrix": function(A, B) {
        const res = _corr(A.toArray(), B.toArray());
        return Array.isArray(res) ? matrix(res) : res;
      }
    });
    function _corr(A, B) {
      const correlations = [];
      if (Array.isArray(A[0]) && Array.isArray(B[0])) {
        if (A.length !== B.length) {
          throw new SyntaxError(
            "Dimension mismatch. Array A and B must have the same length."
          );
        }
        for (let i = 0; i < A.length; i++) {
          if (A[i].length !== B[i].length) {
            throw new SyntaxError(
              "Dimension mismatch. Array A and B must have the same number of elements."
            );
          }
          correlations.push(correlation(A[i], B[i]));
        }
        return correlations;
      } else {
        if (A.length !== B.length) {
          throw new SyntaxError(
            "Dimension mismatch. Array A and B must have the same number of elements."
          );
        }
        return correlation(A, B);
      }
    }
    function correlation(A, B) {
      const n = A.length;
      const wasm = wasmLoader.getModule();
      if (wasm && n >= WASM_CORR_THRESHOLD && isPlainNumberArray2(A) && isPlainNumberArray2(B)) {
        try {
          const aAlloc = wasmLoader.allocateFloat64Array(A);
          const bAlloc = wasmLoader.allocateFloat64Array(B);
          try {
            const result = wasm.statsCorrelation(aAlloc.ptr, bAlloc.ptr, n);
            return result;
          } finally {
            wasmLoader.free(aAlloc.ptr);
            wasmLoader.free(bAlloc.ptr);
          }
        } catch {
        }
      }
      const sumX = sum(A);
      const sumY = sum(B);
      const sumXY = A.reduce(
        (acc, x, index) => add(acc, multiply(x, B[index])),
        0
      );
      const sumXSquare = sum(A.map((x) => pow(x, 2)));
      const sumYSquare = sum(B.map((y) => pow(y, 2)));
      const numerator = subtract(multiply(n, sumXY), multiply(sumX, sumY));
      const denominator = sqrt(
        multiply(
          subtract(multiply(n, sumXSquare), pow(sumX, 2)),
          subtract(multiply(n, sumYSquare), pow(sumY, 2))
        )
      );
      return divide(numerator, denominator);
    }
  }
);

// src/function/probability/bernoulli.ts
var name268 = "bernoulli";
var dependencies269 = [
  "typed",
  "config",
  "isInteger",
  "number",
  "?BigNumber",
  "?Fraction"
];
var createBernoulli = /* @__PURE__ */ factory(
  name268,
  dependencies269,
  ({
    typed: typed2,
    config,
    isInteger: _isInteger,
    number,
    BigNumber,
    Fraction: Fraction2
  }) => {
    const numberCache = [void 0];
    const fractionCache = [void 0];
    let bigCache = [void 0];
    let cachedPrecision = 50;
    return typed2(name268, {
      number: (index) => _bernoulli(
        index,
        (n) => n,
        numberCache,
        (a, b) => a + b,
        (a, b) => a * b,
        (a, b) => a / b
      ),
      "bigint | Fraction": (index) => _bernoulli(
        number(index),
        (n) => new Fraction2(n),
        fractionCache,
        (a, b) => a.add(b),
        (a, b) => a.mul(b),
        (a, b) => a.div(b)
      ),
      BigNumber: (index) => {
        if (config.precision !== cachedPrecision) {
          bigCache = [void 0];
          cachedPrecision = config.precision;
        }
        return _bernoulli(
          number(index),
          (n) => new BigNumber(n),
          bigCache,
          (a, b) => a.add(b),
          (a, b) => a.mul(b),
          (a, b) => a.div(b)
        );
      }
    });
  }
);
function _bernoulli(index, promote, A, plus, times, divide) {
  if (index < 0 || !isInteger(index)) {
    throw new RangeError("Bernoulli index must be nonnegative integer");
  }
  if (index === 0) return promote(1);
  if (index === 1) return divide(promote(-1), promote(2));
  if (index % 2 === 1) return promote(0);
  const one = promote(1);
  if (A.length === 1) {
    A.push([
      divide(one, promote(-3)),
      divide(one, promote(-2)),
      divide(one, promote(6))
    ]);
  }
  const half = index / 2;
  const zero = promote(0);
  const two = promote(2);
  while (A.length <= half) {
    const i = A.length;
    const lim = Math.floor((i + 1) / 2);
    let a = zero;
    for (let m = 1; m < lim; ++m) {
      const entry_m = A[m];
      const entry_i_m = A[i - m];
      a = plus(a, times(entry_m[0], entry_i_m[0]));
    }
    a = times(a, two);
    if (i % 2 === 0) {
      const entry_lim = A[lim];
      a = plus(a, times(entry_lim[0], entry_lim[0]));
    }
    a = divide(a, promote(-(2 * i + 1)));
    const entry_i_1 = A[i - 1];
    const prefactor = divide(times(entry_i_1[1], promote(-i * (2 * i - 1))), two);
    A.push([a, prefactor, times(prefactor, a)]);
  }
  const entry_half = A[half];
  return entry_half[2];
}

// src/function/probability/combinations.ts
var name269 = "combinations";
var dependencies270 = ["typed"];
var createCombinations = /* @__PURE__ */ factory(
  name269,
  dependencies270,
  ({ typed: typed2 }) => {
    return typed2(name269, {
      "number, number": combinationsNumber,
      "BigNumber, BigNumber": function(n, k) {
        const BigNumber = n.constructor;
        let result;
        let i;
        const nMinusk = n.minus(k);
        const one = new BigNumber(1);
        if (!isPositiveInteger(n) || !isPositiveInteger(k)) {
          throw new TypeError(
            "Positive integer value expected in function combinations"
          );
        }
        if (k.gt(n)) {
          throw new TypeError("k must be less than n in function combinations");
        }
        result = one;
        if (k.lt(nMinusk)) {
          for (i = one; i.lte(nMinusk); i = i.plus(one)) {
            result = result.times(k.plus(i)).dividedBy(i);
          }
        } else {
          for (i = one; i.lte(k); i = i.plus(one)) {
            result = result.times(nMinusk.plus(i)).dividedBy(i);
          }
        }
        return result;
      }
      // TODO: implement support for collection in combinations
    });
  }
);
function isPositiveInteger(n) {
  return n.isInteger() && n.gte(0);
}

// src/function/probability/combinationsWithRep.ts
var name270 = "combinationsWithRep";
var dependencies271 = ["typed"];
var createCombinationsWithRep = /* @__PURE__ */ factory(
  name270,
  dependencies271,
  ({ typed: typed2 }) => {
    return typed2(name270, {
      "number, number": function(n, k) {
        if (!isInteger(n) || n < 0) {
          throw new TypeError(
            "Positive integer value expected in function combinationsWithRep"
          );
        }
        if (!isInteger(k) || k < 0) {
          throw new TypeError(
            "Positive integer value expected in function combinationsWithRep"
          );
        }
        if (n < 1) {
          throw new TypeError("k must be less than or equal to n + k - 1");
        }
        if (k < n - 1) {
          const prodrange2 = product2(n, n + k - 1);
          return prodrange2 / product2(1, k);
        }
        const prodrange = product2(k + 1, n + k - 1);
        return prodrange / product2(1, n - 1);
      },
      "BigNumber, BigNumber": function(n, k) {
        const BigNumber = n.constructor;
        let result;
        let i;
        const one = new BigNumber(1);
        const nMinusOne = n.minus(one);
        if (!isPositiveInteger2(n) || !isPositiveInteger2(k)) {
          throw new TypeError(
            "Positive integer value expected in function combinationsWithRep"
          );
        }
        if (n.lt(one)) {
          throw new TypeError(
            "k must be less than or equal to n + k - 1 in function combinationsWithRep"
          );
        }
        result = one;
        if (k.lt(nMinusOne)) {
          for (i = one; i.lte(nMinusOne); i = i.plus(one)) {
            result = result.times(k.plus(i)).dividedBy(i);
          }
        } else {
          for (i = one; i.lte(k); i = i.plus(one)) {
            result = result.times(nMinusOne.plus(i)).dividedBy(i);
          }
        }
        return result;
      }
    });
  }
);
function isPositiveInteger2(n) {
  return n.isInteger() && n.gte(0);
}

// src/function/probability/gamma.ts
var name271 = "gamma";
var dependencies272 = [
  "typed",
  "config",
  "multiplyScalar",
  "pow",
  "BigNumber",
  "Complex"
];
var createGamma = /* @__PURE__ */ factory(
  name271,
  dependencies272,
  ({
    typed: typed2,
    config,
    multiplyScalar: _multiplyScalar,
    pow: _pow,
    BigNumber,
    Complex: Complex2
  }) => {
    function gammaComplex(n) {
      if (n.im === 0) {
        return gammaNumber(n.re);
      }
      if (n.re < 0.5) {
        const t2 = new Complex2(1 - n.re, -n.im);
        const r = new Complex2(Math.PI * n.re, Math.PI * n.im);
        const gammaT = gammaComplex(t2);
        return new Complex2(Math.PI).div(r.sin()).div(gammaT);
      }
      let z = new Complex2(n.re - 1, n.im);
      let x = new Complex2(gammaP[0], 0);
      for (let i = 1; i < gammaP.length; ++i) {
        const gammaPval = new Complex2(gammaP[i], 0);
        x = x.add(gammaPval.div(z.add(i)));
      }
      const t = new Complex2(z.re + gammaG + 0.5, z.im);
      const twoPiSqrt = Math.sqrt(2 * Math.PI);
      const tpow = t.pow(z.add(0.5));
      const expt = t.neg().exp();
      return x.mul(twoPiSqrt).mul(tpow).mul(expt);
    }
    return typed2(name271, {
      number: gammaNumber,
      Complex: gammaComplex,
      BigNumber: function(n) {
        if (n.isInteger()) {
          return n.isNegative() || n.isZero() ? new BigNumber(Infinity) : bigFactorial(n.minus(1));
        }
        if (!n.isFinite()) {
          return new BigNumber(n.isNegative() ? NaN : Infinity);
        }
        throw new Error("Integer BigNumber expected");
      }
    });
    function bigFactorial(n) {
      const nNum = n.toNumber();
      if (nNum < 8) {
        return new BigNumber([1, 1, 2, 6, 24, 120, 720, 5040][nNum]);
      }
      const precision = config.precision + (Math.log(nNum) | 0);
      const Big = BigNumber.clone({ precision });
      if (nNum % 2 === 1) {
        return n.times(bigFactorial(n.minus(1)));
      }
      let p = nNum;
      let prod = new Big(nNum);
      let sum = nNum;
      while (p > 2) {
        p -= 2;
        sum += p;
        prod = prod.times(new BigNumber(sum));
      }
      return new BigNumber(prod.toPrecision(BigNumber.precision));
    }
  }
);

// src/function/probability/lgamma.ts
var name272 = "lgamma";
var dependencies273 = ["Complex", "typed"];
var createLgamma = /* @__PURE__ */ factory(
  name272,
  dependencies273,
  ({
    Complex: Complex2,
    typed: typed2
  }) => {
    const SMALL_RE = 7;
    const SMALL_IM = 7;
    const coeffs = [
      -0.029550653594771242,
      0.00641025641025641,
      -0.0019175269175269176,
      8417508417508417e-19,
      -5952380952380953e-19,
      7936507936507937e-19,
      -0.002777777777777778,
      0.08333333333333333
    ];
    return typed2(name272, {
      number: lgammaNumber,
      Complex: lgammaComplex,
      BigNumber: function() {
        throw new Error(
          "mathjs doesn't yet provide an implementation of the algorithm lgamma for BigNumber"
        );
      }
    });
    function lgammaComplex(n) {
      const TWOPI = 6.283185307179586;
      const LOGPI = 1.1447298858494002;
      const REFLECTION = 0.1;
      if (n.isNaN()) {
        return new Complex2(NaN, NaN);
      } else if (n.im === 0) {
        return new Complex2(lgammaNumber(n.re), 0);
      } else if (n.re >= SMALL_RE || Math.abs(n.im) >= SMALL_IM) {
        return lgammaStirling(n);
      } else if (n.re <= REFLECTION) {
        const tmp = copysign(TWOPI, n.im) * Math.floor(0.5 * n.re + 0.25);
        const a = n.mul(Math.PI).sin().log();
        const b = lgammaComplex(new Complex2(1 - n.re, -n.im));
        return new Complex2(LOGPI, tmp).sub(a).sub(b);
      } else if (n.im >= 0) {
        return lgammaRecurrence(n);
      } else {
        return lgammaRecurrence(n.conjugate()).conjugate();
      }
    }
    function lgammaStirling(z) {
      const leftPart = z.sub(0.5).mul(z.log()).sub(z).add(lnSqrt2PI);
      const rz = new Complex2(1, 0).div(z);
      const rzz = rz.div(z);
      let a = coeffs[0];
      let b = coeffs[1];
      const r = 2 * rzz.re;
      const s = rzz.re * rzz.re + rzz.im * rzz.im;
      for (let i = 2; i < 8; i++) {
        const tmp = b;
        b = -s * a + coeffs[i];
        a = r * a + tmp;
      }
      const rightPart = rz.mul(rzz.mul(a).add(b));
      return leftPart.add(rightPart);
    }
    function lgammaRecurrence(z) {
      let signflips = 0;
      let sb = 0;
      let shiftprod = z;
      z = z.add(1);
      while (z.re <= SMALL_RE) {
        shiftprod = shiftprod.mul(z);
        const nsb = shiftprod.im < 0 ? 1 : 0;
        if (nsb !== 0 && sb === 0) signflips++;
        sb = nsb;
        z = z.add(1);
      }
      return lgammaStirling(z).sub(shiftprod.log()).sub(new Complex2(0, signflips * 2 * Math.PI * 1));
    }
  }
);

// src/function/probability/factorial.ts
var name273 = "factorial";
var dependencies274 = ["typed", "gamma"];
var createFactorial = /* @__PURE__ */ factory(
  name273,
  dependencies274,
  ({ typed: typed2, gamma }) => {
    return typed2(name273, {
      number: function(n) {
        if (n < 0) {
          throw new Error("Value must be non-negative");
        }
        return gamma(n + 1);
      },
      BigNumber: function(n) {
        if (n.isNegative()) {
          throw new Error("Value must be non-negative");
        }
        return gamma(n.plus(1));
      },
      "Array | Matrix": typed2.referToSelf(
        (self) => (n) => deepMap2(n, self)
      )
    });
  }
);

// src/function/probability/kldivergence.ts
var name274 = "kldivergence";
var dependencies275 = [
  "typed",
  "matrix",
  "divide",
  "sum",
  "multiply",
  "map",
  "dotDivide",
  "log",
  "isNumeric"
];
var createKldivergence = /* @__PURE__ */ factory(
  name274,
  dependencies275,
  ({
    typed: typed2,
    matrix,
    divide,
    sum,
    multiply,
    map: map2,
    dotDivide,
    log,
    isNumeric
  }) => {
    return typed2(name274, {
      "Array, Array": function(q, p) {
        return _kldiv(matrix(q), matrix(p));
      },
      "Matrix, Array": function(q, p) {
        return _kldiv(q, matrix(p));
      },
      "Array, Matrix": function(q, p) {
        return _kldiv(matrix(q), p);
      },
      "Matrix, Matrix": function(q, p) {
        return _kldiv(q, p);
      }
    });
    function _kldiv(q, p) {
      const plength = p.size().length;
      const qlength = q.size().length;
      if (plength > 1) {
        throw new Error("first object must be one dimensional");
      }
      if (qlength > 1) {
        throw new Error("second object must be one dimensional");
      }
      if (plength !== qlength) {
        throw new Error("Length of two vectors must be equal");
      }
      const sumq = sum(q);
      if (sumq === 0) {
        throw new Error("Sum of elements in first object must be non zero");
      }
      const sump = sum(p);
      if (sump === 0) {
        throw new Error("Sum of elements in second object must be non zero");
      }
      const qnorm = divide(q, sum(q));
      const pnorm = divide(p, sum(p));
      const result = sum(
        multiply(
          qnorm,
          map2(
            dotDivide(qnorm, pnorm),
            (x) => log(x)
          )
        )
      );
      if (isNumeric(result)) {
        return result;
      } else {
        return Number.NaN;
      }
    }
  }
);

// src/function/probability/multinomial.ts
var name275 = "multinomial";
var dependencies276 = [
  "typed",
  "add",
  "divide",
  "multiply",
  "factorial",
  "isInteger",
  "isPositive"
];
var createMultinomial = /* @__PURE__ */ factory(
  name275,
  dependencies276,
  ({
    typed: typed2,
    add,
    divide,
    multiply,
    factorial,
    isInteger: isInteger2,
    isPositive
  }) => {
    return typed2(name275, {
      "Array | Matrix": function(a) {
        let sum = 0;
        let denom = 1;
        deepForEach2(a, function(ai) {
          if (!isInteger2(ai) || !isPositive(ai)) {
            throw new TypeError(
              "Positive integer value expected in function multinomial"
            );
          }
          sum = add(sum, ai);
          denom = multiply(denom, factorial(ai));
        });
        return divide(factorial(sum), denom);
      }
    });
  }
);

// src/function/probability/permutations.ts
var name276 = "permutations";
var dependencies277 = ["typed", "factorial"];
var createPermutations = /* @__PURE__ */ factory(
  name276,
  dependencies277,
  ({ typed: typed2, factorial }) => {
    return typed2(name276, {
      "number | BigNumber": factorial,
      "number, number": function(n, k) {
        if (!isInteger(n) || n < 0) {
          throw new TypeError(
            "Positive integer value expected in function permutations"
          );
        }
        if (!isInteger(k) || k < 0) {
          throw new TypeError(
            "Positive integer value expected in function permutations"
          );
        }
        if (k > n) {
          throw new TypeError(
            "second argument k must be less than or equal to first argument n"
          );
        }
        return product2(n - k + 1, n);
      },
      "BigNumber, BigNumber": function(n, k) {
        let result;
        let i;
        if (!isPositiveInteger3(n) || !isPositiveInteger3(k)) {
          throw new TypeError(
            "Positive integer value expected in function permutations"
          );
        }
        if (k.gt(n)) {
          throw new TypeError(
            "second argument k must be less than or equal to first argument n"
          );
        }
        const one = n.mul(0).add(1);
        result = one;
        for (i = n.minus(k).plus(1); i.lte(n); i = i.plus(1)) {
          result = result.times(i);
        }
        return result;
      }
      // TODO: implement support for collection in permutations
    });
  }
);
function isPositiveInteger3(n) {
  return n.isInteger() && n.gte(0);
}
var singletonRandom = /* @__PURE__ */ seedrandom__default.default(Date.now());
function createRng(randomSeed) {
  let random;
  function setSeed(seed) {
    random = seed === null ? singletonRandom : seedrandom__default.default(String(seed));
  }
  setSeed(randomSeed);
  function rng() {
    return random();
  }
  return rng;
}

// src/function/probability/pickRandom.ts
var name277 = "pickRandom";
var dependencies278 = ["typed", "config", "?on"];
var createPickRandom = /* @__PURE__ */ factory(
  name277,
  dependencies278,
  ({ typed: typed2, config, on }) => {
    let rng = createRng(config.randomSeed);
    if (on) {
      on("config", function(curr, prev) {
        if (curr.randomSeed !== prev.randomSeed) {
          rng = createRng(curr.randomSeed);
        }
      });
    }
    return typed2(name277, {
      "Array | Matrix": function(possibles) {
        return _pickRandom(possibles, {});
      },
      "Array | Matrix, Object": function(possibles, options) {
        return _pickRandom(possibles, options);
      },
      "Array | Matrix, number": function(possibles, number) {
        return _pickRandom(possibles, { number });
      },
      "Array | Matrix, Array | Matrix": function(possibles, weights) {
        return _pickRandom(possibles, { weights });
      },
      "Array | Matrix, Array | Matrix, number": function(possibles, weights, number) {
        return _pickRandom(possibles, { number, weights });
      },
      "Array | Matrix, number, Array | Matrix": function(possibles, number, weights) {
        return _pickRandom(possibles, { number, weights });
      }
    });
    function _pickRandom(possibles, { number, weights, elementWise = true }) {
      const single = typeof number === "undefined";
      if (single) {
        number = 1;
      }
      const createMatrix2 = isMatrix(possibles) ? possibles.create : isMatrix(weights) ? weights.create : null;
      let possiblesArr = possibles.valueOf();
      let weightsArr;
      if (weights) {
        weightsArr = weights.valueOf();
      }
      if (elementWise === true) {
        possiblesArr = flatten(possiblesArr);
        weightsArr = weightsArr ? flatten(weightsArr) : void 0;
      }
      let totalWeights = 0;
      if (typeof weightsArr !== "undefined") {
        if (weightsArr.length !== possiblesArr.length) {
          throw new Error("Weights must have the same length as possibles");
        }
        for (let i = 0, len = weightsArr.length; i < len; i++) {
          if (!isNumber(weightsArr[i]) || weightsArr[i] < 0) {
            throw new Error("Weights must be an array of positive numbers");
          }
          totalWeights += weightsArr[i];
        }
      }
      const length = possiblesArr.length;
      const result = [];
      let pick;
      while (result.length < number) {
        if (typeof weightsArr === "undefined") {
          pick = possiblesArr[Math.floor(rng() * length)];
        } else {
          let randKey = rng() * totalWeights;
          for (let i = 0, len = possiblesArr.length; i < len; i++) {
            randKey -= weightsArr[i];
            if (randKey < 0) {
              pick = possiblesArr[i];
              break;
            }
          }
        }
        result.push(pick);
      }
      return single ? result[0] : createMatrix2 ? createMatrix2(result) : result;
    }
  }
);

// src/function/probability/util/randomMatrix.ts
function randomMatrix(size, random) {
  const data = [];
  size = size.slice(0);
  if (size.length > 1) {
    for (let i = 0, length = size.shift(); i < length; i++) {
      data.push(randomMatrix(size, random));
    }
  } else {
    for (let i = 0, length = size.shift(); i < length; i++) {
      data.push(random());
    }
  }
  return data;
}

// src/function/probability/random.ts
var name278 = "random";
var dependencies279 = ["typed", "config", "?on"];
var createRandom = /* @__PURE__ */ factory(
  name278,
  dependencies279,
  ({ typed: typed2, config, on }) => {
    let rng = createRng(config.randomSeed);
    if (on) {
      on("config", function(curr, prev) {
        if (curr.randomSeed !== prev.randomSeed) {
          rng = createRng(curr.randomSeed);
        }
      });
    }
    return typed2(name278, {
      "": () => _random(0, 1),
      number: (max) => _random(0, max),
      "number, number": (min, max) => _random(min, max),
      "Array | Matrix": (size) => _randomMatrix(size, 0, 1),
      "Array | Matrix, number": (size, max) => _randomMatrix(size, 0, max),
      "Array | Matrix, number, number": (size, min, max) => _randomMatrix(size, min, max)
    });
    function _randomMatrix(size, min, max) {
      const res = randomMatrix(size.valueOf(), () => _random(min, max));
      return isMatrix(size) ? size.create(res, "number") : res;
    }
    function _random(min, max) {
      return min + rng() * (max - min);
    }
  }
);

// src/function/probability/randomInt.ts
var name279 = "randomInt";
var dependencies280 = ["typed", "config", "log2", "?on"];
var createRandomInt = /* @__PURE__ */ factory(
  name279,
  dependencies280,
  ({
    typed: typed2,
    config,
    log2: log23,
    on
  }) => {
    let rng = createRng(config.randomSeed);
    if (on) {
      on("config", function(curr, prev) {
        if (curr.randomSeed !== prev.randomSeed) {
          rng = createRng(curr.randomSeed);
        }
      });
    }
    return typed2(name279, {
      "": () => _randomInt(0, 2),
      number: (max) => _randomInt(0, max),
      "number, number": (min, max) => _randomInt(min, max),
      bigint: (max) => _randomBigint(0n, max),
      "bigint, bigint": _randomBigint,
      "Array | Matrix": (size) => _randomIntMatrix(size, 0, 1),
      "Array | Matrix, number": (size, max) => _randomIntMatrix(size, 0, max),
      "Array | Matrix, number, number": (size, min, max) => _randomIntMatrix(size, min, max)
    });
    function _randomIntMatrix(size, min, max) {
      const res = randomMatrix(size.valueOf(), () => _randomInt(min, max));
      return isMatrix(size) ? size.create(res, "number") : res;
    }
    function _randomInt(min, max) {
      return Math.floor(min + rng() * (max - min));
    }
    function _randomBigint(min, max) {
      const simpleCutoff = 2n ** 30n;
      const width = max - min;
      if (width <= simpleCutoff) {
        return min + BigInt(_randomInt(0, Number(width)));
      }
      const bits = log23(width);
      let picked = width;
      while (picked >= width) {
        picked = 0n;
        for (let i = 0; i < bits; ++i) {
          picked = 2n * picked + (rng() < 0.5 ? 0n : 1n);
        }
      }
      return min + picked;
    }
  }
);

// src/function/combinatorics/stirlingS2.ts
var name280 = "stirlingS2";
var dependencies281 = [
  "typed",
  "addScalar",
  "subtractScalar",
  "multiplyScalar",
  "divideScalar",
  "pow",
  "factorial",
  "combinations",
  "isNegative",
  "isInteger",
  "number",
  "?bignumber",
  "larger"
];
var createStirlingS2 = /* @__PURE__ */ factory(
  name280,
  dependencies281,
  ({
    typed: typed2,
    addScalar,
    subtractScalar: _subtractScalar,
    multiplyScalar,
    divideScalar: _divideScalar,
    pow: _pow,
    factorial: _factorial,
    combinations: _combinations,
    isNegative,
    isInteger: isInteger2,
    number,
    bignumber,
    larger
  }) => {
    const smallCache = [];
    const bigCache = [];
    return typed2(name280, {
      "number | BigNumber, number | BigNumber": function(n, k) {
        if (!isInteger2(n) || isNegative(n) || !isInteger2(k) || isNegative(k)) {
          throw new TypeError(
            "Non-negative integer value expected in function stirlingS2"
          );
        } else if (larger(k, n)) {
          throw new TypeError(
            "k must be less than or equal to n in function stirlingS2"
          );
        }
        const big = !(isNumber(n) && isNumber(k));
        const cache = big ? bigCache : smallCache;
        const make = big ? bignumber : number;
        const nn = number(n);
        const nk = number(k);
        if (cache[nn] && cache[nn].length > nk) {
          return cache[nn][nk];
        }
        for (let m = 0; m <= nn; ++m) {
          if (!cache[m]) {
            cache[m] = [m === 0 ? make(1) : make(0)];
          }
          if (m === 0) continue;
          const row = cache[m];
          const prev = cache[m - 1];
          for (let i = row.length; i <= m && i <= nk; ++i) {
            if (i === m) {
              row[i] = 1;
            } else {
              row[i] = addScalar(multiplyScalar(make(i), prev[i]), prev[i - 1]);
            }
          }
        }
        return cache[nn][nk];
      }
    });
  }
);

// src/function/combinatorics/bellNumbers.ts
var name281 = "bellNumbers";
var dependencies282 = [
  "typed",
  "addScalar",
  "isNegative",
  "isInteger",
  "stirlingS2"
];
var createBellNumbers = /* @__PURE__ */ factory(
  name281,
  dependencies282,
  ({
    typed: typed2,
    addScalar,
    isNegative,
    isInteger: isInteger2,
    stirlingS2
  }) => {
    return typed2(name281, {
      "number | BigNumber": function(n) {
        if (!isInteger2(n) || isNegative(n)) {
          throw new TypeError(
            "Non-negative integer value expected in function bellNumbers"
          );
        }
        let result = 0;
        for (let i = 0; i <= n; i++) {
          result = addScalar(result, stirlingS2(n, i));
        }
        return result;
      }
    });
  }
);

// src/function/combinatorics/catalan.ts
var name282 = "catalan";
var dependencies283 = [
  "typed",
  "addScalar",
  "divideScalar",
  "multiplyScalar",
  "combinations",
  "isNegative",
  "isInteger"
];
var createCatalan = /* @__PURE__ */ factory(
  name282,
  dependencies283,
  ({
    typed: typed2,
    addScalar,
    divideScalar,
    multiplyScalar,
    combinations,
    isNegative,
    isInteger: isInteger2
  }) => {
    return typed2(name282, {
      "number | BigNumber": function(n) {
        if (!isInteger2(n) || isNegative(n)) {
          throw new TypeError(
            "Non-negative integer value expected in function catalan"
          );
        }
        return divideScalar(
          combinations(multiplyScalar(n, 2), n),
          addScalar(n, 1)
        );
      }
    });
  }
);

// src/function/combinatorics/composition.ts
var name283 = "composition";
var dependencies284 = [
  "typed",
  "addScalar",
  "combinations",
  "isNegative",
  "isPositive",
  "isInteger",
  "larger"
];
var createComposition = /* @__PURE__ */ factory(
  name283,
  dependencies284,
  ({
    typed: typed2,
    addScalar,
    combinations,
    isPositive,
    isNegative: _isNegative,
    isInteger: isInteger2,
    larger
  }) => {
    return typed2(name283, {
      "number | BigNumber, number | BigNumber": function(n, k) {
        if (!isInteger2(n) || !isPositive(n) || !isInteger2(k) || !isPositive(k)) {
          throw new TypeError(
            "Positive integer value expected in function composition"
          );
        } else if (larger(k, n)) {
          throw new TypeError(
            "k must be less than or equal to n in function composition"
          );
        }
        return combinations(
          addScalar(n, -1),
          addScalar(k, -1)
        );
      }
    });
  }
);

// src/function/algebra/leafCount.ts
var name284 = "leafCount";
var dependencies285 = ["parse", "typed"];
var createLeafCount = /* @__PURE__ */ factory(
  name284,
  dependencies285,
  ({ parse: _parse, typed: typed2 }) => {
    function countLeaves(node) {
      let count = 0;
      node.forEach((n) => {
        count += countLeaves(n);
      });
      return count || 1;
    }
    return typed2(name284, {
      Node: function(expr) {
        return countLeaves(expr);
      }
    });
  }
);

// src/function/algebra/simplify/wildcards.ts
function isNumericNode(x) {
  return isConstantNode(x) || isOperatorNode(x) && x.isUnary() && isConstantNode(x.args[0]);
}
function isConstantExpression(x) {
  if (isConstantNode(x)) {
    return true;
  }
  if ((isFunctionNode(x) || isOperatorNode(x)) && x.args.every(isConstantExpression)) {
    return true;
  }
  if (isParenthesisNode(x) && isConstantExpression(x.content)) {
    return true;
  }
  return false;
}

// src/function/algebra/simplify/util.ts
var name285 = "simplifyUtil";
var dependencies286 = ["FunctionNode", "OperatorNode", "SymbolNode"];
var createUtil = /* @__PURE__ */ factory(
  name285,
  dependencies286,
  ({
    FunctionNode,
    OperatorNode,
    SymbolNode
  }) => {
    const T = true;
    const F = false;
    const defaultName = "defaultF";
    const defaultContext = {
      /*      */
      add: { trivial: T, total: T, commutative: T, associative: T },
      /**/
      unaryPlus: { trivial: T, total: T, commutative: T, associative: T },
      /* */
      subtract: { trivial: F, total: T, commutative: F, associative: F },
      /* */
      multiply: { trivial: T, total: T, commutative: T, associative: T },
      /*   */
      divide: { trivial: F, total: T, commutative: F, associative: F },
      /*    */
      paren: { trivial: T, total: T, commutative: T, associative: F },
      /* */
      defaultF: { trivial: F, total: T, commutative: F, associative: F }
    };
    const realContext = {
      divide: { total: F },
      log: { total: F }
    };
    const positiveContext = {
      subtract: { total: F },
      abs: { trivial: T },
      log: { total: T }
    };
    function hasProperty(nodeOrName, property, context = defaultContext) {
      let name323 = defaultName;
      if (typeof nodeOrName === "string") {
        name323 = nodeOrName;
      } else if (isOperatorNode(nodeOrName)) {
        name323 = nodeOrName.fn.toString();
      } else if (isFunctionNode(nodeOrName)) {
        name323 = nodeOrName.name;
      } else if (isParenthesisNode(nodeOrName)) {
        name323 = "paren";
      }
      if (hasOwnProperty(context, name323)) {
        const properties2 = context[name323];
        if (hasOwnProperty(properties2, property)) {
          return properties2[property];
        }
        if (hasOwnProperty(defaultContext, name323)) {
          return defaultContext[name323][property];
        }
      }
      if (hasOwnProperty(context, defaultName)) {
        const properties2 = context[defaultName];
        if (hasOwnProperty(properties2, property)) {
          return properties2[property];
        }
        return defaultContext[defaultName][property];
      }
      if (hasOwnProperty(defaultContext, name323)) {
        const properties2 = defaultContext[name323];
        if (hasOwnProperty(properties2, property)) {
          return properties2[property];
        }
      }
      return defaultContext[defaultName][property];
    }
    function isCommutative(node, context = defaultContext) {
      return hasProperty(node, "commutative", context);
    }
    function isAssociative(node, context = defaultContext) {
      return hasProperty(node, "associative", context);
    }
    function mergeContext(primary, secondary) {
      const merged = { ...primary };
      for (const prop in secondary) {
        if (hasOwnProperty(primary, prop)) {
          merged[prop] = { ...secondary[prop], ...primary[prop] };
        } else {
          merged[prop] = secondary[prop];
        }
      }
      return merged;
    }
    function flatten2(node, context) {
      if (!node.args || node.args.length === 0) {
        return;
      }
      node.args = allChildren(node, context);
      for (let i = 0; i < node.args.length; i++) {
        flatten2(node.args[i], context);
      }
    }
    function allChildren(node, context) {
      let op;
      const children = [];
      const findChildren = function(node2) {
        for (let i = 0; i < (node2.args?.length ?? 0); i++) {
          const child = node2.args[i];
          if (isOperatorNode(child) && op === child.op) {
            findChildren(child);
          } else {
            children.push(child);
          }
        }
      };
      if (isAssociative(node, context)) {
        op = node.op;
        findChildren(node);
        return children;
      } else {
        return node.args ?? [];
      }
    }
    function unflattenr(node, context) {
      if (!node.args || node.args.length === 0) {
        return;
      }
      const makeNode = createMakeNodeFunction(node);
      const l = node.args.length;
      for (let i = 0; i < l; i++) {
        unflattenr(node.args[i], context);
      }
      if (l > 2 && isAssociative(node, context)) {
        let curnode = node.args.pop();
        while (node.args.length > 0) {
          curnode = makeNode([node.args.pop(), curnode]);
        }
        node.args = curnode.args;
      }
    }
    function unflattenl(node, context) {
      if (!node.args || node.args.length === 0) {
        return;
      }
      const makeNode = createMakeNodeFunction(node);
      const l = node.args.length;
      for (let i = 0; i < l; i++) {
        unflattenl(node.args[i], context);
      }
      if (l > 2 && isAssociative(node, context)) {
        let curnode = node.args.shift();
        while (node.args.length > 0) {
          curnode = makeNode([curnode, node.args.shift()]);
        }
        node.args = curnode.args;
      }
    }
    function createMakeNodeFunction(node) {
      if (isOperatorNode(node)) {
        return function(args) {
          try {
            return new OperatorNode(
              node.op,
              node.fn,
              args,
              node.implicit
            );
          } catch (err) {
            console.error(err);
            return [];
          }
        };
      } else {
        return function(args) {
          return new FunctionNode(new SymbolNode(node.name), args);
        };
      }
    }
    return {
      createMakeNodeFunction,
      hasProperty,
      isCommutative,
      isAssociative,
      mergeContext,
      flatten: flatten2,
      allChildren,
      unflattenr,
      unflattenl,
      defaultContext,
      realContext,
      positiveContext
    };
  }
);

// src/function/algebra/simplify.ts
var name286 = "simplify";
var dependencies287 = [
  "typed",
  "parse",
  "equal",
  "resolve",
  "simplifyConstant",
  "simplifyCore",
  "AccessorNode",
  "ArrayNode",
  "ConstantNode",
  "FunctionNode",
  "IndexNode",
  "ObjectNode",
  "OperatorNode",
  "ParenthesisNode",
  "SymbolNode",
  "replacer"
];
var createSimplify = /* @__PURE__ */ factory(
  name286,
  dependencies287,
  ({
    typed: typed2,
    parse,
    equal,
    resolve,
    simplifyConstant,
    simplifyCore,
    AccessorNode,
    ArrayNode,
    ConstantNode,
    FunctionNode,
    IndexNode,
    ObjectNode,
    OperatorNode,
    ParenthesisNode,
    SymbolNode,
    replacer
  }) => {
    const {
      hasProperty,
      isCommutative,
      isAssociative,
      mergeContext,
      flatten: flatten2,
      unflattenr,
      unflattenl,
      createMakeNodeFunction,
      defaultContext,
      realContext,
      positiveContext
    } = createUtil({ FunctionNode, OperatorNode, SymbolNode });
    try {
      typed2.addConversion({ from: "Object", to: "Map", convert: createMap });
    } catch (e2) {
      if (!e2.message?.includes("already a conversion")) {
        throw e2;
      }
    }
    const simplify = typed2("simplify", {
      Node: _simplify,
      "Node, Map": (expr, scope) => _simplify(expr, false, scope),
      "Node, Map, Object": (expr, scope, options) => _simplify(expr, false, scope, options),
      "Node, Array": _simplify,
      "Node, Array, Map": _simplify,
      "Node, Array, Map, Object": _simplify
    });
    typed2.removeConversion({ from: "Object", to: "Map", convert: createMap });
    simplify.defaultContext = defaultContext;
    simplify.realContext = realContext;
    simplify.positiveContext = positiveContext;
    function removeParens(node) {
      return node.transform(function(node2) {
        return isParenthesisNode(node2) ? removeParens(node2.content) : node2;
      });
    }
    const SUPPORTED_CONSTANTS = {
      true: true,
      false: true,
      e: true,
      i: true,
      Infinity: true,
      LN2: true,
      LN10: true,
      LOG2E: true,
      LOG10E: true,
      NaN: true,
      phi: true,
      pi: true,
      SQRT1_2: true,
      SQRT2: true,
      tau: true
      // null: false,
      // undefined: false,
      // version: false,
    };
    simplify.rules = [
      simplifyCore,
      // { l: 'n+0', r: 'n' },     // simplifyCore
      // { l: 'n^0', r: '1' },     // simplifyCore
      // { l: '0*n', r: '0' },     // simplifyCore
      // { l: 'n/n', r: '1'},      // simplifyCore
      // { l: 'n^1', r: 'n' },     // simplifyCore
      // { l: '+n1', r:'n1' },     // simplifyCore
      // { l: 'n--n1', r:'n+n1' }, // simplifyCore
      { l: "log(e)", r: "1" },
      // temporary rules
      // Note initially we tend constants to the right because like-term
      // collection prefers the left, and we would rather collect nonconstants
      {
        s: "n-n1 -> n+-n1",
        // temporarily replace 'subtract' so we can further flatten the 'add' operator
        assuming: { subtract: { total: true } }
      },
      {
        s: "n-n -> 0",
        // partial alternative when we can't always subtract
        assuming: { subtract: { total: false } }
      },
      {
        s: "-(cl*v) -> v * (-cl)",
        // make non-constant terms positive
        assuming: { multiply: { commutative: true }, subtract: { total: true } }
      },
      {
        s: "-(cl*v) -> (-cl) * v",
        // non-commutative version, part 1
        assuming: {
          multiply: { commutative: false },
          subtract: { total: true }
        }
      },
      {
        s: "-(v*cl) -> v * (-cl)",
        // non-commutative version, part 2
        assuming: {
          multiply: { commutative: false },
          subtract: { total: true }
        }
      },
      { l: "-(n1/n2)", r: "-n1/n2" },
      { l: "-v", r: "v * (-1)" },
      // finish making non-constant terms positive
      { l: "(n1 + n2)*(-1)", r: "n1*(-1) + n2*(-1)", repeat: true },
      // expand negations to achieve as much sign cancellation as possible
      { l: "n/n1^n2", r: "n*n1^-n2" },
      // temporarily replace 'divide' so we can further flatten the 'multiply' operator
      { l: "n/n1", r: "n*n1^-1" },
      {
        s: "(n1*n2)^n3 -> n1^n3 * n2^n3",
        assuming: { multiply: { commutative: true } }
      },
      {
        s: "(n1*n2)^(-1) -> n2^(-1) * n1^(-1)",
        assuming: { multiply: { commutative: false } }
      },
      // expand nested exponentiation
      {
        s: "(n ^ n1) ^ n2 -> n ^ (n1 * n2)",
        assuming: { divide: { total: true } }
        // 1/(1/n) = n needs 1/n to exist
      },
      // collect like factors; into a sum, only do this for nonconstants
      { l: " vd   * ( vd   * n1 + n2)", r: "vd^2       * n1 +  vd   * n2" },
      {
        s: " vd   * (vd^n4 * n1 + n2)   ->  vd^(1+n4)  * n1 +  vd   * n2",
        assuming: { divide: { total: true } }
        // v*1/v = v^(1+-1) needs 1/v
      },
      {
        s: "vd^n3 * ( vd   * n1 + n2)   ->  vd^(n3+1)  * n1 + vd^n3 * n2",
        assuming: { divide: { total: true } }
      },
      {
        s: "vd^n3 * (vd^n4 * n1 + n2)   ->  vd^(n3+n4) * n1 + vd^n3 * n2",
        assuming: { divide: { total: true } }
      },
      { l: "n*n", r: "n^2" },
      {
        s: "n * n^n1 -> n^(n1+1)",
        assuming: { divide: { total: true } }
        // n*1/n = n^(-1+1) needs 1/n
      },
      {
        s: "n^n1 * n^n2 -> n^(n1+n2)",
        assuming: { divide: { total: true } }
        // ditto for n^2*1/n^2
      },
      // Unfortunately, to deal with more complicated cancellations, it
      // becomes necessary to simplify constants twice per pass. It's not
      // terribly expensive compared to matching rules, so this should not
      // pose a performance problem.
      simplifyConstant,
      // First: before collecting like terms
      // collect like terms
      {
        s: "n+n -> 2*n",
        assuming: { add: { total: true } }
        // 2 = 1 + 1 needs to exist
      },
      { l: "n+-n", r: "0" },
      { l: "vd*n + vd", r: "vd*(n+1)" },
      // NOTE: leftmost position is special:
      { l: "n3*n1 + n3*n2", r: "n3*(n1+n2)" },
      // All sub-monomials tried there.
      { l: "n3^(-n4)*n1 +   n3  * n2", r: "n3^(-n4)*(n1 + n3^(n4+1) *n2)" },
      { l: "n3^(-n4)*n1 + n3^n5 * n2", r: "n3^(-n4)*(n1 + n3^(n4+n5)*n2)" },
      // noncommutative additional cases (term collection & factoring)
      {
        s: "n*vd + vd -> (n+1)*vd",
        assuming: { multiply: { commutative: false } }
      },
      {
        s: "vd + n*vd -> (1+n)*vd",
        assuming: { multiply: { commutative: false } }
      },
      {
        s: "n1*n3 + n2*n3 -> (n1+n2)*n3",
        assuming: { multiply: { commutative: false } }
      },
      {
        s: "n^n1 * n -> n^(n1+1)",
        assuming: { divide: { total: true }, multiply: { commutative: false } }
      },
      {
        s: "n1*n3^(-n4) + n2 * n3    -> (n1 + n2*n3^(n4 +  1))*n3^(-n4)",
        assuming: { multiply: { commutative: false } }
      },
      {
        s: "n1*n3^(-n4) + n2 * n3^n5 -> (n1 + n2*n3^(n4 + n5))*n3^(-n4)",
        assuming: { multiply: { commutative: false } }
      },
      { l: "n*cd + cd", r: "(n+1)*cd" },
      {
        s: "cd*n + cd -> cd*(n+1)",
        assuming: { multiply: { commutative: false } }
      },
      {
        s: "cd + cd*n -> cd*(1+n)",
        assuming: { multiply: { commutative: false } }
      },
      simplifyConstant,
      // Second: before returning expressions to "standard form"
      // make factors positive (and undo 'make non-constant terms positive')
      {
        s: "(-n)*n1 -> -(n*n1)",
        assuming: { subtract: { total: true } }
      },
      {
        s: "n1*(-n) -> -(n1*n)",
        // in case * non-commutative
        assuming: {
          subtract: { total: true },
          multiply: { commutative: false }
        }
      },
      // final ordering of constants
      {
        s: "ce+ve -> ve+ce",
        assuming: { add: { commutative: true } },
        imposeContext: { add: { commutative: false } }
      },
      {
        s: "vd*cd -> cd*vd",
        assuming: { multiply: { commutative: true } },
        imposeContext: { multiply: { commutative: false } }
      },
      // undo temporary rules
      // { l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant
      { l: "n+-n1", r: "n-n1" },
      // undo replace 'subtract'
      { l: "n+-(n1)", r: "n-(n1)" },
      {
        s: "n*(n1^-1) -> n/n1",
        // undo replace 'divide'; for * commutative
        assuming: { multiply: { commutative: true } }
        // o.w. / not conventional
      },
      {
        s: "n*n1^-n2 -> n/n1^n2",
        assuming: { multiply: { commutative: true } }
        // o.w. / not conventional
      },
      {
        s: "n^-1 -> 1/n",
        assuming: { multiply: { commutative: true } }
        // o.w. / not conventional
      },
      { l: "n^1", r: "n" },
      // can be produced by power cancellation
      {
        s: "n*(n1/n2) -> (n*n1)/n2",
        // '*' before '/'
        assuming: { multiply: { associative: true } }
      },
      {
        s: "n-(n1+n2) -> n-n1-n2",
        // '-' before '+'
        assuming: { addition: { associative: true, commutative: true } }
      },
      // { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },
      // { l: '(n*n1)/(n*n2)', r: 'n1/n2' },
      // simplifyConstant can leave an extra factor of 1, which can always
      // be eliminated, since the identity always commutes
      { l: "1*n", r: "n", imposeContext: { multiply: { commutative: true } } },
      {
        s: "n1/(n2/n3) -> (n1*n3)/n2",
        assuming: { multiply: { associative: true } }
      },
      { l: "n1/(-n2)", r: "-n1/n2" }
    ];
    function _canonicalizeRule(ruleObject, context) {
      const newRule = {};
      if (ruleObject.s) {
        const lr = ruleObject.s.split("->");
        if (lr.length === 2) {
          newRule.l = lr[0];
          newRule.r = lr[1];
        } else {
          throw SyntaxError("Could not parse rule: " + ruleObject.s);
        }
      } else {
        newRule.l = ruleObject.l;
        newRule.r = ruleObject.r;
      }
      newRule.l = removeParens(parse(newRule.l));
      newRule.r = removeParens(parse(newRule.r));
      if ("imposeContext" in ruleObject && ruleObject.imposeContext) {
        newRule.imposeContext = ruleObject.imposeContext;
      }
      if ("repeat" in ruleObject && ruleObject.repeat !== void 0) {
        newRule.repeat = ruleObject.repeat;
      }
      if ("assuming" in ruleObject && ruleObject.assuming) {
        newRule.assuming = ruleObject.assuming;
      }
      if (ruleObject.evaluate) {
        newRule.evaluate = parse(ruleObject.evaluate);
      }
      if (isAssociative(newRule.l, context)) {
        const nonCommutative = !isCommutative(newRule.l, context);
        let leftExpandsym;
        if (nonCommutative) leftExpandsym = _getExpandPlaceholderSymbol();
        const makeNode = createMakeNodeFunction(newRule.l);
        const expandsym = _getExpandPlaceholderSymbol();
        const expandedL = makeNode([newRule.l, expandsym]);
        flatten2(expandedL, context);
        unflattenr(expandedL, context);
        newRule.expanded = {
          l: expandedL,
          r: makeNode([newRule.r, expandsym])
        };
        if (nonCommutative) {
          newRule.expandedNC1 = {
            l: makeNode([leftExpandsym, newRule.l]),
            r: makeNode([leftExpandsym, newRule.r])
          };
          newRule.expandedNC2 = {
            l: makeNode([leftExpandsym, newRule.expanded.l]),
            r: makeNode([leftExpandsym, newRule.expanded.r])
          };
        }
      }
      return newRule;
    }
    function _buildRules(rules, context) {
      const ruleSet = [];
      for (let i = 0; i < rules.length; i++) {
        let rule = rules[i];
        let newRule;
        const ruleType = typeof rule;
        switch (ruleType) {
          case "string":
            rule = { s: rule };
          /* falls through */
          case "object":
            newRule = _canonicalizeRule(
              rule,
              context
            );
            break;
          case "function":
            newRule = rule;
            break;
          default:
            throw TypeError("Unsupported type of rule: " + ruleType);
        }
        ruleSet.push(newRule);
      }
      return ruleSet;
    }
    let _lastsym = 0;
    function _getExpandPlaceholderSymbol() {
      return new SymbolNode("_p" + _lastsym++);
    }
    function _simplify(expr, rules, scope = createEmptyMap(), options = {}) {
      const debug = options.consoleDebug;
      rules = _buildRules(
        rules || simplify.rules,
        options.context
      );
      let res = resolve(expr, scope);
      res = removeParens(res);
      const visited = {};
      let str = res.toString({ parenthesis: "all" });
      while (!visited[str]) {
        visited[str] = true;
        _lastsym = 0;
        let laststr = str;
        if (debug) console.log("Working on: ", str);
        for (let i = 0; i < rules.length; i++) {
          let rulestr = "";
          if (typeof rules[i] === "function") {
            res = rules[i](res, options);
            if (debug) rulestr = rules[i].name;
          } else {
            flatten2(res, options.context);
            res = applyRule(res, rules[i], options.context);
            if (debug) {
              rulestr = `${rules[i].l.toString()} -> ${rules[i].r.toString()}`;
            }
          }
          if (debug) {
            const newstr = res.toString({ parenthesis: "all" });
            if (newstr !== laststr) {
              console.log("Applying", rulestr, "produced", newstr);
              laststr = newstr;
            }
          }
          unflattenl(res, options.context);
        }
        str = res.toString({ parenthesis: "all" });
      }
      return res;
    }
    function mapRule(nodes, rule, context) {
      let resNodes = nodes;
      if (nodes) {
        for (let i = 0; i < nodes.length; ++i) {
          const newNode = applyRule(nodes[i], rule, context);
          if (newNode !== nodes[i]) {
            if (resNodes === nodes) {
              resNodes = nodes.slice();
            }
            resNodes[i] = newNode;
          }
        }
      }
      return resNodes;
    }
    function applyRule(node, rule, context) {
      if (rule.assuming) {
        for (const symbol in rule.assuming) {
          for (const property in rule.assuming[symbol]) {
            if (hasProperty(symbol, property, context) !== rule.assuming[symbol][property]) {
              return node;
            }
          }
        }
      }
      const mergedContext = mergeContext(rule.imposeContext, context);
      let res = node;
      if (res instanceof OperatorNode || res instanceof FunctionNode) {
        const newArgs = mapRule(res.args, rule, context);
        if (newArgs !== res.args) {
          res = res.clone();
          res.args = newArgs;
        }
      } else if (res instanceof ParenthesisNode) {
        if (res.content) {
          const newContent = applyRule(
            res.content,
            rule,
            context
          );
          if (newContent !== res.content) {
            res = new ParenthesisNode(newContent);
          }
        }
      } else if (res instanceof ArrayNode) {
        const newItems = mapRule(res.items, rule, context);
        if (newItems !== res.items) {
          res = new ArrayNode(newItems);
        }
      } else if (res instanceof AccessorNode) {
        let newObj = res.object;
        if (res.object) {
          newObj = applyRule(res.object, rule, context);
        }
        let newIndex = res.index;
        if (res.index) {
          newIndex = applyRule(
            res.index,
            rule,
            context
          );
        }
        if (newObj !== res.object || newIndex !== res.index) {
          res = new AccessorNode(newObj, newIndex);
        }
      } else if (res instanceof IndexNode) {
        const newDims = mapRule(res.dimensions, rule, context);
        if (newDims !== res.dimensions) {
          res = new IndexNode(newDims);
        }
      } else if (res instanceof ObjectNode) {
        let changed = false;
        const newProps = {};
        for (const prop in res.properties) {
          newProps[prop] = applyRule(
            res.properties[prop],
            rule,
            context
          );
          if (newProps[prop] !== res.properties[prop]) {
            changed = true;
          }
        }
        if (changed) {
          res = new ObjectNode(newProps);
        }
      }
      let repl = rule.r;
      let matches = _ruleMatch(rule.l, res, mergedContext)[0];
      if (!matches && rule.expanded) {
        repl = rule.expanded.r;
        matches = _ruleMatch(rule.expanded.l, res, mergedContext)[0];
      }
      if (!matches && rule.expandedNC1) {
        repl = rule.expandedNC1.r;
        matches = _ruleMatch(rule.expandedNC1.l, res, mergedContext)[0];
        if (!matches) {
          repl = rule.expandedNC2.r;
          matches = _ruleMatch(rule.expandedNC2.l, res, mergedContext)[0];
        }
      }
      if (matches) {
        const implicit = res.implicit;
        res = repl.clone();
        if (implicit && "implicit" in repl) {
          res.implicit = true;
        }
        res = res.transform(function(node2) {
          if (node2.isSymbolNode && hasOwnProperty(matches.placeholders, node2.name)) {
            return matches.placeholders[node2.name].clone();
          } else {
            return node2;
          }
        });
      }
      if (rule.repeat && res !== node) {
        res = applyRule(res, rule, context);
      }
      return res;
    }
    function getSplits(node, context) {
      const res = [];
      let right;
      let rightArgs;
      const makeNode = createMakeNodeFunction(node);
      if (isCommutative(node, context)) {
        for (let i = 0; i < node.args.length; i++) {
          rightArgs = node.args.slice(0);
          rightArgs.splice(i, 1);
          right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
          res.push(makeNode([node.args[i], right]));
        }
      } else {
        for (let i = 1; i < node.args.length; i++) {
          let left = node.args[0];
          if (i > 1) {
            left = makeNode(node.args.slice(0, i));
          }
          rightArgs = node.args.slice(i);
          right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
          res.push(makeNode([left, right]));
        }
      }
      return res;
    }
    function mergeMatch(match1, match2) {
      const res = { placeholders: {} };
      if (!match1.placeholders && !match2.placeholders) {
        return res;
      } else if (!match1.placeholders) {
        return match2;
      } else if (!match2.placeholders) {
        return match1;
      }
      for (const key in match1.placeholders) {
        if (hasOwnProperty(match1.placeholders, key)) {
          res.placeholders[key] = match1.placeholders[key];
          if (hasOwnProperty(match2.placeholders, key)) {
            if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {
              return null;
            }
          }
        }
      }
      for (const key in match2.placeholders) {
        if (hasOwnProperty(match2.placeholders, key)) {
          res.placeholders[key] = match2.placeholders[key];
        }
      }
      return res;
    }
    function combineChildMatches(list1, list2) {
      const res = [];
      if (list1.length === 0 || list2.length === 0) {
        return res;
      }
      let merged;
      for (let i1 = 0; i1 < list1.length; i1++) {
        for (let i2 = 0; i2 < list2.length; i2++) {
          merged = mergeMatch(list1[i1], list2[i2]);
          if (merged) {
            res.push(merged);
          }
        }
      }
      return res;
    }
    function mergeChildMatches(childMatches) {
      if (childMatches.length === 0) {
        return [];
      }
      const sets = childMatches.reduce(combineChildMatches);
      const uniqueSets = [];
      const unique = {};
      for (let i = 0; i < sets.length; i++) {
        const s = JSON.stringify(sets[i], replacer);
        if (!unique[s]) {
          unique[s] = true;
          uniqueSets.push(sets[i]);
        }
      }
      return uniqueSets;
    }
    function _ruleMatch(rule, node, context, isSplit) {
      let res = [{ placeholders: {} }];
      if (rule instanceof OperatorNode && node instanceof OperatorNode || rule instanceof FunctionNode && node instanceof FunctionNode) {
        if (rule instanceof OperatorNode) {
          if (rule.op !== node.op || rule.fn !== node.fn) {
            return [];
          }
        } else if (rule instanceof FunctionNode) {
          if (rule.name !== node.name) {
            return [];
          }
        }
        if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node, context) && node.args.length === rule.args.length || isSplit) {
          let childMatches = [];
          for (let i = 0; i < rule.args.length; i++) {
            const childMatch = _ruleMatch(
              rule.args[i],
              node.args[i],
              context
            );
            if (childMatch.length === 0) {
              break;
            }
            childMatches.push(childMatch);
          }
          if (childMatches.length !== rule.args.length) {
            if (!isCommutative(node, context) || // exact match in order needed
            rule.args.length === 1) {
              return [];
            }
            if (rule.args.length > 2) {
              throw new Error(
                "permuting >2 commutative non-associative rule arguments not yet implemented"
              );
            }
            const leftMatch = _ruleMatch(
              rule.args[0],
              node.args[1],
              context
            );
            if (leftMatch.length === 0) {
              return [];
            }
            const rightMatch = _ruleMatch(
              rule.args[1],
              node.args[0],
              context
            );
            if (rightMatch.length === 0) {
              return [];
            }
            childMatches = [leftMatch, rightMatch];
          }
          res = mergeChildMatches(childMatches);
        } else if (node.args.length >= 2 && rule.args.length === 2) {
          const splits = getSplits(node, context);
          let splitMatches = [];
          for (let i = 0; i < splits.length; i++) {
            const matchSet = _ruleMatch(rule, splits[i], context, true);
            splitMatches = splitMatches.concat(matchSet);
          }
          return splitMatches;
        } else if (rule.args.length > 2) {
          throw Error(
            "Unexpected non-binary associative function: " + rule.toString()
          );
        } else {
          return [];
        }
      } else if (rule instanceof SymbolNode) {
        if (rule.name.length === 0) {
          throw new Error("Symbol in rule has 0 length...!?");
        }
        if (SUPPORTED_CONSTANTS[rule.name]) {
          if (rule.name !== node.name) {
            return [];
          }
        } else {
          switch (rule.name[1] >= "a" && rule.name[1] <= "z" ? rule.name.substring(0, 2) : rule.name[0]) {
            case "n":
            case "_p":
              res[0].placeholders[rule.name] = node;
              break;
            case "c":
            case "cl":
              if (isConstantNode(node)) {
                res[0].placeholders[rule.name] = node;
              } else {
                return [];
              }
              break;
            case "v":
              if (!isConstantNode(node)) {
                res[0].placeholders[rule.name] = node;
              } else {
                return [];
              }
              break;
            case "vl":
              if (isSymbolNode(node)) {
                res[0].placeholders[rule.name] = node;
              } else {
                return [];
              }
              break;
            case "cd":
              if (isNumericNode(node)) {
                res[0].placeholders[rule.name] = node;
              } else {
                return [];
              }
              break;
            case "vd":
              if (!isNumericNode(node)) {
                res[0].placeholders[rule.name] = node;
              } else {
                return [];
              }
              break;
            case "ce":
              if (isConstantExpression(node)) {
                res[0].placeholders[rule.name] = node;
              } else {
                return [];
              }
              break;
            case "ve":
              if (!isConstantExpression(node)) {
                res[0].placeholders[rule.name] = node;
              } else {
                return [];
              }
              break;
            default:
              throw new Error(
                "Invalid symbol in rule: " + rule.name
              );
          }
        }
      } else if (rule instanceof ConstantNode) {
        if (!equal(rule.value, node.value)) {
          return [];
        }
      } else {
        return [];
      }
      return res;
    }
    function _exactMatch(p, q) {
      if (p instanceof ConstantNode && q instanceof ConstantNode) {
        if (!equal(p.value, q.value)) {
          return false;
        }
      } else if (p instanceof SymbolNode && q instanceof SymbolNode) {
        if (p.name !== q.name) {
          return false;
        }
      } else if (p instanceof OperatorNode && q instanceof OperatorNode || p instanceof FunctionNode && q instanceof FunctionNode) {
        if (p instanceof OperatorNode) {
          if (p.op !== q.op || p.fn !== q.fn) {
            return false;
          }
        } else if (p instanceof FunctionNode) {
          if (p.name !== q.name) {
            return false;
          }
        }
        if (p.args.length !== q.args.length) {
          return false;
        }
        for (let i = 0; i < p.args.length; i++) {
          if (!_exactMatch(p.args[i], q.args[i])) {
            return false;
          }
        }
      } else {
        return false;
      }
      return true;
    }
    return simplify;
  }
);

// src/function/algebra/simplifyConstant.ts
var name287 = "simplifyConstant";
var dependencies288 = [
  "typed",
  "config",
  "mathWithTransform",
  "matrix",
  "isBounded",
  "?fraction",
  "?bignumber",
  "AccessorNode",
  "ArrayNode",
  "ConstantNode",
  "FunctionNode",
  "IndexNode",
  "ObjectNode",
  "OperatorNode",
  "SymbolNode"
];
var createSimplifyConstant = /* @__PURE__ */ factory(
  name287,
  dependencies288,
  ({
    typed: typed2,
    config,
    mathWithTransform,
    matrix,
    isBounded,
    fraction,
    bignumber,
    AccessorNode,
    ArrayNode,
    ConstantNode,
    FunctionNode,
    IndexNode,
    ObjectNode,
    OperatorNode,
    SymbolNode
  }) => {
    const {
      isCommutative,
      isAssociative,
      allChildren,
      createMakeNodeFunction
    } = createUtil({ FunctionNode, OperatorNode, SymbolNode });
    const simplifyConstant = typed2("simplifyConstant", {
      Node: (node) => _ensureNode(foldFraction(node, {})),
      "Node, Object": function(expr, options) {
        return _ensureNode(foldFraction(expr, options));
      }
    });
    function _removeFractions(thing) {
      if (isFraction(thing)) {
        return thing.valueOf();
      }
      if (thing instanceof Array) {
        return thing.map(_removeFractions);
      }
      if (isMatrix(thing)) {
        return matrix(_removeFractions(thing.valueOf()));
      }
      return thing;
    }
    function _eval(fnname, args, options) {
      try {
        return mathWithTransform[fnname].apply(null, args);
      } catch {
        args = args.map(_removeFractions);
        return _toNumber(mathWithTransform[fnname].apply(null, args), options);
      }
    }
    const _toNode = typed2({
      Fraction: _fractionToNode,
      number: function(n) {
        if (n < 0) {
          return unaryMinusNode(new ConstantNode(-n));
        }
        return new ConstantNode(n);
      },
      BigNumber: function(n) {
        if (n < 0) {
          return unaryMinusNode(new ConstantNode(-n));
        }
        return new ConstantNode(n);
      },
      bigint: function(n) {
        if (n < 0n) {
          return unaryMinusNode(new ConstantNode(-n));
        }
        return new ConstantNode(n);
      },
      Complex: function(_s) {
        throw new Error("Cannot convert Complex number to Node");
      },
      string: function(s) {
        return new ConstantNode(s);
      },
      Matrix: function(m) {
        return new ArrayNode(m.valueOf().map((e2) => _toNode(e2)));
      }
    });
    function _ensureNode(thing) {
      if (isNode(thing)) {
        return thing;
      }
      return _toNode(thing);
    }
    function _exactFraction(n, options) {
      const exactFractions = options && options.exactFractions !== false;
      if (exactFractions && isBounded(n) && fraction) {
        const f = fraction(n);
        const fractionsLimit = options && typeof options.fractionsLimit === "number" ? options.fractionsLimit : Infinity;
        if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {
          return f;
        }
      }
      return n;
    }
    const _toNumber = typed2({
      "string, Object": function(s, options) {
        const numericType = safeNumberType(s, config);
        if (numericType === "BigNumber") {
          if (bignumber === void 0) {
            noBignumber();
          }
          return bignumber(s);
        } else if (numericType === "bigint") {
          return BigInt(s);
        } else if (numericType === "Fraction") {
          if (fraction === void 0) {
            noFraction();
          }
          return fraction(s);
        } else {
          const n = parseFloat(s);
          return _exactFraction(n, options);
        }
      },
      "Fraction, Object": function(s, _options) {
        return s;
      },
      // we don't need options here
      "BigNumber, Object": function(s, _options) {
        return s;
      },
      // we don't need options here
      "number, Object": function(s, options) {
        return _exactFraction(s, options);
      },
      "bigint, Object": function(s, _options) {
        return s;
      },
      "Complex, Object": function(s, options) {
        if (s.im !== 0) {
          return s;
        }
        return _exactFraction(s.re, options);
      },
      "Matrix, Object": function(s, options) {
        return matrix(_exactFraction(s.valueOf(), options));
      },
      "Array, Object": function(s, options) {
        return s.map((item) => _exactFraction(item, options));
      }
    });
    function unaryMinusNode(n) {
      return new OperatorNode("-", "unaryMinus", [n]);
    }
    function _fractionToNode(f) {
      const fromBigInt = (value) => config.number === "BigNumber" && bignumber ? bignumber(value) : Number(value);
      const signBigInt = BigInt(f.s);
      const numeratorValue = signBigInt * f.n;
      const numeratorNode = numeratorValue < 0n ? new OperatorNode("-", "unaryMinus", [
        new ConstantNode(fromBigInt(-numeratorValue))
      ]) : new ConstantNode(fromBigInt(numeratorValue));
      return f.d === 1n ? numeratorNode : new OperatorNode("/", "divide", [
        numeratorNode,
        new ConstantNode(fromBigInt(f.d))
      ]);
    }
    function _foldAccessor(obj, index, options) {
      if (!isIndexNode(index)) {
        return new AccessorNode(_ensureNode(obj), _ensureNode(index));
      }
      if (isArrayNode(obj) || isMatrix(obj)) {
        const remainingDims = Array.from(index.dimensions);
        while (remainingDims.length > 0) {
          if (isConstantNode(remainingDims[0]) && typeof remainingDims[0].value !== "string") {
            const first = _toNumber(remainingDims.shift().value, options);
            if (isArrayNode(obj)) {
              obj = obj.items[first - 1];
            } else {
              obj = obj.valueOf()[first - 1];
              if (obj instanceof Array) {
                obj = matrix(obj);
              }
            }
          } else if (remainingDims.length > 1 && isConstantNode(remainingDims[1]) && typeof remainingDims[1].value !== "string") {
            const second = _toNumber(remainingDims[1].value, options);
            const tryItems = [];
            const fromItems = isArrayNode(obj) ? obj.items : obj.valueOf();
            for (const item of fromItems) {
              if (isArrayNode(item)) {
                tryItems.push(item.items[second - 1]);
              } else if (isMatrix(obj)) {
                tryItems.push(item[second - 1]);
              } else {
                break;
              }
            }
            if (tryItems.length === fromItems.length) {
              if (isArrayNode(obj)) {
                obj = new ArrayNode(tryItems);
              } else {
                obj = matrix(tryItems);
              }
              remainingDims.splice(1, 1);
            } else {
              break;
            }
          } else {
            break;
          }
        }
        if (remainingDims.length === index.dimensions.length) {
          return new AccessorNode(_ensureNode(obj), index);
        }
        if (remainingDims.length > 0) {
          index = new IndexNode(remainingDims);
          return new AccessorNode(_ensureNode(obj), index);
        }
        return obj;
      }
      if (isObjectNode(obj) && index.dimensions.length === 1 && isConstantNode(index.dimensions[0])) {
        const key = index.dimensions[0].value;
        if (key in obj.properties) {
          return obj.properties[key];
        }
        return new ConstantNode();
      }
      return new AccessorNode(_ensureNode(obj), index);
    }
    function foldOp(fn, args, makeNode, options) {
      const first = args.shift();
      const reduction = args.reduce(
        (sofar, next) => {
          if (!isNode(next)) {
            const last = sofar.pop();
            if (isNode(last)) {
              return [last, next];
            }
            try {
              sofar.push(_eval(fn, [last, next], options));
              return sofar;
            } catch {
              sofar.push(last);
            }
          }
          sofar.push(_ensureNode(sofar.pop()));
          const newtree = sofar.length === 1 ? sofar[0] : makeNode(sofar);
          return [makeNode([newtree, _ensureNode(next)])];
        },
        [first]
      );
      if (reduction.length === 1) {
        return reduction[0];
      }
      return makeNode([reduction[0], _toNode(reduction[1])]);
    }
    function foldFraction(node, options) {
      switch (node.type) {
        case "SymbolNode":
          return node;
        case "ConstantNode":
          switch (typeof node.value) {
            case "number":
              return _toNumber(node.value, options);
            case "bigint":
              return _toNumber(node.value, options);
            case "string":
              return node.value;
            default:
              if (!isNaN(node.value))
                return _toNumber(node.value, options);
          }
          return node;
        case "FunctionNode":
          if (mathWithTransform[node.name] && mathWithTransform[node.name].rawArgs) {
            return node;
          }
          {
            const operatorFunctions = ["add", "multiply"];
            if (!operatorFunctions.includes(node.name)) {
              const args = node.args.map(
                (arg) => foldFraction(arg, options)
              );
              if (!args.some(isNode)) {
                try {
                  return _eval(node.name, args, options);
                } catch {
                }
              }
              if (node.name === "size" && args.length === 1 && isArrayNode(args[0])) {
                const sz = [];
                let section = args[0];
                while (isArrayNode(section)) {
                  sz.push(section.items.length);
                  section = section.items[0];
                }
                return matrix(sz);
              }
              return new FunctionNode(
                node.name,
                args.map(_ensureNode)
              );
            }
          }
        /* falls through */
        case "OperatorNode": {
          const fn = node.fn.toString();
          let args;
          let res;
          const makeNode = createMakeNodeFunction(node);
          if (isOperatorNode(node) && node.isUnary()) {
            args = [foldFraction(node.args[0], options)];
            if (!isNode(args[0])) {
              res = _eval(fn, args, options);
            } else {
              res = makeNode(args);
            }
          } else if (isAssociative(node, options.context)) {
            args = allChildren(node, options.context);
            args = args.map((arg) => foldFraction(arg, options));
            if (isCommutative(fn, options.context)) {
              const consts = [];
              const vars = [];
              for (let i = 0; i < args.length; i++) {
                if (!isNode(args[i])) {
                  consts.push(args[i]);
                } else {
                  vars.push(args[i]);
                }
              }
              if (consts.length > 1) {
                res = foldOp(fn, consts, makeNode, options);
                vars.unshift(res);
                res = foldOp(fn, vars, makeNode, options);
              } else {
                res = foldOp(fn, args, makeNode, options);
              }
            } else {
              res = foldOp(fn, args, makeNode, options);
            }
          } else {
            args = node.args.map(
              (arg) => foldFraction(arg, options)
            );
            res = foldOp(fn, args, makeNode, options);
          }
          return res;
        }
        case "ParenthesisNode":
          return foldFraction(node.content, options);
        case "AccessorNode":
          return _foldAccessor(
            foldFraction(node.object, options),
            foldFraction(node.index, options),
            options
          );
        case "ArrayNode": {
          const foldItems = node.items.map(
            (item) => foldFraction(item, options)
          );
          if (foldItems.some(isNode)) {
            return new ArrayNode(foldItems.map(_ensureNode));
          }
          return matrix(foldItems);
        }
        case "IndexNode": {
          return new IndexNode(
            node.dimensions.map(
              (n) => simplifyConstant(n, options)
            )
          );
        }
        case "ObjectNode": {
          const foldProps = {};
          for (const prop in node.properties) {
            foldProps[prop] = simplifyConstant(
              node.properties[prop],
              options
            );
          }
          return new ObjectNode(foldProps);
        }
        case "AssignmentNode":
        /* falls through */
        case "BlockNode":
        /* falls through */
        case "FunctionAssignmentNode":
        /* falls through */
        case "RangeNode":
        /* falls through */
        case "ConditionalNode":
        /* falls through */
        default:
          throw new Error(
            `Unimplemented node type in simplifyConstant: ${node.type}`
          );
      }
    }
    return simplifyConstant;
  }
);

// src/function/algebra/simplifyCore.ts
var name288 = "simplifyCore";
var dependencies289 = [
  "typed",
  "parse",
  "equal",
  "isZero",
  "add",
  "subtract",
  "multiply",
  "divide",
  "pow",
  "AccessorNode",
  "ArrayNode",
  "ConstantNode",
  "FunctionNode",
  "IndexNode",
  "ObjectNode",
  "OperatorNode",
  "ParenthesisNode",
  "SymbolNode"
];
var createSimplifyCore = /* @__PURE__ */ factory(
  name288,
  dependencies289,
  ({
    typed: typed2,
    parse: _parse,
    equal,
    isZero,
    add: _add,
    subtract: _subtract,
    multiply: _multiply,
    divide: _divide,
    pow: _pow,
    AccessorNode,
    ArrayNode,
    ConstantNode,
    FunctionNode,
    IndexNode,
    ObjectNode,
    OperatorNode,
    ParenthesisNode: _ParenthesisNode,
    SymbolNode
  }) => {
    const node0 = new ConstantNode(0);
    const node1 = new ConstantNode(1);
    const nodeT = new ConstantNode(true);
    const nodeF = new ConstantNode(false);
    function isAlwaysBoolean(node) {
      return isOperatorNode(node) && ["and", "not", "or"].includes(node.op);
    }
    const { hasProperty, isCommutative } = createUtil({
      FunctionNode,
      OperatorNode,
      SymbolNode
    });
    function _simplifyCore(nodeToSimplify, options = {}) {
      const context = options ? options.context : void 0;
      if (hasProperty(nodeToSimplify, "trivial", context)) {
        if (isFunctionNode(nodeToSimplify) && nodeToSimplify.args.length === 1) {
          return _simplifyCore(nodeToSimplify.args[0], options);
        }
        let simpChild = false;
        let childCount = 0;
        nodeToSimplify.forEach((c) => {
          ++childCount;
          if (childCount === 1) {
            simpChild = _simplifyCore(c, options);
          }
        });
        if (childCount === 1 && simpChild !== false) {
          return simpChild;
        }
      }
      let node = nodeToSimplify;
      if (isFunctionNode(node)) {
        const op = getOperator(node.name);
        if (op) {
          if (node.args.length > 2 && hasProperty(node, "associative", context)) {
            while (node.args.length > 2) {
              const last = node.args.pop();
              const seclast = node.args.pop();
              node.args.push(new OperatorNode(op, node.name, [last, seclast]));
            }
          }
          node = new OperatorNode(op, node.name, node.args);
        } else {
          return new FunctionNode(
            _simplifyCore(node.fn),
            node.args.map((n) => _simplifyCore(n, options))
          );
        }
      }
      if (isOperatorNode(node) && node.isUnary()) {
        const a0 = _simplifyCore(node.args[0], options);
        if (node.op === "~") {
          if (isOperatorNode(a0) && a0.isUnary() && a0.op === "~") {
            return a0.args[0];
          }
        }
        if (node.op === "not") {
          if (isOperatorNode(a0) && a0.isUnary() && a0.op === "not") {
            if (isAlwaysBoolean(a0.args[0])) {
              return a0.args[0];
            }
          }
        }
        let finish = true;
        if (node.op === "-") {
          if (isOperatorNode(a0)) {
            if (a0.isBinary() && a0.fn === "subtract") {
              node = new OperatorNode("-", "subtract", [a0.args[1], a0.args[0]]);
              finish = false;
            }
            if (a0.isUnary() && a0.op === "-") {
              return a0.args[0];
            }
          }
        }
        if (finish) return new OperatorNode(node.op, node.fn, [a0]);
      }
      if (isOperatorNode(node) && node.isBinary()) {
        const a0 = _simplifyCore(node.args[0], options);
        let a1 = _simplifyCore(node.args[1], options);
        if (node.op === "+") {
          if (isConstantNode(a0) && isZero(a0.value)) {
            return a1;
          }
          if (isConstantNode(a1) && isZero(a1.value)) {
            return a0;
          }
          if (isOperatorNode(a1) && a1.isUnary() && a1.op === "-") {
            a1 = a1.args[0];
            node = new OperatorNode("-", "subtract", [a0, a1]);
          }
        }
        if (node.op === "-") {
          if (isOperatorNode(a1) && a1.isUnary() && a1.op === "-") {
            return _simplifyCore(
              new OperatorNode("+", "add", [a0, a1.args[0]]),
              options
            );
          }
          if (isConstantNode(a0) && isZero(a0.value)) {
            return _simplifyCore(new OperatorNode("-", "unaryMinus", [a1]));
          }
          if (isConstantNode(a1) && isZero(a1.value)) {
            return a0;
          }
          return new OperatorNode(node.op, node.fn, [a0, a1]);
        }
        if (node.op === "*") {
          if (isConstantNode(a0)) {
            if (isZero(a0.value)) {
              return node0;
            } else if (equal(a0.value, 1)) {
              return a1;
            }
          }
          if (isConstantNode(a1)) {
            if (isZero(a1.value)) {
              return node0;
            } else if (equal(a1.value, 1)) {
              return a0;
            }
            if (isCommutative(node, context)) {
              return new OperatorNode(
                node.op,
                node.fn,
                [a1, a0],
                node.implicit
              );
            }
          }
          return new OperatorNode(
            node.op,
            node.fn,
            [a0, a1],
            node.implicit
          );
        }
        if (node.op === "/") {
          if (isConstantNode(a0) && isZero(a0.value)) {
            return node0;
          }
          if (isConstantNode(a1) && equal(a1.value, 1)) {
            return a0;
          }
          return new OperatorNode(node.op, node.fn, [a0, a1]);
        }
        if (node.op === "^") {
          if (isConstantNode(a1)) {
            if (isZero(a1.value)) {
              return node1;
            } else if (equal(a1.value, 1)) {
              return a0;
            }
          }
        }
        if (node.op === "and") {
          if (isConstantNode(a0)) {
            if (a0.value) {
              if (isAlwaysBoolean(a1)) return a1;
              if (isConstantNode(a1)) {
                return a1.value ? nodeT : nodeF;
              }
            } else {
              return nodeF;
            }
          }
          if (isConstantNode(a1)) {
            if (a1.value) {
              if (isAlwaysBoolean(a0)) return a0;
            } else {
              return nodeF;
            }
          }
        }
        if (node.op === "or") {
          if (isConstantNode(a0)) {
            if (a0.value) {
              return nodeT;
            } else {
              if (isAlwaysBoolean(a1)) return a1;
            }
          }
          if (isConstantNode(a1)) {
            if (a1.value) {
              return nodeT;
            } else {
              if (isAlwaysBoolean(a0)) return a0;
            }
          }
        }
        return new OperatorNode(node.op, node.fn, [a0, a1]);
      }
      if (isOperatorNode(node)) {
        return new OperatorNode(
          node.op,
          node.fn,
          node.args.map((a) => _simplifyCore(a, options))
        );
      }
      if (isArrayNode(node)) {
        return new ArrayNode(
          node.items.map((n) => _simplifyCore(n, options))
        );
      }
      if (isAccessorNode(node)) {
        return new AccessorNode(
          _simplifyCore(node.object, options),
          _simplifyCore(node.index, options)
        );
      }
      if (isIndexNode(node)) {
        return new IndexNode(
          node.dimensions.map((n) => _simplifyCore(n, options))
        );
      }
      if (isObjectNode(node)) {
        const newProps = {};
        for (const prop in node.properties) {
          newProps[prop] = _simplifyCore(node.properties[prop], options);
        }
        return new ObjectNode(newProps);
      }
      return node;
    }
    return typed2(name288, { Node: _simplifyCore, "Node,Object": _simplifyCore });
  }
);

// src/function/algebra/resolve.ts
var name289 = "resolve";
var dependencies290 = [
  "typed",
  "parse",
  "ConstantNode",
  "FunctionNode",
  "OperatorNode",
  "ParenthesisNode"
];
var createResolve = /* @__PURE__ */ factory(
  name289,
  dependencies290,
  ({
    typed: typed2,
    parse,
    ConstantNode,
    FunctionNode,
    OperatorNode,
    ParenthesisNode
  }) => {
    function _resolve(node, scope, within = /* @__PURE__ */ new Set()) {
      if (!scope) {
        return node;
      }
      if (isSymbolNode(node)) {
        const symbolNode = node;
        if (within.has(symbolNode.name)) {
          const variables = Array.from(within).join(", ");
          throw new ReferenceError(
            `recursive loop of variable definitions among {${variables}}`
          );
        }
        const value = scope.get(symbolNode.name);
        if (isNode(value)) {
          const nextWithin = new Set(within);
          nextWithin.add(symbolNode.name);
          return _resolve(value, scope, nextWithin);
        } else if (typeof value === "number") {
          return parse(String(value));
        } else if (value !== void 0) {
          return new ConstantNode(value);
        } else {
          return node;
        }
      } else if (isOperatorNode(node)) {
        const opNode = node;
        const args = opNode.args.map(function(arg) {
          return _resolve(arg, scope, within);
        });
        return new OperatorNode(
          opNode.op,
          opNode.fn,
          args,
          opNode.implicit
        );
      } else if (isParenthesisNode(node)) {
        const parenNode = node;
        return new ParenthesisNode(
          _resolve(parenNode.content, scope, within)
        );
      } else if (isFunctionNode(node)) {
        const funcNode = node;
        const args = funcNode.args.map(function(arg) {
          return _resolve(arg, scope, within);
        });
        return new FunctionNode(funcNode.name, args);
      }
      return node.map((child) => _resolve(child, scope, within));
    }
    return typed2("resolve", {
      Node: _resolve,
      "Node, Map | null | undefined": _resolve,
      "Node, Object": (n, scope) => _resolve(n, createMap(scope)),
      // For arrays and matrices, we map `self` rather than `_resolve`
      // because resolve is fairly expensive anyway, and this way
      // we get nice error messages if one entry in the array has wrong type.
      "Array | Matrix": typed2.referToSelf(
        (self) => (A) => A.map((n) => self(n))
      ),
      "Array | Matrix, null | undefined": typed2.referToSelf(
        (self) => (A) => A.map((n) => self(n))
      ),
      "Array, Object": typed2.referTo(
        "Array,Map",
        (selfAM) => (A, scope) => selfAM(A, createMap(scope))
      ),
      "Matrix, Object": typed2.referTo(
        "Matrix,Map",
        (selfMM) => (A, scope) => selfMM(A, createMap(scope))
      ),
      "Array | Matrix, Map": typed2.referToSelf(
        (self) => (A, scope) => A.map((n) => self(n, scope))
      )
    });
  }
);

// src/function/algebra/symbolicEqual.ts
var name290 = "symbolicEqual";
var dependencies291 = ["parse", "simplify", "typed", "OperatorNode"];
var createSymbolicEqual = /* @__PURE__ */ factory(
  name290,
  dependencies291,
  ({
    parse: _parse,
    simplify,
    typed: typed2,
    OperatorNode
  }) => {
    function _symbolicEqual(e1, e2, options = {}) {
      const diff = new OperatorNode("-", "subtract", [e1, e2]);
      const simplified = simplify(diff, [], options);
      return isConstantNode(simplified) && !simplified.value;
    }
    return typed2(name290, {
      "Node, Node": _symbolicEqual,
      "Node, Node, Object": _symbolicEqual
    });
  }
);

// src/function/algebra/derivative.ts
var name291 = "derivative";
var dependencies292 = [
  "typed",
  "config",
  "parse",
  "simplify",
  "equal",
  "isZero",
  "numeric",
  "ConstantNode",
  "FunctionNode",
  "OperatorNode",
  "ParenthesisNode",
  "SymbolNode"
];
var createDerivative = /* @__PURE__ */ factory(
  name291,
  dependencies292,
  ({
    typed: typed2,
    config,
    parse,
    simplify,
    equal,
    isZero,
    numeric,
    ConstantNode,
    FunctionNode,
    OperatorNode,
    ParenthesisNode,
    SymbolNode
  }) => {
    function plainDerivative(expr, variable, options = { simplify: true }) {
      const cache = /* @__PURE__ */ new Map();
      const variableName = variable.name;
      function isConstCached(node) {
        const cached = cache.get(node);
        if (cached !== void 0) {
          return cached;
        }
        const res2 = _isConst(isConstCached, node, variableName);
        cache.set(node, res2);
        return res2;
      }
      const res = _derivative(expr, isConstCached);
      return options.simplify ? simplify(res) : res;
    }
    function parseIdentifier(string) {
      const symbol = parse(string);
      if (!symbol.isSymbolNode) {
        throw new TypeError(
          `Invalid variable. Cannot parse ${JSON.stringify(string)} into a variable in function derivative`
        );
      }
      return symbol;
    }
    const derivative = typed2(name291, {
      "Node, SymbolNode": plainDerivative,
      "Node, SymbolNode, Object": plainDerivative,
      "Node, string": (node, symbol) => plainDerivative(node, parseIdentifier(symbol)),
      "Node, string, Object": (node, symbol, options) => plainDerivative(node, parseIdentifier(symbol), options)
      /* TODO: implement and test syntax with order of derivatives -> implement as an option {order: number}
      'Node, SymbolNode, ConstantNode': function (expr, variable, {order}) {
        let res = expr
        for (let i = 0; i < order; i++) {
          <create caching isConst>
          res = _derivative(res, isConst)
        }
        return res
      }
      */
    });
    derivative._simplify = true;
    derivative.toTex = function(deriv) {
      return _derivTex.apply(null, deriv.args);
    };
    const _derivTex = typed2("_derivTex", {
      "Node, SymbolNode": function(expr, x) {
        if (isConstantNode(expr) && typeOf(expr.value) === "string") {
          return _derivTex(
            parse(expr.value).toString(),
            x.toString(),
            1
          );
        } else {
          return _derivTex(expr.toTex(), x.toString(), 1);
        }
      },
      "Node, ConstantNode": function(expr, x) {
        if (typeOf(x.value) === "string") {
          return _derivTex(expr, parse(x.value));
        } else {
          throw new Error(
            "The second parameter to 'derivative' is a non-string constant"
          );
        }
      },
      "Node, SymbolNode, ConstantNode": function(expr, x, order) {
        return _derivTex(expr.toString(), x.name, order.value);
      },
      "string, string, number": function(expr, x, order) {
        let d;
        if (order === 1) {
          d = "{d\\over d" + x + "}";
        } else {
          d = "{d^{" + order + "}\\over d" + x + "^{" + order + "}}";
        }
        return d + `\\left[${expr}\\right]`;
      }
    });
    const _isConst = typed2("_isConst", {
      "function, ConstantNode, string": function() {
        return true;
      },
      "function, SymbolNode, string": function(isConst, node, varName) {
        return node.name !== varName;
      },
      "function, ParenthesisNode, string": function(isConst, node, varName) {
        return isConst(node.content, varName);
      },
      "function, FunctionAssignmentNode, string": function(isConst, node, varName) {
        if (!node.params.includes(varName)) {
          return true;
        }
        return isConst(node.expr, varName);
      },
      "function, FunctionNode | OperatorNode, string": function(isConst, node, varName) {
        return node.args.every((arg) => isConst(arg, varName));
      }
    });
    const _derivative = typed2("_derivative", {
      "ConstantNode, function": function() {
        return createConstantNode2(0);
      },
      "SymbolNode, function": function(node, isConst) {
        if (isConst(node)) {
          return createConstantNode2(0);
        }
        return createConstantNode2(1);
      },
      "ParenthesisNode, function": function(node, isConst) {
        return new ParenthesisNode(_derivative(node.content, isConst));
      },
      "FunctionAssignmentNode, function": function(node, isConst) {
        if (isConst(node)) {
          return createConstantNode2(0);
        }
        return _derivative(node.expr, isConst);
      },
      "FunctionNode, function": function(node, isConst) {
        if (isConst(node)) {
          return createConstantNode2(0);
        }
        const arg0 = node.args[0];
        let arg1;
        let div = false;
        let negative = false;
        let funcDerivative;
        switch (node.name) {
          case "cbrt":
            div = true;
            funcDerivative = new OperatorNode("*", "multiply", [
              createConstantNode2(3),
              new OperatorNode("^", "pow", [
                arg0,
                new OperatorNode("/", "divide", [
                  createConstantNode2(2),
                  createConstantNode2(3)
                ])
              ])
            ]);
            break;
          case "sqrt":
          case "nthRoot":
            if (node.args.length === 1) {
              div = true;
              funcDerivative = new OperatorNode("*", "multiply", [
                createConstantNode2(2),
                new FunctionNode("sqrt", [arg0])
              ]);
            } else if (node.args.length === 2) {
              arg1 = new OperatorNode("/", "divide", [
                createConstantNode2(1),
                node.args[1]
              ]);
              return _derivative(
                new OperatorNode("^", "pow", [arg0, arg1]),
                isConst
              );
            }
            break;
          case "log10":
            arg1 = createConstantNode2(10);
          /* fall through! */
          case "log":
            if (!arg1 && node.args.length === 1) {
              funcDerivative = arg0.clone();
              div = true;
            } else if (node.args.length === 1 && arg1 || node.args.length === 2 && isConst(node.args[1])) {
              funcDerivative = new OperatorNode("*", "multiply", [
                arg0.clone(),
                new FunctionNode("log", [arg1 || node.args[1]])
              ]);
              div = true;
            } else if (node.args.length === 2) {
              return _derivative(
                new OperatorNode("/", "divide", [
                  new FunctionNode("log", [arg0]),
                  new FunctionNode("log", [node.args[1]])
                ]),
                isConst
              );
            }
            break;
          case "pow":
            if (node.args.length === 2) {
              return _derivative(
                new OperatorNode("^", "pow", [arg0, node.args[1]]),
                isConst
              );
            }
            break;
          case "exp":
            funcDerivative = new FunctionNode("exp", [arg0.clone()]);
            break;
          case "sin":
            funcDerivative = new FunctionNode("cos", [arg0.clone()]);
            break;
          case "cos":
            funcDerivative = new OperatorNode("-", "unaryMinus", [
              new FunctionNode("sin", [arg0.clone()])
            ]);
            break;
          case "tan":
            funcDerivative = new OperatorNode("^", "pow", [
              new FunctionNode("sec", [arg0.clone()]),
              createConstantNode2(2)
            ]);
            break;
          case "sec":
            funcDerivative = new OperatorNode("*", "multiply", [
              node,
              new FunctionNode("tan", [arg0.clone()])
            ]);
            break;
          case "csc":
            negative = true;
            funcDerivative = new OperatorNode("*", "multiply", [
              node,
              new FunctionNode("cot", [arg0.clone()])
            ]);
            break;
          case "cot":
            negative = true;
            funcDerivative = new OperatorNode("^", "pow", [
              new FunctionNode("csc", [arg0.clone()]),
              createConstantNode2(2)
            ]);
            break;
          case "asin":
            div = true;
            funcDerivative = new FunctionNode("sqrt", [
              new OperatorNode("-", "subtract", [
                createConstantNode2(1),
                new OperatorNode("^", "pow", [
                  arg0.clone(),
                  createConstantNode2(2)
                ])
              ])
            ]);
            break;
          case "acos":
            div = true;
            negative = true;
            funcDerivative = new FunctionNode("sqrt", [
              new OperatorNode("-", "subtract", [
                createConstantNode2(1),
                new OperatorNode("^", "pow", [
                  arg0.clone(),
                  createConstantNode2(2)
                ])
              ])
            ]);
            break;
          case "atan":
            div = true;
            funcDerivative = new OperatorNode("+", "add", [
              new OperatorNode("^", "pow", [
                arg0.clone(),
                createConstantNode2(2)
              ]),
              createConstantNode2(1)
            ]);
            break;
          case "asec":
            div = true;
            funcDerivative = new OperatorNode("*", "multiply", [
              new FunctionNode("abs", [arg0.clone()]),
              new FunctionNode("sqrt", [
                new OperatorNode("-", "subtract", [
                  new OperatorNode("^", "pow", [
                    arg0.clone(),
                    createConstantNode2(2)
                  ]),
                  createConstantNode2(1)
                ])
              ])
            ]);
            break;
          case "acsc":
            div = true;
            negative = true;
            funcDerivative = new OperatorNode("*", "multiply", [
              new FunctionNode("abs", [arg0.clone()]),
              new FunctionNode("sqrt", [
                new OperatorNode("-", "subtract", [
                  new OperatorNode("^", "pow", [
                    arg0.clone(),
                    createConstantNode2(2)
                  ]),
                  createConstantNode2(1)
                ])
              ])
            ]);
            break;
          case "acot":
            div = true;
            negative = true;
            funcDerivative = new OperatorNode("+", "add", [
              new OperatorNode("^", "pow", [
                arg0.clone(),
                createConstantNode2(2)
              ]),
              createConstantNode2(1)
            ]);
            break;
          case "sinh":
            funcDerivative = new FunctionNode("cosh", [arg0.clone()]);
            break;
          case "cosh":
            funcDerivative = new FunctionNode("sinh", [arg0.clone()]);
            break;
          case "tanh":
            funcDerivative = new OperatorNode("^", "pow", [
              new FunctionNode("sech", [arg0.clone()]),
              createConstantNode2(2)
            ]);
            break;
          case "sech":
            negative = true;
            funcDerivative = new OperatorNode("*", "multiply", [
              node,
              new FunctionNode("tanh", [arg0.clone()])
            ]);
            break;
          case "csch":
            negative = true;
            funcDerivative = new OperatorNode("*", "multiply", [
              node,
              new FunctionNode("coth", [arg0.clone()])
            ]);
            break;
          case "coth":
            negative = true;
            funcDerivative = new OperatorNode("^", "pow", [
              new FunctionNode("csch", [arg0.clone()]),
              createConstantNode2(2)
            ]);
            break;
          case "asinh":
            div = true;
            funcDerivative = new FunctionNode("sqrt", [
              new OperatorNode("+", "add", [
                new OperatorNode("^", "pow", [
                  arg0.clone(),
                  createConstantNode2(2)
                ]),
                createConstantNode2(1)
              ])
            ]);
            break;
          case "acosh":
            div = true;
            funcDerivative = new FunctionNode("sqrt", [
              new OperatorNode("-", "subtract", [
                new OperatorNode("^", "pow", [
                  arg0.clone(),
                  createConstantNode2(2)
                ]),
                createConstantNode2(1)
              ])
            ]);
            break;
          case "atanh":
            div = true;
            funcDerivative = new OperatorNode("-", "subtract", [
              createConstantNode2(1),
              new OperatorNode("^", "pow", [
                arg0.clone(),
                createConstantNode2(2)
              ])
            ]);
            break;
          case "asech":
            div = true;
            negative = true;
            funcDerivative = new OperatorNode("*", "multiply", [
              arg0.clone(),
              new FunctionNode("sqrt", [
                new OperatorNode("-", "subtract", [
                  createConstantNode2(1),
                  new OperatorNode("^", "pow", [
                    arg0.clone(),
                    createConstantNode2(2)
                  ])
                ])
              ])
            ]);
            break;
          case "acsch":
            div = true;
            negative = true;
            funcDerivative = new OperatorNode("*", "multiply", [
              new FunctionNode("abs", [arg0.clone()]),
              new FunctionNode("sqrt", [
                new OperatorNode("+", "add", [
                  new OperatorNode("^", "pow", [
                    arg0.clone(),
                    createConstantNode2(2)
                  ]),
                  createConstantNode2(1)
                ])
              ])
            ]);
            break;
          case "acoth":
            div = true;
            negative = true;
            funcDerivative = new OperatorNode("-", "subtract", [
              createConstantNode2(1),
              new OperatorNode("^", "pow", [
                arg0.clone(),
                createConstantNode2(2)
              ])
            ]);
            break;
          case "abs":
            funcDerivative = new OperatorNode("/", "divide", [
              new FunctionNode(new SymbolNode("abs"), [arg0.clone()]),
              arg0.clone()
            ]);
            break;
          case "gamma":
          // Needs digamma function, d/dx(gamma(x)) = gamma(x)digamma(x)
          default:
            throw new Error(
              'Cannot process function "' + node.name + '" in derivative: the function is not supported, undefined, or the number of arguments passed to it are not supported'
            );
        }
        let op;
        let func;
        if (div) {
          op = "/";
          func = "divide";
        } else {
          op = "*";
          func = "multiply";
        }
        let chainDerivative = _derivative(arg0, isConst);
        if (negative) {
          chainDerivative = new OperatorNode("-", "unaryMinus", [
            chainDerivative
          ]);
        }
        return new OperatorNode(op, func, [chainDerivative, funcDerivative]);
      },
      "OperatorNode, function": function(node, isConst) {
        if (isConst(node)) {
          return createConstantNode2(0);
        }
        if (node.op === "+") {
          return new OperatorNode(
            node.op,
            node.fn,
            node.args.map(function(arg) {
              return _derivative(arg, isConst);
            })
          );
        }
        if (node.op === "-") {
          if (node.isUnary()) {
            return new OperatorNode(node.op, node.fn, [
              _derivative(node.args[0], isConst)
            ]);
          }
          if (node.isBinary()) {
            return new OperatorNode(node.op, node.fn, [
              _derivative(node.args[0], isConst),
              _derivative(node.args[1], isConst)
            ]);
          }
        }
        if (node.op === "*") {
          const constantTerms = node.args.filter(function(arg) {
            return isConst(arg);
          });
          if (constantTerms.length > 0) {
            const nonConstantTerms = node.args.filter(function(arg) {
              return !isConst(arg);
            });
            const nonConstantNode = nonConstantTerms.length === 1 ? nonConstantTerms[0] : new OperatorNode("*", "multiply", nonConstantTerms);
            const newArgs = constantTerms.concat(
              _derivative(nonConstantNode, isConst)
            );
            return new OperatorNode("*", "multiply", newArgs);
          }
          return new OperatorNode(
            "+",
            "add",
            node.args.map(function(argOuter) {
              return new OperatorNode(
                "*",
                "multiply",
                node.args.map(function(argInner) {
                  return argInner === argOuter ? _derivative(argInner, isConst) : argInner.clone();
                })
              );
            })
          );
        }
        if (node.op === "/" && node.isBinary()) {
          const arg0 = node.args[0];
          const arg1 = node.args[1];
          if (isConst(arg1)) {
            return new OperatorNode("/", "divide", [
              _derivative(arg0, isConst),
              arg1
            ]);
          }
          if (isConst(arg0)) {
            return new OperatorNode("*", "multiply", [
              new OperatorNode("-", "unaryMinus", [arg0]),
              new OperatorNode("/", "divide", [
                _derivative(arg1, isConst),
                new OperatorNode("^", "pow", [
                  arg1.clone(),
                  createConstantNode2(2)
                ])
              ])
            ]);
          }
          return new OperatorNode("/", "divide", [
            new OperatorNode("-", "subtract", [
              new OperatorNode("*", "multiply", [
                _derivative(arg0, isConst),
                arg1.clone()
              ]),
              new OperatorNode("*", "multiply", [
                arg0.clone(),
                _derivative(arg1, isConst)
              ])
            ]),
            new OperatorNode("^", "pow", [arg1.clone(), createConstantNode2(2)])
          ]);
        }
        if (node.op === "^" && node.isBinary()) {
          const arg0 = node.args[0];
          const arg1 = node.args[1];
          if (isConst(arg0)) {
            if (isConstantNode(arg0) && (isZero(arg0.value) || equal(arg0.value, 1))) {
              return createConstantNode2(0);
            }
            return new OperatorNode("*", "multiply", [
              node,
              new OperatorNode("*", "multiply", [
                new FunctionNode("log", [arg0.clone()]),
                _derivative(arg1.clone(), isConst)
              ])
            ]);
          }
          if (isConst(arg1)) {
            if (isConstantNode(arg1)) {
              if (isZero(arg1.value)) {
                return createConstantNode2(0);
              }
              if (equal(arg1.value, 1)) {
                return _derivative(arg0, isConst);
              }
            }
            const powMinusOne = new OperatorNode("^", "pow", [
              arg0.clone(),
              new OperatorNode("-", "subtract", [arg1, createConstantNode2(1)])
            ]);
            return new OperatorNode("*", "multiply", [
              arg1.clone(),
              new OperatorNode("*", "multiply", [
                _derivative(arg0, isConst),
                powMinusOne
              ])
            ]);
          }
          return new OperatorNode("*", "multiply", [
            new OperatorNode("^", "pow", [arg0.clone(), arg1.clone()]),
            new OperatorNode("+", "add", [
              new OperatorNode("*", "multiply", [
                _derivative(arg0, isConst),
                new OperatorNode("/", "divide", [arg1.clone(), arg0.clone()])
              ]),
              new OperatorNode("*", "multiply", [
                _derivative(arg1, isConst),
                new FunctionNode("log", [arg0.clone()])
              ])
            ])
          ]);
        }
        throw new Error(
          'Cannot process operator "' + node.op + '" in derivative: the operator is not supported, undefined, or the number of arguments passed to it are not supported'
        );
      }
    });
    function createConstantNode2(value, valueType) {
      return new ConstantNode(
        numeric(value, safeNumberType(String(value), config))
      );
    }
    return derivative;
  }
);

// src/function/algebra/rationalize.ts
var name292 = "rationalize";
var dependencies293 = [
  "config",
  "typed",
  "equal",
  "isZero",
  "add",
  "subtract",
  "multiply",
  "divide",
  "pow",
  "parse",
  "simplifyConstant",
  "simplifyCore",
  "simplify",
  "?bignumber",
  "?fraction",
  "mathWithTransform",
  "matrix",
  "AccessorNode",
  "ArrayNode",
  "ConstantNode",
  "FunctionNode",
  "IndexNode",
  "ObjectNode",
  "OperatorNode",
  "SymbolNode",
  "ParenthesisNode"
];
var createRationalize = /* @__PURE__ */ factory(
  name292,
  dependencies293,
  ({
    config: _config,
    typed: typed2,
    equal: _equal,
    isZero: _isZero,
    add: _add,
    subtract: _subtract,
    multiply: _multiply,
    divide: _divide,
    pow: _pow,
    parse: _parse,
    simplifyConstant,
    simplifyCore,
    simplify,
    fraction: _fraction,
    bignumber: _bignumber,
    mathWithTransform: _mathWithTransform,
    matrix: _matrix,
    AccessorNode: _AccessorNode,
    ArrayNode: _ArrayNode,
    ConstantNode,
    FunctionNode: _FunctionNode,
    IndexNode: _IndexNode,
    ObjectNode: _ObjectNode,
    OperatorNode,
    SymbolNode,
    ParenthesisNode: _ParenthesisNode
  }) => {
    function _rationalize(expr, scope = {}, detailed = false) {
      const setRules = rulesRationalize();
      const polyRet = polynomial(expr, scope, true, setRules.firstRules);
      const nVars = polyRet.variables.length;
      const noExactFractions = { exactFractions: false };
      const withExactFractions = { exactFractions: true };
      expr = polyRet.expression;
      if (nVars >= 1) {
        expr = expandPower(expr);
        let sBefore;
        let rules;
        let eDistrDiv = true;
        let redoInic = false;
        expr = simplify(expr, setRules.firstRules, {}, noExactFractions);
        let s;
        while (true) {
          rules = eDistrDiv ? setRules.distrDivRules : setRules.sucDivRules;
          expr = simplify(expr, rules, {}, withExactFractions);
          eDistrDiv = !eDistrDiv;
          s = expr.toString();
          if (s === sBefore) {
            break;
          }
          redoInic = true;
          sBefore = s;
        }
        if (redoInic) {
          expr = simplify(expr, setRules.firstRulesAgain, {}, noExactFractions);
        }
        expr = simplify(expr, setRules.finalRules, {}, noExactFractions);
      }
      const coefficients = [];
      const retRationalize = {};
      if (expr.type === "OperatorNode" && expr.isBinary() && expr.op === "/") {
        if (nVars === 1) {
          expr.args[0] = polyToCanonical(
            expr.args[0],
            coefficients
          );
          expr.args[1] = polyToCanonical(
            expr.args[1]
          );
        }
        if (detailed) {
          retRationalize.numerator = expr.args[0];
          retRationalize.denominator = expr.args[1];
        }
      } else {
        if (nVars === 1) {
          expr = polyToCanonical(expr, coefficients);
        }
        if (detailed) {
          retRationalize.numerator = expr;
          retRationalize.denominator = null;
        }
      }
      if (!detailed) return expr;
      retRationalize.coefficients = coefficients;
      retRationalize.variables = polyRet.variables;
      retRationalize.expression = expr;
      return retRationalize;
    }
    return typed2(name292, {
      Node: _rationalize,
      "Node, boolean": (expr, detailed) => _rationalize(expr, {}, detailed),
      "Node, Object": _rationalize,
      "Node, Object, boolean": _rationalize
    });
    function polynomial(expr, scope, extended, rules) {
      const variables = [];
      const node = simplify(expr, rules, scope, { exactFractions: false });
      extended = !!extended;
      const oper = "+-*" + (extended ? "/" : "");
      recPoly(node);
      const retFunc = {};
      retFunc.expression = node;
      retFunc.variables = variables;
      return retFunc;
      function recPoly(node2) {
        const tp = node2.type;
        if (tp === "FunctionNode") {
          throw new Error("There is an unsolved function call");
        } else if (tp === "OperatorNode") {
          if (node2.op === "^") {
            if (node2.args[1].type !== "ConstantNode" || !isInteger(
              parseFloat(
                String(node2.args[1].value)
              )
            )) {
              throw new Error("There is a non-integer exponent");
            } else {
              recPoly(node2.args[0]);
            }
          } else {
            if (!oper.includes(node2.op)) {
              throw new Error(
                "Operator " + node2.op + " invalid in polynomial expression"
              );
            }
            for (let i = 0; i < node2.args.length; i++) {
              recPoly(node2.args[i]);
            }
          }
        } else if (tp === "SymbolNode") {
          const name323 = node2.name;
          const pos = variables.indexOf(name323);
          if (pos === -1) {
            variables.push(name323);
          }
        } else if (tp === "ParenthesisNode") {
          recPoly(node2.content);
        } else if (tp !== "ConstantNode") {
          throw new Error(
            "type " + tp + " is not allowed in polynomial expression"
          );
        }
      }
    }
    function rulesRationalize() {
      const oldRules = [
        simplifyCore,
        // sCore
        { l: "n+n", r: "2*n" },
        { l: "n+-n", r: "0" },
        simplifyConstant,
        // sConstant
        { l: "n*(n1^-1)", r: "n/n1" },
        { l: "n*n1^-n2", r: "n/n1^n2" },
        { l: "n1^-1", r: "1/n1" },
        { l: "n*(n1/n2)", r: "(n*n1)/n2" },
        { l: "1*n", r: "n" }
      ];
      const rulesFirst = [
        { l: "(-n1)/(-n2)", r: "n1/n2" },
        // Unary division
        { l: "(-n1)*(-n2)", r: "n1*n2" },
        // Unary multiplication
        { l: "n1--n2", r: "n1+n2" },
        // '--' elimination
        { l: "n1-n2", r: "n1+(-n2)" },
        // Subtraction turn into add with unary minus
        { l: "(n1+n2)*n3", r: "(n1*n3 + n2*n3)" },
        // Distributive 1
        { l: "n1*(n2+n3)", r: "(n1*n2+n1*n3)" },
        // Distributive 2
        { l: "c1*n + c2*n", r: "(c1+c2)*n" },
        // Joining constants
        { l: "c1*n + n", r: "(c1+1)*n" },
        // Joining constants
        { l: "c1*n - c2*n", r: "(c1-c2)*n" },
        // Joining constants
        { l: "c1*n - n", r: "(c1-1)*n" },
        // Joining constants
        { l: "v/c", r: "(1/c)*v" },
        // variable/constant (new!)
        { l: "v/-c", r: "-(1/c)*v" },
        // variable/constant (new!)
        { l: "-v*-c", r: "c*v" },
        // Inversion constant and variable 1
        { l: "-v*c", r: "-c*v" },
        // Inversion constant and variable 2
        { l: "v*-c", r: "-c*v" },
        // Inversion constant and variable 3
        { l: "v*c", r: "c*v" },
        // Inversion constant and variable 4
        { l: "-(-n1*n2)", r: "(n1*n2)" },
        // Unary propagation
        { l: "-(n1*n2)", r: "(-n1*n2)" },
        // Unary propagation
        { l: "-(-n1+n2)", r: "(n1-n2)" },
        // Unary propagation
        { l: "-(n1+n2)", r: "(-n1-n2)" },
        // Unary propagation
        { l: "(n1^n2)^n3", r: "(n1^(n2*n3))" },
        // Power to Power
        { l: "-(-n1/n2)", r: "(n1/n2)" },
        // Division and Unary
        { l: "-(n1/n2)", r: "(-n1/n2)" }
      ];
      const rulesDistrDiv = [
        { l: "(n1/n2 + n3/n4)", r: "((n1*n4 + n3*n2)/(n2*n4))" },
        // Sum of fractions
        { l: "(n1/n2 + n3)", r: "((n1 + n3*n2)/n2)" },
        // Sum fraction with number 1
        { l: "(n1 + n2/n3)", r: "((n1*n3 + n2)/n3)" }
      ];
      const rulesSucDiv = [
        { l: "(n1/(n2/n3))", r: "((n1*n3)/n2)" },
        // Division simplification
        { l: "(n1/n2/n3)", r: "(n1/(n2*n3))" }
      ];
      const setRules = {};
      setRules.firstRules = oldRules.concat(rulesFirst, rulesSucDiv);
      setRules.distrDivRules = rulesDistrDiv;
      setRules.sucDivRules = rulesSucDiv;
      setRules.firstRulesAgain = oldRules.concat(rulesFirst);
      setRules.finalRules = [
        simplifyCore,
        // simplify.rules[0]
        { l: "n*-n", r: "-n^2" },
        // Joining multiply with power 1
        { l: "n*n", r: "n^2" },
        // Joining multiply with power 2
        simplifyConstant,
        // simplify.rules[14] old 3rd index in oldRules
        { l: "n*-n^n1", r: "-n^(n1+1)" },
        // Joining multiply with power 3
        { l: "n*n^n1", r: "n^(n1+1)" },
        // Joining multiply with power 4
        { l: "n^n1*-n^n2", r: "-n^(n1+n2)" },
        // Joining multiply with power 5
        { l: "n^n1*n^n2", r: "n^(n1+n2)" },
        // Joining multiply with power 6
        { l: "n^n1*-n", r: "-n^(n1+1)" },
        // Joining multiply with power 7
        { l: "n^n1*n", r: "n^(n1+1)" },
        // Joining multiply with power 8
        { l: "n^n1/-n", r: "-n^(n1-1)" },
        // Joining multiply with power 8
        { l: "n^n1/n", r: "n^(n1-1)" },
        // Joining division with power 1
        { l: "n/-n^n1", r: "-n^(1-n1)" },
        // Joining division with power 2
        { l: "n/n^n1", r: "n^(1-n1)" },
        // Joining division with power 3
        { l: "n^n1/-n^n2", r: "n^(n1-n2)" },
        // Joining division with power 4
        { l: "n^n1/n^n2", r: "n^(n1-n2)" },
        // Joining division with power 5
        { l: "n1+(-n2*n3)", r: "n1-n2*n3" },
        // Solving useless parenthesis 1
        { l: "v*(-c)", r: "-c*v" },
        // Solving useless unary 2
        { l: "n1+-n2", r: "n1-n2" },
        // Solving +- together (new!)
        { l: "v*c", r: "c*v" },
        // inversion constant with variable
        { l: "(n1^n2)^n3", r: "(n1^(n2*n3))" }
        // Power to Power
      ];
      return setRules;
    }
    function expandPower(node, parent, indParent) {
      const tp = node.type;
      const internal = arguments.length > 1;
      if (tp === "OperatorNode" && node.isBinary()) {
        let does = false;
        let val;
        if (node.op === "^") {
          if ((node.args[0].type === "ParenthesisNode" || node.args[0].type === "OperatorNode") && node.args[1].type === "ConstantNode") {
            val = parseFloat(
              String(node.args[1].value)
            );
            does = val >= 2 && isInteger(val);
          }
        }
        if (does) {
          if (val > 2) {
            const nEsqTopo = node.args[0];
            const nDirTopo = new OperatorNode("^", "pow", [
              node.args[0].cloneDeep(),
              new ConstantNode(val - 1)
            ]);
            node = new OperatorNode("*", "multiply", [nEsqTopo, nDirTopo]);
          } else {
            node = new OperatorNode("*", "multiply", [
              node.args[0],
              node.args[0].cloneDeep()
            ]);
          }
          if (internal) {
            if (indParent === "content") {
              parent.content = node;
            } else {
              parent.args[indParent] = node;
            }
          }
        }
      }
      if (tp === "ParenthesisNode") {
        expandPower(node.content, node, "content");
      } else if (tp !== "ConstantNode" && tp !== "SymbolNode") {
        for (let i = 0; i < node.args.length; i++) {
          expandPower(node.args[i], node, i);
        }
      }
      if (!internal) {
        return node;
      }
      return node;
    }
    function polyToCanonical(node, coefficients) {
      if (coefficients === void 0) {
        coefficients = [];
      }
      coefficients[0] = 0;
      const o = {};
      o.cte = 1;
      o.oper = "+";
      o.fire = "";
      let maxExpo = 0;
      let varname = "";
      recurPol(node, null, o);
      maxExpo = coefficients.length - 1;
      let first = true;
      let no;
      for (let i = maxExpo; i >= 0; i--) {
        if (coefficients[i] === 0) continue;
        let n16 = new ConstantNode(
          first ? coefficients[i] : Math.abs(coefficients[i])
        );
        const op = coefficients[i] < 0 ? "-" : "+";
        if (i > 0) {
          let n25 = new SymbolNode(varname);
          if (i > 1) {
            const n3 = new ConstantNode(i);
            n25 = new OperatorNode("^", "pow", [n25, n3]);
          }
          if (coefficients[i] === -1 && first) {
            n16 = new OperatorNode("-", "unaryMinus", [n25]);
          } else if (Math.abs(coefficients[i]) === 1) {
            n16 = n25;
          } else {
            n16 = new OperatorNode("*", "multiply", [n16, n25]);
          }
        }
        if (first) {
          no = n16;
        } else if (op === "+") {
          no = new OperatorNode("+", "add", [no, n16]);
        } else {
          no = new OperatorNode("-", "subtract", [no, n16]);
        }
        first = false;
      }
      if (first) {
        return new ConstantNode(0);
      } else {
        return no;
      }
      function recurPol(node2, noPai, o2) {
        const tp = node2.type;
        if (tp === "FunctionNode") {
          throw new Error("There is an unsolved function call");
        } else if (tp === "OperatorNode") {
          if (!"+-*^".includes(node2.op))
            throw new Error(
              "Operator " + node2.op + " invalid"
            );
          if (noPai !== null) {
            if ((node2.fn === "unaryMinus" || node2.fn === "pow") && noPai.fn !== "add" && noPai.fn !== "subtract" && noPai.fn !== "multiply") {
              throw new Error(
                "Invalid " + node2.op + " placing"
              );
            }
            if ((node2.fn === "subtract" || node2.fn === "add" || node2.fn === "multiply") && noPai.fn !== "add" && noPai.fn !== "subtract") {
              throw new Error(
                "Invalid " + node2.op + " placing"
              );
            }
            if ((node2.fn === "subtract" || node2.fn === "add" || node2.fn === "unaryMinus") && o2.noFil !== 0) {
              throw new Error(
                "Invalid " + node2.op + " placing"
              );
            }
          }
          if (node2.op === "^" || node2.op === "*") {
            o2.fire = node2.op;
          }
          for (let i = 0; i < node2.args.length; i++) {
            if (node2.fn === "unaryMinus") o2.oper = "-";
            if (node2.op === "+" || node2.fn === "subtract") {
              o2.fire = "";
              o2.cte = 1;
              o2.oper = i === 0 ? "+" : node2.op;
            }
            o2.noFil = i;
            recurPol(node2.args[i], node2, o2);
          }
        } else if (tp === "SymbolNode") {
          if (node2.name !== varname && varname !== "") {
            throw new Error("There is more than one variable");
          }
          varname = node2.name;
          if (noPai === null) {
            coefficients[1] = 1;
            return;
          }
          if (noPai.op === "^" && o2.noFil !== 0) {
            throw new Error(
              "In power the variable should be the first parameter"
            );
          }
          if (noPai.op === "*" && o2.noFil !== 1) {
            throw new Error(
              "In multiply the variable should be the second parameter"
            );
          }
          if (o2.fire === "" || o2.fire === "*") {
            if (maxExpo < 1) coefficients[1] = 0;
            coefficients[1] += o2.cte * (o2.oper === "+" ? 1 : -1);
            maxExpo = Math.max(1, maxExpo);
          }
        } else if (tp === "ConstantNode") {
          const valor = parseFloat(String(node2.value));
          if (noPai === null) {
            coefficients[0] = valor;
            return;
          }
          if (noPai.op === "^") {
            if (o2.noFil !== 1) throw new Error("Constant cannot be powered");
            if (!isInteger(valor) || valor <= 0) {
              throw new Error("Non-integer exponent is not allowed");
            }
            for (let i = maxExpo + 1; i < valor; i++) coefficients[i] = 0;
            if (valor > maxExpo) coefficients[valor] = 0;
            coefficients[valor] += o2.cte * (o2.oper === "+" ? 1 : -1);
            maxExpo = Math.max(valor, maxExpo);
            return;
          }
          o2.cte = valor;
          if (o2.fire === "") {
            coefficients[0] += o2.cte * (o2.oper === "+" ? 1 : -1);
          }
        } else {
          throw new Error("Type " + tp + " is not allowed");
        }
      }
    }
  }
);

// src/function/signal/zpk2tf.ts
var name293 = "zpk2tf";
var dependencies294 = ["typed", "add", "multiply", "Complex", "number"];
var createZpk2tf = /* @__PURE__ */ factory(
  name293,
  dependencies294,
  ({ typed: typed2, add, multiply, Complex: Complex2, number }) => {
    return typed2(name293, {
      "Array,Array,number": function(z, p, k) {
        return _zpk2tf(z, p, k);
      },
      "Array,Array": function(z, p) {
        return _zpk2tf(z, p, 1);
      },
      "Matrix,Matrix,number": function(z, p, k) {
        return _zpk2tf(z.valueOf(), p.valueOf(), k);
      },
      "Matrix,Matrix": function(z, p) {
        return _zpk2tf(z.valueOf(), p.valueOf(), 1);
      }
    });
    function _zpk2tf(z, p, k) {
      if (z.some((el) => el.type === "BigNumber")) {
        z = z.map((el) => number(el));
      }
      if (p.some((el) => el.type === "BigNumber")) {
        p = p.map((el) => number(el));
      }
      let num = [Complex2(1, 0)];
      let den = [Complex2(1, 0)];
      for (let i = 0; i < z.length; i++) {
        let zero = z[i];
        if (typeof zero === "number") zero = Complex2(zero, 0);
        num = _multiply(num, [
          Complex2(1, 0),
          Complex2(-zero.re, -zero.im)
        ]);
      }
      for (let i = 0; i < p.length; i++) {
        let pole = p[i];
        if (typeof pole === "number") pole = Complex2(pole, 0);
        den = _multiply(den, [
          Complex2(1, 0),
          Complex2(-pole.re, -pole.im)
        ]);
      }
      for (let i = 0; i < num.length; i++) {
        num[i] = multiply(num[i], k);
      }
      return [num, den];
    }
    function _multiply(a, b) {
      const c = [];
      for (let i = 0; i < a.length + b.length - 1; i++) {
        c[i] = Complex2(0, 0);
        for (let j = 0; j < a.length; j++) {
          if (i - j >= 0 && i - j < b.length) {
            c[i] = add(c[i], multiply(a[j], b[i - j]));
          }
        }
      }
      return c;
    }
  }
);

// src/function/signal/freqz.ts
var name294 = "freqz";
var dependencies295 = ["typed", "add", "multiply", "Complex", "divide", "matrix"];
var createFreqz = /* @__PURE__ */ factory(
  name294,
  dependencies295,
  ({ typed: typed2, add, multiply, Complex: Complex2, divide, matrix }) => {
    return typed2(name294, {
      "Array, Array": function(b, a) {
        const w = createBins(512);
        return _freqz(b, a, w);
      },
      "Array, Array, Array": function(b, a, w) {
        return _freqz(b, a, w);
      },
      "Array, Array, number": function(b, a, w) {
        if (w < 0) {
          throw new Error("w must be a positive number");
        }
        const w2 = createBins(w);
        return _freqz(b, a, w2);
      },
      "Matrix, Matrix": function(b, a) {
        const _w = createBins(512);
        const { w, h } = _freqz(
          b.valueOf(),
          a.valueOf(),
          _w
        );
        return {
          w: matrix(w),
          h: matrix(h)
        };
      },
      "Matrix, Matrix, Matrix": function(b, a, w) {
        const { h } = _freqz(
          b.valueOf(),
          a.valueOf(),
          w.valueOf()
        );
        return {
          h: matrix(h),
          w: matrix(w)
        };
      },
      "Matrix, Matrix, number": function(b, a, w) {
        if (w < 0) {
          throw new Error("w must be a positive number");
        }
        const _w = createBins(w);
        const { h } = _freqz(
          b.valueOf(),
          a.valueOf(),
          _w
        );
        return {
          h: matrix(h),
          w: matrix(_w)
        };
      }
    });
    function _freqz(b, a, w) {
      const num = [];
      const den = [];
      for (let i = 0; i < w.length; i++) {
        let sumNum = Complex2(0, 0);
        let sumDen = Complex2(0, 0);
        for (let j = 0; j < b.length; j++) {
          sumNum = add(
            sumNum,
            multiply(b[j], Complex2(Math.cos(-j * w[i]), Math.sin(-j * w[i])))
          );
        }
        for (let j = 0; j < a.length; j++) {
          sumDen = add(
            sumDen,
            multiply(a[j], Complex2(Math.cos(-j * w[i]), Math.sin(-j * w[i])))
          );
        }
        num.push(sumNum);
        den.push(sumDen);
      }
      const h = [];
      for (let i = 0; i < num.length; i++) {
        h.push(divide(num[i], den[i]));
      }
      return { h, w };
    }
    function createBins(n) {
      const bins = [];
      for (let i = 0; i < n; i++) {
        bins.push(i / n * Math.PI);
      }
      return bins;
    }
  }
);

// src/json/reviver.ts
var name295 = "reviver";
var dependencies296 = ["classes"];
var createReviver = /* @__PURE__ */ factory(
  name295,
  dependencies296,
  ({ classes }) => {
    return function reviver(key, value) {
      const constructor = classes[value && value.mathjs];
      if (constructor && typeof constructor.fromJSON === "function") {
        return constructor.fromJSON(value);
      }
      return value;
    };
  }
);

// src/json/replacer.ts
var name296 = "replacer";
var dependencies297 = [];
var createReplacer = /* @__PURE__ */ factory(
  name296,
  dependencies297,
  () => {
    return function replacer(key, value) {
      if (typeof value === "number" && (!Number.isFinite(value) || isNaN(value))) {
        return {
          mathjs: "number",
          value: String(value)
        };
      }
      if (typeof value === "bigint") {
        return {
          mathjs: "bigint",
          value: String(value)
        };
      }
      return value;
    };
  }
);

// src/version.ts
var version = "15.1.0";

// src/constants.ts
var createTrue = /* @__PURE__ */ factory("true", [], () => true);
var createFalse = /* @__PURE__ */ factory("false", [], () => false);
var createNull = /* @__PURE__ */ factory("null", [], () => null);
var createInfinity = /* @__PURE__ */ recreateFactory(
  "Infinity",
  ["config", "?BigNumber"],
  ({ config, BigNumber }) => config.number === "BigNumber" ? new BigNumber(Infinity) : Infinity
);
var createNaN = /* @__PURE__ */ recreateFactory(
  "NaN",
  ["config", "?BigNumber"],
  ({ config, BigNumber }) => config.number === "BigNumber" ? new BigNumber(NaN) : NaN
);
var createPi = /* @__PURE__ */ recreateFactory(
  "pi",
  ["config", "?BigNumber"],
  ({ config, BigNumber }) => config.number === "BigNumber" ? createBigNumberPi(BigNumber) : pi
);
var createTau = /* @__PURE__ */ recreateFactory(
  "tau",
  ["config", "?BigNumber"],
  ({ config, BigNumber }) => config.number === "BigNumber" ? createBigNumberTau(BigNumber) : tau
);
var createE = /* @__PURE__ */ recreateFactory(
  "e",
  ["config", "?BigNumber"],
  ({ config, BigNumber }) => config.number === "BigNumber" ? createBigNumberE(BigNumber) : e
);
var createPhi = /* @__PURE__ */ recreateFactory(
  "phi",
  ["config", "?BigNumber"],
  ({ config, BigNumber }) => config.number === "BigNumber" ? createBigNumberPhi(BigNumber) : phi
);
var createLN2 = /* @__PURE__ */ recreateFactory(
  "LN2",
  ["config", "?BigNumber"],
  ({ config, BigNumber }) => config.number === "BigNumber" ? new BigNumber(2).ln() : Math.LN2
);
var createLN10 = /* @__PURE__ */ recreateFactory(
  "LN10",
  ["config", "?BigNumber"],
  ({ config, BigNumber }) => config.number === "BigNumber" ? new BigNumber(10).ln() : Math.LN10
);
var createLOG2E = /* @__PURE__ */ recreateFactory(
  "LOG2E",
  ["config", "?BigNumber"],
  ({ config, BigNumber }) => config.number === "BigNumber" ? new BigNumber(1).div(new BigNumber(2).ln()) : Math.LOG2E
);
var createLOG10E = /* @__PURE__ */ recreateFactory(
  "LOG10E",
  ["config", "?BigNumber"],
  ({ config, BigNumber }) => config.number === "BigNumber" ? new BigNumber(1).div(new BigNumber(10).ln()) : Math.LOG10E
);
var createSQRT1_2 = /* @__PURE__ */ recreateFactory(
  // eslint-disable-line camelcase
  "SQRT1_2",
  ["config", "?BigNumber"],
  ({ config, BigNumber }) => config.number === "BigNumber" ? new BigNumber("0.5").sqrt() : Math.SQRT1_2
);
var createSQRT2 = /* @__PURE__ */ recreateFactory(
  "SQRT2",
  ["config", "?BigNumber"],
  ({ config, BigNumber }) => config.number === "BigNumber" ? new BigNumber(2).sqrt() : Math.SQRT2
);
var createI = /* @__PURE__ */ recreateFactory(
  "i",
  ["Complex"],
  ({ Complex: Complex2 }) => Complex2.I
);
var createUppercasePi = /* @__PURE__ */ factory(
  "PI",
  ["pi"],
  ({ pi: pi2 }) => pi2
);
var createUppercaseE = /* @__PURE__ */ factory(
  "E",
  ["e"],
  ({ e: e2 }) => e2
);
var createVersion = /* @__PURE__ */ factory(
  "version",
  [],
  () => version
);
function recreateFactory(name323, dependencies324, create2) {
  return factory(name323, dependencies324, create2, {
    recreateOnConfigChange: true
  });
}

// src/type/unit/physicalConstants.ts
var createSpeedOfLight = /* @__PURE__ */ unitFactory(
  "speedOfLight",
  "299792458",
  "m s^-1"
);
var createGravitationConstant = /* @__PURE__ */ unitFactory(
  "gravitationConstant",
  "6.67430e-11",
  "m^3 kg^-1 s^-2"
);
var createPlanckConstant = /* @__PURE__ */ unitFactory(
  "planckConstant",
  "6.62607015e-34",
  "J s"
);
var createReducedPlanckConstant = /* @__PURE__ */ unitFactory(
  "reducedPlanckConstant",
  "1.0545718176461565e-34",
  "J s"
);
var createMagneticConstant = /* @__PURE__ */ unitFactory(
  "magneticConstant",
  "1.25663706212e-6",
  "N A^-2"
);
var createElectricConstant = /* @__PURE__ */ unitFactory(
  "electricConstant",
  "8.8541878128e-12",
  "F m^-1"
);
var createVacuumImpedance = /* @__PURE__ */ unitFactory(
  "vacuumImpedance",
  "376.730313667",
  "ohm"
);
var createCoulomb = /* @__PURE__ */ unitFactory(
  "coulomb",
  "8.987551792261171e9",
  "N m^2 C^-2"
);
var createCoulombConstant = /* @__PURE__ */ unitFactory(
  "coulombConstant",
  "8.987551792261171e9",
  "N m^2 C^-2"
);
var createElementaryCharge = /* @__PURE__ */ unitFactory(
  "elementaryCharge",
  "1.602176634e-19",
  "C"
);
var createBohrMagneton = /* @__PURE__ */ unitFactory(
  "bohrMagneton",
  "9.2740100783e-24",
  "J T^-1"
);
var createConductanceQuantum = /* @__PURE__ */ unitFactory(
  "conductanceQuantum",
  "7.748091729863649e-5",
  "S"
);
var createInverseConductanceQuantum = /* @__PURE__ */ unitFactory(
  "inverseConductanceQuantum",
  "12906.403729652257",
  "ohm"
);
var createMagneticFluxQuantum = /* @__PURE__ */ unitFactory(
  "magneticFluxQuantum",
  "2.0678338484619295e-15",
  "Wb"
);
var createNuclearMagneton = /* @__PURE__ */ unitFactory(
  "nuclearMagneton",
  "5.0507837461e-27",
  "J T^-1"
);
var createKlitzing = /* @__PURE__ */ unitFactory(
  "klitzing",
  "25812.807459304513",
  "ohm"
);
var createBohrRadius = /* @__PURE__ */ unitFactory(
  "bohrRadius",
  "5.29177210903e-11",
  "m"
);
var createClassicalElectronRadius = /* @__PURE__ */ unitFactory(
  "classicalElectronRadius",
  "2.8179403262e-15",
  "m"
);
var createElectronMass = /* @__PURE__ */ unitFactory(
  "electronMass",
  "9.1093837015e-31",
  "kg"
);
var createFermiCoupling = /* @__PURE__ */ unitFactory(
  "fermiCoupling",
  "1.1663787e-5",
  "GeV^-2"
);
var createFineStructure = numberFactory(
  "fineStructure",
  0.0072973525693
);
var createHartreeEnergy = /* @__PURE__ */ unitFactory(
  "hartreeEnergy",
  "4.3597447222071e-18",
  "J"
);
var createProtonMass = /* @__PURE__ */ unitFactory(
  "protonMass",
  "1.67262192369e-27",
  "kg"
);
var createDeuteronMass = /* @__PURE__ */ unitFactory(
  "deuteronMass",
  "3.3435830926e-27",
  "kg"
);
var createNeutronMass = /* @__PURE__ */ unitFactory(
  "neutronMass",
  "1.6749271613e-27",
  "kg"
);
var createQuantumOfCirculation = /* @__PURE__ */ unitFactory(
  "quantumOfCirculation",
  "3.6369475516e-4",
  "m^2 s^-1"
);
var createRydberg = /* @__PURE__ */ unitFactory(
  "rydberg",
  "10973731.568160",
  "m^-1"
);
var createThomsonCrossSection = /* @__PURE__ */ unitFactory(
  "thomsonCrossSection",
  "6.6524587321e-29",
  "m^2"
);
var createWeakMixingAngle = numberFactory("weakMixingAngle", 0.2229);
var createEfimovFactor = numberFactory("efimovFactor", 22.7);
var createAtomicMass = /* @__PURE__ */ unitFactory(
  "atomicMass",
  "1.66053906660e-27",
  "kg"
);
var createAvogadro = /* @__PURE__ */ unitFactory(
  "avogadro",
  "6.02214076e23",
  "mol^-1"
);
var createBoltzmann = /* @__PURE__ */ unitFactory(
  "boltzmann",
  "1.380649e-23",
  "J K^-1"
);
var createFaraday = /* @__PURE__ */ unitFactory(
  "faraday",
  "96485.33212331001",
  "C mol^-1"
);
var createFirstRadiation = /* @__PURE__ */ unitFactory(
  "firstRadiation",
  "3.7417718521927573e-16",
  "W m^2"
);
var createLoschmidt = /* @__PURE__ */ unitFactory(
  "loschmidt",
  "2.686780111798444e25",
  "m^-3"
);
var createGasConstant = /* @__PURE__ */ unitFactory(
  "gasConstant",
  "8.31446261815324",
  "J K^-1 mol^-1"
);
var createMolarPlanckConstant = /* @__PURE__ */ unitFactory(
  "molarPlanckConstant",
  "3.990312712893431e-10",
  "J s mol^-1"
);
var createMolarVolume = /* @__PURE__ */ unitFactory(
  "molarVolume",
  "0.022413969545014137",
  "m^3 mol^-1"
);
var createSackurTetrode = numberFactory(
  "sackurTetrode",
  -1.16487052358
);
var createSecondRadiation = /* @__PURE__ */ unitFactory(
  "secondRadiation",
  "0.014387768775039337",
  "m K"
);
var createStefanBoltzmann = /* @__PURE__ */ unitFactory(
  "stefanBoltzmann",
  "5.67037441918443e-8",
  "W m^-2 K^-4"
);
var createWienDisplacement = /* @__PURE__ */ unitFactory(
  "wienDisplacement",
  "2.897771955e-3",
  "m K"
);
var createMolarMass = /* @__PURE__ */ unitFactory(
  "molarMass",
  "0.99999999965e-3",
  "kg mol^-1"
);
var createMolarMassC12 = /* @__PURE__ */ unitFactory(
  "molarMassC12",
  "11.9999999958e-3",
  "kg mol^-1"
);
var createGravity = /* @__PURE__ */ unitFactory(
  "gravity",
  "9.80665",
  "m s^-2"
);
var createPlanckLength = /* @__PURE__ */ unitFactory(
  "planckLength",
  "1.616255e-35",
  "m"
);
var createPlanckMass = /* @__PURE__ */ unitFactory(
  "planckMass",
  "2.176435e-8",
  "kg"
);
var createPlanckTime = /* @__PURE__ */ unitFactory(
  "planckTime",
  "5.391245e-44",
  "s"
);
var createPlanckCharge = /* @__PURE__ */ unitFactory(
  "planckCharge",
  "1.87554603778e-18",
  "C"
);
var createPlanckTemperature = /* @__PURE__ */ unitFactory(
  "planckTemperature",
  "1.416785e+32",
  "K"
);
function unitFactory(name323, valueStr, unitStr) {
  const dependencies324 = ["config", "Unit", "BigNumber"];
  return factory(
    name323,
    dependencies324,
    ({ config, Unit, BigNumber }) => {
      const value = config.number === "BigNumber" ? new BigNumber(valueStr) : parseFloat(valueStr);
      const unit = new Unit(value, unitStr);
      unit.fixPrefix = true;
      return unit;
    }
  );
}
function numberFactory(name323, value) {
  const dependencies324 = ["config", "BigNumber"];
  return factory(
    name323,
    dependencies324,
    ({ config, BigNumber }) => {
      return config.number === "BigNumber" ? new BigNumber(value) : value;
    }
  );
}

// src/expression/transform/mapSlices.transform.ts
var name297 = "mapSlices";
var dependencies298 = ["typed", "isInteger"];
var createMapSlicesTransform = /* @__PURE__ */ factory(
  name297,
  dependencies298,
  ({ typed: typed2, isInteger: isInteger2 }) => {
    const mapSlices = createMapSlices({ typed: typed2, isInteger: isInteger2 });
    return typed2("mapSlices", {
      "...any": function(args) {
        const dim = args[1];
        if (isNumber(dim)) {
          args[1] = dim - 1;
        } else if (isBigNumber(dim)) {
          args[1] = dim.minus(1);
        }
        try {
          return mapSlices.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  },
  { isTransformFunction: true, ...createMapSlices.meta }
);

// src/expression/transform/column.transform.ts
var name298 = "column";
var dependencies299 = ["typed", "Index", "matrix", "range"];
var createColumnTransform = /* @__PURE__ */ factory(
  name298,
  dependencies299,
  ({ typed: typed2, Index: Index2, matrix, range }) => {
    const column = createColumn({ typed: typed2, Index: Index2, matrix, range });
    return typed2("column", {
      "...any": function(args) {
        const lastIndex = args.length - 1;
        const last = args[lastIndex];
        if (isNumber(last)) {
          args[lastIndex] = last - 1;
        }
        try {
          return column.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  },
  { isTransformFunction: true }
);

// src/expression/transform/utils/compileInlineExpression.ts
function compileInlineExpression(expression, math, scope) {
  const filterFn = expression.filter;
  if (!filterFn) {
    throw new Error("Expression does not support filter");
  }
  const symbols = filterFn.call(expression, function(node) {
    return isSymbolNode(node) && node.name !== void 0 && !(node.name in math) && !scope.has(node.name);
  });
  const symbol = symbols[0];
  if (!symbol) {
    throw new Error(
      'No undefined variable found in inline expression "' + expression + '"'
    );
  }
  const name323 = symbol.name;
  const argsScope = /* @__PURE__ */ new Map();
  const subScope = new PartitionedMap(scope, argsScope, /* @__PURE__ */ new Set([name323]));
  const eq = expression.compile();
  return function inlineExpression(x) {
    argsScope.set(name323, x);
    return eq.evaluate(subScope);
  };
}

// src/expression/transform/utils/transformCallback.ts
var name299 = "transformCallback";
var dependencies300 = ["typed"];
var createTransformCallback = /* @__PURE__ */ factory(
  name299,
  dependencies300,
  ({ typed: typed2 }) => {
    const typedChecker = typed2;
    return function(callback, numberOfArrays) {
      if (typedChecker.isTypedFunction(callback)) {
        return _transformTypedCallbackFunction(callback, numberOfArrays);
      } else {
        return _transformCallbackFunction(
          callback,
          callback.length,
          numberOfArrays
        );
      }
    };
    function _transformTypedCallbackFunction(typedFunction3, numberOfArrays) {
      const signatures = Object.fromEntries(
        Object.entries(typedFunction3.signatures).map(
          ([signature, callbackFunction]) => {
            const numberOfCallbackInputs = signature.split(",").length;
            if (typedChecker.isTypedFunction(callbackFunction)) {
              return [
                signature,
                _transformTypedCallbackFunction(
                  callbackFunction,
                  numberOfArrays
                )
              ];
            } else {
              return [
                signature,
                _transformCallbackFunction(
                  callbackFunction,
                  numberOfCallbackInputs,
                  numberOfArrays
                )
              ];
            }
          }
        )
      );
      if (typeof typedFunction3.name === "string") {
        return typed2(typedFunction3.name, signatures);
      } else {
        return typed2(signatures);
      }
    }
  }
);
function _transformCallbackFunction(callbackFunction, numberOfCallbackInputs, numberOfArrays) {
  if (numberOfCallbackInputs === numberOfArrays) {
    return callbackFunction;
  } else if (numberOfCallbackInputs === numberOfArrays + 1) {
    return function(...args) {
      const vals = args.slice(0, numberOfArrays);
      const idx = _transformDims(args[numberOfArrays]);
      return callbackFunction(...vals, idx);
    };
  } else if (numberOfCallbackInputs > numberOfArrays + 1) {
    return function(...args) {
      const vals = args.slice(0, numberOfArrays);
      const idx = _transformDims(args[numberOfArrays]);
      const rest = args.slice(numberOfArrays + 1);
      return callbackFunction(...vals, idx, ...rest);
    };
  } else {
    return callbackFunction;
  }
}
function _transformDims(dims) {
  return dims.map((dim) => dim + 1);
}

// src/expression/transform/filter.transform.ts
var name300 = "filter";
var dependencies301 = ["typed"];
var createFilterTransform = /* @__PURE__ */ factory(
  name300,
  dependencies301,
  ({ typed: typed2 }) => {
    function filterTransform(args, math, scope) {
      const filter2 = createFilter({ typed: typed2 });
      const transformCallback = createTransformCallback({ typed: typed2 });
      if (args.length === 0) {
        return filter2();
      }
      let x = args[0];
      if (args.length === 1) {
        return filter2(x);
      }
      const N = args.length - 1;
      let callback = args[N];
      if (x) {
        x = _compileAndEvaluate(x, scope);
      }
      if (callback) {
        if (isSymbolNode(callback) || isFunctionAssignmentNode(callback)) {
          callback = _compileAndEvaluate(callback, scope);
        } else {
          callback = compileInlineExpression(callback, math, scope);
        }
      }
      return filter2(x, transformCallback(callback, N));
    }
    filterTransform.rawArgs = true;
    function _compileAndEvaluate(arg, scope) {
      return arg.compile().evaluate(scope);
    }
    return filterTransform;
  },
  { isTransformFunction: true }
);

// src/expression/transform/forEach.transform.ts
var name301 = "forEach";
var dependencies302 = ["typed"];
var createForEachTransform = /* @__PURE__ */ factory(
  name301,
  dependencies302,
  ({ typed: typed2 }) => {
    const forEach2 = createForEach({ typed: typed2 });
    const transformCallback = createTransformCallback({ typed: typed2 });
    function forEachTransform(args, math, scope) {
      if (args.length === 0) {
        return forEach2();
      }
      let x = args[0];
      if (args.length === 1) {
        return forEach2(x);
      }
      const N = args.length - 1;
      let callback = args[N];
      if (x) {
        x = _compileAndEvaluate(x, scope);
      }
      if (callback) {
        if (isSymbolNode(callback) || isFunctionAssignmentNode(callback)) {
          callback = _compileAndEvaluate(callback, scope);
        } else {
          callback = compileInlineExpression(callback, math, scope);
        }
      }
      return forEach2(x, transformCallback(callback, N));
    }
    forEachTransform.rawArgs = true;
    function _compileAndEvaluate(arg, scope) {
      return arg.compile().evaluate(scope);
    }
    return forEachTransform;
  },
  { isTransformFunction: true }
);

// src/expression/transform/index.transform.ts
var name302 = "index";
var dependencies303 = ["Index", "getMatrixDataType"];
var createIndexTransform = /* @__PURE__ */ factory(
  name302,
  dependencies303,
  ({ Index: Index2, getMatrixDataType }) => {
    return function indexTransform(...args) {
      const transformedArgs = [];
      for (let i = 0, ii = args.length; i < ii; i++) {
        let arg = args[i];
        if (isRange(arg)) {
          const range = arg;
          range.start--;
          range.end -= range.step > 0 ? 0 : 2;
        } else if (arg && arg.isSet === true) {
          arg = arg.map(function(v) {
            return v - 1;
          });
        } else if (isArray(arg) || isMatrix(arg)) {
          if (getMatrixDataType(arg) !== "boolean") {
            arg = arg.map(function(v) {
              return v - 1;
            });
          }
        } else if (isNumber(arg)) {
          arg = arg - 1;
        } else if (isBigInt(arg)) {
          arg = arg - BigInt(1);
        } else if (isBigNumber(arg)) {
          arg = arg.toNumber() - 1;
        } else if (typeof arg === "string") ; else {
          throw new TypeError(
            "Dimension must be an Array, Matrix, number, bigint, string, or Range"
          );
        }
        transformedArgs[i] = arg;
      }
      return new Index2(...transformedArgs);
    };
  },
  { isTransformFunction: true }
);

// src/expression/transform/map.transform.ts
var name303 = "map";
var dependencies304 = ["typed"];
var createMapTransform = /* @__PURE__ */ factory(
  name303,
  dependencies304,
  ({ typed: typed2 }) => {
    const map2 = createMap2({ typed: typed2 });
    const transformCallback = createTransformCallback({ typed: typed2 });
    function mapTransform(args, math, scope) {
      if (args.length === 0) {
        return map2();
      }
      if (args.length === 1) {
        return map2(args[0]);
      }
      const N = args.length - 1;
      let X = args.slice(0, N);
      let callback = args[N];
      X = X.map((arg) => _compileAndEvaluate(arg, scope));
      if (callback) {
        if (isSymbolNode(callback) || isFunctionAssignmentNode(callback)) {
          callback = _compileAndEvaluate(callback, scope);
        } else {
          callback = compileInlineExpression(callback, math, scope);
        }
      }
      return map2(...X, transformCallback(callback, N));
      function _compileAndEvaluate(arg, scope2) {
        return arg.compile().evaluate(scope2);
      }
    }
    mapTransform.rawArgs = true;
    return mapTransform;
  },
  { isTransformFunction: true }
);

// src/expression/transform/utils/dimToZeroBase.ts
function dimToZeroBase(dim) {
  if (isNumber(dim)) {
    return dim - 1;
  } else if (isBigNumber(dim)) {
    return dim.minus(1);
  } else {
    return dim;
  }
}
function isNumberOrBigNumber(n) {
  return isNumber(n) || isBigNumber(n);
}

// src/expression/transform/utils/lastDimToZeroBase.ts
function lastDimToZeroBase(args) {
  if (args.length === 2 && isCollection(args[0])) {
    args = args.slice();
    const dim = args[1];
    if (isNumberOrBigNumber(dim)) {
      args[1] = dimToZeroBase(dim);
    }
  }
  return args;
}

// src/expression/transform/max.transform.ts
var name304 = "max";
var dependencies305 = ["typed", "config", "numeric", "larger", "isNaN"];
var createMaxTransform = /* @__PURE__ */ factory(
  name304,
  dependencies305,
  ({ typed: typed2, config, numeric, larger, isNaN: mathIsNaN }) => {
    const max = createMax({ typed: typed2, config, numeric, larger, isNaN: mathIsNaN });
    return typed2("max", {
      "...any": function(args) {
        args = lastDimToZeroBase(args);
        try {
          return max.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  },
  { isTransformFunction: true }
);

// src/expression/transform/mean.transform.ts
var name305 = "mean";
var dependencies306 = ["typed", "add", "divide"];
var createMeanTransform = /* @__PURE__ */ factory(
  name305,
  dependencies306,
  ({ typed: typed2, add, divide }) => {
    const mean = createMean({ typed: typed2, add, divide });
    return typed2("mean", {
      "...any": function(args) {
        args = lastDimToZeroBase(args);
        try {
          return mean.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  },
  { isTransformFunction: true }
);

// src/expression/transform/min.transform.ts
var name306 = "min";
var dependencies307 = ["typed", "config", "numeric", "smaller", "isNaN"];
var createMinTransform = /* @__PURE__ */ factory(
  name306,
  dependencies307,
  ({ typed: typed2, config, numeric, smaller, isNaN: mathIsNaN }) => {
    const min = createMin({ typed: typed2, config, numeric, smaller, isNaN: mathIsNaN });
    return typed2("min", {
      "...any": function(args) {
        args = lastDimToZeroBase(args);
        try {
          return min.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  },
  { isTransformFunction: true }
);

// src/expression/transform/range.transform.ts
var name307 = "range";
var dependencies308 = [
  "typed",
  "config",
  "?matrix",
  "?bignumber",
  "equal",
  "smaller",
  "smallerEq",
  "larger",
  "largerEq",
  "add",
  "isZero",
  "isPositive"
];
var createRangeTransform = /* @__PURE__ */ factory(
  name307,
  dependencies308,
  ({
    typed: typed2,
    config,
    matrix,
    bignumber,
    equal,
    smaller,
    smallerEq,
    larger,
    largerEq,
    add,
    isZero,
    isPositive
  }) => {
    const range = createRange({
      typed: typed2,
      config,
      matrix,
      bignumber,
      equal,
      smaller,
      smallerEq,
      larger,
      largerEq,
      add,
      isZero,
      isPositive
    });
    return typed2("range", {
      "...any": function(args) {
        const lastIndex = args.length - 1;
        const last = args[lastIndex];
        if (typeof last !== "boolean") {
          args.push(true);
        }
        return range.apply(null, args);
      }
    });
  },
  { isTransformFunction: true }
);

// src/expression/transform/row.transform.ts
var name308 = "row";
var dependencies309 = ["typed", "Index", "matrix", "range"];
var createRowTransform = /* @__PURE__ */ factory(
  name308,
  dependencies309,
  ({ typed: typed2, Index: Index2, matrix, range }) => {
    const row = createRow({ typed: typed2, Index: Index2, matrix, range });
    return typed2("row", {
      "...any": function(args) {
        const lastIndex = args.length - 1;
        const last = args[lastIndex];
        if (isNumber(last)) {
          args[lastIndex] = last - 1;
        }
        try {
          return row.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  },
  { isTransformFunction: true }
);

// src/expression/transform/subset.transform.ts
var name309 = "subset";
var dependencies310 = ["typed", "matrix", "zeros", "add"];
var createSubsetTransform = /* @__PURE__ */ factory(
  name309,
  dependencies310,
  ({ typed: typed2, matrix, zeros: zeros2, add }) => {
    const subset = createSubset({ typed: typed2, matrix, zeros: zeros2, add });
    return typed2("subset", {
      "...any": function(args) {
        try {
          return subset.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  },
  { isTransformFunction: true }
);

// src/expression/transform/concat.transform.ts
var name310 = "concat";
var dependencies311 = ["typed", "matrix", "isInteger"];
var createConcatTransform = /* @__PURE__ */ factory(
  name310,
  dependencies311,
  ({ typed: typed2, matrix, isInteger: isInteger2 }) => {
    const concat2 = createConcat({ typed: typed2, matrix, isInteger: isInteger2 });
    return typed2("concat", {
      "...any": function(args) {
        const lastIndex = args.length - 1;
        const last = args[lastIndex];
        if (isNumber(last)) {
          args[lastIndex] = last - 1;
        } else if (isBigNumber(last)) {
          args[lastIndex] = last.minus(1);
        }
        try {
          return concat2.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  },
  { isTransformFunction: true }
);

// src/expression/transform/diff.transform.ts
var name311 = "diff";
var dependencies312 = ["typed", "matrix", "subtract", "number", "bignumber"];
var createDiffTransform = /* @__PURE__ */ factory(
  name311,
  dependencies312,
  ({ typed: typed2, matrix, subtract, number, bignumber }) => {
    const diff = createDiff({ typed: typed2, matrix, subtract, number, bignumber });
    return typed2(name311, {
      "...any": function(args) {
        args = lastDimToZeroBase(args);
        try {
          return diff.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  },
  { isTransformFunction: true }
);

// src/expression/transform/std.transform.ts
var name312 = "std";
var dependencies313 = ["typed", "map", "sqrt", "variance"];
var createStdTransform = /* @__PURE__ */ factory(
  name312,
  dependencies313,
  ({ typed: typed2, map: map2, sqrt, variance }) => {
    const std = createStd({ typed: typed2, map: map2, sqrt, variance });
    return typed2("std", {
      "...any": function(args) {
        args = lastDimToZeroBase(args);
        try {
          return std.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  },
  { isTransformFunction: true }
);

// src/expression/transform/sum.transform.ts
var name313 = "sum";
var dependencies314 = ["typed", "config", "add", "numeric"];
var createSumTransform = /* @__PURE__ */ factory(
  name313,
  dependencies314,
  ({ typed: typed2, config, add, numeric }) => {
    const sum = createSum({ typed: typed2, config, add, numeric });
    return typed2(name313, {
      "...any": function(args) {
        args = lastDimToZeroBase(args);
        try {
          return sum.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  },
  { isTransformFunction: true }
);

// src/expression/transform/quantileSeq.transform.ts
var name314 = "quantileSeq";
var dependencies315 = [
  "typed",
  "bignumber",
  "add",
  "subtract",
  "divide",
  "multiply",
  "partitionSelect",
  "compare",
  "isInteger",
  "smaller",
  "smallerEq",
  "larger",
  "mapSlices"
];
var createQuantileSeqTransform = /* @__PURE__ */ factory(
  name314,
  dependencies315,
  ({
    typed: typed2,
    bignumber,
    add,
    subtract,
    divide,
    multiply,
    partitionSelect,
    compare,
    isInteger: isInteger2,
    smaller,
    smallerEq,
    larger,
    mapSlices
  }) => {
    const quantileSeq = createQuantileSeq({
      typed: typed2,
      bignumber,
      add,
      subtract,
      divide,
      multiply,
      partitionSelect,
      compare,
      isInteger: isInteger2,
      smaller,
      smallerEq,
      larger,
      mapSlices
    });
    return typed2("quantileSeq", {
      "Array | Matrix, number | BigNumber": quantileSeq,
      "Array | Matrix, number | BigNumber, number": (arr, prob, dim) => quantileSeq(arr, prob, dimToZeroBase2(dim)),
      "Array | Matrix, number | BigNumber, boolean": quantileSeq,
      "Array | Matrix, number | BigNumber, boolean, number": (arr, prob, sorted, dim) => quantileSeq(arr, prob, sorted, dimToZeroBase2(dim)),
      "Array | Matrix, Array | Matrix": quantileSeq,
      "Array | Matrix, Array | Matrix, number": (data, prob, dim) => quantileSeq(data, prob, dimToZeroBase2(dim)),
      "Array | Matrix, Array | Matrix, boolean": quantileSeq,
      "Array | Matrix, Array | Matrix, boolean, number": (data, prob, sorted, dim) => quantileSeq(data, prob, sorted, dimToZeroBase2(dim))
    });
    function dimToZeroBase2(dim) {
      return lastDimToZeroBase([[], dim])[1];
    }
  },
  { isTransformFunction: true }
);

// src/expression/transform/cumsum.transform.ts
var name315 = "cumsum";
var dependencies316 = ["typed", "add", "unaryPlus"];
var createCumSumTransform = /* @__PURE__ */ factory(
  name315,
  dependencies316,
  ({ typed: typed2, add, unaryPlus }) => {
    const cumsum = createCumSum({ typed: typed2, add, unaryPlus });
    return typed2(name315, {
      "...any": function(args) {
        if (args.length === 2 && isCollection(args[0])) {
          const dim = args[1];
          if (isNumber(dim)) {
            args[1] = dim - 1;
          } else if (isBigNumber(dim)) {
            args[1] = dim.minus(1);
          }
        }
        try {
          return cumsum.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  },
  { isTransformFunction: true }
);

// src/expression/transform/variance.transform.ts
var name316 = "variance";
var dependencies317 = [
  "typed",
  "add",
  "subtract",
  "multiply",
  "divide",
  "mapSlices",
  "isNaN"
];
var createVarianceTransform = /* @__PURE__ */ factory(
  name316,
  dependencies317,
  ({
    typed: typed2,
    add,
    subtract,
    multiply,
    divide,
    mapSlices,
    isNaN: mathIsNaN
  }) => {
    const variance = createVariance({
      typed: typed2,
      add,
      subtract,
      multiply,
      divide,
      mapSlices,
      isNaN: mathIsNaN
    });
    return typed2(name316, {
      "...any": function(args) {
        args = lastDimToZeroBase(args);
        try {
          return variance.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  },
  { isTransformFunction: true }
);

// src/expression/transform/print.transform.ts
var name317 = "print";
var dependencies318 = ["typed", "matrix", "zeros", "add"];
var createPrintTransform = /* @__PURE__ */ factory(
  name317,
  dependencies318,
  ({ typed: typed2, matrix, zeros: zeros2, add }) => {
    const print = createPrint({ typed: typed2, matrix, zeros: zeros2, add });
    return typed2(name317, {
      "string, Object | Array": function(template, values) {
        return print(_convertTemplateToZeroBasedIndex(template), values);
      },
      "string, Object | Array, number | Object": function(template, values, options) {
        return print(
          _convertTemplateToZeroBasedIndex(template),
          values,
          options
        );
      }
    });
    function _convertTemplateToZeroBasedIndex(template) {
      return template.replace(printTemplate, (x) => {
        const parts = x.slice(1).split(".");
        const result = parts.map(function(part) {
          const num = Number(part);
          if (!isNaN(num) && part.length > 0) {
            return num - 1;
          } else {
            return part;
          }
        });
        return "$" + result.join(".");
      });
    }
  },
  { isTransformFunction: true }
);

// src/expression/transform/and.transform.ts
var name318 = "and";
var dependencies319 = [
  "typed",
  "matrix",
  "zeros",
  "add",
  "equalScalar",
  "not",
  "concat"
];
var createAndTransform = /* @__PURE__ */ factory(
  name318,
  dependencies319,
  ({ typed: typed2, matrix, equalScalar, zeros: zeros2, not, concat: concat2 }) => {
    const and = createAnd({ typed: typed2, matrix, equalScalar, zeros: zeros2, not, concat: concat2 });
    function andTransform(args, math, scope) {
      const condition1 = args[0].compile().evaluate(scope);
      if (!isCollection(condition1) && !and(condition1, true)) {
        return false;
      }
      const condition2 = args[1].compile().evaluate(scope);
      return and(condition1, condition2);
    }
    andTransform.rawArgs = true;
    return andTransform;
  },
  { isTransformFunction: true }
);

// src/expression/transform/or.transform.ts
var name319 = "or";
var dependencies320 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
var createOrTransform = /* @__PURE__ */ factory(
  name319,
  dependencies320,
  ({ typed: typed2, matrix, equalScalar, DenseMatrix, concat: concat2 }) => {
    const or = createOr({ typed: typed2, matrix, equalScalar, DenseMatrix, concat: concat2 });
    function orTransform(args, math, scope) {
      const condition1 = args[0].compile().evaluate(scope);
      if (!isCollection(condition1) && or(condition1, false)) {
        return true;
      }
      const condition2 = args[1].compile().evaluate(scope);
      return or(condition1, condition2);
    }
    orTransform.rawArgs = true;
    return orTransform;
  },
  { isTransformFunction: true }
);

// src/expression/transform/nullish.transform.ts
var name320 = "nullish";
var dependencies321 = ["typed", "matrix", "size", "flatten", "deepEqual"];
var createNullishTransform = /* @__PURE__ */ factory(
  name320,
  dependencies321,
  ({ typed: typed2, matrix, size, flatten: flatten2, deepEqual }) => {
    const nullish = createNullish({ typed: typed2, matrix, size, flatten: flatten2, deepEqual });
    function nullishTransform(args, math, scope) {
      const left = args[0].compile().evaluate(scope);
      if (!isCollection(left) && left != null && left !== void 0) {
        return left;
      }
      const right = args[1].compile().evaluate(scope);
      return nullish(left, right);
    }
    nullishTransform.rawArgs = true;
    return nullishTransform;
  },
  { isTransformFunction: true }
);

// src/expression/transform/bitAnd.transform.ts
var name321 = "bitAnd";
var dependencies322 = [
  "typed",
  "matrix",
  "zeros",
  "add",
  "equalScalar",
  "not",
  "concat"
];
var createBitAndTransform = /* @__PURE__ */ factory(
  name321,
  dependencies322,
  ({ typed: typed2, matrix, equalScalar, zeros: zeros2, not, concat: concat2 }) => {
    const bitAnd = createBitAnd({
      typed: typed2,
      matrix,
      equalScalar,
      zeros: zeros2,
      not,
      concat: concat2
    });
    function bitAndTransform(args, math, scope) {
      const condition1 = args[0].compile().evaluate(scope);
      if (!isCollection(condition1)) {
        if (isNaN(condition1)) {
          return NaN;
        }
        if (condition1 === 0 || condition1 === false) {
          return 0;
        }
      }
      const condition2 = args[1].compile().evaluate(scope);
      return bitAnd(condition1, condition2);
    }
    bitAndTransform.rawArgs = true;
    return bitAndTransform;
  },
  { isTransformFunction: true }
);

// src/expression/transform/bitOr.transform.ts
var name322 = "bitOr";
var dependencies323 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
var createBitOrTransform = /* @__PURE__ */ factory(
  name322,
  dependencies323,
  ({ typed: typed2, matrix, equalScalar, DenseMatrix, concat: concat2 }) => {
    const bitOr = createBitOr({
      typed: typed2,
      matrix,
      equalScalar,
      DenseMatrix,
      concat: concat2
    });
    function bitOrTransform(args, math, scope) {
      const condition1 = args[0].compile().evaluate(scope);
      if (!isCollection(condition1)) {
        if (isNaN(condition1)) {
          return NaN;
        }
        if (condition1 === -1) {
          return -1;
        }
        if (condition1 === true) {
          return 1;
        }
      }
      const condition2 = args[1].compile().evaluate(scope);
      return bitOr(condition1, condition2);
    }
    bitOrTransform.rawArgs = true;
    return bitOrTransform;
  },
  { isTransformFunction: true }
);
function mixin(obj) {
  const emitter = new Emitter__default.default();
  const extendedObj = obj;
  extendedObj.on = emitter.on.bind(emitter);
  extendedObj.off = emitter.off.bind(emitter);
  extendedObj.once = emitter.once.bind(emitter);
  extendedObj.emit = emitter.emit.bind(emitter);
  return extendedObj;
}

// src/core/config.ts
var DEFAULT_CONFIG = {
  // minimum relative difference between two compared values,
  // used by all comparison functions
  relTol: 1e-12,
  // minimum absolute difference between two compared values,
  // used by all comparison functions
  absTol: 1e-15,
  // type of default matrix output. Choose 'matrix' (default) or 'array'
  matrix: "Matrix",
  // type of default number output. Choose 'number' (default) 'BigNumber', 'bigint', or 'Fraction'
  number: "number",
  // type of fallback used for config { number: 'bigint' } when a value cannot be represented
  // in the configured numeric type. Choose 'number' (default) or 'BigNumber'.
  numberFallback: "number",
  // number of significant digits in BigNumbers
  precision: 64,
  // predictable output type of functions. When true, output type depends only
  // on the input types. When false (default), output type can vary depending
  // on input values. For example `math.sqrt(-4)` returns `complex('2i')` when
  // predictable is false, and returns `NaN` when true.
  predictable: false,
  // random seed for seeded pseudo random number generation
  // null = randomly seed
  randomSeed: null,
  // legacy behavior for matrix subset. When true, the subset function
  // returns a matrix or array with the same size as the index (except for scalars).
  // When false, it returns a matrix or array with a size depending on the type of index.
  legacySubset: false
};

// src/core/function/config.ts
var MATRIX_OPTIONS = ["Matrix", "Array"];
var NUMBER_OPTIONS = [
  "number",
  "BigNumber",
  "bigint",
  "Fraction"
];
function configFactory(config, emit) {
  function _config(options) {
    if (options) {
      if (options.epsilon !== void 0) {
        console.warn(
          'Warning: The configuration option "epsilon" is deprecated. Use "relTol" and "absTol" instead.'
        );
        const optionsFix = clone(options);
        optionsFix.relTol = options.epsilon;
        optionsFix.absTol = options.epsilon * 1e-3;
        delete optionsFix.epsilon;
        return _config(optionsFix);
      }
      if (options.legacySubset === true) {
        console.warn(
          'Warning: The configuration option "legacySubset" is for compatibility only and might be deprecated in the future.'
        );
      }
      const prev = clone(config);
      validateOption(options, "matrix", MATRIX_OPTIONS);
      validateOption(options, "number", NUMBER_OPTIONS);
      deepExtend(config, options);
      const curr = clone(config);
      const changes = clone(options);
      emit("config", curr, prev, changes);
      return curr;
    } else {
      return clone(config);
    }
  }
  _config.MATRIX_OPTIONS = MATRIX_OPTIONS;
  _config.NUMBER_OPTIONS = NUMBER_OPTIONS;
  Object.keys(DEFAULT_CONFIG).forEach((key) => {
    Object.defineProperty(_config, key, {
      get: () => config[key],
      enumerable: true,
      configurable: true
    });
  });
  return _config;
}
function validateOption(options, name323, values) {
  const optionValue = options[name323];
  if (optionValue !== void 0 && values.indexOf(optionValue) === -1) {
    console.warn(
      'Warning: Unknown value "' + optionValue + '" for configuration option "' + name323 + '". Available options: ' + values.map((value) => JSON.stringify(value)).join(", ") + "."
    );
  }
}

// src/core/function/import.ts
function importFactory(typed2, load, math, importedFactories) {
  function mathImport(functions, options) {
    const num = arguments.length;
    if (num !== 1 && num !== 2) {
      throw new ArgumentsError("import", num, 1, 2);
    }
    const opts = options || {};
    function flattenImports(flatValues2, value, name323) {
      if (Array.isArray(value)) {
        value.forEach((item) => flattenImports(flatValues2, item, void 0));
      } else if (isObject(value) || isModule(value)) {
        const objValue = value;
        for (const propName in objValue) {
          if (hasOwnProperty(objValue, propName)) {
            flattenImports(flatValues2, objValue[propName], propName);
          }
        }
      } else if (isFactory(value) || name323 !== void 0) {
        const flatName = isFactory(value) ? isTransformFunctionFactory(value) ? value.fn + ".transform" : value.fn : name323;
        if (hasOwnProperty(flatValues2, flatName) && flatValues2[flatName] !== value && !opts.silent) {
          throw new Error('Cannot import "' + flatName + '" twice');
        }
        flatValues2[flatName] = value;
      } else {
        if (!opts.silent) {
          throw new TypeError("Factory, Object, or Array expected");
        }
      }
    }
    const flatValues = {};
    flattenImports(flatValues, functions, void 0);
    for (const name323 in flatValues) {
      if (hasOwnProperty(flatValues, name323)) {
        const value = flatValues[name323];
        if (isFactory(value)) {
          _importFactory(value, opts);
        } else if (isSupportedType(value)) {
          _import(name323, value, opts);
        } else {
          if (!opts.silent) {
            throw new TypeError("Factory, Object, or Array expected");
          }
        }
      }
    }
  }
  function _import(name323, value, options) {
    let importValue = value;
    if (options.wrap && typeof importValue === "function") {
      importValue = _wrap(importValue);
    }
    if (hasTypedFunctionSignature(importValue)) {
      const fnWithSig = importValue;
      importValue = typed2(name323, {
        [fnWithSig.signature]: fnWithSig
      });
    }
    const existingValue = math[name323];
    if (typed2.isTypedFunction(existingValue) && typed2.isTypedFunction(importValue)) {
      const typedImportValue = importValue;
      if (options.override) {
        importValue = typed2(name323, typedImportValue.signatures);
      } else {
        importValue = typed2(existingValue, typedImportValue);
      }
      math[name323] = importValue;
      delete importedFactories[name323];
      _importTransform(name323, importValue);
      math.emit("import", name323, function resolver() {
        return importValue;
      });
      return;
    }
    const isDefined = math[name323] !== void 0;
    const isValuelessUnit = math.Unit?.isValuelessUnit(name323);
    if (!isDefined && !isValuelessUnit || options.override) {
      math[name323] = importValue;
      delete importedFactories[name323];
      _importTransform(name323, importValue);
      math.emit("import", name323, function resolver() {
        return importValue;
      });
      return;
    }
    if (!options.silent) {
      throw new Error('Cannot import "' + name323 + '": already exists');
    }
  }
  function _importTransform(name323, value) {
    const valueWithTransform = value;
    if (valueWithTransform && typeof valueWithTransform.transform === "function") {
      math.expression.transform[name323] = valueWithTransform.transform;
      if (allowedInExpressions(name323)) {
        math.expression.mathWithTransform[name323] = valueWithTransform.transform;
      }
    } else {
      delete math.expression.transform[name323];
      if (allowedInExpressions(name323)) {
        math.expression.mathWithTransform[name323] = value;
      }
    }
  }
  function _deleteTransform(name323) {
    delete math.expression.transform[name323];
    if (allowedInExpressions(name323)) {
      math.expression.mathWithTransform[name323] = math[name323];
    } else {
      delete math.expression.mathWithTransform[name323];
    }
  }
  function _wrap(fn) {
    const wrapper = function wrapper2(...fnArgs) {
      const args = [];
      for (let i = 0, len = fnArgs.length; i < len; i++) {
        const arg = fnArgs[i];
        args[i] = arg && arg.valueOf ? arg.valueOf() : arg;
      }
      return fn.apply(math, args);
    };
    if (fn.transform) {
      wrapper.transform = fn.transform;
    }
    return wrapper;
  }
  function _importFactory(factory2, options, name323 = factory2.fn) {
    if (name323.includes(".")) {
      throw new Error(
        "Factory name should not contain a nested path. Name: " + JSON.stringify(name323)
      );
    }
    const namespace = isTransformFunctionFactory(
      factory2
    ) ? math.expression.transform : math;
    const existingTransform = name323 in math.expression.transform;
    const existing = hasOwnProperty(namespace, name323) ? namespace[name323] : void 0;
    const resolver = function() {
      const dependencies324 = {};
      factory2.dependencies.map(stripOptionalNotation).forEach((dependency) => {
        if (dependency.includes(".")) {
          throw new Error(
            "Factory dependency should not contain a nested path. Name: " + JSON.stringify(dependency)
          );
        }
        if (dependency === "math") {
          dependencies324.math = math;
        } else if (dependency === "mathWithTransform") {
          dependencies324.mathWithTransform = math.expression.mathWithTransform;
        } else if (dependency === "classes") {
          dependencies324.classes = math;
        } else {
          dependencies324[dependency] = math[dependency];
        }
      });
      const instance = /* @__PURE__ */ factory2(dependencies324);
      const instanceWithTransform = instance;
      if (instanceWithTransform && typeof instanceWithTransform.transform === "function") {
        throw new Error(
          'Transforms cannot be attached to factory functions. Please create a separate function for it with export const path = "expression.transform"'
        );
      }
      if (existing === void 0 || options.override) {
        return instance;
      }
      if (typed2.isTypedFunction(existing) && typed2.isTypedFunction(instance)) {
        return typed2(existing, instance);
      }
      if (options.silent) {
        return existing;
      } else {
        throw new Error('Cannot import "' + name323 + '": already exists');
      }
    };
    const meta = factory2.meta;
    const former = meta?.formerly ?? "";
    const needsTransform = isTransformFunctionFactory(factory2) || factoryAllowedInExpressions(factory2);
    const withTransform = math.expression.mathWithTransform;
    if (!meta || meta.lazy !== false) {
      lazy(namespace, name323, resolver);
      if (former) lazy(namespace, former, resolver);
      if (existing && existingTransform) {
        _deleteTransform(name323);
        if (former) _deleteTransform(former);
      } else {
        if (needsTransform) {
          lazy(withTransform, name323, () => namespace[name323]);
          if (former) lazy(withTransform, former, () => namespace[name323]);
        }
      }
    } else {
      namespace[name323] = resolver();
      if (former) namespace[former] = namespace[name323];
      if (existing && existingTransform) {
        _deleteTransform(name323);
        if (former) _deleteTransform(former);
      } else {
        if (needsTransform) {
          lazy(withTransform, name323, () => namespace[name323]);
          if (former) lazy(withTransform, former, () => namespace[name323]);
        }
      }
    }
    importedFactories[name323] = factory2;
    math.emit("import", name323, resolver);
  }
  function isSupportedType(object) {
    return typeof object === "function" || typeof object === "number" || typeof object === "string" || typeof object === "boolean" || object === null || isUnit(object) || isComplex(object) || isBigNumber(object) || isFraction(object) || isMatrix(object) || Array.isArray(object);
  }
  function isModule(object) {
    return typeof object === "object" && object !== null && object[Symbol.toStringTag] === "Module";
  }
  function hasTypedFunctionSignature(fn) {
    return typeof fn === "function" && typeof fn.signature === "string";
  }
  function allowedInExpressions(name323) {
    return !hasOwnProperty(unsafe, name323);
  }
  function factoryAllowedInExpressions(factory2) {
    const meta = factory2.meta;
    return !factory2.fn.includes(".") && // FIXME: make checking on path redundant, check on meta data instead
    !hasOwnProperty(unsafe, factory2.fn) && (!meta || !meta.isClass);
  }
  function isTransformFunctionFactory(factory2) {
    const meta = factory2.meta;
    return meta?.isTransformFunction === true;
  }
  const unsafe = {
    expression: true,
    type: true,
    docs: true,
    error: true,
    json: true,
    chain: true
    // chain method not supported. Note that there is a unit chain too.
  };
  return mathImport;
}

// src/core/create.ts
function create(factories, config) {
  const configInternal = Object.assign(
    {},
    DEFAULT_CONFIG,
    config
  );
  if (typeof Object.create !== "function") {
    throw new Error(
      "ES5 not supported by this JavaScript engine. Please load the es5-shim and es5-sham library for compatibility."
    );
  }
  const math = mixin({
    // only here for backward compatibility for legacy factory functions
    isNumber,
    isComplex,
    isBigNumber,
    isBigInt,
    isFraction,
    isUnit,
    isString,
    isArray,
    isMatrix,
    isCollection,
    isDenseMatrix,
    isSparseMatrix,
    isRange,
    isIndex,
    isBoolean,
    isResultSet,
    isHelp,
    isFunction,
    isDate,
    isRegExp,
    isObject,
    isMap,
    isPartitionedMap,
    isObjectWrappingMap,
    isNull,
    isUndefined,
    isAccessorNode,
    isArrayNode,
    isAssignmentNode,
    isBlockNode,
    isConditionalNode,
    isConstantNode,
    isFunctionAssignmentNode,
    isFunctionNode,
    isIndexNode,
    isNode,
    isObjectNode,
    isOperatorNode,
    isParenthesisNode,
    isRangeNode,
    isRelationalNode,
    isSymbolNode,
    isChain
  });
  math.config = configFactory(configInternal, math.emit);
  math.expression = {
    transform: {},
    mathWithTransform: {
      config: math.config
    }
  };
  const legacyFactories = [];
  const legacyInstances = [];
  function load(factory2) {
    if (isFactory(factory2)) {
      return factory2(math);
    }
    const firstProperty = factory2[Object.keys(factory2)[0]];
    if (isFactory(firstProperty)) {
      return firstProperty(math);
    }
    if (!isLegacyFactory(factory2)) {
      console.warn(
        "Factory object with properties `type`, `name`, and `factory` expected",
        factory2
      );
      throw new Error(
        "Factory object with properties `type`, `name`, and `factory` expected"
      );
    }
    const index = legacyFactories.indexOf(factory2);
    let instance;
    if (index === -1) {
      if (factory2.math === true) {
        instance = factory2.factory(
          math.type,
          configInternal,
          load,
          math.typed,
          math
        );
      } else {
        instance = factory2.factory(math.type, configInternal, load, math.typed);
      }
      legacyFactories.push(factory2);
      legacyInstances.push(instance);
    } else {
      instance = legacyInstances[index];
    }
    return instance;
  }
  const importedFactories = {};
  function lazyTyped(...args) {
    return math.typed.apply(math.typed, args);
  }
  lazyTyped.isTypedFunction = typedFunction__default.default.isTypedFunction;
  const internalImport = importFactory(
    lazyTyped,
    load,
    math,
    importedFactories
  );
  math.import = internalImport;
  math.on("config", () => {
    Object.values(importedFactories).forEach((factory2) => {
      if (factory2 && factory2.meta && factory2.meta.recreateOnConfigChange) {
        internalImport(factory2, { override: true });
      }
    });
  });
  math.create = create.bind(null, factories);
  math.factory = factory;
  if (factories) {
    math.import(Object.values(deepFlatten(factories)));
  }
  math.ArgumentsError = ArgumentsError;
  math.DimensionError = DimensionError;
  math.IndexError = IndexError;
  return math;
}

// src/defaultInstance.ts
var defaultInstance_default = create(factoriesAny_exports);

module.exports = defaultInstance_default;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map